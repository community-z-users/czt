% Adapted from LLNCS.DEM Springer-Verlag for LNCS, version 2.3 for LaTeX2e
\documentclass{llncs}
\usepackage{czt}  %% for the Standard Z specification macros
\usepackage{graphics}
\usepackage{url}
%
\begin{document}
\pagestyle{headings}  % switches on printing of running heads
%
\title{Testing a Z Specification of Posix}
\titlerunning{Testing a Z Spec of Posix}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Mark Utting\inst{1} \and Petra Malik\inst{2}}
%
\authorrunning{Utting and Malik}   % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
%\tocauthor{Mark Utting, Petra Malik}
%
\institute{Department of Computer Science, The University of Waikato, NZ\\
\email{marku@cs.waikato.ac.nz},\\
% WWW home page: \texttt{http://www.cs.waikato.ac.nz/\homedir marku}
\and
Faculty of Engineering,
Victoria University of Wellington, NZ
\email{petra.malik@mcs.vuw.ac.nz}
}

\maketitle              % typeset the title of the contribution

\begin{abstract}
  We refactor Morgan and Suffrin's original Z specification of the Posix
  file system, to break it into Z sections and make it conform to the Z
  Standard.  We propose a simple framework for validation testing of Z
  specifications, and illustrate this framework by testing the first few
  levels of the specification.  The tests are written in standard Z, and
  are executable by the CZT animator, ZLive.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In~\cite{Hoa03}, Hoare proposes a grand challenge for computer
science---a verifying compiler---and inspired researchers from all
over the world to work jointly towards this ambitous goal.  The
verified software repository~\cite{BicHoaWoo06} is a means to record
and coordinate these efforts.  The repository contains an evolving
collection of tools related to software verification as well as case
studies.

The pilot case studies for the verified software repository are
carefully chosen.  They are sufficiently complex to be challenging and
of industrial relevance but small enough to be completed within a few
years.  They provide examples of specified and verified code and can
be used as benchmarks to exercise and test current and future
verification tools.

The Mondex case study was tackled as a first challenge in 2006.
Several teams using a variety of techniques and tools were working on
a fully automated proof of the Mondex smart-card banking application.
A verifiable filesystem has been proposed~\cite{JosHol07} as another
mini challenge.  An initial small subset of POSIX has been
chosen~\cite{FreFuWoo07} and participants of the ABZ 2008 conference
were challenged to contribute to this project.

This paper proposes a simple framework for testing Z specifications.
The framework has been used to develop positive and negative tests for
the first few levels of a refactored version of Morgan and Suffrin's Z
specification of the Posix file system~\cite{MorSufTOSE84}.  The tests
were executed and checked by the CZT animator ZLive.

The structure of this paper is as follows.  Section~\ref{sect:posix}
describes the refactored POSIX specification.  In
section~\ref{sect:framework}, we present our testing framework.
Section~\ref{sect:zlive} gives an overview of the CZT animator ZLive,
which is used to execute the tests.  In Section~\ref{sect:ds}, the
tests for the data system are explained.  Section~\ref{sect:ss} shows
how promotion can be used to derive tests for the storage system.
Finally, Section~\ref{sect:conclusions} gives conclusions.

The main contributions of the paper are: the framework for expressing
Z validation tests, a simple style for promoting tests from one level
to another, the example tests of the Posix specification, and
the use of the ZLive animator to execute the tests.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Posix Standardized}\label{sect:posix}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section, we describe the refactored Posix specification.
The main change was to break up the original specification into
sections.  Figure~\ref{fig:sects} shows the structure of the
resulting Z sections, using a notation similar to a UML class diagram.
Each box represents a Z section, and the three parts within each box
show the name of the section, the main variables within the state
schema of that definition, and the names of its operation schemas
(we omit Init schemas and auxiliary schemas).

As well as breaking the specification into sections, we made several other
changes.  TODO: describe the other changes we made.


\begin{figure}[htbp]
\newcommand{\DIVIDER}{\vspace{0.5ex} \hrule \vspace{1ex}}
\newcommand{\FATDIVIDER}{\vspace{1ex} \hrule \vspace{1.5ex}}
\newcommand{\SECTNAME}[2]{\hfil\hfil\hfil\textbf{#1}\hfil\emph{(#2)}}
  \centering
  \setlength{\unitlength}{1cm}
  \begin{picture}(10,20)
%
  \put(1,18){\framebox(8,1){\parbox{6cm}{
        \hfil \textbf{standard\_toolkit} \hfil
    }}}
  \put(5,17){\vector(0,1){1}}
  \put(1,15){\framebox(8,2){\parbox{8cm}{
        \SECTNAME{DS}{Data System}
        \DIVIDER
        ~$FILE == \seq BYTE$ \\ \hbox{}
        ~$file : FILE$
        \DIVIDER
        $~readFILE, writeFILE$
    }}}
  \put(5,14){\vector(0,1){1}}
  \put(1,12){\framebox(8,2){\parbox{8cm}{
        \SECTNAME{SS}{Storage System}
        \FATDIVIDER
        ~$fstore : FID \pfun FILE$
        \FATDIVIDER
        $~createSS, destroySS, readSS, writeSS$
    }}}
  \put(5,11){\vector(0,1){1}}
  \put(1,9){\framebox(8,2){\parbox{8cm}{
        \SECTNAME{CS}{Channel System}
        \FATDIVIDER
        ~$cstore : CID \pfun CHAN$
        \FATDIVIDER
        $~openCS, closeCS$
    }}}
  \put(5,8){\vector(0,1){1}}
  \put(1,6){\framebox(8,2){\parbox{8cm}{
        \SECTNAME{AS}{Access System}
        \FATDIVIDER
        ~$SS; CS$
        \FATDIVIDER
        $~readAS, writeAS, seekAS$
    }}}
  \put(5,5){\vector(0,1){1}}
  \put(1,3){\framebox(8,2){\parbox{8cm}{
        \SECTNAME{NS}{Name System}
        \FATDIVIDER
        ~$nstore : NAME \pfun FID$
        \FATDIVIDER
        $~createNS, lookupNS, destroyNS, lsNS$
    }}}
  \put(5,2){\vector(0,1){1}}
  \put(1,0){\framebox(8,2){\parbox{8cm}{
        \SECTNAME{FS}{File System}
        \DIVIDER
        ~$SS; CS; NS; usedfids : \power FID$
        \DIVIDER
        $~createFS, openFS, readFS, writeFS, closeFS,$ \\
        \hbox{}$~unlinkFS0, destroyFS, linkFS, moveFS$
    }}}

  \end{picture}
  \caption{Overview of Z Sections in the Posix Specification}
  \label{fig:sects}
\end{figure}

\input{ds.zed}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{How to Test a Z Specification}\label{sect:framework}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section introduces a simple framework for expressing tests
of a Z specification.  We assume that the specification is written in the
common Z \emph{sequential} style, with a state schema, an initialisation
schema, several operation schemas, as well as various auxiliary definitions
and schemas.

The first question that must be asked is why we do not use an existing
testing framework for Z, such as the Test Template Framework
(TTF)~\cite{Stocks93,carrington94} or Heirons' Z-to-FSM
approach~\cite{hierons97}.  The difference is that these all aim at
generating tests \emph{from} a Z specification, in order to test some
implementation of that specification.  But in this paper, we want to design
some tests that actually test the Z specification itself.  So the goal of
those approaches is \emph{verification} (of some implementation), whereas
our goal is \emph{validation} (of the Z specification).  This results in
quite a different style of testing.  

One difference is that when testing an implementation, we can control its
inputs but not its outputs, whereas when testing a Z specification we can
ask arbitrary questions about inputs or outputs.  So when validating a Z
specification, we can use a richer variety of tests.  Another difference is
that when validating a specification, we want to design both positive
tests, which test that a given behaviour is allowed by the specification,
and negative tests, which test that a given behaviour is not allowed by the
specification.  In contrast, when testing an implementation of the
specification, we use only positive tests, because refinement means that
the implementation is free to add behaviour that is outside the
precondition of the specification.

To illustrate our testing framework, we shall use a simple example
specification given by the following specification, which defines
the shape shown in Figure~\ref{fig:wedge}.
Our tests will be written using standard Z conjecture paragraphs,
so that they can be checked by theorem provers or by the ZLive
animator.  We use one or more Z sections for the specification,
and then group the tests into separate Z sections that have the
specification as a parent.

\begin{figure}[htbp]
  \centering
  \includegraphics{wedge}
  \caption{A graph of the solutions to the Wedge schema (TODO: rename x1 to n and x2 to n')}
  \label{fig:wedge}
\end{figure}

\begin{zsection}
  \SECTION wedge \parents standard\_toolkit
\end{zsection}
\begin{zed}
  State == [n: \negate 10 \upto 10] \\
  Wedge == [\Delta State | n*n + n'*n' \leq 25; n + n' \leq 5; 0 \leq n']
\end{zed}

\subsection{Positive Tests}

The first kind of testing we want to do is positive tests to check that an
operation has a desired input-output behaviour.  When specifying
tests, it is important to specify the expected output values as well as the
input values, so we write all the inputs and output values as a Z binding
and use a membership test.  Here are two examples that test the
non-deterministic output behaviour of Wedge when the input $x=0$.
Since 2007, the Z standard requires conjectures to be written within
a \LaTeX\ \emph{theorem} environment, and allows each conjecture to be
given a name.  Our naming convention for tests is typically to use the name
of the operation being tested, followed by some information about the input
and output values that are being tested.

\begin{zsection}
  \SECTION wedgeTests \parents wedge
\end{zsection}

\begin{theorem}{Wedge0Min}
\vdash? ~~ \lblot n==0, n'==0 \rblot \in Wedge
\end{theorem}

\begin{theorem}{Wedge0Max}
\vdash? ~~ \lblot n==0, n'==5 \rblot \in Wedge
\end{theorem}

Alternatively, we may prefer to group a set of tests together, and test
them all in one conjecture.  We can do this by naming the test tuples, and
testing them all using a subset conjecture.

\begin{zed}
  Wedge0Min == \lblot n==0, n'==0 \rblot \\
  Wedge0Max == \lblot n==0, n'==5 \rblot
\end{zed}

\begin{theorem}{WedgePos}
  \vdash? ~~ \{Wedge0Min, Wedge0Max\} \subseteq Wedge
\end{theorem}


\subsection{Negative Tests}

It is also useful to perform \emph{negative} tests to validate an
operation.  For example, we may want to check that an input value is
outside the precondition of the operation, or check that a certain output
can never be produced by the operation.  The idea is to validate the
specification by showing that its behaviour is squeezed in between the set
of positive tests and the set of negative tests.  The more positive and
negative tests that we design, the more sure we can be that we have
specified the desired behaviour, rather than allowing too many or too few
behaviours.

We can write negative tests using a negated membership test ($test \notin
Op$) or, equivalently, we can test that the tuple is a member of the negated
schema ($test \in \lnot Op$).
Our conjecture naming convention is the same as for positive tests, but
we prefix the name with $Not$ to indicate that it is a negative tests.

\begin{zsection}
  \SECTION notWedgeTests \parents wedge
\end{zsection}

\begin{theorem}{NotWedge0Neg}
\vdash? ~~ \lblot n==0, n'==\negate 1 \rblot \notin Wedge
\end{theorem}

\begin{theorem}{NotWedge06}
\vdash? ~~ \lblot n==0, n'==6 \rblot \in \lnot Wedge
\end{theorem}

We can also test just the precondition of the operation.
%% Note: ZLive cannot evaluate this if the type of x is any integer
%% because it requires enumerating pre Wedge, and then there is no
%% lower bound on $n'$.
\begin{theorem}{NotWedgePre6}
\vdash? ~~ \lblot n==6 \rblot \notin \pre Wedge
\end{theorem}

As we did for positive tests, we may also combine several negative tests
into a group.  In this case, our conjecture may be written as $tests
\subseteq \lnot Op$, or equivalently we may check that the intersection of
the negative test suite and the operation is empty, $tests \land Op =
\emptyset$.  The latter style is often more convenient, since it allows us
to write $tests$ using schema notation, and to omit variables that we are
not interested in (because the schema conjunction will expand the type of
$tests$ to match the type of $Op$).  For example, the following two negative
test suites check that 6 can never be an input for $Wedge$, and that 6 can
never be an output of $Wedge$.

\begin{theorem}{NotWedgeIn6}
\vdash? ~~ ([State | n=6] \land Wedge) = \emptyset
\end{theorem}

\begin{theorem}{NotWedgeOut6}
\vdash? ~~ ([State~' | n'=6] \land Wedge) = \emptyset
\end{theorem}

It is sometimes convenient to write these kinds of negative test values
\emph{within} the operation schema (e.g., $[Wedge | x=6] = \emptyset$),
which can make the tests even more concise.


\subsection{Promoting Tests}

A heavily-used pattern in the Posix Z specification is the use of
\emph{promotion} to lift the operations of one data type up to work on a
more complex data type.  It is useful to be able to promote the tests
of those operations as well.  To illustrate an elegant way of doing this,
we shall promote the $Wedge$ tests up to the following function space:

\begin{zsection}
  \SECTION manyStates \parents wedge
\end{zsection}

\begin{schema}{ManyStates}
  states : \nat \fun \num
\end{schema}

\begin{schema}{\Phi ManyStates}
  \Delta State \\
  \Delta ManyStates \\
  curr? : \nat
\where
  (curr? \mapsto n) \in states \\
  states' = states \oplus \{curr? \mapsto n'\}
\end{schema}

We promote the $Wedge$ operation up to the $ManyStates$ level simply by
conjoining $Wedge$ with the \emph{framing schema} $\Phi ManyStates$.
The effect is to apply the $Wedge$ operation to just the $curr?$ element of
the $states$ function. 

\begin{zed}
  ManyWedge == \Phi ManyStates \land Wedge
\end{zed}


We use the same framing schema to promote the tests.  But to ensure that
all inputs of the promoted operation are given, we use a specialised
version of the framing schema that also specifies an initial value
for the $states$ mapping and which $curr?$ input will be tested.

\begin{zsection}
  \SECTION manyStatesTest \parents manyStates, wedgeTests
\end{zsection}

\begin{zed}
  \Phi ManyStatesTest ==
    [\Phi ManyStates; curr? == 1 | states = \{0 \mapsto 3, 1 \mapsto n\}]
\end{zed}

%% NOTE: this fails if State contains x, because of a scoping
%% error in the unfolding or in the translation to FlatPreds.
%% Probably an 'x' in the ZLive preprocess rules gets accidentally
%% bound to the 'x' from the State schema.
\begin{theorem}{ManyWedgePos}
  \vdash? ~~ (\{Wedge0Min, Wedge0Max\} \land \Phi ManyStatesTest)
      \subseteq ManyWedge
\end{theorem}

In fact, this style of promoted test theorem will always be true,
because for any test suite $OpTests$ of an operation $Op$,
and any promoted operation defined as $Op_P == Op \land \Phi P$,
it is true that:
\[
   (OpTests \in Op) \land (\Phi PTests \subseteq \Phi P)
   \implies (OpTests \land \Phi PTests \subseteq Op_P)
\]

\textbf{Proof:} follows from the monotonicity of $\subseteq$ and schema
conjunction.

However, there is a possibility that some of the promoted tests
might be inconsistent with the framing schema (either $\Phi P$ or $\Phi
PTests$), which would mean that the set $OpTests \land \Phi PTests$
would be empty or smaller than our original set of tests $Optests$.
If we want to check that all of the original tests can be promoted without
being lost, we can check the conjecture 
$(OpTests \land \Phi PTests) = Optests$.

If this is not true, we may want to check each test vector $v \in Optests$
separately.  We can define the promoted vector as 
$pv == (\mu \Phi PTests | \theta \{v\} = v)$.
Then we can test $pv \in Op_P$. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The ZLive Animator}\label{sect:zlive}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

One of the tools available in the CZT system is the ZLive animator.
It is the successor to the Jaza animator for Z~\cite{utting:jaza},
and its command line interface is largely backwards compatible with that of
Jaza.  However, the animation algorithm of ZLive is quite different and
more general.  It is based on an extension of the \emph{Z mode} system
developed at Melbourne University by Winikoff and
others~\cite{kazmierczak:animation98,winikoff:modes-subtypes98}.

When an expression or predicate is evaluated in ZLive, it is
parsed and typechecked, and then unfolded and simplified using
the \emph{transformation rules} system of CZT~\cite{utting:rules07}.
This unfolds schema operators, expands definitions and performs a
variety of simplifications.  For example, the test $\lblot n==0, n'==0
\rblot \in Wedge$ is unfolded to:
\[
  \lblot n == 0 , n' == 0 \rblot \in 
 [ n :~\negate 10 \upto 10; n' :~\negate 10 \upto 10 | \\
   \t2 n * n + n' * n'  \leq 25; n + n' \leq 5; 0 \leq n' ]
\]

The resulting term is then translated into a sequence of primitive
relations, each of which corresponds to a single Z operator.
For example, the term $n * n + n' * n'  \leq 25$ is 
translated into:
\[
\begin{array}{l@{\quad}l}
   FlatMult(n, n, tmp1),       & \% n * n = tmp1 \\
   FlatMult(n', n', tmp2),     & \% n' * n' = tmp2 \\
   FlatPlus(tmp1, tmp2, tmp3), & \% tmp1 + tmp2 = tmp3 \\
   FlatLessThanEq(tmp3, 25)    & \% tmp3 \leq 25
\end{array}
\]

ZLive next performs a bounds analysis phase, which does a fixpoint
calculation to infer conservative lower and upper bounds for each
integer variable, bounds on the size and contents of sets, and
aliasing between variables.  This infers that $n \in \negate 10 \upto
5$ and $n' \in 0 \upto 10$.

The last analysis phase attempts to reorder the sequence of primitive
$Flat\ldots$ relations into an efficient computation order.  Each of
the relations can be executed in one or more \emph{modes}.  A mode
determines whether each parameter is an input or an output.  In
addition, ZLive estimates the expected number of results for each
mode.  For example, the mode IIO:1 for $FlatPlus(x,y,z)$ means that
$x$ and $y$ are inputs and $z$ is an output (with one result
expected), while mode III:0.6 means they are all inputs and there is a
60\% probability of getting a result.  The reordering algorithm gives
preference to modes that have a small number of expected results,
which means that filter predicates are moved as near to the front as
possible, which reduces the search space.

Finally, ZLive generates all possible results via a backtracking
search of all the solutions generated by the sorted sequence.
However, for membership tests such as $A \in S$, where $A$ is a known
value and $S$ is a set comprehension, it substitutes the value of $A$
into the result of $S$ and then checks whether the set is empty or not
-- this avoids generating all of $S$.

ZLive can usually evaluate expressions that contain only finite sets,
and can sometimes handle expressions that contain a mixture of finite
and infinite sets.  So it is a useful tool for checking the correctness
of tests, and can sometimes be used to generate one or all solutions
of a partially specified test or schema.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Testing the DS Specification}\label{sect:ds}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{dstest.zed}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Testing the SS Specification}\label{sect:ss}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

TODO: give a test promotion schema for promoting the DS tests up to this
level.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}\label{sect:conclusions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this paper, we have proposed a framework for testing Z
specifications.  The framework uses the sections and conjectures of
the Z standard to allow various kinds of validation tests to be
expressed in an elegant and concise style.  The ability to promote a
large set of tests in a single expression makes it practical to
develop multiple layers of tests, matching the layers of the
specification.  Testing is a useful validation technique for
specifications, especially when the execution of the tests can be
automated, as we have done with ZLive.

The refactored Z specification of Posix, and our simple test suite,
may be a useful starting point
for other researchers who want to work on refinement or proofs
about the Posix case study.  It is available from the CZT sourceforge
website~\cite{CZT}.


%
% ---- Bibliography ----
%
\bibliographystyle{alpha}
\bibliography{posix}
%\begin{thebibliography}{5}
%
%\bibitem {clarke}
%TODO...
%\end{thebibliography}
\end{document}
