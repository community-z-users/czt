\begin{zsection}
  \SECTION ds \parents standard\_toolkit
\end{zsection}

% The ultimate constituent of the filing system is the byte.
% A file is a finite sequence of bytes.

\begin{zed}
  BYTE == 0 \upto 255 \\
  ZERO == 0 \\
  FILE == \seq BYTE
\end{zed}

The $after$ operator returns the subfile that starts after a given offset.
We write this as an explicit definition (==) rather than axiomatically,
because it is clearer, avoids possible inconsistency, and is easier
to evaluate.

\begin{zed}
  \function 42 \leftassoc ( \varg after \varg )
\end{zed}

\begin{zed}
  \varg after \varg ==
  (\lambda f : FILE ; offs : \nat @ (\lambda i : 1 .. \#f - offs @ f(i+offs)))
\end{zed}

\begin{schema}{DS}
  file : FILE
\end{schema}

\begin{schema}{InitDS}
  DS~'
\where
  file ' = \{\}
\end{schema}

\begin{schema}{readFILE}\\
  \Xi DS \\
  offset?, length? : \nat \\
  data! : FILE
\where
  data! = ( 1 \upto length? ) \dres ( file~after~offset? )
\end{schema}

Auxiliary functions:
The $zero$ function returns a FILE containing $n$ ZERO bytes.

\begin{zed}
  zero == (\lambda n : \nat @ ( \lambda i : 1 \upto n @ ZERO ) )
\end{zed}

The infix operator $shift$ takes a FILE and an offset and shifts the
content of the file by the offset, adding ZERO bytes into the beginning of
the file.

\begin{zed}
  \function 42 \leftassoc ( \varg shift \varg )
\end{zed}

\begin{zed}
  \varg shift \varg == (\lambda f : FILE ; offs : \nat
        @ ( 1 \upto offs ) \ndres ( zero~offs \cat f ))
\end{zed}

\begin{schema}{writeFILE}
  \Delta DS \\
  offset? : \nat \\
  data? : FILE
\where
  file' = ( zero~offset? \oplus file ) \oplus ( data?~shift~offset? )
\end{schema}
