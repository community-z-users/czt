\begin{zsection}
  \SECTION dstest \parents ds
\end{zsection}

This section contains positive and negative tests for the 'ds' section.
We start by testing the $InitDS$ schema.

\begin{theorem}{InitDSEmpty}
\vdash? \lblot file' == \langle \rangle \rblot \in InitDS
\end{theorem}

\begin{theorem}{InitDSCannotContainData}
\vdash? \lblot file' == \langle 3 \rangle \rblot \notin InitDS
\end{theorem}

For $readFILE$, we design a set of positive tests that all work
on the same input file, $eg1$.  When writing the set of tests,
it is convenient to use the schema calculus to factor out the 
unchanging $file, file'$ from the other test values.
\begin{zed}
  eg1 == \langle 1, 255 \rangle \\
  dsPos == [file==eg1; file'==eg1] \land \\
  \t2 \{\lblot offset?==0, length?==0, data!==\langle \rangle \rblot, \\
  \t2 ~ \lblot offset?==0, length?==3, data!==\langle 1, 255 \rangle \rblot, \\
  \t2 ~ \lblot offset?==1, length?==1, data!==\langle 255 \rangle \rblot, \\
  \t2 ~ \lblot offset?==3, length?==2, data!==\langle 0,0 \rangle \rblot \\
  \t2 \}
\end{zed}

\begin{theorem}{dsPosTests}
\vdash? ~~ dsPos \subseteq readFILE
\end{theorem}

Here is the output from ZLive when we use its \texttt{conjectures}
command to evaluate all the conjectures in this $dstest$
section.\footnote{We plan to display the conjecture names rather than
just the line numbers.  However, the Z standard does not pass the
conjecture names from the \LaTeX\ markup to the Unicode markup, so
getting access to the names within the parser and ZLive will require
some extensions to the Z standard, which we have not yet made.}

\begin{small}
\begin{verbatim}
dstest> conjectures
Conjecture on line 7
true
Conjecture on line 11
true
Conjecture on line 29
false
\end{verbatim}
\end{small}

To investigate which of the $dsPos$ tests failed, we can ask ZLive
to evaluate $dsPos \setminus readFILE$.  This displays just the
test vectors that are not members of $readFILE$, which tells us
that the third and fourth tests failed.
For each of these, we investigate why it failed by giving ZLive
just the input values, and using the ZLive `\texttt{do}' command
to search for any one of the solutions for the schema.
We get this output:

\begin{small}
\begin{verbatim}
dstest> do [readFILE | file=eg1; offset?=1; length?=1]
1: \lblot file == \{ ( 1 , 1 ) , ( 2 , 255 ) \} , 
 file' == \{ ( 1 , 1 ) , ( 2 , 255 ) \} , \\
 offset? == 1 , length? == 1 , data! == \{ ( 1 , 255 ) \} \rblot
\end{verbatim}
\end{small}
 
Oops, the third test ($offset?==1, length?==1$) should have had 255 in
$data!$ rather than $1$. 

\begin{small}
\begin{verbatim}
dstest> do [readFILE | file=eg1; offset?=3; length?=2]
1: \lblot file == \{ ( 1 , 1 ) , ( 2 , 255 ) \} ,
 file' == \{ ( 1 , 1 ) , ( 2 , 255 ) \} , \\
 offset? == 3 , length? == 2 , data! == \{ \} \rblot
\end{verbatim}
\end{small}

Ah, of course!  Reading past the end of the file should return empty
$data!$, rather than zeroes.  (When designing this fourth test, Mark was 
incorrectly thinking of the behaviour of the Write command past the end
of the file, which inserts zeroes automatically.) 
%
Once these two errors in the expected output values are corrected,
all tests give true.


\subsection{Negative Tests for $readFILE$}

Our first two negative tests check that $\negate 1$ is not a valid
input for $offset?$ or $length?$.  In the $length?$ test, we show how
we can write the test values inside the $readFILE$ schema, which can
sometimes be more convenient.

\begin{theorem}{ReadOffsetNotNeg}
 \vdash?  ([offset? == \negate 1] \land readFILE) = \{\}
\end{theorem}

%\footnote{CZT gives some really interesting and non-obvious error messages
%  if we omit the (..) parentheses!  The parser assumes that $readFILE=\{\}$
%  is a predicate, which makes the typechecker interpret $[offset?==\negate 1]$
%  as a predicate rather than a schema expression, so it complains about 
%  Undeclared identifier $offset?$~!}

\begin{theorem}{ReadLengthNotNeg}
 \vdash?  [readFILE | length? = \negate 1] = \{\}
\end{theorem}

The remaining negative tests are partially specified, so each conjecture
checks a set of negative tests.  The BadOutFile test checks that the read
operation does not change the file contents.  The BadData test checks that
the output $data!$ is never longer than the file contents.

\begin{theorem}{ReadCannotChangeFile}
 \vdash?  [readFILE | file=eg1; file' \neq eg1] = \{\}
\end{theorem}

\begin{theorem}{ReadDataNotLongerThanFile}
 \vdash?  [readFILE | file=eg1; offset?=0; length? < 4; \# data! > 2] = \{\}
\end{theorem}


%\subsection{Positive Tests for $writeFILE$}

We can write positive and negative unit tests for the $writeFile$
operation in a similar way to $readFile$, but space does not permit us
to show the details of this.

%\begin{schema}{writeFILE2}
%  \Delta DS \\
%  offset? : \nat \\
%  data? : FILE
%\where
%  file' = ( zero~offset? \oplus file ) \oplus ( data?~shift~offset? )
%\end{schema}


