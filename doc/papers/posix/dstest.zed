\begin{zsection}
  \SECTION dstest \parents ds
\end{zsection}

This section contains several positive and negative tests
for the DS specification of POSIX files.

\begin{theorem}{InitDSEmpty}
\vdash? \lblot file' == \langle \rangle \rblot \in InitDS
\end{theorem}

\begin{theorem}{InitDSCannotContainData}
\vdash? \lblot file' == \langle 3 \rangle \rblot \notin InitDS
\end{theorem}

\begin{zed}
  eg1 == \langle 1, 255 \rangle
\end{zed}

\begin{theorem}{ReadTest0\_0}
\vdash? \lblot file==eg1, offset?==0, length?==0, \\
\t1            data!==\langle \rangle, file'==eg1 \rblot \in readFILE
\end{theorem}

\begin{theorem}{ReadTest0\_3}
\vdash? \lblot file==eg1, offset?==0, length?==3, \\
\t1            data!==\langle 1, 255 \rangle, file'==eg1 \rblot \in readFILE
\end{theorem}

\begin{theorem}{ReadTest1\_1}
\vdash? \lblot file==eg1, offset?==1, length?==1, \\
\t1            data!==\langle 255 \rangle, file'==eg1 \rblot \in readFILE
\end{theorem}

\begin{theorem}{ReadTest3\_2}
\vdash? \lblot file==eg1, offset?==3, length?==2, \\
\t1            data!==\langle \rangle, file'==eg1 \rblot \in readFILE
\end{theorem}

Here is the output from ZLive when we use its \texttt{conjectures}
command to evaluate all the conjectures in the $dstest$
section.\footnote{We plan to display the conjecture names rather than
just the line numbers.  However, the Z standard does not pass the
conjecture names from the \LaTeX\ markup to the Unicode markup, so
getting access to the names within the parser and ZLive will require
some extensions to the Z standard, which we have not yet made.}

\begin{small}
\begin{verbatim}
dstest> conjectures
Conjecture on line 7
true
Conjecture on line 11
true
Conjecture on line 19
true
Conjecture on line 24
true
Conjecture on line 29
false
Conjecture on line 34
false
\end{verbatim}
\end{small}

To investigate why two of these tests failed, we give ZLive
just the input test values, and ask it to show any one of the
solutions for the schema.  We get this output:

\begin{small}
\begin{verbatim}
dstest> do [readFILE | file=eg1; offset?=1; length?=1]
1: \lblot file == \{ ( 1 , 1 ) , ( 2 , 255 ) \} , 
 file' == \{ ( 1 , 1 ) , ( 2 , 255 ) \} , \\
 offset? == 1 , length? == 1 , data! == \{ ( 1 , 255 ) \} \rblot
\end{verbatim}
\end{small}
 
Oops, ReadTest1\_1 should have had 255 in $data!$ rather than $1$.

\begin{small}
\begin{verbatim}
dstest> do [readFILE | file=eg1; offset?=3; length?=2]
1: \lblot file == \{ ( 1 , 1 ) , ( 2 , 255 ) \} ,
 file' == \{ ( 1 , 1 ) , ( 2 , 255 ) \} , \\
 offset? == 3 , length? == 2 , data! == \{ \} \rblot
\end{verbatim}
\end{small}

Ah, of course!  Reading past the end of the file should return empty
$data!$, rather than zeroes.  (When designing this test, Mark was 
incorrectly thinking of the behaviour of the Write command past the end
of the file, which inserts zeroes automatically.) 
%
Once these two errors in the expected output values are corrected,
all tests give true.


\subsection{Negative Tests for $readFILE$}

Our first two negative tests check that $\negate 1$ is not a valid
input for $offset?$ or $length?$.  In the $length?$ test, we show how
we can write the test values inside the $readFILE$ schema, which can
sometimes be more convenient.

\begin{theorem}{ReadOffsetNotNeg}
 \vdash?  ([offset? == \negate 1] \land readFILE) = \{\}
\end{theorem}

%\footnote{CZT gives some really interesting and non-obvious error messages
%  if we omit the (..) parentheses!  The parser assumes that $readFILE=\{\}$
%  is a predicate, which makes the typechecker interpret $[offset?==\negate 1]$
%  as a predicate rather than a schema expression, so it complains about 
%  Undeclared identifier $offset?$~!}

\begin{theorem}{ReadLengthNotNeg}
 \vdash?  [readFILE | length? = \negate 1] = \{\}
\end{theorem}

The remaining negative tests are partially specified, so each define a
set of negative tests.  The BadOutFile test checks that the read
operation does not change the file contents.  The BadData test checks
that the output $data!$ can never be longer than the file contents.

\begin{theorem}{ReadCannotChangeFile}
 \vdash?  [readFILE | file=eg1; file' \neq eg1] = \{\}
\end{theorem}

\begin{theorem}{ReadDataNotLongerThanFile}
 \vdash?  [readFILE | file=eg1; offset?=0; length? < 4; \# data! > 2] = \{\}
\end{theorem}


%\subsection{Positive Tests for $writeFILE$}

We can write positive and negative unit tests for the $writeFile$
operation in a similar way to $readFile$, but space does not permit us
to show the details of this.

%\begin{schema}{writeFILE2}
%  \Delta DS \\
%  offset? : \nat \\
%  data? : FILE
%\where
%  file' = ( zero~offset? \oplus file ) \oplus ( data?~shift~offset? )
%\end{schema}


