\section{Related Work}

Typechecking formal object-oriented specification languages has not
been investigated in great detail in the existing literature,
especially when compared to other specification languages such as Z.

Chen's class type model \cite{chen94}, discussed in
Section~\ref{background}, similar to our model, but does not seem to
provide support for generic class types, and does not model the
polymorphic core. Chen does not discuss unification or type
inference. No other reference to Chen's Object-Z typechecker can be
found in literature or via an Internet search.

The Wizard typechecker for Object-Z \cite{johnston96} models class
types similar to that of Chen. The basic class type is a {\em class
reference type}, with two additional types are included: {\em
polymorphic reference types} and {\em class union type}. A polymorphic
reference type is a class reference type with an additional list of
subclasses that define possible sets of object identities. A class
union type is a set of class references. This is similar to both our
model, but differs in that the core information of polymorphic
expressions and class unions is modelled in each class
reference. Neither unification or type inference are discussed in
\cite{johnston96}.

Smalltalk \cite{goldberg83} seems to be one of the few object-oriented
languages that has attracted interest in the research community with
regards to typechecking. It is also quite relevant to Object-Z because
it supports class union types. Graver and Johnson \cite{graver90}
discuss a type system for Smalltalk that is similar to both Chen's
model and our model. However, Graver and Johnson use a subtype
relation in their type system.
They state that the class type $A$ is a subtype of
$B$ if $A = B$. In addition, Graver and Johnson model class union
types as lists of class types, similar to ours. 

This is because Smalltalk is a language in which the type information
flow is one-way. That is, for the assignment statement $b = a$, in
which $b \in B$, $a \in \poly A$, and $B$ inherits $A$, a Smalltalk
typechecker can detected that $a$ could possibly be in $A$, and that
this is type inconsistent. Specification languages using the pre- and
post-condition style for operations do not have assignment, so the
statement $b = a$ is a predicate specifying that they are equal -- not
an assignment. Even though it is possible that $a \in A$, it is also
possible that $a \in B$, so this is type consistent. Therefore, in
Graver and Johnson's Smalltalk type system, if we have a type $A$,
then $A \subtypeeq A \classuni B$ (in which $\subtypeeq$ is a
subtyping relation), but $A \classuni B \not\subtypeeq A$ and $B
\not\subtypeeq A \classuni B$, even though an object $ab$ with type
$AB$ is an instance of one of the classes representing the types $A$
and $B$. This is different to both versions of our unification
relation.
