\section{Related Work}

Typechecking formal object-oriented specification languages has not
been investigated in great detail in the existing literature,
especially when compared to other specification languages such as Z.

Chen's class type model \cite{chen94}, discussed in
Section~\ref{background}, is similar to our model, but models classes
as sets of object identities, but with no discussion of how to
represent these sets. Chen does not model the polymorphic core in
class types, making feature renaming difficult to support, and meaning
that the polymorphic core must be calculated each time a reference to
a class type with more than one subtype is made. Chen does not discuss
unification or type inference. No other reference to Chen's Object-Z
typechecker can be found in literature or via an Internet search.

The Wizard typechecker for Object-Z \cite{johnston96} models class
types similar to that of Chen. The basic class type is a {\em class
reference type}, with two additional types included: {\em
polymorphic reference type} and {\em class union type}. A polymorphic
reference type is a class reference type with an additional list of
subclasses that define possible sets of object identities. A class
union type is a set of class reference types. This is similar to
our model, but differs in that the core information of polymorphic
expressions and class unions is modelled in each class
reference. Neither unification or type inference are discussed in
\cite{johnston96}, and Wizard supports only weak typing.

Smalltalk \cite{goldberg83} seems to be one of the few object-oriented
languages that has attracted interest in the research community with
regards to typechecking. It is also quite relevant to Object-Z because
it supports class union types and implicit downcasting. Graver and
Johnson \cite{graver90} discuss a type system for Smalltalk that is
similar to both Chen's model and our model. Graver and Johnson model
class union types as lists of class types, similar to ours. However,
they use a subtype relation in their type system.

This is because Smalltalk is a language in which the type information
flow is one-way. That is, for the assignment statement $b := a$, in
which $b \in B$, $a \in \poly A$, and $B$ inherits $A$, a Smalltalk
typechecker can detected that $a$ could possibly be in $A$, and that
this is type inconsistent. Specification languages using the pre- and
post-condition style for operations do not have assignment, so the
statement $b = a$ is a predicate specifying that they are equal -- not
a one-way assignment. Even though it is possible that $a \in A$, it is
also possible that $a \in B$, so this can be considered type
consistent. Therefore, in Graver and Johnson's Smalltalk type system,
if we have a type $A$, then $A \subtypeeq A \classuni B$ (in which
$\subtypeeq$ is a subtyping relation), but $A \classuni B
\not\subtypeeq A$ and $B \not\subtypeeq A \classuni B$, even though an
object $ab$ with type $AB$ is an instance of one of the classes
representing the types $A$ and $B$. Subtyping over two class reference
types is defined as equality. These definitions are
different to both versions of our unification function.
