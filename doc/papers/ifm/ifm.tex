\documentclass{llncs}
\pagestyle{headings}   % turn on page numbers

\usepackage{url}

\newcommand{\Class}[1]{\texttt{#1}}
\newcommand{\Interface}[1]{\texttt{#1}}
\newcommand{\Method}[1]{\texttt{#1}}

\begin{document}
\title{CZT support for Z extensions}
\author{Leo Freitas \and Tim Miller \and Petra Malik \and Mark Utting}
\maketitle

\begin{abstract}
  An integrated framework for supporting multiple dialects of a formal
  notation.
\end{abstract}

\section{Introduction} \label{sec:intro}

  The Z language~\cite{isoz} is a formal specification language that
  can be used to precisely specify the behaviour of systems, and
  analyse it via proof, animation, test generation etc.  The Community
  Z Tools (CZT) project~\cite{czt} is an open-source Java framework
  for building formal methods tools for Z and Z dialects.

  [TODO: write more]

\section{XML Schemas and AST classes}

  The first step was the development of an XML Schema~\cite{UttEA:03}
  that describes the XML markup for Z specifications (ZML).  This is
  an interchange format that can be used to exchange parsed and even
  typechecked Z specifications between sessions and tools.

  Standard Z allows specifications to be exchanged using Unicode,
  \LaTeX\ or email markup.  However, implementing a parser for such
  specifications is a non-trivial task that might take several weeks
  or even months to be finished.  ZML, in contrast, can be parsed
  immediatly using one of the available XML parsers like
  Xerces\footnote{\url{http://xml.apache.org/xerces-j/}} or
  Crimson\footnote{\url{http://xml.apache.org/crimson/}}.

  Tools also benefit from being able to annotate terms with type
  information, anticipated usage, comments, and so on.  The ZML format
  allows such annotations.

  The XML Schema for ZML has been carefully designed to be extensible
  in order to allow Z dialects and extensions to profit from those
  advantages as well.  The following strategies have been used to
  achieve this.

  The any element can be used in an XML Schema to enable instance XML
  documents to contain additional elements not specified by the
  schema.  This concept has been used to define annotations.  That is,
  an annotation to a term can either be one of the annotations defined
  in the XML Schema for Z or any other kind of data.  This allows a
  tool builder to decide what data makes sense for a particular tool.

  Secondly, inheritance is used extensively.  Abstract elements are
  used to provide placeholders for their derived elements.

  [TODO: The XML Schema can be extended without touching it.]

  [TODO: Perhaps give an example of how the Z hierarchy can be
  extended in Object Z?]

  [TODO: are there other things that make the Schema extensible?]

  \begin{itemize}
    \item[LEO] The old Circus parser has a series of problems in the Z
      part that the CZT XML classes and parser have solved.  Z/Eves
      files are also defined in XML and I've got the internal
      documentation and I am used with it (good for comparison).  It
      may be an interesting example on how the idea of XML seems to be
      the way forward.
  \end{itemize}



  The Java \emph{annotated syntax tree} (AST) provides a tree view of
  a parsed Z specification using Java interfaces and classes.  This
  allows easy access to syntactical objects like, for instance,
  paragraphs, predicates, and expressions, from within Java programs.

  The CZT Java AST interfaces and classes were automatically generated
  from the XML Schema describing ZML using our code generator
  \emph{GnAST} (GeNerator for AST).  The generated code looks similar
  to the code Java data binding tools like
  JAXB\footnote{\url{http://java.sun.com/xml/jaxb/}} or
  Castor\footnote{\url{http://www.castor.org/}} are producing.  The
  generated Java interfaces and classes represent the structures
  defined in the XML Schema instance document.  While the main purpose
  of a Java binding tool is to provide the ability to convert from XML
  format to Java objects and vice versa, the main purpose of GnAST is
  to generate well-designed AST classes.  For example, the AST classes
  generated by GnAST support the visitor design pattern described
  later on.

  GnAST has also been used to generate AST interfaces and classes for
  Z extensions like Object Z, TCOZ, and Circus.  This provides a very
  convenient way to obtain AST's for Z extensions that fit well into
  the AST for Standard Z.  For example, the AST classes for Z
  extensions also support the visitor design pattern described below.

  This architectrue makes it very easy to write tools like
  typechecker, printer, etc.\ that need to traverse an AST.  The
  visitor design pattern~\cite{GamEA:95,MaiCha:01} provides a way to
  separate the structure of a set of objects from the operations
  performed on these objects.  This allows a new operation to be
  defined without modifying the AST classes.  To define a new
  operation, all you need to do is to implement a new visitor class.

  In CZT, a visitor interface is defined for every AST class,
  including abstract superclasses.  If a visitor implements this
  interface, then any \Interface{AxPara} AST nodes that it visits will
  call the visitor's \Method{visitAxPara} method.  However, if the
  visitor does not implement the \Interface{AxParaVisitor} interface,
  then the \Interface{AxPara} AST nodes will search up though their
  superclasses and call the first \Method{visit$AAA$} method that the
  visitor implements (for example, \Interface{visitPara} or
  \Interface{visitTermA} or \Interface{visitTerm}).  With this
  approach, the AST classes themselves take care of calling the
  closest (with respect to the inheritance hierarchy) \Method{visit}
  method implemented by the visitor.

  \begin{itemize}
    \item[LEO] Here I can include the architecture of the Circus
      Compiler that uses two Visitors, one for each semantic function.
      The multiple hierarchies are really helpful as it allows me to
      implement the compilation rules piecewise.
  \end{itemize}

\section{Parsing}

  CZT includes parsers for Standard Z specifications given either in
  Unicode or using \LaTeX\ mark-up.  Support for e-mail mark-up is
  planned.  The different mark-up languages suit different
  communities.  For example, \LaTeX\ is prefered by researchers while
  Unicode WYSIWYG editing might be more attractive for students or
  industrial users.

  The CZT parser is generated using the Java
  Cup\footnote{\url{http://www.cs.princeton.edu/~appel/modern/java/CUP}}
  parser generator.

  In addition to a parser for Z, an Object Z parser is provided, and a
  Circus parser as well as a TCOZ parser are under development.  The
  Object Z, TCOS, and Circus parser and scanner extend the Z parser
  and scanner by some more tokens and grammar rules.  Unfortunately,
  it is quite difficult to reuse code from an automatically generated
  scanner or parser, and Java Cup does not provide means to do so.  To
  avoid duplicated code, XML templates are used that contain the
  different parser and scanner variants.  From this, the different
  source files are generated.  This maximises the commonality between
  the parsers and minimises versioning and maintenance problems.

  \begin{itemize}
    \item[LEO] Here Tim or I could include the basics for setting up
               and extending parsers.
    \item[LEO] Worthwhile mentioning performance penalties as the
               section manager, OpTable, and DefinitionTable, are
               quite slow.
  \end{itemize}

\subsection{Section Manager}

  (is independent of Z/Object-Z/Circus etc.
  Can easily be extended with new kinds of objects, commands)

    \begin{itemize}
        \item[LEO] The SectionManager commands archiecture is a clever solution I believe worthwhile explaining.
    \end{itemize}

\section{Type Checking}

      The (future!) modular design, using interfaces and visitors,
      allows the core Z typechecker to be extended separately
      to handle Object-Z and Circus.  (TODO!)

    \begin{itemize}
        \item[LEO] I can include my experiences in extending the Z:TypeChecker for Circus.
                    I should also discuss with Tim some of the ideas for decoupling the type checker.
    \end{itemize}

\section{Animating}

    Animation of Circus using Z animator???
      (Operational semantics of Circus are in Z itself, so this makes a meta-level animation possible...)
    This could set the scenario for the possibilities CZT gives towards integration.

    \begin{itemize}
        \item[LEO] I can write here about the Circus refinement engine that uses ZLive, as well as the compiler.
    \end{itemize}


\section{Other Tools}

    \begin{itemize}
        \item[LEO]
        There is another tool under development that translates Circus (Latex) specifications into Java code.
        It uses JCSP (a java csp-occam library) that allows execution of Circus.
        In the Z part, due to the lack of tools, extreme simplifications (via data refinement in the original Circus)
        are needed.
        This tool could also use ZLive to be able to animate/execute (run!) more expressive Circus specifications quite
        automatically, or at least minimise the data refinement effort required for the translation
    \end{itemize}


\section{Conclusions and Future Work} \label{sec:conclusions}

\section*{Acknowledgements}

\bibliographystyle{splncs}
\bibliography{ifm}

\end{document}
