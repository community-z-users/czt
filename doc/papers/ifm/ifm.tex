\documentclass{llncs}
\pagestyle{headings}   % turn on page numbers

\begin{document}
\title{CZT support for Z extensions}
\author{Leo Freitas \and Tim Miller \and Petra Malik \and Mark Utting}
\maketitle

\begin{abstract}
  An integrated framework for supporting multiple dialects of a formal
  notation.
\end{abstract}

\section{Introduction} \label{sec:intro}

  The Z language~\cite{isoz} is a formal specification language that
  can be used to precisely specify the behaviour of systems, and
  analyse it via proof, animation, test generation etc.  The Community
  Z Tools (CZT) project~\cite{czt} is an open-source Java framework
  for building formal methods tools for Z and Z dialects.

  [TODO: write more]

\section{XML Schemas and AST classes}

  The first step was the development of an XML Schema\cite{UttEA:03}
  that describes the XML markup for Z specifications (ZML).  This is
  an interchange format that can be used to exchange parsed and even
  typechecked Z specifications between sessions and tools.

  Standard Z allows specifications to be exchanged using Unicode,
  \LaTeX\ or email markup.  However, implementing a parser for such
  specifications is a non-trivial task that might take several weeks
  or even months to be finished.  ZML, in contrast, can be parsed
  immediatly using one of the available XML parsers [TODO: cite some].

  Tools also benefit from being able to annotate terms with type
  information, anticipated usage, comments, and so on.  The ZML format
  allows such annotations.

  The XML Schema for ZML has been carefully designed to be extensible
  in order to allow Z dialects and extensions to profit from those
  advantages as well.  The following strategies have been used to
  achieve this.

  The any element can be used in an XML Schema to enable instance XML
  documents to contain additional elements not specified by the
  schema.  This concept has been used to define annotations.  That is,
  an annotation to a term can either be one of the annotations defined
  in the XML Schema for Z or any other kind of data.  This allows a
  tool builder to decide what data makes sense for a particular tool.

  Secondly, inheritance is used extensively.  Abstract elements are
  used to provide placeholders for their derived elements.

  [TODO: The XML Schema can be extended without touching it.]

  [TODO: Perhaps give an example of how the Z hierarchy can be
  extended in Object Z?]

  [TODO: are there other things that make the Schema extensible?]

  \begin{itemize}
    \item[LEO] The old Circus parser has a series of problems in the Z
      part that the CZT XML classes and parser have solved.  Z/Eves
      files are also defined in XML and I've got the internal
      documentation and I am used with it (good for comparison).  It
      may be an interesting example on how the idea of XML seems to be
      the way forward.
  \end{itemize}

 The \emph{annotated syntax tree} (AST) provides a tree view of a
  parsed Z specification using Java interfaces and classes.  This
  allows easy access to syntactical objects like, for instance,
  paragraphs, predicates, and expressions, from within Java programs.

  The AST interfaces and classes were automatically generated from the
  XML Schema describing ZML using our self-written code generator
  \emph{GnAST} (GeNerator for AST). [TODO: mention similarities to
  other Java XML binding compilers like JAXB].

  [TODO: explain that tools need to traverse AST]

  The visitor design pattern~\cite{GamEA:95} provides a way to
  separate the structure of a set of objects from the operations
  performed on these objects.  This allows a new operation to be
  defined without modifying the AST classes.  To define a new
  operation, all you need to do is to implement a new visitor class.

  A variety of variants~\cite{MaiCha:01} of the visitor design pattern
  have been proposed, all having different advantages and
  disadvantages.  The visitor design used in CZT is the result of a
  lot of experimentation and redesign.  We discussed many variants and
  implemented three or four different designs before we found a design
  that met all our requirements.

  [TODO: describe CZT visitor design pattern, or just refer to the CZT
  paper?; at least mention that it supports multiple hierarchies]


  \begin{itemize}
    \item[LEO] Here I can include the architecture of the Circus
      Compiler that uses two Visitors, one for each semantic function.
      The multiple hierarchies are really helpful as it allows me to
      implement the compilation rules piecewise.
  \end{itemize}

\section{Parsing}

  \begin{enumerate}
    \item Multiple parsers and scanners (xml templates)
        \begin{itemize}
            \item[LEO] Here Tim or I could include the basics for setting up and extending parsers.
        \end{itemize}

    \item Multiple markups for each language.
      (suits different communities:  Latex for researchers,
      Unicode WYSIWYG editing for students and industry etc.)
      \begin{itemize}
         \item[LEO] Worthwhile mentioning performance penalties as the section manager,
                OpTable, and DefinitionTable, are quite slow.
      \end{itemize}
  \end{enumerate}

\subsection{Section Manager}

  (is independent of Z/Object-Z/Circus etc.
  Can easily be extended with new kinds of objects, commands)

    \begin{itemize}
        \item[LEO] The SectionManager commands archiecture is a clever solution I believe worthwhile explaining.
    \end{itemize}

\section{Type Checking}

      The (future!) modular design, using interfaces and visitors,
      allows the core Z typechecker to be extended separately
      to handle Object-Z and Circus.  (TODO!)

    \begin{itemize}
        \item[LEO] I can include my experiences in extending the Z:TypeChecker for Circus.
                    I should also discuss with Tim some of the ideas for decoupling the type checker.
    \end{itemize}

\section{Animating}

    Animation of Circus using Z animator???
      (Operational semantics of Circus are in Z itself, so this makes a meta-level animation possible...)
    This could set the scenario for the possibilities CZT gives towards integration.

    \begin{itemize}
        \item[LEO] I can write here about the Circus refinement engine that uses ZLive, as well as the compiler.
    \end{itemize}


\section{Other Tools}

    \begin{itemize}
        \item[LEO]
        There is another tool under development that translates Circus (Latex) specifications into Java code.
        It uses JCSP (a java csp-occam library) that allows execution of Circus.
        In the Z part, due to the lack of tools, extreme simplifications (via data refinement in the original Circus)
        are needed.
        This tool could also use ZLive to be able to animate/execute (run!) more expressive Circus specifications quite
        automatically, or at least minimise the data refinement effort required for the translation
    \end{itemize}


\section{Conclusions and Future Work} \label{sec:conclusions}

\section*{Acknowledgements}

\bibliographystyle{splncs}
\bibliography{ifm}

\end{document}
