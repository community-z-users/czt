<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<meta name="author" content="Mark Utting">
<title>CZT Projects</title>
</head>

<body>
<h1>CZT Projects</h1>

Here is a list of possible CZT projects.
Some should be suitable for student semester projects,
or larger honours/masters projects.

<p>
It is based on the assumption that in the short term, CZT will
provide a loosely coupled set of tools (like UNIX command-line tools),
centred around an <a href="http://czt.sourceforge.net/zml">XML markup</a>
for Z.  As well as the formal parts of a Z specification,
this XML markup can include the informal text of specifications,
and a wide variety of annotations, such as types, cross reference
links and source-file positions.

<p>
CZT also provides a Java representation of Z,
because communicating via XML files is a very heavy-weight
mechanism, and is an inefficient way of linking a sequence
of lightweight tools together.  For example, in CADiZ, prelude.tex
is 4141 bytes.  Excluding informal text, prelude.utf8 is 792 bytes,
but prelude.xml is 22212 bytes.
Similarly, standard_toolkit.utf8 is 14093 bytes, and
standard_toolkit.xml is 573670 bytes.
So there is an overhead of roughly 20 times for XML,
and that's with only some of the type annotations present.
Also, many projects are likely to want to write tools in Java,
so it is desirable to have the AST (Annotated Syntax Trees)
already defined in Java, with commands to convert them to and from
the XML format etc.

<p>
Possible projects
<dl>
  <dt>Z/Java Definition [DONE]
  <dd>Define Java data structures for Z, closely based on the XML DTD for Z.

  <dt>Z/XML to/from Z/Java [DONE]
  <dd>Write a Java module that reads Z/XML format and converts it into the
      Z/Java data structures, and vice versa.  These will use the standard
      Java XML library. 

  <dt>Standard Z to Z/Java input chain. [DONE except for typechecking]
  <dd>Eventually, we probably want Java versions of Z lexing, parsing,
      typechecking etc.  This project will reimplement these, based on the
      markups defined in the Z standard, the grammar on Ian Toyn's web
      page, and the existing Zeta parser/typechecker chain. 

  <dt>Z/Java to Latex/Email/Unicode [Petra is working on this]
  <dd>Write Java modules for outputting Z/Java specifications in each of
      the markups defined in the Z standard.  The LaTeX output will be
      useful for displaying Z.
      
  <dt>Schema Unfolder
  <dd>Write a Java module that contains procedures for unfolding various Z
      constructs, such as the schema operators.  This will allow other
      tools to start with a simplified form of Z if they wish. 
  
  <dt>Z Simplifier
  <dd>Write a Java module that provides various routines for simplifying
      Z.  The goal is to quickly simplify a Z construct before passing it
      to other tools, such as theorem provers.  The simplifier would remove
      obvious redundancies (that typically result from other
      transformations), apply one-point rules etc. (Ideally, transformation
      tools like this and the above two should be generic, driven by a
      table of transformation rules that are written in a Z-like syntax,
      similar to the proof rules of CadiZ). 
  
  <dt>Z Editor [Satish at Oxford is working on this]
  <dd>Write (in Java) a simple WYSIWYG Z editor for students, similar
      to the Z/EVES editor.

  <dt>ZEUS Connection?
  <dd>Write a connection between ZEUS and Zeta, so that ZEUS can
      be used as the Z editor for large projects?

  <dt>XEmacs Connection?
  <dd>Write/upgrade the Zeta to XEmacs connection so that 
      specifications can be edited using XEmacs, in LaTeX markup.

  <dt>Proof Obligations
  <dd>Write a tool that generates various proof obligations for a
      Z specification, such as domain checks, Init feasibility,
      preservation of some additional invariant.

  <dt>Refinement Condition Generator
  <dd>Write a tool that, given two schemas, generates the proof 
      obligations that check that one schema is an algorithmic refinement
      of the other.

  <dt>Translators to provers.
  <dd>Write translators from Z/Java into the input formats of
      various provers/systems, such as Z/EVES (accepts LaTeX or the Z/EVES
      XML format), Isabelle, SMV, Alloy, B, TLA, PVS etc.  This would allow
      conjectures to be discharged and other properties to be proved. 

  <dt>TTF Test Case Generator
  <dd>Write an interactive tool that implements the TTF (Test Template
      Framework) strategies for specification-based testing.

  <dt>Code Skeleton Generator [Bing Wang at Waikato is working on this]
  <dd>Write a tool that, for a restricted subset of Z, generates
      executable Java code for a schema, with JML preconditions and
      postconditions.

  <dt>Z Style/Pattern Checker
  <dd>See the ZB2003 patterns papers.

  <dt>Object-Z to Z translator
  <dd>Maps the object-oriented constructs into plain Z.
      UQ has a prototype of this.

  <dt>UML-Z tools
  <dd>Tools to convert from UML into Z and perhaps vice versa.

  <dt>Case Studies
  <dd>Develop a library of case studies, all in ISO Standard Z.
</dl>

<hr>
<address>marku@cs.waikato.ac.nz</address>
<!-- hhmts start -->
Last modified: Thu Mar 18 11:49:29 NZDT 2004
<!-- hhmts end -->
</body> </html>
