<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.2//EN" "http://apache.org/forrest/dtd/document-v12.dtd">
<document> 
  <header> 
    <title>CZT Design Alternatives and Rationale</title> 
  </header> 
  <body>
    <p>
      This document describes some CZT design issues, the solutions
      that were considered, the pros and cons for those solutions,
      the criteria used to choose between, and which choice was made.
    </p>

    <section id="ast-mutable">
      <title>Should the AST be mutable or immutable or both?</title>
      <section>
        <title>Mutable</title>
        <p>Each AST interface provides setXXX(newVal) methods as well as
	getXXX().</p>
	<table>
	  <tr><td>+</td>
	      <td>Some visitors/algorithms are more efficient.
	      For example, the typechecker can just add the missing
	      generic instantiation parameters, without copying the tree.
	      </td></tr>
	  <tr><td>-</td>
              <td>Makes sharing of common subtrees
                  difficult/error-prone</td></tr> 
	  <tr><td>-</td>
              <td>Programmers must be careful not to mutate AST objects
	        that are used in the domain of Maps etc.  This requires
		global knowledge.
		</td></tr> 
	</table>
      </section>
      <section>
        <title>Immutable</title>
        <p>Each AST interface has only getXXX() methods.
	All data fields have to be set in the constructor.
	A variant would be to allow annotations to be mutable,
	while other data fields are immutable.</p>
	<table>
	  <tr><td>+</td>
	      <td>Less error prone to accidental changes.</td></tr>
	  <tr><td>+</td>
              <td>Makes sharing of common subtrees easy (except for
	      	annotations like LocAnn!)</td></tr>
	  <tr><td>+</td>
              <td>Section managers must provide methods to update
	        the AST of a section after a visitor has changed it.
		This tells the section manager when to discard derived
		products. 
	      	</td></tr>
	</table>
      </section>
      <section>
        <title>Both</title>
        <p>Each AST interface provides setXXX(newVal) methods as well as
	getXXX(), but implementations are allowed to throw an exception
	instead of implementing the setXXX methods.  Different factories
	would be provided for each style (mutable/immutable).  This is
	similar to the Java List interface.</p>
	<table>
	  <tr><td>-</td>
	      <td>More complex -- more classes -- user must choose which to
	      	use.</td></tr>
	  <tr><td>+</td>
              <td>Allows efficiency of the mutable approach or the
	        safety of the immutable one (depending upon which factory
		is used).
	      	</td></tr>
	</table>
      </section>
      <section>
        <title><em>Conclusions</em></title>
        <p>We have initially implemented mutable.  We are considering
      implementing 'Both' and gradually moving towards immutable.</p>
      </section>
    </section>




    <section id="scope-problems">
      <title>Scope Problems: how to avoid variable capture?</title>
      <p>There are two kinds of scope problems that arise in a Z tool.
      The first is that the typechecker must sometimes insert a reference
      to a global type T from within a hole in the scope of T.
      This is described in Section 4.3 of the ZB2003 paper 
      <link href="ext:zml-paper"><em>ZML: XML Support for Standard
      Z</em></link>.
      </p>
      <p>The second scope problem is the standard one of variable
      capture during substitution <code>P[E/x]</code> -- one must be
      careful that local (bound) variables do not capture any free
      variables of <code>E</code>.
      </p>
      <p>These problems become more complex because we want to
      save parts of a specification as XML files, then reload
      them later.  We also want the XML file to contain links
      between variable declarations and uses (where possible).
      </p>
      <p>There are three common solutions to the second problem,
      so we describe these first.
      </p>
      <section>
        <title>Rename during Substitution</title>
        <p>Bound variables are renamed when necessary, to avoid capturing
	free variables.</p>
	<table>
	  <tr><td>+</td>
	      <td>This is a traditional well-known solution.
	      </td></tr>
	  <tr><td>-</td>
              <td>It is incredibly easy to make subtle errors while
	      implementing this.  These errors are rarely uncovered,
	      ecause they depend upon certain combinations of free and bound
	      ariable names, so they result in rare and difficult bugs.
              </td></tr> 
	</table>
      </section>
      <section>
        <title>Use de Bruijn indices</title>
        <p>Bound variables do not have names.  Instead, each reference
	to a bound variable uses a number -- the distance from the
	reference up to the point of declaration of that bound variable.
	So for example, <code>\lambda x:T @ (\lambda y:U @ y x)</code>
	is represented by <code>\lambda T @ (\lambda U @ 0 1)</code>.
	This would need to be extended to handle the complexity of Z,
	such as multiple variable declarations.</p>
	<table>
	  <tr><td>+</td>
	      <td>This is another traditional well-known solution,
	      which is reportedly easier to get right than the renaming
	      solution. </td></tr>
	  <tr><td>-</td>
              <td>The printer has to re-add names in a way that is readable
	      and that does not create scope holes.
              </td></tr> 
	  <tr><td>-</td>
              <td>Complexity: the defns of substitution etc. are quite complex.
              </td></tr> 
	</table>
      </section>
      <section>
        <title>Unique names for all bound variables</title>
        <p>Every bound variable is assigned a unique name which
	is distinct from all global names.  Typically this is done
	by associating a unique number with each bound variable.
	A variant is to assign unique names to ALL variables,
	including globals.
	</p>
	<p>Variants:</p>
	<ol>
	  <li>we could do this only while the AST is in memory
	     (not save the unique names in XML files), or</li>
	  <li>within the XML files we could use the ID/IDREF attributes to
	      record these unique names (this is only allowed within a
	      single XML file, not between XML files), or </li>
	  <li>define our own crossref attributes (an arbitrary string)
	      and allow dangling references between XML files.</li>
        </ol>
	<table>
	  <tr><td>+</td>
	      <td>Substitution becomes trivial -- <code>P[E/x2]</code>
	      just involves replacing EVERY occurence of x2 by E
	      (because the free vars of E are disjoint from the
	      bound vars of P).
	      </td></tr>
	  <tr><td>-</td>
              <td>Must generate unique names/numbers across all AST trees.
	      This implies that bound variables within AST trees loaded
	      from XML files must be renumbered (if the numbers are saved
	      in the XML) or assigned fresh numbers.  
              </td></tr> 
	  <tr><td>-</td>
              <td>The printer must be careful to print the unique
	      name (rather than the original name) if this is necessary
	      to avoid scope holes.  One simple approach is to always
	      use the unique name of bound variables that have the
	      same base name as a global name.  This is safe, but
	      prints renamed bound variables slightly more often
	      than necessary.
              </td></tr> 
	</table>
      </section>
     </section>
  </body>
</document>
