\documentclass{article}
\usepackage{czt}

\parindent 0pt
\parskip 1ex plus 3pt

%% Syntax within provisos.

\newcommand{\sexprUnfoldsTo}{\mathrel{\leadsto_{se}}}
\newcommand{\declListUnfoldsTo}{\mathrel{\leadsto_d}}


\title{Unfolding Rules for ZLive}
\author{Mark Utting}
\begin{document}
\maketitle

TODO: Replace binding primitive by $\theta$ and correctly implement
the strange decoration semantics of $\theta$.


This document defines some simple rules for unfolding expressions 
and predicates prior to evaluating them in ZLive.  The rules are
applied repeatedly to each expression/predicate until no more rules
match, then the subexpressions are transformed.  So it is a top-down
traversal of the syntax tree.  We must be careful not to write rules
that create infinite loops of rewritings (eg. generating larger and
larger terms).

\begin{zsection}
  \SECTION ZLivePreprocess \parents unfold
\end{zsection}

\section{Rules from the sets\_toolkit}

We do not unfold $\emptyset$ to $\{\}$, because it is not possible
to preserve the type information (one cannot write $\{\}[T]$).
So this rule unfolds it to an easily-evaluated empty set that
preserves the type information.
\begin{zedrule}{emptysetTyped}
   \emptyset[E] = \{x:\{\} | x \in E\}
\end{zedrule}

TODO: $\power_1$ ?

\begin{zedrule}{intersection}
   E1 \cap E2 = \{x:E1 | x \in E2\}
\end{zedrule}

\begin{zedrule}{setminus}
   E1 \setminus E2 = \{x:E1 | x \notin E2\}
\end{zedrule}

\begin{zedrule}{symdiff}
  \proviso E1 : \power E
\derives
   E1 \symdiff E2 = \{ x:E | \lnot (x \in E1 \iff x \in E2) \}
\end{zedrule}

TODO: it might be better to make $\subseteq$ into a primitive constraint?
\begin{zedrule}{subseteq}
   E1 \subseteq E2 \iff (\forall x:E1 @ x \in E2)
\end{zedrule}

\begin{zedrule}{subset}
   E1 \subset E2 \iff (\forall x:E1 @ x \in E2) \land E1 \neq E2
\end{zedrule}

Some rules for easy cases of $\bigcup$.
\begin{zedrule}{genunion1}
   \bigcup \{E\} = E
\end{zedrule}

TODO: we really want a recursive rule here,
but we need an ExprList joker for that.
\begin{zedrule}{genunion2}
   \bigcup \{E1,E2\} = E1 \cup E2
\end{zedrule}
\begin{zedrule}{genunion3}
   \bigcup \{E1,E2,E3\} = E1 \cup E2 \cup E3
\end{zedrule}

A general rule for $\bigcup$.
The right-hand side will be evaluable after we have implemented
some reordering optimizations. 
\begin{zedrule}{genunion}
   \proviso E : \power \power E2
\derives
   \bigcup E = \{s:E; x:E2 | x \in s @ x\}
\end{zedrule}

This right-hand side will not be evaluable in general,
unless the base type $E2$ is small.  We might have to
implement $\bigcap$ as a primitive?
\begin{zedrule}{genintersection}
   \proviso E : \power \power E2
\derives
   \bigcap E = \{x:E2 | (\forall s:E @ x \in s) @ x\}
\end{zedrule}


\section{Rules for Relations}

\begin{zedrule}{firstdef}
   first~ E = E.1
\end{zedrule}

\begin{zedrule}{seconddef}
   second~ E = E.2
\end{zedrule}

\begin{zedrule}{maplet}
   E1 \mapsto E2 = (E1,E2)
\end{zedrule}

\begin{zedrule}{domain}
   \dom E = \{x:E @ x.1\}
\end{zedrule}

\begin{zedrule}{range}
   \ran E = \{x:E @ x.2\}
\end{zedrule}

\begin{zedrule}{identity}
   \id E = \{x:E @ (x,x)\}
\end{zedrule}

\begin{zedrule}{relcomp}
   E1 \comp E2 = \{r1:E1; r2:E2 | r1.2=r2.1 @ (r1.1,r2.2)\}
\end{zedrule}

\begin{zedrule}{funccomp}
   E1 \circ E2 = \{r1:E1; r2:E2 | r2.2=r1.1 @ (r2.1,r1.2)\}
\end{zedrule}

\begin{zedrule}{domainrestriction}
   E1 \dres E2 = \{r:E2 | r.1 \in E1\}
\end{zedrule}

\begin{zedrule}{rangerestriction}
   E1 \rres E2 = \{r:E1 | r.2 \in E2\}
\end{zedrule}

\begin{zedrule}{domainsubtraction}
   E1 \ndres E2 = \{r:E2 | r.1 \notin E1\}
\end{zedrule}

\begin{zedrule}{rangesubtraction}
   E1 \nrres E2 = \{r:E1 | r.2 \notin E2\}
\end{zedrule}

\begin{zedrule}{inverse}
   E1 \inv = \{r:E1 @ (r.2,r.1)\}
\end{zedrule}

\begin{zedrule}{relimage}
   E1 \limg E2 \rimg = \{r:E1 | r.1 \in E2 @ r.2\}
\end{zedrule}

This is a bit complicated, because we have to expand $\dom$ out.
\begin{zedrule}{reloverride}
   E1 \oplus E2 = ((\dom E2) \ndres E1) \cup E2
%   E1 \oplus E2 = \{domE2==\{r2:E2@r2.1\}; r1:E1 | r1.1 \notin domE2 @ r1\} \cup E2
\end{zedrule}

TODO: transitive closure and reflexive transitive closure.


\section{Unfolding Definitions}

Next, we try unfolding simple definitions.
(This must at least come after the $\emptyset$ rule above,
otherwise the definition of emptyset in the sets\_toolkit
gets used instead of our simpler unfold rule).

\begin{zedrule}{unfolddefn}
  \proviso? ~ E==E2
\derives
   E = E2
\end{zedrule}


\section{Rules for Functions}

TODO: generalise this to work on more complex decllists.
(We must calculate its characteristic tuple).
\begin{zedrule}{lambda}
   (\lambda v:E @ E2) = \{v:E @ (v,E2) \}
\end{zedrule}

%% NOTE: We do not include this rule, because it causes TOO MANY
%% applications to be unfolded.  Instead, ZLive does this
%% rule as the last step of unfolding, after all its
%% predefined operators have been translated into FlatPred
%% constraints.
%\begin{zedrule}{funcappl}
%   E1 ~ E2 = (\mu r:E1 | r.1=E2 @ r.2)
%\end{zedrule}

TODO: add a new set representation, which handles all function types,
plus relations and the various kinds of sequences.

\begin{zedrule}{disjointdef}
   \disjoint E \iff (\forall p,q:E | p \neq q @ p.2 \cap q.2 = \{\})
\end{zedrule}

\begin{zedrule}{partitiondef}
   E1 \partition E2 \iff \disjoint E1 \land \bigcup(\ran E1) = E2
\end{zedrule}


\section{Integer Rules}

These are mostly handled as primitives of ZLive.

\begin{zedrule}{num1}
   \num_1 = \{x:\num | x \neq 0\}
\end{zedrule}

TODO: add mod as a primitive?

TODO: implement iter somehow (it is like transitive closure).

TODO: implement min and max as primitives, but only over integer sets.


\section{Sequence Rules}

\begin{zedrule}{literalsequence}
   (\langle \listarg \rangle) ~ E = E
\end{zedrule}

TODO: implement concatenation as a primitive, with several
modes of evaluation (III is semi-det, IIO, OII and IOI are det
and OOI is multi-det).

TODO: this could be more efficient and have more modes if it
was a primitive? (IO and OI are det).
\begin{zedrule}{reverse}
   rev ~ E = (\lambda n:\dom E @ E(\# E - n + 1))
\end{zedrule}

\begin{zedrule}{headdef}
   head ~ E = E ~ 1
\end{zedrule}

\begin{zedrule}{lastdef}
   last ~ E = E ~ (\# E)
\end{zedrule}

TODO: it might be possible and better to implement $s=tail~e$
as $\langle x \rangle \cat s = e$, where $x$ is a fresh variable?
Similarly for $front$.
\begin{zedrule}{taildef}
   tail ~ E = (\lambda n : 1 \upto (\# E - 1) @ E ~ (n+1))
\end{zedrule}

\begin{zedrule}{frontdef}
   front ~ E = \{\# E\} \ndres E
\end{zedrule}

TODO: implement squash as a primitive?
Because the following definition from the Z standard is quite 
inefficient as an evaluation rule ($O(N^2)$ at least).  
Also, this definition is not quite correct, because it does
not return undefined when $s$ is not a function.
\begin{zedrule}{squash}
   squash~E = \{ p:E @ \#\{i:\dom E | i \leq p.1\} \mapsto p.2 \}
\end{zedrule}

\begin{zedrule}{extractdef}
   E1 \extract E2 = squash(E1 \dres E2)
\end{zedrule}

\begin{zedrule}{filterdef}
   E1 \filter E2 = squash(E1 \rres E2)
\end{zedrule}

TODO: this might be better done using $\cat$
(if we had much more sophisticated modes).
\begin{zedrule}{prefixdef}
   E1 \prefix E2 \iff E1 \subseteq E2
\end{zedrule}

\begin{zedrule}{suffixdef}
   \proviso E1 : \power (\arithmos \cross E3)
\derives
   E1 \suffix E2 \iff (\exists s:\seq E3 @ s \cat E1 = E2)
\end{zedrule}

\begin{zedrule}{infixdef}
   \proviso E1 : \power (\arithmos \cross E3)
\derives
   E1 \infix E2 \iff (\exists s,t:\seq E3 @ s \cat E1 \cat t = E2)
\end{zedrule}

For distributed concatenation, we have a recursive rule and
two base cases, exactly like the axioms in the Z standard.
However, the recursive axiom will not match all arguments,
so we really need some additional recursive rules that use 
head and tail (but these would only be valid when the sequence
is non-empty, hence we need an if-then-else or something, but this
creates an infinite rewrite loop...).  So we probably have to
implement $\dcat$ as a ZLive primitive. 
\begin{zedrule}{dcat0}
   \dcat \langle \rangle = \langle \rangle
\end{zedrule}
\begin{zedrule}{dcat1}
   \dcat \langle E \rangle = E
\end{zedrule}
\begin{zedrule}{dcatdistributive}
   \dcat (E1 \cat E2) = (\dcat E1) \cat (\dcat E2)
\end{zedrule}

% This rule causes infinite recursion, of course!
%\begin{zedrule}{dcatheadtail}
%   \dcat E = \IF E=\{\} 
%             \THEN \{\} 
%             \ELSE (\dcat (head~E)) \cat (\dcat (tail~E))
%\end{zedrule}


\end{document}
