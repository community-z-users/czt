\documentclass{article}
\usepackage{oz}
\usepackage{alltt}
\newenvironment{Rationale}{\\ \textbf{Rationale:}\it}{}
\newcommand{\V}{\mathcal{V}}

% Simulate some standard Z commands
\newenvironment{zsection}{\[}{\]}
\newcommand{\SECTION}{\textbf{section}~}
\newcommand{\parents}{\mathrel{\textbf{parents}}}
\newcommand{\relation}{\mathrel{\textbf{relation}}}
\newcommand{\function}{\mathrel{\textbf{function}}}
\newcommand{\generic}{\mathrel{\textbf{generic}}}
\newcommand{\leftassoc}{\mathrel{\textbf{leftassoc}}}
\newcommand{\rightassoc}{\mathrel{\textbf{rightassoc}}}


% Rule syntax: \begin{zedrule}{Name} Ant1 \\ Ant2 \derive Concl \end{zedrule}
\newenvironment{zedrule}[1]{\par\textbf{rule }#1\vspace{-1ex}\infrule}{\endinfrule}
\newcommand{\derives}{\derive{}}

\newenvironment{zedjoker}[1]{\par$\bigstar$ #1\ }{}

\newcommand{\Context}{\Gamma}
\newcommand{\notfreein}{\mathbin{\backslash}}
\newcommand{\HasType}{\mathbin{:}} % \small\rlap{$\circ$}{\raisebox{1ex}{$\circ$}}}}
\parindent 0pt
\parskip 1ex plus 3pt

%% Define some extra macros for the Z standard.
%% These will eventually be defined in a czt.sty file.
\newcommand{\negate}{\mathop{-}}
\newcommand{\arithmos}{{A\!\!\!\!A}}   %% TODO: get a proper symbol
\newcommand{\substitute}{\mathrel{\curvearrowleft}}  % U+21B6
\newcommand{\proviso}{\raisebox{0.5ex}{${}_{\blacktriangleright}\ $}}%%or\star
%       %%Zprechar \proviso U+22C6    % small star, or
%       %%Zprechar \proviso U+25B8    % small solid triangle  |> )

%% Syntax within provisos
\newcommand{\schemamerge}{\mathbin{\textbf{schemamerge}}}


\title{Unfolding Rules for ZLive}
\author{Mark Utting}
\begin{document}
\maketitle

This document defines some simple rules for unfolding expressions prior to
evaluating them in ZLive.

\begin{zsection}
  \SECTION ZLivePreprocess \parents zpattern\_toolkit, standard\_toolkit
\end{zsection}

Declare the jokers used in these rules.

\begin{zedjoker}{DeclList} D, D1, D2, D3 \end{zedjoker} \\
\begin{zedjoker}{Pred} P, P1, P2, P3 \end{zedjoker} \\
\begin{zedjoker}{Expr} E, E1, E2, E3 \end{zedjoker} \\
\begin{zedjoker}{Name} v, v1, v2, v3 \end{zedjoker} \\

\newcommand{\unfoldsTo}{\mathrel{\leadsto}}

TODO 1: respect order of rules in this file.

Note that the right hand side of these rules must use only 
the primitive constraints of ZLive, because unfolding is done
as a single bottom-up pass, so the terms on the right hand side
are not unfolded again.

First we try unfolding simple definitions.
TODO: when the recursive call to = fails, continue with E.

\begin{zedrule}{unfolddefn}
  \proviso? ~ v==E \\
  E = E2
\derives
   v = E2
\end{zedrule}


\section{Rules from the sets\_toolkit}

\begin{zedrule}{emptyset}
   \emptyset = \{\}
\end{zedrule}

TODO: $\power_1$ ?

\begin{zedrule}{intersection}
   E1 \cap E2 = \{x:E1 | x \in E2\}
\end{zedrule}

\begin{zedrule}{setminus}
   E1 \setminus E2 = \{x:E1 | x \notin E2\}
\end{zedrule}

\begin{zedrule}{symdiff}
  \proviso E1 : \power E
\derives
   E1 \symdiff E2 = \{ x:E | \lnot (x \in E1 \iff x \in E2) \}
\end{zedrule}

TODO: it might be better to make $\subseteq$ into a primitive constraint?
\begin{zedrule}{subseteq}
   E1 \subseteq E2 \iff (\forall x:E1 @ x \in E2)
\end{zedrule}

\begin{zedrule}{subset}
   E1 \subset E2 \iff (\forall x:E1 @ x \in E2) \land E1 \neq E2
\end{zedrule}


\section{Rules for Relations}

\begin{zedrule}{first}
   first~ E = E.1
\end{zedrule}

\begin{zedrule}{second}
   second~ E = E.2
\end{zedrule}

\begin{zedrule}{maplet}
   E1 \mapsto E2 = (E1,E2)
\end{zedrule}

\begin{zedrule}{domain}
   \dom E = \{x:E @ x.1\}
\end{zedrule}

\begin{zedrule}{range}
   \ran E = \{x:E @ x.2\}
\end{zedrule}

\begin{zedrule}{identity}
   \id ~ E = \{x:E @ (x,x)\}
\end{zedrule}

\begin{zedrule}{relcomp}
   E1 \semi E2 = \{r1:E1; r2:E2 | r1.2=r2.1 @ (r1.1,r2.2)\}
\end{zedrule}

\begin{zedrule}{funccomp}
   E1 \semi E2 = \{r1:E1; r2:E2 | r2.2=r1.1 @ (r2.1,r1.2)\}
\end{zedrule}

\begin{zedrule}{domainrestriction}
   E1 \dres E2 = \{r:E2 | r.1 \in E1\}
\end{zedrule}

\begin{zedrule}{rangerestriction}
   E1 \rres E2 = \{r:E1 | r.2 \in E2\}
\end{zedrule}

\begin{zedrule}{domainsubtraction}
   E1 \ndres E2 = \{r:E2 | r.1 \notin E1\}
\end{zedrule}

\begin{zedrule}{rangesubtraction}
   E1 \nrres E2 = \{r:E1 | r.2 \notin E2\}
\end{zedrule}

\begin{zedrule}{inverse}
   E1 \inv = \{r:E1 @ (r.2,r.1)\}
\end{zedrule}

\begin{zedrule}{relimage}
   E1 \limg E2 \rimg = \{r:E1 | r.1 \in E2 @ r.2\}
\end{zedrule}

This is a bit complicated, because we have to expand $\dom$ out.
\begin{zedrule}{reloverride}
   E1 \oplus E2 = \{domE2==\{r2:E2@r2.1\}; r1:E1 | r1.1 \notin domE2 @ r1\} \cup E2
\end{zedrule}

TODO: transitive closure and reflexive transitive closure.


\section{Rules for Functions}

TODO: generalise this to work on more complex decllists.
(We must calculate its characteristic tuple).
\begin{zedrule}{lambda}
   (\lambda v:E @ E2) = \{v:E @ (v,E2) \}
\end{zedrule}

TODO: implement function application (using $\mu$?)

\end{document}
