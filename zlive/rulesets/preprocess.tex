\documentclass{article}
\usepackage{czt}

\parindent 0pt
\parskip 1ex plus 3pt

%% Syntax within provisos.

\newcommand{\sexprUnfoldsTo}{\mathrel{\leadsto_{se}}}
\newcommand{\declListUnfoldsTo}{\mathrel{\leadsto_d}}


\title{Unfolding Rules for ZLive}
\author{Mark Utting}
\begin{document}
\maketitle

This document defines some simple rules for unfolding expressions 
and predicates prior to evaluating them in ZLive.  The rules are
applied repeatedly to each expression/predicate until no more rules
match, then the subexpressions are transformed.  So it is a top-down
traversal of the syntax tree.  We must be careful not to write rules
that create infinite loops of rewritings (eg. generating larger and
larger terms).


\begin{zsection}
  \SECTION ZLivePreprocess \parents zpattern\_toolkit, standard\_toolkit
\end{zsection}

Declare the jokers used in these rules.

\begin{zedjoker}{DeclList} D, D1, D2, D3, D4 \end{zedjoker}
\begin{zedjoker}{Pred} P, P1, P2, P3, P4 \end{zedjoker}
\begin{zedjoker}{Expr} E, E1, E2, E3, E4, E5, E6, E7, E8, E9 \end{zedjoker}
\begin{zedjoker}{Name} v, v1, v2, v3, v4 \end{zedjoker}


To clearly distinguish our rules for unfolding declaration lists and
schema expressions from other rules, we introduce two new infix
operators: $\sexprUnfoldsTo$ and $\declListUnfoldsTo$.  
We do not really need to define their semantics in order to use them within
rules, but to reassure readers, we define their semantics to be just
equality.  In fact, the intention is that the right hand argument
will be the unfolded and normalized form of the left hand argument.

\begin{verbatim}
%%Zinword \sexprUnfoldsTo sexprUnfoldsTo
%%Zinword \declListUnfoldsTo declListUnfoldsTo
\end{verbatim}

\begin{zed}
  \relation ( \_ \sexprUnfoldsTo \_ )
\end{zed}
\begin{zed}
  \relation ( \_ \declListUnfoldsTo \_ )
\end{zed}


\begin{gendef}[SCHEMA]
  \_ \sexprUnfoldsTo \_ : SCHEMA \rel SCHEMA \\
  \_ \declListUnfoldsTo \_ : SCHEMA \rel SCHEMA
\where
  \forall s1,s2:SCHEMA @ s1 \sexprUnfoldsTo s2 \iff s1=s2 \\
  \forall s1,s2:SCHEMA @ s1 \declListUnfoldsTo s2 \iff s1=s2 \\
\end{gendef}


\section{Rules for Unfolding Predicates}

%% Syntax error on the conclusion of these rules.
%\begin{zedrule}{implies}
%   (P1 \implies P2) \iff ((\lnot P1) \lor P2)
%\end{zedrule}

%\begin{zedrule}{iff}
%   (P1 \iff P2) \iff ((P1 \land P2) \lor ((\lnot P1) \land (\lnot P2))
%\end{zedrule}


\section{Rules from the sets\_toolkit}

We do not unfold $\emptyset$ to $\{\}$, because it is not possible
to preserve the type information (one cannot write $\{\}[T]$).
So this rule unfolds it to an easily-evaluated empty set that
preserves the type information.
\begin{zedrule}{emptysetTyped}
   \emptyset[E] = \{x:\{\} | x \in E\}
\end{zedrule}

TODO: $\power_1$ ?

\begin{zedrule}{intersection}
   E1 \cap E2 = \{x:E1 | x \in E2\}
\end{zedrule}

\begin{zedrule}{setminus}
   E1 \setminus E2 = \{x:E1 | x \notin E2\}
\end{zedrule}

\begin{zedrule}{symdiff}
  \proviso E1 : \power E
\derives
   E1 \symdiff E2 = \{ x:E | \lnot (x \in E1 \iff x \in E2) \}
\end{zedrule}

TODO: it might be better to make $\subseteq$ into a primitive constraint?
\begin{zedrule}{subseteq}
   E1 \subseteq E2 \iff (\forall x:E1 @ x \in E2)
\end{zedrule}

\begin{zedrule}{subset}
   E1 \subset E2 \iff (\forall x:E1 @ x \in E2) \land E1 \neq E2
\end{zedrule}

Some rules for easy cases of $\bigcup$.
\begin{zedrule}{genunion1}
   \bigcup \{E\} = E
\end{zedrule}

TODO: we really want a recursive rule here,
but we need an ExprList joker for that.
\begin{zedrule}{genunion2}
   \bigcup \{E1,E2\} = E1 \cup E2
\end{zedrule}
\begin{zedrule}{genunion3}
   \bigcup \{E1,E2,E3\} = E1 \cup E2 \cup E3
\end{zedrule}

A general rule for $\bigcup$.
The right-hand side will be evaluable after we have implemented
some reordering optimizations. 
\begin{zedrule}{genunion}
   \proviso E : \power \power E2
\derives
   \bigcup E = \{s:E; x:E2 | x \in s @ x\}
\end{zedrule}

This right-hand side will not be evaluable in general,
unless the base type $E2$ is small.  We might have to
implement $\bigcap$ as a primitive?
\begin{zedrule}{genintersection}
   \proviso E : \power \power E2
\derives
   \bigcap E = \{x:E2 | (\forall s:E @ x \in s) @ x\}
\end{zedrule}


\section{Rules for Relations}

\begin{zedrule}{firstdef}
   first~ E = E.1
\end{zedrule}

\begin{zedrule}{seconddef}
   second~ E = E.2
\end{zedrule}

\begin{zedrule}{maplet}
   E1 \mapsto E2 = (E1,E2)
\end{zedrule}

\begin{zedrule}{domain}
   \dom E = \{x:E @ x.1\}
\end{zedrule}

\begin{zedrule}{range}
   \ran E = \{x:E @ x.2\}
\end{zedrule}

\begin{zedrule}{identity}
   \id E = \{x:E @ (x,x)\}
\end{zedrule}

\begin{zedrule}{relcomp}
   E1 \comp E2 = \{r1:E1; r2:E2 | r1.2=r2.1 @ (r1.1,r2.2)\}
\end{zedrule}

\begin{zedrule}{funccomp}
   E1 \circ E2 = \{r1:E1; r2:E2 | r2.2=r1.1 @ (r2.1,r1.2)\}
\end{zedrule}

\begin{zedrule}{domainrestriction}
   E1 \dres E2 = \{r:E2 | r.1 \in E1\}
\end{zedrule}

\begin{zedrule}{rangerestriction}
   E1 \rres E2 = \{r:E1 | r.2 \in E2\}
\end{zedrule}

\begin{zedrule}{domainsubtraction}
   E1 \ndres E2 = \{r:E2 | r.1 \notin E1\}
\end{zedrule}

\begin{zedrule}{rangesubtraction}
   E1 \nrres E2 = \{r:E1 | r.2 \notin E2\}
\end{zedrule}

\begin{zedrule}{inverse}
   E1 \inv = \{r:E1 @ (r.2,r.1)\}
\end{zedrule}

\begin{zedrule}{relimage}
   E1 \limg E2 \rimg = \{r:E1 | r.1 \in E2 @ r.2\}
\end{zedrule}

This is a bit complicated, because we have to expand $\dom$ out.
\begin{zedrule}{reloverride}
   E1 \oplus E2 = ((\dom E2) \ndres E1) \cup E2
%   E1 \oplus E2 = \{domE2==\{r2:E2@r2.1\}; r1:E1 | r1.1 \notin domE2 @ r1\} \cup E2
\end{zedrule}

TODO: transitive closure and reflexive transitive closure.


\section{Unfolding Definitions}

Next, we try unfolding simple definitions.
(This must at least come after the $\emptyset$ rule above,
otherwise the definition of emptyset in the sets\_toolkit
gets used instead of our simpler unfold rule).

\begin{zedrule}{unfolddefn}
  \proviso? ~ v==E2
\derives
   v = E2
\end{zedrule}


\section{Rules for Functions}

TODO: generalise this to work on more complex decllists.
(We must calculate its characteristic tuple).
\begin{zedrule}{lambda}
   (\lambda v:E @ E2) = \{v:E @ (v,E2) \}
\end{zedrule}

%% NOTE: We do not include this rule, because it causes TOO MANY
%% applications to be unfolded.  Instead, ZLive does this
%% rule as the last step of unfolding, after all its
%% predefined operators have been translated into FlatPred
%% constraints.
%\begin{zedrule}{funcappl}
%   E1 ~ E2 = (\mu r:E1 | r.1=E2 @ r.2)
%\end{zedrule}

TODO: add a new set representation, which handles all function types,
plus relations and the various kinds of sequences.

\begin{zedrule}{disjointdef}
   \disjoint E \iff (\forall p,q:E | p \neq q @ p.2 \cap q.2 = \{\})
\end{zedrule}

\begin{zedrule}{partitiondef}
   E1 \partition E2 \iff \disjoint E1 \land \bigcup(\ran E1) = E2
\end{zedrule}


\section{Integer Rules}

These are mostly handled as primitives of ZLive.

\begin{zedrule}{num1}
   \num_1 = \{x:\num | x \neq 0\}
\end{zedrule}

TODO: add mod as a primitive?

TODO: implement iter somehow (it is like transitive closure).

TODO: implement min and max as primitives, but only over integer sets.


\section{Sequence Rules}

\begin{zedrule}{literalsequence}
   (\langle \listarg \rangle) ~ E = E
\end{zedrule}

TODO: implement concatenation as a primitive, with several
modes of evaluation (III is semi-det, IIO, OII and IOI are det
and OOI is multi-det).

TODO: this could be more efficient and have more modes if it
was a primitive? (IO and OI are det).
\begin{zedrule}{reverse}
   rev ~ E = (\lambda n:\dom E @ E(\# E - n + 1))
\end{zedrule}

\begin{zedrule}{headdef}
   head ~ E = E ~ 1
\end{zedrule}

\begin{zedrule}{lastdef}
   last ~ E = E ~ (\# E)
\end{zedrule}

TODO: it might be possible and better to implement $s=tail~e$
as $\langle x \rangle \cat s = e$, where $x$ is a fresh variable?
Similarly for $front$.
\begin{zedrule}{taildef}
   tail ~ E = (\lambda n : 1 \upto (\# E - 1) @ E ~ (n+1))
\end{zedrule}

\begin{zedrule}{frontdef}
   front ~ E = (\# E) \ndres E
\end{zedrule}

TODO: implement squash as a primitive?
Because the definition in the standard is quite inefficient as
an evaluation rule ($O(N^2)$ at least). 

\begin{zedrule}{extractdef}
   E1 \extract E2 = squash(E1 \dres E2)
\end{zedrule}

\begin{zedrule}{filterdef}
   E1 \filter E2 = squash(E1 \rres E2)
\end{zedrule}

TODO: this might be better done using $\cat$
(if we had much more sophisticated modes).
\begin{zedrule}{prefixdef}
   E1 \prefix E2 \iff E1 \subseteq E2
\end{zedrule}

\begin{zedrule}{suffixdef}
   \proviso E1 : \power (\arithmos \cross E3)
\derives
   E1 \suffix E2 \iff (\exists s:\seq E3 @ s \cat E1 = E2)
\end{zedrule}

\begin{zedrule}{infixdef}
   \proviso E1 : \power (\arithmos \cross E3)
\derives
   E1 \infix E2 \iff (\exists s,t:\seq E3 @ s \cat E1 \cat t = E2)
\end{zedrule}

For distributed concatenation, we have a recursive rule and
two base cases, exactly like the axioms in the Z standard.
However, the recursive axiom will not match all arguments,
so we really need some additional recursive rules that use 
head and tail (but these would only be valid when the sequence
is non-empty, hence we need an if-then-else or something, but this
creates an infinite rewrite loop...).  So we probably have to
implement $\dcat$ as a ZLive primitive. 
\begin{zedrule}{dcat0}
   \dcat \langle \rangle = \langle \rangle
\end{zedrule}
\begin{zedrule}{dcat1}
   \dcat \langle E \rangle = E
\end{zedrule}
\begin{zedrule}{dcatdistributive}
   \dcat (E1 \cat E2) = (\dcat E1) \cat (\dcat E2)
\end{zedrule}

% This rule causes infinite recursion, of course!
%\begin{zedrule}{dcatheadtail}
%   \dcat E = \IF E=\{\} 
%             \THEN \{\} 
%             \ELSE (\dcat (head~E)) \cat (\dcat (tail~E))
%\end{zedrule}


\section{Unfolding Declaration Lists}

We use the $\declListUnfoldsTo$ operator for unfolding declaration
lists.   The left-hand side is always of the form $[DeclList|true]$
and the right-hand side (which is usually a generated output) is
a normalized schema with no duplicated names in the signature, and
all the non-basetype conditions in the predicate part.

The next few rules implement the $\declListUnfoldsTo$ operator,
which unfolds and normalizes declaration lists.

\begin{zedrule}{VarDecl}
   \proviso E : \power E2 \\
   [D1 | true] \declListUnfoldsTo [D2 | P2]
\derives
   [v:E; D1 | true] \declListUnfoldsTo [v:E2; D2 |  v \in E \land P2]
\end{zedrule}

\begin{zedrule}{IncludeDecl}
   E \sexprUnfoldsTo [D1 | P1] \\
   [D | true] \declListUnfoldsTo [D2 | P2] \\
   \proviso [D1 | true] \land [D2 | true] : \power [D3]
\derives
   [E; D | true] \declListUnfoldsTo [D3 |  P1 \land P2]
\end{zedrule}

\begin{zedrule}{EmptyDeclList}
   [~ | true] \declListUnfoldsTo [~ | true]
\end{zedrule}


\section{Unfolding Schema Expressions}

This section defines the unfolding of schema expressions,
using the $se \sexprUnfoldsTo stext$ operator, where $se$
is a schema expression and $stext$ is the resulting normalized
schema construction ($[Decls|Preds]$, where the types in $Decls$
are only base types).

Top-level schema expressions are unfolded into sets of bindings.
However, we have a special case for $\exists$, so that we can
put all the variables into the bound variable list of the
set comprehension, then create a binding using a subset of
those variables.  Putting all the variables at the same level
of scope gives the evaluation optimization algorithms more
freedom to reorder things later.

\begin{zedrule}{TopLevelExistsSchema}
   E1 \sexprUnfoldsTo [D1 | P1] \\
   E2 \sexprUnfoldsTo [D2 | P2] \\
   \proviso [D1 | true] \land [D2 | true] : \power [D3] \\
   \proviso [D4|true] == [D2|true] \schemaminus [D1|true] \\
   \proviso E == binding ~ [D4|true]
\derives
   (\exists E1 @ E2) = \{D3 | P1 \land P2 @ E\}
\end{zedrule}

\begin{zedrule}{TopLevelSchemaExpr}
  E \sexprUnfoldsTo [D1|P1] \\
  \proviso E2 == binding [D1 | true]
\derives
  E = \{ D1 | P1 @ E2 \}
\end{zedrule}


\begin{zedrule}{SchemaConstruction}
   [D1 | true] \declListUnfoldsTo [D2 | P2]
\derives
   [D1 | P] \sexprUnfoldsTo [D2 | P2 \land P]
\end{zedrule}

\begin{zedrule}{SchemaRef}
  \proviso ?~ v == [D1 | P1] \\
  [D1 | true] \declListUnfoldsTo [D2 | P2]
\derives
  v \sexprUnfoldsTo [D2 | P1 \land P2]
\end{zedrule}

\begin{zedrule}{SchemaPrime}
   E \sexprUnfoldsTo [D1 | P1] \\
   \proviso [D2|P2] == [D1|P1]~' \\
\derives
   E~' \sexprUnfoldsTo [D2 | P2]
\end{zedrule}

The type proviso in the ExistsSchema rule checks
that $D1$ and $D2$ are type compatible.
\begin{zedrule}{ExistsSchema}
   E1 \sexprUnfoldsTo [D1 | P1] \\
   E2 \sexprUnfoldsTo [D2 | P2] \\
   \proviso [D1 | true] \land [D2 | true] : \power [D3] \\
   \proviso [D4|true] == [D2|true] \schemaminus [D1|true]
\derives
   (\exists E1 @ E2) \sexprUnfoldsTo [D4 | (\exists D1 @ P1 \land P2)]
\end{zedrule}

\end{document}
