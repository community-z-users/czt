\documentclass{article}
\usepackage{oz}
\usepackage{alltt}
\newenvironment{Rationale}{\\ \textbf{Rationale:}\it}{}
\newcommand{\V}{\mathcal{V}}

% Simulate some standard Z commands
\newenvironment{zsection}{\[}{\]}
\newcommand{\SECTION}{\textbf{section}~}
\newcommand{\parents}{\mathrel{\textbf{parents}}}
\newcommand{\relation}{\mathrel{\textbf{relation}}}
\newcommand{\function}{\mathrel{\textbf{function}}}
\newcommand{\generic}{\mathrel{\textbf{generic}}}
\newcommand{\leftassoc}{\mathrel{\textbf{leftassoc}}}
\newcommand{\rightassoc}{\mathrel{\textbf{rightassoc}}}


% Rule syntax: \begin{zedrule}{Name} Ant1 \\ Ant2 \derive Concl \end{zedrule}
\newenvironment{zedrule}[1]{\par\textbf{rule }#1\vspace{-1ex}\infrule}{\endinfrule}
\newcommand{\derives}{\derive{}}

\newenvironment{zedjoker}[1]{\par$\bigstar$ #1\ }{}

\newcommand{\Context}{\Gamma}
\newcommand{\notfreein}{\mathbin{\backslash}}
\newcommand{\HasType}{\mathbin{:}} % \small\rlap{$\circ$}{\raisebox{1ex}{$\circ$}}}}
\parindent 0pt
\parskip 1ex plus 3pt

%% Define some extra macros for the Z standard.
%% These will eventually be defined in a czt.sty file.
\newcommand{\negate}{\mathop{-}}
\newcommand{\arithmos}{{A\!\!\!\!A}}   %% TODO: get a proper symbol
\newcommand{\substitute}{\mathrel{\curvearrowleft}}  % U+21B6
\newcommand{\proviso}{\raisebox{0.5ex}{${}_{\blacktriangleright}\ $}}%%or\star
%       %%Zprechar \proviso U+22C6    % small star, or
%       %%Zprechar \proviso U+25B8    % small solid triangle  |> )

%% Syntax within provisos
\newcommand{\schemamerge}{\mathbin{\textbf{schemamerge}}}


\title{Unfolding Rules for ZLive}
\author{Mark Utting}
\begin{document}
\maketitle

This document defines some simple rules for unfolding expressions prior to
evaluating them in ZLive.

\begin{zsection}
  \SECTION ZLivePreprocess \parents zpattern\_toolkit, standard\_toolkit
\end{zsection}

Declare the jokers used in these rules.

\begin{zedjoker}{DeclList} D, D1, D2, D3 \end{zedjoker} \\
\begin{zedjoker}{Pred} P, P1, P2, P3 \end{zedjoker} \\
\begin{zedjoker}{Expr} E, E1, E2, E3 \end{zedjoker} \\
\begin{zedjoker}{Name} v, v1, v2, v3 \end{zedjoker} \\

\newcommand{\unfoldsTo}{\mathrel{\leadsto}}


\section{Rules from the sets\_toolkit}

\begin{zedrule}{emptyset}
   \emptyset = \{\}
\end{zedrule}

TODO: $\power_1$ ?

\begin{zedrule}{intersection}
   E1 \cap E2 = \{x:E1 | x \in E2\}
\end{zedrule}

\begin{zedrule}{setminus}
   E1 \setminus E2 = \{x:E1 | x \notin E2\}
\end{zedrule}

\begin{zedrule}{symdiff}
  \proviso E1 : \power E
\derives
   E1 \symdiff E2 = \{ x:E | \lnot (x \in E1 \iff x \in E2) \}
\end{zedrule}

TODO: it might be better to make $\subseteq$ into a primitive constraint?
\begin{zedrule}{subseteq}
   E1 \subseteq E2 \iff (\forall x:E1 @ x \in E2)
\end{zedrule}

\begin{zedrule}{subset}
   E1 \subset E2 \iff (\forall x:E1 @ x \in E2) \land E1 \neq E2
\end{zedrule}

Some rules for easy cases of $\bigcup$.
\begin{zedrule}{genunion1}
   \bigcup \{E\} = E
\end{zedrule}

TODO: we really want a recursive rule here,
but we need an ExprList joker for that.
\begin{zedrule}{genunion2}
   \bigcup \{E1,E2\} = E1 \cup E2
\end{zedrule}
\begin{zedrule}{genunion3}
   \bigcup \{E1,E2,E3\} = E1 \cup E2 \cup E3
\end{zedrule}

A general rule for $\bigcup$.
\begin{zedrule}{genunion}
   \proviso E : \power \power E2
\derives
   \bigcup E = \{s:E; x:E2 | x \in s @ x\}
\end{zedrule}

\begin{zedrule}{genintersection}
   \proviso E : \power \power E2
\derives
   \bigcap E = \{x:E2 | (\forall s:E @ x \in s) @ x\}
\end{zedrule}


\section{Rules for Relations}

\begin{zedrule}{firstdef}
   first~ E = E.1
\end{zedrule}

\begin{zedrule}{seconddef}
   second~ E = E.2
\end{zedrule}

\begin{zedrule}{maplet}
   E1 \mapsto E2 = (E1,E2)
\end{zedrule}

\begin{zedrule}{domain}
   \dom E = \{x:E @ x.1\}
\end{zedrule}

\begin{zedrule}{range}
   \ran E = \{x:E @ x.2\}
\end{zedrule}

\begin{zedrule}{identity}
   \id ~ E = \{x:E @ (x,x)\}
\end{zedrule}

\begin{zedrule}{relcomp}
   E1 \semi E2 = \{r1:E1; r2:E2 | r1.2=r2.1 @ (r1.1,r2.2)\}
\end{zedrule}

\begin{zedrule}{funccomp}
   E1 \semi E2 = \{r1:E1; r2:E2 | r2.2=r1.1 @ (r2.1,r1.2)\}
\end{zedrule}

\begin{zedrule}{domainrestriction}
   E1 \dres E2 = \{r:E2 | r.1 \in E1\}
\end{zedrule}

\begin{zedrule}{rangerestriction}
   E1 \rres E2 = \{r:E1 | r.2 \in E2\}
\end{zedrule}

\begin{zedrule}{domainsubtraction}
   E1 \ndres E2 = \{r:E2 | r.1 \notin E1\}
\end{zedrule}\mapsto

\begin{zedrule}{rangesubtraction}
   E1 \nrres E2 = \{r:E1 | r.2 \notin E2\}
\end{zedrule}

\begin{zedrule}{inverse}
   E1 \inv = \{r:E1 @ (r.2,r.1)\}
\end{zedrule}

\begin{zedrule}{relimage}
   E1 \limg E2 \rimg = \{r:E1 | r.1 \in E2 @ r.2\}
\end{zedrule}

This is a bit complicated, because we have to expand $\dom$ out.
\begin{zedrule}{reloverride}
   E1 \oplus E2 = ((\dom E2) \ndres E1) \cup E2
%   E1 \oplus E2 = \{domE2==\{r2:E2@r2.1\}; r1:E1 | r1.1 \notin domE2 @ r1\} \cup E2
\end{zedrule}

TODO: transitive closure and reflexive transitive closure.


\section{Unfolding Definitions}

Next, we try unfolding simple definitions.
(This must at least come after the $\emptyset$ rule above,
otherwise the definition of emptyset in the sets_toolkit
gets used instead of our simpler unfold rule).

\begin{zedrule}{unfolddefn}
  \proviso? ~ v==E
\derives
   v = E
\end{zedrule}


\section{Rules for Functions}

TODO: generalise this to work on more complex decllists.
(We must calculate its characteristic tuple).
\begin{zedrule}{lambda}
   (\lambda v:E @ E2) = \{v:E @ (v,E2) \}
\end{zedrule}

%% NOTE: We do not include this rule, because it causes TOO MANY
%% applications to be unfolded.  Instead, ZLive does this
%% rule as the last step of unfolding, after all its
%% predefined operators have been translated into FlatPred
%% constraints.
%\begin{zedrule}{funcappl}
%   E1 ~ E2 = (\mu r:E1 | r.1=E2 @ r.2)
%\end{zedrule}

TODO: add a new set representation, which handles all function types,
plus relations and the various kinds of sequences.

\begin{zedrule}{disjointdef}
   \disjoint E \iff (\forall p,q:E | p \neq q @ p.2 \cap q.2 = \{\})
\end{zedrule}

\begin{zedrule}{partitiondef}
   E1 \partition E2 \iff \disjoint E1 \land \bigcup(\ran E1) = E2
\end{zedrule}


\section{Integer Rules}

These are mostly handled as primitives of ZLive.

\begin{zedrule}{num1}
   \num_1 = \{x:\num | x \neq 0\}
\end{zedrule}

TODO: add mod as a primitive?

TODO: implement iter somehow (it is like transitive closure).

TODO: implement min and max as primitives, but only over integer sets.


\section{Sequence Rules}

\begin{zedrule}{literalsequence}
   (\langle \listarg \rangle) ~ E = E
\end{zedrule}

TODO: implement concatenation as a primitive, with several
modes of evaluation (III is semi-det, IIO, OII and IOI are det
and OOI is multi-det).

TODO: this could be more efficient and have more modes if it
was a primitive? (IO and OI are det).
\begin{zedrule}{reverse}
   rev ~ E = (\lambda n:\dom E @ E(\# E - n + 1))
\end{zedrule}

\begin{zedrule}{headdef}
   head ~ E = E ~ 1
\end{zedrule}

\begin{zedrule}{lastdef}
   last ~ E = E ~ (\# E)
\end{zedrule}

TODO: it might be possible and better to implement $s=tail~e$
as $\langle x \rangle \cat s = e$, where $x$ is a fresh variable?
Similarly for $front$.
\begin{zedrule}{taildef}
   tail ~ E = (\lambda n : 1 \upto (\# E - 1) @ E ~ (n+1))
\end{zedrule}

\begin{zedrule}{frontdef}
   front ~ E = (\# E) \ndres E
\end{zedrule}

TODO: implement squash as a primitive?
Because the definition in the standard is quite inefficient as
an evaluation rule ($O(N^2)$ at least). 

\begin{zedrule}{extractdef}
   E1 \extract E2 = squash(E1 \dres E2)
\end{zedrule}

\begin{zedrule}{filterdef}
   E1 \filter E2 = squash(E1 \rres E2)
\end{zedrule}

TODO: this might be better done using $\cat$
(if we had much more sophisticated modes).
\begin{zedrule}{prefixdef}
   E1 \prefix E2 \iff E1 \subseteq E2
\end{zedrule}

\begin{zedrule}{suffixdef}
   \proviso E1 : \power (\arithmos \cross E3)
\derives
   E1 \suffix E2 \iff (\exists s:\seq E3 @ s \cat E1 = E2)
\end{zedrule}

\begin{zedrule}{infixdef}
   \proviso E1 : \power (\arithmos \cross E3)
\derives
   E1 \infix E2 \iff (\exists s,t:\seq E3 @ s \cat E1 \cat t = E2)
\end{zedrule}

For distributed concatenation, we have a recursive rule and
two base cases, exactly like the axioms in the Z standard.
However, the recursive axiom will not match all arguments,
so we really need some additional recursive rules that use 
head and tail (but these would only be valid when the sequence
non-empty, hence the if-then-else). 
\begin{zedrule}{dcat0}
   \dcat \langle \rangle = \langle \rangle
\end{zedrule}
\begin{zedrule}{dcat1}
   \dcat \langle E \rangle = E
\end{zedrule}
\begin{zedrule}{dcatdistributive}
   \dcat (E1 \cat E2) = (\dcat E1) \cat (\dcat E2)
\end{zedrule}

% This rule causes infinite recursion, of course!
%\begin{zedrule}{dcatheadtail}
%   \dcat E = \IF E=\{\} 
%             \THEN \{\} 
%             \ELSE (\dcat (head~E)) \cat (\dcat (tail~E))
%\end{zedrule}

\end{document}
