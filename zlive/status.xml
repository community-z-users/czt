<?xml version="1.0"?>
<status>

  <developers>
    <person name="Mark Utting" email="marku@cs.waikato.ac.nz" id="Mark"/>
    <person name="Leo Freitas" email="leouk@sourceforge.net" id="Leo"/>
    <person name="Rohit Bansal" email="rohit@sourceforge.net" id="Rohit"/>
    <person name="Petra Malik" email="PetraMalik@sourceforge.net" id="Petra"/>
  </developers>

  <changes>
    <!-- Add new releases here
         Some action types have associated images. By default, images are
         defined for 'add', 'fix', 'remove', 'update' and 'hack'. If you add
         src/documentation/resources/images/<foo>.jpg images, these will
         automatically be used for entries of type <foo>.
         Sample action:
         <action dev="JB" type="fix" due-to="Joe Contributor"
           due-to-email="joec@apache.org" fixes-bug="123">
           Fixed a bug in the Foo class.
         </action>
    -->
    
    <release version="0.5" date="July 6, 2006">
      <action dev="MarkU" type="add">
      	Implemented a simple textual user interface which provides
        eval Expr and evalp Pred commands.
      </action>
      <action dev="Rohit" type="add">
      	Better reporting from the usertests.  Each animate*.tex file
      	is a separate JUnit test suite so that we can see which groups
      	of tests are mostly passing/failing.  It shows line numbers for each
      	test that fails and records previous test runs in subdirectories
	and shows when new tests pass or old tests start failing.
      </action>
      <action dev="MarkU, Rohit" type="add">
        Implemented all basic arithmetic operators, tuples and several 
        implementations of sets.
      </action>
      <action dev="MarkU, Rohit" type="add">
        Designed the EvalSet interface.  Rohit wrote the first implementation
        of it (RangeSet for a..b sets), plus the FlatMember predicate
        which uses it.
      </action>
      <action dev="MarkU" type="add">
        Designed basic architecture of ZLive (unfolding, flattening, 
        mode analysis, reordering, then evaluation), and the FlatPred
        interface (abstract class actually).  With Rohit, developed
        several FlatPred implementations for plus, times, negate etc.
        plus a basic left-to-right, deterministic-only evaluation engine.
      </action>
      <action dev="MarkU, Rohit" type="add">
        Translated the 500+ Jaza tests into standard Z conjectures and 
        wrote a JUnit harness which calls evalPred on each one (but
        conjectures of the form E=undefnum pass E to evalExpr and expect
        an exception to be raised).
        The resulting 'usertests' give a good measure of how much 
        progress we are making towards a useful animator.
      </action>
    </release>
    
    <release version="0.2" date="unreleased">
     <actions priority="high">
      <action dev="Mark" type="fix">
      	Fix flatpred/FlatForall.java so that simple bounded forall predicates
        work.  For example: (\forall x:\{1,3,5\} @ x = 3) should be false,
        but currently gives a "Cannot find mode" error.  
      </action>
      <action dev="MarkU" type="add">
      	Design and implement a bounds analysis feature for numeric variables,
      	so that <code>x&lt;=10</code> and <code>x&gt;=y</code> are combined
      	into the (finite) constraint <code>x \in y..10</code>.
      	This could be done in at least three ways: (1) associate
      	a static lower and upper bound constant with each variable; 
      	(2) associate a set of lower/upper bound expressions with each
      	variable; (3) merge several complementary FlatPred constraints into
      	single FlatPred constraint which is more efficient.  The first or
      	third approaches seem more in keeping with the ZLive philosophy
      	of static analysis/transformation.
      </action>
      <action context="tests" dev="MarkU" type="fix">
      	Change the test-and-compare framework so that a single directory
        is used for the results (and these change with time).
	This is a more CVS-friendly way of recording our progress.
      </action>
      <action dev="MarkU" type="add">
	Implement set union as a new FlatPred subclass.  This should give us
        more flexibility to choose different algorithms than just unfolding the
        definition of union, which is a set comprehension with a disjunction.
        Intersection and difference might be okay done via unfolding.
      </action>
      <action dev="MarkU" type="add">
      	Unfold definitions and rewrite some complex constructs into
      	simpler constructs.  This will be done via CZT rules.
      </action>
      <action context="code" dev="MarkU">
        Change the FlatSetComp implementation of sets so that members
	are generated lazily, on demand.  This will allow us to evaluate
	schemas that have an infinite number of solutions, when we only
	want to explore the first few solutions.
      </action>
      <action context="code" dev="MarkU">
      	Design and implement a 'FlatOr' class to handle disjunctions.
      	All branches of the disjunct must have the same mode. 
      	Other complex predicates should probably be unfolded into disjunctions.
      </action>
    </release>
    <release version="1.0" date="unreleased">
      <action context="code" dev="open">
         The calculation of free/bound variables now handles tmpNNN
         variables as normal variables, so that they are scoped correctly.
         This was necessary to avoid errors in the mode calculations, such
         as for sets whose results contained tmpNNN variables.
      </action>
      <action context="code" dev="open">
       	Implemented a FlatPred implementation of function/relation types,
	    like in Jaza.  That is, an implementation of A --> B, for all 
	    the kinds of functions/relations/sequences that Z supports.
	    (Use flags to keep track of each property such as one-to-one,
	    total, onto etc.)
      </action>
      <action context="code" dev="MarkU, Petra">
        Separated the FlatPred hierarchy from the evaluated results that it
        returns (see the net.sourceforge.czt.animation.eval.result package).
        For example, FlatPowerSet now returns a PowerSet object each time
        it is evaluated.  This is more flexible, and was necessary to handle
        examples like {a:1..10 @ \power(0..a)}.
      </action>
      <action context="code" dev="Petra, MarkU">
       	Implemented a better mode algorithm to reorder lists of FlatPreds,
       	based on the estimated number of solutions for each mode.
	    Initially, just repeatedly choose the predicate with the 
	    smallest number of expected solutions.  In the future, more 
	    sophisticated path-finding algorithms may be used, such as 
	    best-first or A* path-finding algorithms.
      </action>
    </release>
  </changes>

  <todo>
  	  <action context="code" dev="open">
  	    Unfold all characteristic tuples, before preprocessing.
  	  </action>
  	  <action context="code" dev="open">
  	    Implement/extend a term printer that can handle the extended
  	    terms of ZLive, such as the various kinds of EvalSet.
  	    This could either be an extended version of an existing printer,
  	    or we could translate all ZLive expressions back into std Z exprs.
  	  </action>
  	  <action context="code" dev="open">
  	    Provide more sophisticated modes, so that (X,Y) in S can be
  	    evaluated in a mode where X and S are inputs and Y is an output.
  	    Similarly for Binding in S.
  	    This is particularly important and common when S is a set 
  	    comprehension, and the input X can be used to narrow its search.
  	    This is quite a major design extension.
  	  <action context="code" dev="open">
  	    Implement FlatBindSel, which handles Binding.Var = Expr.
  	  </action>
      <action context="code" dev="open">
       	Implement a FlatPred implementation of list concatenation,
	    A^B=C.  This is needed to support lots of the sequence operators.
      </action>
    </actions>

    <actions priority="medium">
      <action context="code" dev="open">
      	Integrate ZLive with the Gaffe animator interface generator/editor.
      	This will allow users to generate and customise interfaces for
      	each Z specification.
      </action>
    </actions>
    <actions priority="low">
      <action context="docs" dev="open">
        Design a ZLive logo.
      </action>
      <action context="code" dev="open">
        Design a simple ZLive GUI which allows expressions to be
        entered and evaluated.
      </action>
    </actions>
    <!-- Add todo items. @context is an arbitrary string. Eg:
    <actions priority="high">
      <action context="code" dev="SN">
      </action>
    </actions>
    <actions priority="medium">
      <action context="docs" dev="open">
      </action>
    </actions>
    -->
  </todo>
</status>
