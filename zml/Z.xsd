<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSPY v5 rel. 3 U (http://www.xmlspy.com) by Mark Utting (The University of Waikato) -->
<xs:schema targetNamespace="http://web.comlab.ox.ac.uk/oucl/work/andrew.martin/CZT/zstd.xsd" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:Z="http://web.comlab.ox.ac.uk/oucl/work/andrew.martin/CZT/zstd.xsd" elementFormDefault="qualified" attributeFormDefault="unqualified" version="1.0">
	<xs:annotation>
		<xs:documentation>This XML schema defines XML markup for formal specifications written in the ISO Standard Z notation.  $Id$</xs:documentation>
	</xs:annotation>
	<xs:element name="Spec">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:TermA">
					<xs:choice minOccurs="0" maxOccurs="unbounded">
						<xs:element ref="Z:Sect"/>
						<xs:any namespace="##other" processContents="lax"/>
					</xs:choice>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Sect" type="Z:Sect" abstract="true">
		<xs:annotation>
			<xs:documentation>Abstract: replacable by any kind of section</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="ZSect" type="Z:ZSect" substitutionGroup="Z:Sect">
		<xs:annotation>
			<xs:documentation>Concrete Z section</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="UnparsedZSect" type="Z:UnparsedZSect" substitutionGroup="Z:Sect"/>
	<xs:element name="NarrSect" type="Z:NarrSect" substitutionGroup="Z:Sect"/>
	<xs:element name="Para" type="Z:Para" abstract="true">
		<xs:annotation>
			<xs:documentation>Abstract: replacable by any paragraph</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="GivenPara" type="Z:GivenPara" substitutionGroup="Z:Para"/>
	<xs:element name="AxPara" type="Z:AxPara" substitutionGroup="Z:Para"/>
	<xs:element name="FreePara" type="Z:FreePara" substitutionGroup="Z:Para"/>
	<xs:element name="ConjPara" type="Z:ConjPara" substitutionGroup="Z:Para"/>
	<xs:element name="OptempPara" type="Z:OptempPara" substitutionGroup="Z:Para"/>
	<xs:element name="UnparsedPara" type="Z:UnparsedPara" substitutionGroup="Z:Para"/>
	<xs:element name="NarrPara" type="Z:NarrPara" substitutionGroup="Z:Para"/>
	<xs:element name="Decl" type="Z:Decl" abstract="true">
		<xs:annotation>
			<xs:documentation>Abstract: replacable by any declaration</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="VarDecl" substitutionGroup="Z:Decl">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Decl">
					<xs:sequence>
						<xs:element name="DeclName" type="Z:DeclName" maxOccurs="unbounded"/>
						<xs:element ref="Z:Expr"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ConstDecl" substitutionGroup="Z:Decl">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Decl">
					<xs:sequence>
						<xs:element name="DeclName" type="Z:DeclName"/>
						<xs:element ref="Z:Expr"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="InclDecl" substitutionGroup="Z:Decl">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Decl">
					<xs:sequence>
						<xs:element ref="Z:Expr"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Stroke" type="Z:Stroke" abstract="true">
		<xs:annotation>
			<xs:documentation>Abstract: replacable by any kind of stroke</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="InStroke" type="Z:Stroke" substitutionGroup="Z:Stroke"/>
	<xs:element name="OutStroke" type="Z:Stroke" substitutionGroup="Z:Stroke"/>
	<xs:element name="NextStroke" type="Z:Stroke" substitutionGroup="Z:Stroke"/>
	<xs:element name="NumStroke" substitutionGroup="Z:Stroke">
		<xs:annotation>
			<xs:documentation>Multidigit strokes are not allowed</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Stroke">
					<xs:attribute name="Number" use="required">
						<xs:simpleType>
							<xs:restriction base="xs:nonNegativeInteger">
								<xs:minInclusive value="0"/>
								<xs:maxInclusive value="9"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Expr" type="Z:Expr" abstract="true">
		<xs:annotation>
			<xs:documentation>Abstract: replacable by any expression</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="RefExpr" substitutionGroup="Z:Expr">
		<xs:annotation>
		  <xs:documentation>The mixfix attribute distinguishes
		  S \fun T (mixfix=true) from (_ \fun _) [S, T] (mixfix=false).
		  </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Expr">
					<xs:sequence>
						<xs:element name="RefName" type="Z:RefName"/>
						<xs:element ref="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
					<xs:attribute name="Mixfix" type="xs:boolean" use="optional" default="false"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NumExpr" substitutionGroup="Z:Expr">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Expr">
					<xs:attribute name="Value" type="xs:integer" use="required"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PowerExpr" type="Z:Expr1" substitutionGroup="Z:Expr"/>
	<xs:element name="SetExpr" type="Z:Expr0N" substitutionGroup="Z:Expr"/>
	<xs:element name="TupleExpr" type="Z:Expr2N" substitutionGroup="Z:Expr"/>
	<xs:element name="ProdExpr" type="Z:Expr2N" substitutionGroup="Z:Expr"/>
	<xs:element name="BindExpr" substitutionGroup="Z:Expr">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Expr">
					<xs:sequence>
						<xs:element name="NameExprPair" type="Z:NameExprPair" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TupleSelExpr" substitutionGroup="Z:Expr">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Expr1">
					<xs:attribute name="Select" type="xs:positiveInteger" use="required"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="BindSelExpr" substitutionGroup="Z:Expr">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Expr1">
					<xs:sequence>
						<xs:element name="Name" type="Z:Name"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CondExpr" substitutionGroup="Z:Expr">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Expr">
					<xs:sequence>
						<xs:element ref="Z:Pred"/>
						<xs:element ref="Z:Expr" minOccurs="2" maxOccurs="2"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ApplExpr" substitutionGroup="Z:Expr">
		<xs:annotation>
		  <xs:documentation>The mixfix attribute distinguishes
		     m + n (mixfix=true) from (_ + _)(m, n) (mixfix=false).
		  </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Expr2">
					<xs:attribute name="Mixfix" type="xs:boolean" use="optional" default="false"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="DecorExpr" substitutionGroup="Z:Expr">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Expr1">
					<xs:sequence>
						<xs:element ref="Z:Stroke"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ThetaExpr" substitutionGroup="Z:Expr">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Expr1">
					<xs:sequence>
						<xs:element ref="Z:Stroke" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SchExpr" substitutionGroup="Z:Expr">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Expr">
					<xs:sequence>
						<xs:element name="SchText" type="Z:SchText"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="RenameExpr" substitutionGroup="Z:Expr">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Expr1">
					<xs:sequence>
						<xs:group ref="Z:NameNamePair" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NegExpr" type="Z:Expr1" substitutionGroup="Z:Expr">
		<xs:annotation>
			<xs:documentation>Schema negation</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="PreExpr" type="Z:Expr1" substitutionGroup="Z:Expr">
		<xs:annotation>
			<xs:documentation>Schema precondition</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="AndExpr" type="Z:LogExpr" substitutionGroup="Z:Expr"/>
	<xs:element name="OrExpr" type="Z:LogExpr" substitutionGroup="Z:Expr"/>
	<xs:element name="ImpliesExpr" type="Z:LogExpr" substitutionGroup="Z:Expr"/>
	<xs:element name="IffExpr" type="Z:LogExpr" substitutionGroup="Z:Expr"/>
	<xs:element name="CompExpr" type="Z:Expr2" substitutionGroup="Z:Expr"/>
	<xs:element name="PipeExpr" type="Z:Expr2" substitutionGroup="Z:Expr"/>
	<xs:element name="ProjExpr" type="Z:Expr2" substitutionGroup="Z:Expr"/>
	<xs:element name="HideExpr" substitutionGroup="Z:Expr">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Expr1">
					<xs:sequence>
						<xs:element name="Hide" type="Z:RefName" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ForallExpr" type="Z:Qnt1Expr" substitutionGroup="Z:Expr"/>
	<xs:element name="ExistsExpr" type="Z:ExistsExpr" substitutionGroup="Z:Expr"/>
	<xs:element name="Exists1Expr" type="Z:ExistsExpr" substitutionGroup="Z:Expr"/>
	<xs:element name="LambdaExpr" type="Z:Qnt1Expr" substitutionGroup="Z:Expr"/>
	<xs:element name="MuExpr" type="Z:QntExpr" substitutionGroup="Z:Expr"/>
	<xs:element name="LetExpr" type="Z:Qnt1Expr" substitutionGroup="Z:Expr">
		<xs:annotation>
			<xs:documentation>Note: the SchText should contain x==Expr only, and no predicate.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="SetCompExpr" type="Z:QntExpr" substitutionGroup="Z:Expr"/>
	<xs:element name="Pred" type="Z:Pred" abstract="true">
		<xs:annotation>
			<xs:documentation>Abstract: replacable by any predicate</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="ExprPred" substitutionGroup="Z:Pred">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Pred">
					<xs:sequence>
						<xs:element ref="Z:Expr"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NegPred" substitutionGroup="Z:Pred">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Pred">
					<xs:sequence>
						<xs:element ref="Z:Pred"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AndPred" substitutionGroup="Z:Pred">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Pred2">
					<xs:attribute name="Op" use="optional" default="And">
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:enumeration value="And"/>
								<xs:enumeration value="NL"/>
								<xs:enumeration value="Semi"/>
								<xs:enumeration value="Chain"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="OrPred" type="Z:Pred2" substitutionGroup="Z:Pred"/>
	<xs:element name="ImpliesPred" type="Z:Pred2" substitutionGroup="Z:Pred"/>
	<xs:element name="IffPred" type="Z:Pred2" substitutionGroup="Z:Pred"/>
	<xs:element name="ForallPred" type="Z:QntPred" substitutionGroup="Z:Pred"/>
	<xs:element name="ExistsPred" type="Z:QntPred" substitutionGroup="Z:Pred"/>
	<xs:element name="Exists1Pred" type="Z:QntPred" substitutionGroup="Z:Pred"/>
	<xs:element name="MemPred" substitutionGroup="Z:Pred">
		<xs:annotation>
		  <xs:documentation>The mixfix attribute distinguishes
		     m = n (mixfix=true) from (m,n) \in (_ = _) (mixfix=false).
		  </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Pred">
					<xs:sequence>
						<xs:element ref="Z:Expr" minOccurs="2" maxOccurs="2"/>
					</xs:sequence>
					<xs:attribute name="Mixfix" type="xs:boolean" use="optional" default="false"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="FalsePred" type="Z:Fact" substitutionGroup="Z:Pred"/>
	<xs:element name="TruePred" type="Z:Fact" substitutionGroup="Z:Pred"/>
	<xs:element name="TypeAnn">
		<xs:annotation>
			<xs:documentation>Type annotations give the type of an expression/term</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Ann">
					<xs:sequence>
						<xs:element ref="Z:Type"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TypeEnvAnn">
		<xs:annotation>
			<xs:documentation>Type environments map names to types</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Ann">
					<xs:sequence>
						<xs:element name="NameTypePair" type="Z:NameTypePair" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SectTypeEnvAnn">
		<xs:annotation>
			<xs:documentation>Section-Type environments map names to (SectionName,Type) pairs</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Ann">
					<xs:sequence>
						<xs:element name="NameSectTypeTriple" type="Z:NameSectTypeTriple" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="LocAnn">
		<xs:annotation>
			<xs:documentation>Location annotations define the source-code location of a construct.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Ann">
					<xs:attribute name="Loc" type="xs:anyURI" use="required"/>
					<xs:attribute name="Line" type="xs:nonNegativeInteger" use="optional"/>
					<xs:attribute name="Col" type="xs:nonNegativeInteger" use="optional"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ParenAnn" type="Z:Ann">
		<xs:annotation>
			<xs:documentation>This means unnecessary parentheses surrounded the annotated element</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="Type" type="Z:Type" abstract="true">
		<xs:annotation>
			<xs:documentation>Abstract: replacable by any Z base type</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="GivenType" substitutionGroup="Z:Type">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Type">
					<xs:sequence>
						<xs:element name="Name" type="Z:Name"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="GenType" substitutionGroup="Z:Type">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Type">
					<xs:sequence>
						<xs:element name="Name" type="Z:Name"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PowerType" substitutionGroup="Z:Type">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Type">
					<xs:sequence>
						<xs:element ref="Z:Type"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProdType" substitutionGroup="Z:Type">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Type">
					<xs:sequence>
						<xs:element ref="Z:Type" minOccurs="2" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SchemaType" substitutionGroup="Z:Type">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="Z:Type">
					<xs:sequence>
						<xs:element name="Signature" type="Z:Signature"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:complexType name="TermA" mixed="false">
		<xs:annotation>
			<xs:documentation>Supertype of all ANNOTATED Z constructs</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Anns" minOccurs="0">
				<xs:complexType mixed="false">
					<xs:sequence>
						<xs:any namespace="##any" processContents="lax" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="Sect">
		<xs:annotation>
			<xs:documentation>Supertype of all sections</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ZSect">
		<xs:annotation>
			<xs:documentation>A parsed Z section (may contain unparsed paragraphs)</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Sect">
				<xs:sequence>
					<xs:element name="Name" type="xs:string"/>
					<xs:element name="Parent" type="Z:Parent" minOccurs="0" maxOccurs="unbounded"/>
					<xs:choice minOccurs="0" maxOccurs="unbounded">
						<xs:element ref="Z:Para"/>
						<xs:any namespace="##other" processContents="lax"/>
					</xs:choice>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UnparsedZSect">
		<xs:annotation>
			<xs:documentation>A completely unparsed Z section</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Sect">
				<xs:sequence>
					<xs:element name="Content" type="xs:anyType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NarrSect">
		<xs:annotation>
			<xs:documentation>Narrative before or after sections</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Sect">
				<xs:sequence>
					<xs:element name="Content" type="xs:anyType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Parent">
		<xs:complexContent>
			<xs:extension base="Z:TermA">
				<xs:sequence>
					<xs:element name="Word" type="xs:string"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Para">
		<xs:annotation>
			<xs:documentation>Supertype of all paragraphs</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GivenPara">
		<xs:complexContent>
			<xs:extension base="Z:Para">
				<xs:sequence>
					<xs:element name="DeclName" type="Z:DeclName" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AxPara">
		<xs:complexContent>
			<xs:extension base="Z:Para">
				<xs:sequence>
					<xs:element name="DeclName" type="Z:DeclName" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="SchText" type="Z:SchText"/>
				</xs:sequence>
				<xs:attribute name="Box" use="optional" default="AxBox">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="OmitBox"/>
							<xs:enumeration value="AxBox"/>
							<xs:enumeration value="SchBox"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FreePara">
		<xs:complexContent>
			<xs:extension base="Z:Para">
				<xs:sequence>
					<xs:element name="FreeType" type="Z:FreeType" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConjPara">
		<xs:complexContent>
			<xs:extension base="Z:Para">
				<xs:sequence>
					<xs:element name="DeclName" type="Z:DeclName" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="Z:Pred"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OptempPara">
		<xs:complexContent>
			<xs:extension base="Z:Para">
				<xs:choice minOccurs="2" maxOccurs="unbounded">
					<xs:element name="Word" type="xs:string"/>
					<xs:element name="Operand"/>
					<xs:element name="OperandList"/>
				</xs:choice>
				<xs:attribute name="Cat" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="Relation"/>
							<xs:enumeration value="Function"/>
							<xs:enumeration value="Generic"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="Assoc" use="optional" default="Left">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="Left"/>
							<xs:enumeration value="Right"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="Prec" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:nonNegativeInteger"/>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UnparsedPara">
		<xs:complexContent>
			<xs:extension base="Z:Para">
				<xs:sequence>
					<xs:element name="Content" type="xs:anyType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NarrPara">
		<xs:complexContent>
			<xs:extension base="Z:Para">
				<xs:sequence>
					<xs:element name="Content" type="xs:anyType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FreeType">
		<xs:complexContent>
			<xs:extension base="Z:TermA">
				<xs:sequence>
					<xs:element name="DeclName" type="Z:DeclName"/>
					<xs:element name="Branch" type="Z:Branch" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Branch">
		<xs:complexContent>
			<xs:extension base="Z:TermA">
				<xs:sequence>
					<xs:element name="DeclName" type="Z:DeclName"/>
					<xs:element ref="Z:Expr" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SchText">
		<xs:complexContent>
			<xs:extension base="Z:TermA">
				<xs:sequence>
					<xs:element ref="Z:Decl" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="Z:Pred" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Decl">
		<xs:annotation>
			<xs:documentation>Supertype of all declarations</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Name">
		<xs:annotation>
			<xs:documentation>Supertype of all Z names that can be decorated</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:TermA">
				<xs:sequence>
					<xs:element name="Word" type="xs:string"/>
					<xs:element ref="Z:Stroke" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DeclName">
		<xs:complexContent>
			<xs:extension base="Z:Name">
				<xs:attribute name="Id" type="xs:ID" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RefName">
		<xs:annotation>
			<xs:documentation>The Decl=IDREF attribute points to the matching declaration, which may not be the nearest enclosing one</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Name">
				<xs:attribute name="Decl" type="xs:IDREF" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Stroke" mixed="false">
		<xs:annotation>
			<xs:documentation>Supertype of the four kinds of name decorations</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="Expr">
		<xs:annotation>
			<xs:documentation>Supertype of all expressions</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Expr1">
		<xs:annotation>
			<xs:documentation>Supertype of unary expressions</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Expr">
				<xs:sequence>
					<xs:element ref="Z:Expr"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Expr2">
		<xs:annotation>
			<xs:documentation>Supertype of binary expressions</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Expr">
				<xs:sequence>
					<xs:element ref="Z:Expr" minOccurs="2" maxOccurs="2"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Expr0N">
		<xs:annotation>
			<xs:documentation>Supertype of lists of 0..N expressions</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Expr">
				<xs:sequence>
					<xs:element ref="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Expr2N">
		<xs:annotation>
			<xs:documentation>Supertype of lists of 2..N expressions (currently this schema does not check that there are at least two expressions, but code should)</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Expr0N"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LogExpr">
		<xs:annotation>
			<xs:documentation>Supertype of binary logical schema operators</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Expr2"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QntExpr">
		<xs:annotation>
			<xs:documentation>Supertype of all quantifier-like expressions</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Expr">
				<xs:sequence>
					<xs:element name="SchText" type="Z:SchText"/>
					<xs:element ref="Z:Expr" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Qnt1Expr">
		<xs:annotation>
			<xs:documentation>Abstract subtype of QntExpr, with compulsory Expr (currently this schema does not check that the Expr is compulsory, but code should)</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:QntExpr"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ExistsExpr">
		<xs:annotation>
			<xs:documentation>Supertype of schema exists expressions</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Qnt1Expr"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Pred">
		<xs:annotation>
			<xs:documentation>Supertype of all predicates</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Pred2">
		<xs:annotation>
			<xs:documentation>Supertype of binary predicates</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Pred">
				<xs:sequence>
					<xs:element ref="Z:Pred" minOccurs="2" maxOccurs="2"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QntPred">
		<xs:annotation>
			<xs:documentation>Supertype of all quantifier-like predicates</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:Pred">
				<xs:sequence>
					<xs:element name="SchText" type="Z:SchText"/>
					<xs:element ref="Z:Pred"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Fact">
		<xs:complexContent>
			<xs:extension base="Z:Pred"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Ann" mixed="false">
		<xs:annotation>
			<xs:documentation>Supertype of all annotations</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="Type">
		<xs:annotation>
			<xs:documentation>Supertype of all Z base types</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Signature">
		<xs:sequence>
			     <xs:element name="NameTypePair" type="Z:NameTypePair" minOccurs="0" maxOccurs="unbounded"/>
			     <xs:element ref="Z:Type"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NameExprPair">
		<xs:sequence>
			<xs:element name="Name" type="Z:DeclName"/>
			<xs:element ref="Z:Expr"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NameTypePair">
		<xs:sequence>
			<xs:element name="Name" type="Z:Name"/>
			<xs:element ref="Z:Type"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NameSectTypeTriple">
		<xs:sequence>
			<xs:element name="Name" type="Z:Name"/>
                        <xs:element name="Sect" type="xs:string"/>
			<xs:element ref="Z:Type"/>
		</xs:sequence>
	</xs:complexType>
	<xs:group name="NameNamePair">
		<xs:sequence>
			<xs:element name="OldName" type="Z:RefName"/>
			<xs:element name="NewName" type="Z:DeclName"/>
		</xs:sequence>
	</xs:group>
</xs:schema>
