<?xml version="1.0" encoding="UTF-8"?>
<!-- 
  Despite other extensions having xmlns inclusion top-down and some bottom-up,
  the top-down approach (i.e. circus, zpatt, zml) was creating problems for GnAST.
-->
<xs:schema  
  targetNamespace="http://czt.sourceforge.net/circus"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:P="http://czt.sourceforge.net/zpatt"
  xmlns:CIRCUS="http://czt.sourceforge.net/circus"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="0.1">
  <xs:annotation>
    <xs:documentation>
      Copyright 2005, 2006 Leonardo Freitas
      $Id$

      This XML schema defines XML markup for formal specifications 
      written in Circus, a concurrent language for refinement that
      combines CSP, Z and the refinement calculus.
      More information at <a href="http://www.cs.york.ac.uk/~circus">Circus main web page</a>
      or at <a href="http://www.cs.york.ac.uk/~leo">the author'ss web page</a>.

      This file is part of the Community Z Tools (CZT) project.
 
      The CZT project contains free software; you can
      redistribute it and/or modify it under the terms
      of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of
      the License, or (at your option) any later version.
 
      The CZT project is distributed in the hope that it
      will be useful, but WITHOUT ANY WARRANTY; without
      even the implied warranty of MERCHANTABILITY or
      FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.

      You should have received a copy of the GNU General
      Public License along with CZT; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place,
      Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
      <jaxb:schemaBindings>
        <jaxb:package name="net.sourceforge.czt.circus.jaxb.gen">
          <jaxb:javadoc>
            &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
            &lt;html&gt;
            &lt;body&gt;
            &lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
          </jaxb:javadoc>
        </jaxb:package>
      </jaxb:schemaBindings>
      <gnast:schemaBindings name="Circus">
        <gnast:package name="net.sourceforge.czt.circus">
          <gnast:package id="ast" name="ast">
            <gnast:generate id="factory" class="CircusFactory" template="CoreFactory.vm"/>
            <gnast:javadoc>
&lt;p&gt;
These interfaces represent the AST for Circus. 
&lt;/p&gt;
            </gnast:javadoc>
          </gnast:package>
          <gnast:package id="impl" name="impl">
            <gnast:generate id="factoryImpl" class="CircusFactoryImpl" template="CoreFactoryImpl.vm"/>
          </gnast:package>
          <gnast:package id="visitor" name="visitor">
            <gnast:generate id="AstVisitor" class="CircusVisitor" template="AstVisitor.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="convFactory" class="Factory" template="Factory.vm"/>
          </gnast:package>
          <!-- NOT YET...
          <gnast:package id="util" name="util">
            <gnast:generate id="flyFactory" class="FlyweightFactory"
              template="FlyweightFactory.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="createVisitor" class="CreateVisitor"
              template="CreateVisitor.vm"/>
          </gnast:package>
          -->
          <gnast:package id="jaxb" name="jaxb">
            <gnast:generate id="AstToJaxb" class="AstToJaxb" template="AstToJaxb.vm"/>
            <gnast:generate id="JaxbToAst" class="JaxbToAst" template="JaxbToAst.vm"/>
          </gnast:package>
          <gnast:package id="dom" name="dom">
            <gnast:generate id="AstToDom" class="AstToDom" template="AstToDom.vm"/>
          </gnast:package>
        </gnast:package>
      </gnast:schemaBindings>
    </xs:appinfo>
  </xs:annotation>

  <!-- NOTE: GnAST considers the first import only in the SchemaProject build phase,
             so always put ZPattern.xsd first for Circus.xsd (i.e. innermost parent).
   -->
  <xs:import namespace="http://czt.sourceforge.net/zpatt" schemaLocation="ZPattern.xsd"/>  
  <xs:import namespace="http://czt.sourceforge.net/zml" schemaLocation="Z.xsd"/>

  <!-- ********************************************************************* -->
  <!-- Definitions of the elements in the order of appearance in the grammar -->
  <!-- ********************************************************************* -->

  <!-- Section level paragraphs -->
  
  <xs:element name="ChannelPara" type="CIRCUS:ChannelPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel paragraph that declares channel names with corresponding types, possibly generic. 
        Channels are used in process definitions. Strokes are not allowed in channel names, and this is
        ensured by the parser. 
        </p>
        <p>
        It represents the <b>channel</b> <code>ChannelDecl</code> grammar rule.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ChannelSetPara" type="CIRCUS:ChannelSetPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel set paragraph that declares a name for a channel set.
        A channel set encapsulates a Z <code>Expr</code>.
        </p>
        <p>
        It represents the <b>channelset</b> <code>N == CSExpression</code> grammar rule, 
        where <code>N</code> is a <code>Name</code>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ProcessPara" type="CIRCUS:ProcessPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
        A process paragraph that introduces a name for a process definition.
        Strokes are not allowed in process names, and this is ensured by the parser.
        </p>
        <p>
        This element represents the <b>ProcessDeclaration</b> grammar rule.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
    
  <xs:element name="CircusConjPara" type="CIRCUS:CircusConjPara" substitutionGroup="Z:Para" abstract="true">
    <xs:annotation>
      <xs:documentation>
        A (generic) Circus conjecture paragraph. It is used by tools to ensure that
        certain special properties hold.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="TransformerPara" type="CIRCUS:TransformerPara" substitutionGroup="CIRCUS:CircusConjPara">
    <xs:annotation>
      <xs:documentation>
        A circus conjecture between two circus transformer predicates.
        This is usually used by the model checker as a refinement transformation
        between process and actions, but can also be used as a simulation or 
        equivalence transformation by other tools.
      </xs:documentation>
    </xs:annotation>        
  </xs:element>  
  
  <!-- Section level declarations -->  
  <!-- Channel declaration -->
  
  <xs:element name="ChannelDecl" type="CIRCUS:ChannelDecl" substitutionGroup="Z:Decl">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel declaration is a Z declaration that accepts generic types.
        It represents the <b>SimpleCDeclaration</b> grammar rule.
        </p>
        <p>
        Channels can be declared either as typed or synchronisation. 
        They can als have generic types or come from a previously declared schema.
        </p>
        <p>
        The structure of the complex type associated with this class is a follows:
        <ul>
          <li>Typed  channels = optional generics, nonempty list of declnames, non-null Expr. </li>
          <li>Synch. channels = empty generics, nonempty list of declnames, RefExpr(SYNCH), where SYNCH is a given type. </li>
          <li>Schema channels = optional generics, empty list of declnames, non-null RefExpr. </li>          
        </ul>
        This invariant is to be enforced by the parser, and further unfolded by the typechecker.
        That is, channels declared through schemas must be expanded to their typed declaration form.
        Such unfolding must take into account both sets of generic formals comming from the channel 
        declaration as well as the schema generic formals. In this sense, the user is allowed to
        change the pattern of generic formals inside the schema through the generic formals of the
        channel declaration (see <code>./parser/tests/cirus/channels.tex</code> for an example).
        </p>
        <p>
        The <code>getNameList()</code> method contains a list of non-null <code>NameList </code> 
        objects with size two. The first element is the (possibly empty) list of generic formal 
        parameters, whereas the second element is the (possibly empty) list of declared channel names.
        If the second list is empty, that means the <code>ChannelDecl</code> represents a <em>channelfrom</em>
        (i.e., channel declaration from a schema expression found in the <code>getExpr()</code> method).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Channel Set Expressions -->
  <xs:element name="ChannelSet" type="CIRCUS:ChannelSet" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
        Abstract base classe for Circus channel set expressions. There are two
        implementations: one for normal <code>CircusChannelSet</code>s appearing
        in specifications; and one for chennel set jokers appearing in refinement
        laws.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <xs:element name="CircusChannelSet" type="CIRCUS:CircusChannelSet" substitutionGroup="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        <p>
        An channel set expression is a special kind of expression used in Circus that is
        not within the Z expressions subtree. It represents the <b>CSExpression</b> grammar rule.
        </p>
        <p>
        Although it is formed by a Z expression, channel set expressions cannot appear wherever a Z expression can;
        they are only allowed in some operators such parallelism and hiding. For this it encpasulates a Z expression
        within the <code>ChannelSet</code> class.
        </p>
        <p>
        The most common Z expressions used in channel sets are set extensions, the empty set, and application expressions.
        The most common application expressions are set union, intersection, and diference. Other (possibly user defined) 
        functions can also be used.
        </p>
        <p>
        In any case, a channel set expression is well-typed only if the names it refer to are from previously declared channels,
        or a previously declared channel set. That is, a well-typed <code>ChannelSet</code> must be a power type of previously declared
        channel names.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <xs:element name="BasicChannelSetExpr" type="CIRCUS:BasicChannelSetExpr" substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel set expression containing a set of references to previously declared channel names (i.e. channel references).
        It represents the grammar rules for empty and enumerated channel sets. It is just like a set extension but the parser
        identifies differently due to the spceial channel set braces.        
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
        
  <!-- Process Description -->                
  <!-- DESIGN DECISION
      In order to allow a more uniform implementation, we avoided having an explicit ProcessDesc hierarchy tree.
      Instead, we expect the parser to actually manage the appropriate creation, hence allowing productions such as:      
      (x: \nat @ c \then STOP) \extchoice (y: \nat @ d \then STOP).
      
      This decision allows one to have a uniform/intuitive implementation of Declaration::Unary processes as expected. 
      That is, ParamProcessDesc and IndexedProcessDesc are considered unary as well.

  <xs:element name="ProcessDesc" type="CIRCUS:ProcessDesc" abstract="true">
      <xs:annotation>
          <xs:documentation>
              An abstract process description.
              Available extensions process definition, parameterised process, and indexed process.
          </xs:documentation>
      </xs:annotation>
  </xs:element>
  <xs:element name="ParamProcessDesc" type="CIRCUS:ParamProcessDesc" substitutionGroup="CIRCUS:ProcessDesc">
    <xs:annotation>
      <xs:documentation>
        A parameterised process description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IndexedProcessDesc" type="CIRCUS:ParamProcessDesc" substitutionGroup="CIRCUS:ProcessDesc">
    <xs:annotation>
      <xs:documentation>
        An indexed process description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>      
  -->

  <!-- Processes -->    
  <xs:element name="CircusProcess" type="CIRCUS:CircusProcess" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract Circus process definition. It represents the <b>ProcessDefinition</b> grammar rule.
        Available extensions are basic process description; recursion; prefixing; guarded process; 
        process call; all forms of unary, binary, iterated, and indexed processes;
        processes involving expressions; and processes involving declarations. 
        </p>
        <p>
        The parser is responsible to enforce restrictions over process definitions involving parameters 
        or indexes within some binary productions. For instance, the parse must rule out cases such as 
        <code>(x: nat @ A) [] (y: nat @ B)</code>, since parameterised process can only appear in an 
        external choice whenever the actual parameters are given.
        </p>
        <p>        
        This allows us to represent the grammar rules <b>ProcessDefinition</b> and <b>Process</b> with 
        a single class. The main advantage is that we can treat unary process definitions uniformly 
        through a single hierarchy tree.
        </p>
        <p>
        Naming this class <code>Process</code> would have been a better choice but unfortunately this would 
        conflict with the interface <code>java.lang.Process</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Process1" type="CIRCUS:Process1" abstract="true" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract unary Circus process.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="Process2" type="CIRCUS:Process2" abstract="true" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract binary Circus process.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessD" type="CIRCUS:ProcessD" abstract="true" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract unary Circus process with Z declarations.</p>
        <p>The parser must enforce that the declared variables do not have strokes via <code>VarDecl</code>,
           that strokes should be ignored via <code>InclDecl</code> (schema inclusion), and that <code>ConstDecl</code>
           is not allowed at all.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessIte" type="CIRCUS:ProcessIte" abstract="true" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract iterated Circus process with Z declarations.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <!-- DESIGN DECISION:
    Originally the substitution group for ProcessIdx was ProcessD, hence the two subtrees for iterated and
    indexed iterated processes were siblings. However, yet replicated and iterated processes are not simply 
    syntactic sugar due to the special renaming that changes the channel types, one can see it as a replication 
    followed by a kind of renaming. Therefore, by deriving from ProcessIte instead of ProcessD, we give the user 
    the chance to reuse visiting code for replication and then further add the necessary renaming functionality. 
    If, on the other hand, a different treatment of replication becomes necessary, one just needs to ignore the 
    superclass implementation from ProcessIte and provide a new one for the replication task.
  -->
  <xs:element name="ProcessIdx" type="CIRCUS:ProcessIdx" abstract="true" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract indexed and iterated Circus process with Z declarations.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process :: Unary with Declaration -->
  <xs:element name="ParamProcess" type="CIRCUS:ProcessD" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        <p>
        A parameterised process definition. It represents grammar rule <b>Declaration @ ProcessDefinition</b>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IndexedProcess" type="CIRCUS:ProcessD" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        An indexed process definition. It represents grammar rule <b>Declaration odot ProcessDefinition</b>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>     

  <!-- Process :: Basic -->

  <xs:element name="BasicProcess" type="CIRCUS:BasicProcess" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>
        A process definition for an explicit process declaration.
        It is formed by a (possibly empty) set of process paragraphs,
        an optional process state given as a schema and a (mandatory) 
        main action definition.
        </p>
        <p>
        It represents the grammar rule <b>begin</b> <code>PParagraph*</code> <b>state</b> <code>Schema-Exp PParagraph*</code>
        <b>@</b> <code>Action</code> <b>end</b>.
        </p>
        <p>
                For the process state, the corresponding action (as a SchExprAction) or Z paragraph (as a Schema or HorizontalDef) 
                must contain a <code>CircusStateAnn</code> annotation.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process :: Call -->

  <!-- DESIGN DECISION: 
  
    As Circus allows calls over definitions given on-the-fly, we need a more powerful approach for a call,
    rather than a simple Name. There are two approaches for the implementation of process/action calls.
    We have taken the first one in order to simplify the implementation of visitor of different tools.
    
    The first demands specialised CallKind attribute on CallProcess, whereas the second introduces specialised classes      
    for each special production. For processes, these are actual parameters, indexes, and actual types. For action 
    these are actual parameters, and command parameters.
    
    Another interesting issue is that in the production tree, one is allowed to use a Process for renaming 
    (Process[N^+ := N^+]).  This allowed the definition of renaming on-the-fly (unnamed) or via a call processes.                                                
    Ex:  (c?x \then Skip)[c := b] or P = (c?x \then Skip), Q = P[c := b].
    On the second case via CallProcess it means that the CircusProcess descendent of ProcessDesc is being selected.
    In turn, the kind of CircusProcess is CallProcess and the list of renaming names are under RenameProcess.
    This allows both indexed and parameterised processes to use renaming hence creating a undesired ambiguity.
    
    The second approach is to have individual classes for this on-the-fly declaration and call directly,
    together with a base case of call with simple name on it. See more details below at ActualParamProcess.     
  -->
  <xs:element name="CallProcess" type="CIRCUS:CallProcess" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus process reference call. In other words, it permits a name to be a process.
        That is, it contains a reference name to lookup the process definition.
        </p>
        <p>
        Moreover, it contains two list of expressions and an attribute defining the kind of call this 
        reference is related too. The first list is related to generic actuals, whereas the second list is 
        related to actual parameters or indexes. 
        An empty list of generic actuals means that refering process is not generic.
        An empty list of expressions means a simple process call of the grammar rules <b>N, N[Expr+]</b>,
        where <b>N</b> is the process name.
        If the list of expressions is not empty, then the <code>CallKind</code> attribute defines if this is an indexed 
        process instantiation call, a parameterised process call.
        It represents the grammar rules: <b>N(Expr+), N lfloor Expr+ rfloor</b>
        </p>
        <p>        
        The invariant is as follows:  TODO: THIS COMMENT NEEDS UPDATE (See Parser.xml)
        <ul>
          <li>N        = nonempty name, empty generic actuals, and empty parameters/indexes. </li>
          <li>N[Expr+] = nonempty name, nonempty generic actuals, and empty parameters/indexes. </li>
          <li>N(Expr+) = empty generic actuals, nonempty parameters. 
                         Internal name for on-the-fly, user given name for previously declared action. 
                         The call type defines whether the expressions are actual parameters or indexes.</li>
          <li>N[Expr+](Expr+) = nonempty generic actuals, nonempty parameters. 
                         Internal name for on-the-fly, user given name for previously declared action. 
                         The call type defines whether the expressions are actual parameters or indexes.</li>          
        </ul>
        The case for parameterised and indexed process is not present in the grammar. 
        The default value of CallKind is <b>Param</b> and need to be inspected only for the case where the 
        second expression list demands attention.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process :: Unary  -->  
  <xs:element name="HideProcess" type="CIRCUS:HideProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        Circus process with event concealment through hiding.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="RenameProcess" type="CIRCUS:RenameProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        Circus process with channel renaming. As channels in Circus are strongly-typed, type-checking is expected.
        Note that, since the class derives from <code>Process1</code>, the grammar does not accept on-the-fly renaming 
        of parameterised processes. ex: (x: \nat @ c!x -> Stop)[c := b]. This is a design decision for uniformity purposes only.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <xs:element name="AssignmentPairs" type="CIRCUS:AssignmentPairs">
    <xs:annotation>
      <xs:documentation>
        Encapsulates two lists used for assignments.
        <p>
        Syntactically, that corresponds to either channels in <code>RenamingProcess</code>,
        or to variables in an assignment command. Semantically, it is also used to determine
        which (process) state variables were updated, and in which order.
        </p>
        <p>
        It represents two lists of equal size for the left and right hand sides. 
        Moreover, for <code>RenamingProcess</code>, the RHS list can only contain 
        <code>RefExpr</code>, as channels might have generic actuals.
        For state updates, the RHS may be a predicate, in which case it is given as
        an SchExpr to operate upon the process state.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process Definition :: Binary -->
  <xs:element name="SeqProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParProcess" type="CIRCUS:ParProcess" substitutionGroup="CIRCUS:Process2" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract circus process for parallel operators.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcess" type="CIRCUS:ParProcess" substitutionGroup="CIRCUS:ParProcess">
    <xs:annotation>
      <xs:documentation>
        Circus process for interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcess" type="CIRCUS:ParallelProcess" substitutionGroup="CIRCUS:ParProcess">
    <xs:annotation>
      <xs:documentation>
        Circus process for parallel composition;
        it includes the synchronisation set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelProcess" type="CIRCUS:AlphabetisedParallelProcess" substitutionGroup="CIRCUS:ParProcess">
    <xs:annotation>
      <xs:documentation>
        Circus alphabetised parallel process; it includes the two alphabets as channel sets.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process Definition :: Expressions -->

  <!--
    DESIGN DECISION: 
      The next element was used for on-the-fly declaration of parameters for processes. 
      A similar construction needed to be created for indexes, and actual types. 
      Actions and commands also have similar constructs.
      
      These constructs usually appear through refinement steps from tools rather than directly by the user.           
      As the treatment of each of these cases is very similar, having separate AST nodes would possibly mean 
      repeated code (versioning and maintenance problems). 
      
      Instead, as the treatment of each of these cases is equivalent to a CallProcess with the appropriate call 
      type determining the meaning of the list of expressions, we assume that the Circus parser will interpret
      these cases appropriately by generating internal ProcessPara on-the-fly with reserved names not allowed to
      be declared by the user.

  <xs:element name="ProcessE" type="CIRCUS:ProcessE" abstract="true" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        An abstract Circus process involving expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
    <xs:element name="ActualParamProcess" type="CIRCUS:ActualParamProcess" substitutionGroup="CIRCUS:ProcessE">
      <xs:annotation>
        <xs:documentation>
          Defines a parameterised Circus process on-the-fly with its actual parameter.
          This enables on-the-fly declaration of parameterised indexed processes.             
          Ex: (x: T \spot c.x \then Skip)~(0) \equiv c.0 \then Skip.
          Note that this is different from a parameterised process description with a reference name calling 
          it with the given actual parameters.
          Ex: P = (x: T \spot c.x \then Skip).
                  Q = P~(0).
        </xs:documentation>
      </xs:annotation>
  </xs:element>
  <xs:element name="InstantiationProcess" type="CIRCUS:InstantiationProcess" substitutionGroup="CIRCUS:ProcessE">
    <xs:annotation>
      <xs:documentation>
        Defines a indexed Circus process on-the-fly with its actual instantiation
        This enables on-the-fly declaration of indexed parameterised processes.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  -->

  <!-- Process Definition :: Unary :: Declaration :: Iterated -->
  <xs:element name="SeqProcessIte" type="CIRCUS:ProcessIte" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcessIte" type="CIRCUS:ProcessIte" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcessIte" type="CIRCUS:ProcessIte" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParProcessIte" type="CIRCUS:ParProcessIte" substitutionGroup="CIRCUS:ProcessIte" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract circus iterated parallel process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcessIte" type="CIRCUS:ParProcessIte" substitutionGroup="CIRCUS:ParProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcessIte" type="CIRCUS:ParallelProcessIte" substitutionGroup="CIRCUS:ParProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="AlphabetisedParallelProcessIte" type="CIRCUS:ParallelProcessIte" substitutionGroup="CIRCUS:ParProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for alphabetised iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition :: Unary :: Declaration :: Iterated :: Indexed -->
  <xs:element name="SeqProcessIdx" type="CIRCUS:ProcessIdx" substitutionGroup="CIRCUS:ProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcessIdx" type="CIRCUS:ProcessIdx" substitutionGroup="CIRCUS:ProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="IntChoiceProcessIdx" type="CIRCUS:ProcessIdx" substitutionGroup="CIRCUS:ProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParProcessIdx" type="CIRCUS:ParProcessIdx" substitutionGroup="CIRCUS:ProcessIdx" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract circus indexed iterated parallel process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="InterleaveProcessIdx" type="CIRCUS:ParProcessIdx" substitutionGroup="CIRCUS:ParProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcessIdx" type="CIRCUS:ParallelProcessIdx" substitutionGroup="CIRCUS:ParProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelProcessIdx" type="CIRCUS:ParallelProcessIdx" substitutionGroup="CIRCUS:ParProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for alphabetised indexed and iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Action Para -->
  <xs:element name="ActionPara" type="CIRCUS:ActionPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
        A action paragraph that declares a name for an action definition.
        Strokes are not allowed in channel set names, and this is ensured by the parser.
        </p>
        <p>
        This element represents the <code>N == ParAction</code> grammar rule, where,
        where <code>N</code> is a <code>Name</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Name Set Paragraphs -->
  <xs:element name="NameSetPara" type="CIRCUS:NameSetPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>        
        <p>
        A name set paragraph that introduces a name for a name set.
        A name set encapsulates a Z <code>Expr</code>.
        </p>
        <p>
        It represents the <b>nameset</b> <code>N == NSExpression</code> grammar rule, 
        where <code>N</code> is a <code>Name</code>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Name Set Expressions -->
  <xs:element name="NameSet" type="CIRCUS:NameSet" abstract="true">
    <xs:annotation>
      <xs:documentation>        
        <p>
        Abstract base classe for Circus name set expressions. There are two
        implementations: one for <code>CircusNameSet</code>s appearing
        in specifications; and one for name set jokers appearing in refinement
        laws.
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
    
  <xs:element name="CircusNameSet" type="CIRCUS:CircusNameSet" substitutionGroup="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>        
        <p>
        A name set expression is a special kind of expression used in Circus that is
        not within the Z expressions subtree. It represents the <b>NSExpression</b> grammar rule.
        </p>
        <p>
        Although it is formed by a Z expression, name set expressions cannot appear wherever a Z expression can;
        they are only allowed in some operators such as parallelism. For this it encpasulates a Z expression
        within the <code>NameSet</code> class.
        </p>
        <p>
        The most common Z expressions used in name sets are set extensions, the empty set, and application expressions.
        The most common application expressions are set union, intersection, and diference. Other (possibly user defined) 
        functions can also be used.
        </p>
        <p>
        In any case, a name set expression is well-typed only if the names it refer to are from previously declared state variables,
        or a previously declared name set. That is, a well-typed <code>NameSet</code> must be a power type of previously declared
        state variable names.
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Action Description -->     
  <!-- See ProcessDesc above 
  <xs:element name="ActionDesc" type="CIRCUS:ActionDesc" abstract="true">
      <xs:annotation>
          <xs:documentation>
              An abstract action description.
              Available extensions action definition, and parameterised action.
          </xs:documentation>
      </xs:annotation>
  </xs:element>
  <xs:element name="ParamActionDesc" type="CIRCUS:ParamActionDesc" substitutionGroup="CIRCUS:ActionDesc">
    <xs:annotation>
      <xs:documentation>
        A parameterised action description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  -->
  
  <!-- Actions -->    
  <xs:element name="CircusAction" type="CIRCUS:CircusAction" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract Circus action definition. It represents the <b>ParAction</b> grammar rule.
        Available extensions are recursion; prefixing; guarded actions; action call; 
        all forms of unary, binary, iterated, and indexed actions;
        actions involving expressions; and actions involving declarations. 
        </p>
        <p>
        The parser is responsible to enforce restrictions over action definitions involving parameters 
        within some binary productions. For instance, the parse must rule out cases such as 
        <code>(x: nat @ A) [] (y: nat @ B)</code>, since parameterised actions can only appear in an 
        external choice whenever the actual parameters are given.
        </p>
        <p>        
        This allows us to represent the grammar rules <b>ParAction</b>, <b>Action</b>, and <b>CSPAction</b>
        with a single class. The main advantage is that we can treat unary action definitions uniformly 
        through a single hierarchy tree.
        </p>
        <p>
        Naming this class <code>Action</code> would have been a better choice but it often conflicts with 
        other main stream Java libraries class names.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Action1" type="CIRCUS:Action1" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        An abstract unary Circus action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="Action2" type="CIRCUS:Action2" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        An abstract binary Circus action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="ActionD" type="CIRCUS:ActionD" abstract="true" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract unary Circus action with Z declarations.
        </p>
        <p>
        The parser must enforce that the declared variables do not have strokes via <code>VarDecl</code>,
        that strokes should be ignored via <code>InclDecl</code> (schema inclusion), and that <code>ConstDecl</code>
        is not allowed at all.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="ActionIte" type="CIRCUS:ActionIte" abstract="true" substitutionGroup="CIRCUS:ActionD">
    <xs:annotation>
      <xs:documentation>
        An abstract iterated unary Circus action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Action :: Unary with Declaration -->
  <xs:element name="ParamAction" type="CIRCUS:ActionD" substitutionGroup="CIRCUS:ActionD">
    <xs:annotation>
      <xs:documentation>
        A parameterised action definition. It represents grammar rule <b>Declaration @ ParAction</b>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Action :: Commands (base class) -->
  <xs:element name="CircusCommand" type="CIRCUS:CircusCommand" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract command action definition. Available extensions are specification statement
        in Carroll Morgan's style; (possibly multiple) assignment; if guards in Dijkstra's style;
        (possibly multiple) variable declaration; and parameterised commands with qualified declarations.
        </p>
        <p>It represents the grammar rule <b>ParCommand</b> as the base class of Circus commands.</p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>    

  <!-- Action :: Schema-Exp -->  
    
  <xs:element name="SchExprAction" type="CIRCUS:SchExprAction" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        An action given as a schema expression.
        In this way, schema expressions are included into the <code>CircusAction</code> subtree
        in a similar way as schema expressions are included in the declaration and predicate subtrees.
        </p>
        <p>
        As one might use a schema expression for defining a Z schema (i.e. S and T), this class contains an 
        Z <code>Expr</code> instead of <code>SchExpr</code>. The parser is responsible to rule out other 
        possibilities and ensure that only well formed schema expressions are allowed.
        From the CZT these came through <code>SchExpr</code>, <code>SchExpr2</code>, <code>DecorExpr</code>,
        <code>NegExpr</code>, and <code>RenameExpr</code>. (TODO: Check this carefully).
        </p>        
        <p>
        For the process state, this action or a the corresponding Z paragraph must contain a <code>CircusStateAnn</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  

  <!-- Action :: Call -->  
  <xs:element name="CallAction" type="CIRCUS:CallAction" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus action reference call. In other words, it permits a name to be an action.
        That is, it contains a reference name to lookup the action definition.
        </p>
        <p>
        Moreover, it contains a list of expressions representing possible actual parameters.
        An empty list of expressions means a simple action call of the grammar rule <b>N</b>,
        where <b>N</b> is the action name.
        If the list of expressions is not empty, then the this is a parameterised action.
        It represents the grammar rule <b>N(Expr+)</b> for CSP actions and commands.
        </p>
        <p>
        The invariant is as follows:        
        <ul>
          <li>N        = nonempty name and empty parameters. </li>
          <li>N(Expr+) = nonempty parameters. Internal name for on-the-fly, user given name for previously declared action. </li>
        </ul>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

    <!-- CSP Action :: ActionDesc -->
    
    <!-- 
    <xs:element name="ActualParamAction" type="CIRCUS:ActualParamAction" substitutionGroup="CIRCUS:CircusAction">
      <xs:annotation>
        <xs:documentation>
          The CSP operator for parameterised action defined on the fly with its actual parameters.
          Ex: (x: \nat \spot c.x \then Skip)(10)
        </xs:documentation>
      </xs:annotation>
    </xs:element>
    -->

  <!-- CSP Action :: Basic -->      
  <xs:element name="BasicAction" type="CIRCUS:BasicAction" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract class for basic Circus action.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SkipAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus action that represents successful silent termination. That is, an action that has 
        terminated (i.e. ok' = true and wait' = false) and no modification in the trace has 
        occurred (i.e. trace' = trace).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="StopAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus action that represents deadlock. That is, an action that refuses every possible event
        and is still waiting (i.e. wait' = false).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ChaosAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Chaotic Circus action as defined by the UTP (see also Hoare's CSP CHAOS process, 
        as well as Roscoe's CSP <b>div</b> process).
        </p>
        <p>
        Theoretically, it represents the bottom element of the Circus lattice of 
        failures-divergences with embedded imperative features. 
        Implementations should usually treat this element as the base case for the 
        <b>possibility</b> (not certainty) of divergence.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Unary -->  
  <xs:element name="MuAction" type="CIRCUS:MuAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        <p>The mu operator defines a recursive action.</p>
        <p>The parser must enforce that the given name does not have strokes.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="GuardedAction" type="CIRCUS:GuardedAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The Circus guarded action defines an action guarded by a Z predicate.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="HideAction" type="CIRCUS:HideAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The Circus hide operator defines events concealment within an action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="PrefixingAction" type="CIRCUS:PrefixingAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The Circus operator for actions prefixed with a communication.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SubstitutionAction" type="CIRCUS:SubstitutionAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus action variable substitution. As variables in Circus are strongly-typed, type-checking is expected here.
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>  

  <!-- CSP Action :: Binary -->
  <xs:element name="SeqAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        Sequential composition between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        External choice between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        Internal choice between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParAction" type="CIRCUS:ParAction" abstract="true" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract parallel action definition;
        it includes the name set partitions of the state.
        </p>
        <p>
        As empty name disjoint sets are often used in parallel actions, syntactic sugar for these cases
        is provided in the grammar rules for interleaving, parallel composition, and alphabetised parallel 
        composition, so that we do not need explicit AST classes. 
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveAction" type="CIRCUS:ParAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Interleaving between two actions.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelAction" type="CIRCUS:ParallelAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        Parallel composition between two actions;
        it includes the channel set expression for the synchronisation set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelAction" type="CIRCUS:AlphabetisedParallelAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        Alphabetised Parallel composition between two actions;
        it includes the channel set expression for both alphabets as synchronisation sets.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Unary :: Declaration :: Iterated -->
  <xs:element name="SeqActionIte" type="CIRCUS:ActionIte" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceActionIte" type="CIRCUS:ActionIte" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceActionIte" type="CIRCUS:ActionIte" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParActionIte" type="CIRCUS:ParActionIte" abstract="true" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract parallel iterated action definition.
        it includes the name set partitions of the state.
        </p>
        <p>
        As empty name disjoint sets are often used in iterated parallel actions, syntactic sugar for these cases
        is provided in the grammar rules for iterated interleaving, iterated parallel composition, and iterated 
        alphabetised parallel composition, so that we do not need explicit AST classes. 
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveActionIte" type="CIRCUS:ParActionIte" substitutionGroup="CIRCUS:ParActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelActionIte" type="CIRCUS:ParallelActionIte" substitutionGroup="CIRCUS:ParActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelActionIte" type="CIRCUS:ParallelActionIte" substitutionGroup="CIRCUS:ParActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for alphabetised iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Communication --> 
  <xs:element name="Communication" type="CIRCUS:Communication">
    <xs:annotation>
      <xs:documentation>
        <p>
        A CSP communication that is part of a prefixing process or action. 
        If the communicating channel has been declared with generic types, the communication 
        must carry the generic actual expressions, hence we have a <code>RefExpr</code> rather than
        a <code>Name</code>. It represents the <b>Communication</b> grammar rule.
        </p>
        <p>
        A communication can be either a communication for synchronisation, input, output, or mixed.
        Synchronisation has no fields. Input and Output has only input or output fields respectively. 
        Mixed communication has both input and output fields, such as <code>c?x:P!v -> A</code>.
        </p>
        <p>
        The semantics of dot (c.x) and output (c!x) is equivalent. 
        However, for some applications/tools, their evaluation can be done differently.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Communication Fields --> 
  <xs:element name="Field" type="CIRCUS:Field" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract field is part of a communication. 
        Available extensions are input, dot, and output fields.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InputField" type="CIRCUS:InputField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        <p>
        An input field that is part of a communication.
        It represents grammar rules <b>?N</b> and <b>?N: Pred</b>.
        </p>
        <p>
        The parse must ensure that the declared name <b>N</b> does not have strokes.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="DotField" type="CIRCUS:DotField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        <p>
        A field that is part of a communication and contains an expression.
        It represents the grammar rule <b>.Expr</b>.
        </p>
        <p>
        In general, the ``dot'' is treated as output communication.
        However, depending on the purpose of use, it can be considered as a reading or writing synchronisation point.        
        </p>
        <p>        
        Another example where the differentiation between dot and output fields is relevant comes from CSP_M and FDR,
        where ``dot'' fields are used for resolved expressions, whereas ``output'' fields can be used for expressions 
        yet to be resolved. 
        Roscoe's give some insight on further interesting possibilities that motivates such differentiation in 
        his CSP book (p.27).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OutputField" type="CIRCUS:DotField" substitutionGroup="CIRCUS:DotField">
    <xs:annotation>
      <xs:documentation>
        <p>
        A field that is part of a communication and contains an expression.
        It represents the grammar rule <b>!Expr</b>.        
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>       
  
  <!-- Circus declarations -->  
  <xs:element name="QualifiedDecl" type="CIRCUS:QualifiedDecl" substitutionGroup="Z:Decl">
    <xs:annotation>
      <xs:documentation>
        This is like <code>VarDecl</code>, but it includes qualifier attributes for each <code>Name</code>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>      
 
  <!-- Circus Commands -->
  <xs:element name="SpecStmtCommand" type="CIRCUS:SpecStmtCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus command declaring a specification statement in Carroll Morgan's style.
        It represents the grammar rule <code>N+:[Pred,Pred]</code>.
        The parser is responsible to ensure that no strokes are allowed in the frame variables.
        </p>
        <p>
        As assumption and coercion are syntactic sugar for often used specification statements,
        they do not have an explicit AST class. Instead, assumption (grammar rule <code>{Pred}</code>)
        is represented by a specification statement with empty frame, <code>Pred</code> precondition, 
        and true postcondition. Similarly, coercion (grammar rule <code>[Pred]</code>) is represented by 
        a specification statement with empty frame, true precondition, and <code>Pred</code> postcondition.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AssignmentCommand" type="CIRCUS:AssignmentCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        Circus command declaring (possibly) multiple assignment.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IfGuardedCommand" type="CIRCUS:IfGuardedCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
        Command declaring a if statement containing guarded actions in Dijkstra's style.
        Although semantically different, we can represent the AST for the production of guarded actions 
        from the BNF of if commands with the <code>GuardedAction</code> AST class, hence minimising the 
        AST classes. 
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  <xs:element name="VarDeclCommand" type="CIRCUS:VarDeclCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
        Command declaring (possibly multiple) variables local to an action definition.
        The parser is responsible to ensure that no strokes are allowed in the frame variables.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Circus predicates -->
  
  <xs:element name="TransformerPred" type="CIRCUS:TransformerPred" 
    substitutionGroup="Z:Pred" abstract="true">
    <xs:annotation>
      <xs:documentation>
        A quantified refinement predicate, where the quantifier is
        universal on the alphabet of the Circus preocess or action.
        For instance, in A \subseteq B, we have that 
        \forall V @ B \implies A.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- DESIGN DECISION:
     An alternative to adding a new predicate class would be to reuse MemPred
     and have the transformation relations as just relational operators defined
     within circuspatt_toolkit.tex (much like what already happens for ZPattern).
     
     The problem for Circus is that neither Action nor Process are expressions,
     as opposed to schemas in ZPattern, hence the need to include Action/Process
     within the Expr subtree if this path were to be followed in CircusPattern.xsd. 
     
     Although regarding the AST this placement choice is somewhat irrelevant, 
     choosing the option with MemPred might unnecessarily complicate the CircusPttern
     parser. Thus, we decided to have them as separate predicates and do not 
     touch/mofidy/extend the Expr tree.
     
     Another benefitial consequence of this choice is that we now do not need
     varied forms of assertion check paragraphs, but just a transformer paragraph
     for any type of transformer predicate!
  -->
  
  <xs:element name="ActionTransformerPred" type="CIRCUS:ActionTransformerPred"
    substitutionGroup="CIRCUS:TransformerPred">
    <xs:annotation>
      <xs:documentation>
        An action transformer predicate is a predicate that relates two actions
        by one of the available transformation relations in one of the available
        models. 
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ProcessTransformerPred" type="CIRCUS:ProcessTransformerPred"
    substitutionGroup="CIRCUS:TransformerPred">
    <xs:annotation>
      <xs:documentation>
        A process transformer predicate is a predicate that relates two process
        by one of the available transformation relations in one of the available
        models. 
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Special Circus actions used on post-parsing. 
       They are related to scope for mutual recursion and variable declaration.
    -->  
  
  <xs:element name="LetAction" type="CIRCUS:LetAction" substitutionGroup="CIRCUS:Action1" abstract="true">
    <xs:annotation>
        <xs:documentation>
            Abstract local environment.
        </xs:documentation>
    </xs:annotation>     
  </xs:element>      
  <xs:element name="LetMuAction" type="CIRCUS:LetMuAction" substitutionGroup="CIRCUS:LetAction">
    <xs:annotation>
      <xs:documentation>
        Local environment for mu actions. It resolves mutual recursions through a weak fixed point
        equation with an array of recursive variables.
      </xs:documentation>
    </xs:annotation>     
  </xs:element>    
  <xs:element name="LetVarAction" type="CIRCUS:LetVarAction" substitutionGroup="CIRCUS:LetAction">
    <xs:annotation>
      <xs:documentation>
        Local environment for prefixing actions involving input fields, parameterised actions, and variable commands.
        They are important to carry the declared type, and any type restrictions, of these constructs. Note thist 
        is different from the signature the referred variable in the let may occur in, as signatures only contain
        maximal types generated by the type checker.
      </xs:documentation>
    </xs:annotation>     
  </xs:element>    
  
  <!-- Additional top-level types in Circus -->
  
  <!-- DESIGN CLARIFICATION:
  
  In Standard Z, the BNF for the type system includes Type, Type2, and Signature. 
  Type represent generic types, which encompass all constructs that allow the
  declaration of (formal) generic parameters, such as generic axiomatic descriptions
  and generic schemas.
  Type2 represent bare types where (formal) generic parameters have been resolved,
  even if the resolution is to a "GENTYPE". 
  Signature contains a list of name type pairs, where the type associated with each 
  name is Type, hence allowing the opportunity for declarations which have (formal)
  generic parameters, such as channel declarations.
  
  For example:
  
  channel [X, Y] c, d: X x Y; e, f: Y 
  
  ChannelPara has a signature containing a generic type should have Type, where [X, Y] 
  are part of GenericType, and the references to X and Y are GENTYPE X/Y. 
  Thus, ChannelType is a Type2 and contains a Signature of the names and types it represents.
  -->
  <xs:element name="ChannelType" type="CIRCUS:CircusType" substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        A channel type is like a generic type, where the type can be <code>null</code> for synchronisation channels.
        The <code>OptionalType</code> is the resolved type after instantiation via generic actuals or type inference.
      </xs:documentation>
    </xs:annotation>
  </xs:element>      
  
  <xs:element name="ChannelSetType" type="CIRCUS:CircusType" substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        A channel set type contains the signature of the set of names it represents, where synchronisation channels have null type.
        The signature contains the channel name and its corresponding ChannelType. So, synchronisation channels will have 
        in their signature a name with a <code>ChannelType</code> whose <code>getType()==null</code>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="ProcessType" type="CIRCUS:ProcessType" substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        A process type contains its signature.
        Generic process parameters must be resolved.
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  
  <!-- Additional process-level types in Circus -->

  
  <xs:element name="SigmaExpr" type="CIRCUS:SigmaExpr" substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        <p>
        Expression for channel selections, such as c.x or c.true for channel c. 
        It is set of pairs, where the first element is the channel reference and 
        the second element is the expression corresponding to the value to be
        communicaticated. The channel reference is a RefExpr, as channel can 
        contain generic actuals. It denotes set of the all the possible values a 
        channel can communicate.
        </p>
        <p>
        These expressions require special typechecking to ensure that elements are 
        well typed with respect to the (RefExpr X Expr) pair, rather than the structure 
        of the expressions. That is, SigmaExpr unify even when the expression have different
        types, so that we can create the Sigma environment.
        </p>
      </xs:documentation>
    </xs:annotation>     
  </xs:element>
  
  <xs:element name="ActionType" type="CIRCUS:ActionType" substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        An action type contains the action signature.              
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="NameSetType" type="CIRCUS:CircusType" substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        A name set type contains the signature of the set of names it represents.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <!-- Additional top-level signatures in Circus -->
  
   <xs:element name="CircusSignature" type="CIRCUS:CircusSignature" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract Circus signature term.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <xs:element name="ProcessSignature" type="CIRCUS:ProcessSignature" abstract="true" 
    substitutionGroup="CIRCUS:CircusSignature">
    <xs:annotation>
      <xs:documentation>
        <p>
        Abstract process signature class used by both CircusProcessSignature and
        BasicProcessSignature.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="CircusProcessSignature" type="CIRCUS:ProcessSignature" 
    substitutionGroup="CIRCUS:ProcessSignature">
    <xs:annotation>
      <xs:documentation>
        <p>
        A process signature consists of the process name, possibly empty generic formal parameters, 
        possibly empty formal parameters or indexes, and the channels usage.
        Generic actuals must be resolved while type checking similarly to Z and ObjectZ (see ClassSignature and oz.TypeChecker).
        </p>
        <p>
        The channels usage is a function from channel name to a set of usage flags.
        These flags can be either IN, OUT, SYNCH or HIDE.
        In the case of HIDE, all other flags are irrelevant.        
        These usage flags are built up by collecting the channel usage from action signatures.
        </p>
        <p>
        Because BasicProcessSignature uses yet another SignatureList, 
        we need  more than one SignatureList, so we have a list of signature lists!
        So, we add through GnAST the following convenience methods:       
        
        <ul>
          <li>
            ZSignatureList getMainSignatures() = getSignatureList().get(0):
            <ul>
              <li>a) Signature getParamOrIndexes() = getSignatureList().get(0).get(0)</li>
              <li>b) Signature getUsedChannels()   = getSignatureList().get(0).get(1)</li>
              <li>c) Signature getUsedNameSets()   = getSignatureList().get(0).get(2) (for BasicProcessSignature only)</li>
              <li>d) Signature getStateSignature() = getSignatureList().get(0).get(3) (for BasicProcessSignature only)</li>
            </ul>
          </li>
          <li>
            The Signature returned by the above projections correspond to: 
            <ul>
              <li>a) non-null (possibly empty) signature of param or indexes of a process </li>
              <li>b) non-null (possibly empty) signature of process state (empty = default state as [ | true]).</li>
              <li>c) non-null (possibly empty) signature used channels as list of name type pairs within Signature.</li>
              <li>d) non-null (possibly empty) signature used name sets as list of name type pairs within Signature.</li>              
            </ul>
          </li>
          <li>
            ZSignatureList getLocalZSignatures()= getSignatureList().get(1)       (for BasicProcessSignature only).
            This represents the local Z paragraphs within the basic process.
          </li>          
          <li>
            ActionSignatureList getActionSignatures() = getSignatureList().get(2) (for BasicProcessSignature only)
          </li>            
        </ul>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="BasicProcessSignature" type="CIRCUS:BasicProcessSignature" 
    substitutionGroup="CIRCUS:ProcessSignature">
    <xs:annotation>
      <xs:documentation>
        <p>
        Extends process signature to contain information about basic processes.
        Those are declarations of state variables, local variables, actions, and name sets.
        Local variables comes from either <code>VarDeclCommand</code>, or action formal parameters.
        In the case of a stateless process, the state variables signatures is empty (as oposed to null).
        </p>
      </xs:documentation>      
    </xs:annotation>
  </xs:element>     
  
  <!-- Additional process-level signatures in Circus -->
  
  <xs:element name="ActionSignature" type="CIRCUS:ActionSignature"
    substitutionGroup="CIRCUS:CircusSignature">
    <xs:annotation>
      <xs:documentation>
        <p>
        An action signature consists of the action name, formal parameters, and the channels usage.             
        The channels usage is function from channel name to a set of usage flags.
        These flags can be either IN, OUT, SYNCH or HIDE.
        In the case of HIDE, all other flags are irrelevant.                
        </p>
        <p>
        Because ActionProcessSignature requires a list of Z Signatures,        
        So, we add through GnAST the following convenience methods:               
          <ul>
            <li>Signature getFormalParams() = getSignatureList().get(0)</li>
            <li>Signature getLocalVars()    = getSignatureList().get(1)</li>
            <li>Signature getUsedChannels() = getSignatureList().get(2)</li>
          </ul>          
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <!-- Lists used by Circus elements -->
  
  <xs:element name="ActionList" type="CIRCUS:ActionList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract Action list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="CircusActionList" type="CIRCUS:CircusActionList"
    substitutionGroup="CIRCUS:ActionList">
    <xs:annotation>
      <xs:documentation>
        A list with (concrete) Circus actions. An alternative implementation
        would be a list with action jokers.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="CommunicationList" type="CIRCUS:CommunicationList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract communication list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="CircusCommunicationList" type="CIRCUS:CircusCommunicationList"
    substitutionGroup="CIRCUS:CommunicationList">
    <xs:annotation>
      <xs:documentation>
        A list with (concrete) Circus communications. An alternative implementation
        would be a list with communication jokers.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="FieldList" type="CIRCUS:FieldList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract communication fields list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="CircusFieldList" type="CIRCUS:CircusFieldList"
    substitutionGroup="CIRCUS:FieldList">
    <xs:annotation>
      <xs:documentation>
        A communication fields list. An alternative implementation would be a
        list with communication field jokers.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="SignatureList" type="CIRCUS:SignatureList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract signature list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ZSignatureList" type="CIRCUS:ZSignatureList"
    substitutionGroup="CIRCUS:SignatureList">
    <xs:annotation>
      <xs:documentation>
        An signature list with Z signatures.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ActionSignatureList" type="CIRCUS:ActionSignatureList" 
    substitutionGroup="CIRCUS:SignatureList">
    <xs:annotation>
      <xs:documentation>
        An signature list with action signatures.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ProcessSignatureList" type="CIRCUS:ProcessSignatureList" 
    substitutionGroup="CIRCUS:SignatureList">
    <xs:annotation>
      <xs:documentation>
        An signature list with action signatures.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Term Annotations defined by Circus -->
  
  <xs:element name="CircusAnn" type="CIRCUS:CircusAnn" abstract="true" substitutionGroup="Z:Ann">
    <xs:annotation>
        <xs:documentation>
            Abstract annotation type for all term annotations used within Circus.
        </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="CircusStateAnn" type="CIRCUS:CircusAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
        <xs:documentation>
            Defines if a given paragraph is the process state. 
            The parser must enforce such a paragraph is a schema.
        </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="OnTheFlyDefAnn" type="CIRCUS:CircusAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
        <xs:documentation>
            Defines an on-the-fly definition annotation used for both Process and Action terms.            
            It must be included into <code>ParamAction</code> and <code>ParamProcess</code> by 
            the parser whenever an on-the-fly definition occurs. It is also used for on-the-fly
            schema definitions.
        </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ImplicitChannelAnn" type="CIRCUS:CircusAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
        <xs:documentation>
            Annotation used for implicitly declared channnels via indexed processes.
        </xs:documentation>
    </xs:annotation>
  </xs:element>
  
   <xs:element name="ActionSignatureAnn" type="CIRCUS:ActionSignatureAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
        <xs:documentation>
            An action signature wrapped within an annotation, where generic type are resolved.
            This is just like SignatureAnn.
        </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ProcessSignatureAnn" type="CIRCUS:ProcessSignatureAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
        <xs:documentation>
            A process signature wrapped within an annotation, where generic type are resolved.
            This is just like SignatureAnn.
        </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- TODO: CHECK: would channels need something similar, as the have generic types also? -->
  
  <!-- ***************************************************************** -->
  <!-- Definitions of complexTypes in the order of usage by the elements -->
  <!-- ***************************************************************** -->

  <!-- Outermost Paragraph Types -->
  <xs:complexType name="ChannelPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>          
          <!--<xs:element ref="CIRCUS:ChannelDecl" minOccurs="0" maxOccurs="unbounded"/>-->
          <xs:element ref="Z:DeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ChannelDecl">
    <xs:complexContent>
      <xs:extension base="Z:Decl">
        <xs:sequence>
          <!-- Because the new JAXB feature for XML read/writing does not allow
               multiple ref elements with the same type, we are forced to use lists.
               Nevertheless, we add via GnAST the necessary convenience methods. 
               
               All productions affected and modified were: 
               
               ChannelDecl, Process2, BasicProcess, AlphabetisedParallelProcess,
               Action2, ParAction, AlphabetisedParallelAction, SpecStmtCommand,
               ActionTransformerPred, ProcessTransformerPred, and ActionSignature.
               
               All new productions must bare this in mind from now on (revision 5826). 
               Convenience setXXX methods follow the same implementation as Z:Expr2.
            -->
           
          <!-- This returns a list of NameList containing exactly two elements.
               The first is the non-null (possibly emptty) generic formals, 
               whereas the second is the list of channel names for the "channel" 
               keyword, or non-null empty list for the "channelFrom" keyword. -->                    
          <xs:element ref="Z:NameList" minOccurs="2" maxOccurs="2"/>
          
          <!-- Channel type for typed channels, null for synchronisation channels, or RefExpr for ChannelFrom -->
          <xs:element ref="Z:Expr" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>           
      
  <xs:complexType name="ChannelSetPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:NameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenFormals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Name"/>            
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ProcessPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <!-- Although the syntax is \circprocess [X, Y] N \defs ...,
               I couldn't figure out how to put the generics before the
               name without causing an ambiguity complaint by the XML
               validator :( -->
          <xs:element ref="Z:Name"/>            
          <xs:element ref="Z:NameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenFormals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusProcess"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusConjPara">
    <xs:complexContent>
      <xs:extension base="Z:Para"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="TransformerPara">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusConjPara">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="CIRCUS:TransformerPred"/>                      
        </xs:sequence>                  
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  

  <!-- Channel Set Expression complexTypes -->
  <xs:complexType name="ChannelSet">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="CircusChannelSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSet">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  
  <xs:complexType name="BasicChannelSetExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <!--
          <xs:element ref="CIRCUS:Communication" minOccurs="0" maxOccurs="unbounded"/>
          -->
          <xs:element ref="CIRCUS:CommunicationList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <!-- Process Definition complexType -->
  <xs:complexType name="CircusProcess">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="Process1">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusProcess"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessD">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>        
          <!-- Accommodate Z.xsd changes: using Z Standard DeclPart from (12.7.2)
          <xs:element ref="Z:Decl" minOccurs="1" maxOccurs="unbounded"/> 
          -->
          <!-- 
          In Circus, the only possibility is QualifiedDecl and the parser must rule others out.
          ConstDecl and InclDecl are to be avoided, as parameters in CSP do not come from schemas.
          -->
          <xs:element ref="Z:DeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessD"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ProcessIdx">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessIte"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Process2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>
          <!-- Because the new JAXB feature for XML read/writing does not allow
               multiple ref elements with the same type, we are forced to use lists.
               Nevertheless, we add via GnAST the necessary convenience methods.
               getCircusProcess().get(0) = getLeftProc
               getCircusProcess().get(1) = getRightProc          
               
              <xs:element ref="CIRCUS:CircusProcess">
                <xs:annotation>
                  <xs:appinfo>
                    <jaxb:property name="LeftProc"/>
                  </xs:appinfo>
                </xs:annotation>
              </xs:element>
              <xs:element ref="CIRCUS:CircusProcess">
                <xs:annotation>
                  <xs:appinfo>
                    <jaxb:property name="RightProc"/>
                  </xs:appinfo>
                </xs:annotation>
              </xs:element>            
          -->      
          <xs:element ref="CIRCUS:CircusProcess" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>     

  <!-- Bssic Process -->
  <xs:complexType name="BasicProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>          
          <!--
          REFACTORING: Collapsed all BasicProcess elements into a single ParaList
                       in order to properly implement new JAXB features. See 
                       details below.
          -->
          
          <!--
          This will create a get/setParaList method accessing all paragraphs.
          We will also add the following convenience methods:
          
          Para getStatePara() 
          -> returns the paragraph within ParaList with a CircusStateAnn 
             annotation or throw a UnsupportedASTException otherwise. 
             That is because, by default, the  parser always create a state.
                            
             The parser allows schema boxes, horizontal schemas, and schema actions.
             That rules out generic schemas (or generic abbreviations), as the 
             geneirc types on schemas must come from the process generic formals.
                            
              Also, we allow implicit circus state to be declared on the fly,
              where the default name is "$$defaultSt". That is, we allow
              Expr production after \circstate\ as well. For example,
              "\circstate\ S \land T", we translate the on-the-fly description 
              to the following convention: "\circstate\ $$defaultState == S \land T".

              In the case of a BasicProcess without state, the parser MUST  
              include an empty schema for it as if it had been declared as 
              "\circstate $$defaultSt == [~ | true ~]". 
              
          CircusAction getMainAction()
          -> The main action is the action within the ActionPara inside
             OnTheFlyPara. It is annotated with an OnTheFlyDefAnn.          
          
          ZParaList getLocalPara()
          -> Contains both Z and Circus paragraphs. 
             It does not contain any OnTheFlyPara.             
             It may contain the state para, if it was declared 
             using a ConstDecl (i.e. \circstate\ S == expr).
          
          ZParaList getOnTheFlyPara(),
          -> Contains implicitly declared ActionPara. 
             This includes the main action, which is always implicitly declared.
             Elements are annotated with an OnTheFlyDefAnn to be used by
             the typechecker. If it is a state, a CircusStateAnn is also
             included, which can only happens in the case where an expression
             is used (i.e. \circstate S; \circstate (S \land T); etc). 
             
             ActionPara are named as $$implicitActN, whereas 
             the state is named "$$defaultSt" and the main 
             action "$$mainAction".
             
          INVARIANTS: 
          
          1) Main action is never null and always within on-the-fly paragraphs            
          
          * Logic: 
          mainAct \in ohTheFlyPara
          
          * Java:
          assert getZOhTheFlyPara().contains(createActionPara("$$mainAction", getMainAction());
          
          2) State para is never null and always within either local or on-the-fly
            paragraphs, where the default state is just "$$defaultSt -> [|true]".
          
          * Logic:
          CircStateAnn \in state.getAnns()          
          OnTheFlyDefAnn \in state.getAnns()    \implies state \in ohTheFlyPara
          OnTheFlyDefAnn \notin state.getAnns() \implies state \in localPara
          
          * Java:
          assert ....
          
          3) Size is always at least two (i.e. state + main action) 
             TODO: Think about perhaps not in case of joker(?)
          
          4) Local and on-the-fly para form a partition of ParaList            
          
          PS: Add those and other Circus.xsd invariants as unit tests for the parser.
          -->
          <xs:element ref="Z:ParaList"/>            
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:element name="StateUpdate" type="CIRCUS:StateUpdate" substitutionGroup="Z:QntPred">
    <xs:annotation>
      <xs:documentation>
        <p>
          Process state update is a list of assignment pairs representing
          how state updates took place sequentially. For complex compositional 
          operators, such as external choice and parallel composition, there are
          semantic functions that define how the state merge occurs, which
          is much like what happens in the UTP.
        </p>
        <p>
          These classes shall never be instantiated by the user manually.
          They are produced by Circus tools as they go along performing the
          varied state update forms the language allows.
        </p>
        <p>
          It is a Z quantified predicate extended to contain a list of
          assignment pairs. Essentially, a tool, say a typechecker, collects 
          the assignment pairs representing a particular branch of the AST.
          This can be built backwards as it traverses the AST during typechecking.
          After that, another tool, say an animator or model checker, can 
          apply necessary transformations needed to the assignment
          pairs list so that the merge of information reflect the denotational
          semantics of a particular construct. The resulting predicate representing
          the whole state update is then feed into the actual structure of a QntPred,
          where the SchText is the state components (and invariant), and the predicate
          is the calculated state merge. (!) 
        </p>
        <p>
          It is part of a BasicProcessSignature.
          It may also be part of a StateUpdateAnn.
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
   
  
  <xs:element name="StateUpdateAnn" type="CIRCUS:StateUpdateAnn" substitutionGroup="CIRCUS:CircusAnn">
    <xs:annotation>
      <xs:documentation>
        <p>Annotation for StateUpdate instances outside BasicProcessSignature 
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process Definition :: Calls --> 
  
  <xs:complexType name="CallProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>          
          <!-- CallExpr because it can contain generic actuals -->
          <xs:element ref="Z:RefExpr">                    
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="CallExpr"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element ref="Z:ExprList">          
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Actuals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>       
        </xs:sequence>
        <xs:attribute name="CallKind" type="CIRCUS:CallKind" use="optional" default="Param"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:simpleType name="CallKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Param"/>
      <xs:enumeration value="Index"/>
      <!-- 
      <xs:enumeration value="Normal"/>      
      <xs:enumeration value="Gen"/>
      <xs:enumeration value="GenParam"/>
      <xs:enumeration value="GenIndex"/>
      -->
    </xs:restriction>
  </xs:simpleType> 
  

  <!-- Process Definition :: Unary -->
  <xs:complexType name="HideProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RenameProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>                   
          <!-- Accommodate Z.xsd changes: RenameList 
          <xs:element name="OldNames" type="Z:Name" minOccurs="1" maxOccurs="unbounded"/>                      
          <xs:element name="NewNames" type="Z:Name" minOccurs="1" maxOccurs="unbounded"/>
          -->
          <xs:element ref="CIRCUS:AssignmentPairs">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="AssignmentPairs">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
            <!-- <xs:element ref="Z:Name" minOccurs="1" maxOccurs="unbounded"> -->
            <xs:element ref="Z:NameList">
              <xs:annotation>
                <xs:appinfo>
                  <jaxb:property name="LHS"/>
                </xs:appinfo>
              </xs:annotation>
            </xs:element>      
            <!-- <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"> -->
            <xs:element ref="Z:ExprList">
              <xs:annotation>
                <xs:appinfo>
                  <jaxb:property name="RHS"/>
                </xs:appinfo>
              </xs:annotation>
            </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  
          
  <!-- Process Definition :: Binary -->
  
  <xs:complexType name="ParProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process2"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ParallelProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcess">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="AlphabetisedParallelProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcess">
        <xs:sequence>
          <!--
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAlpha"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAlpha"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          -->
          <xs:element ref="CIRCUS:ChannelSet" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <!-- Process Definition :: Expressions -->  
  
  <!--
  <xs:complexType name="ProcessE">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>          
          <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>          
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  <xs:complexType name="ActualParamProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessE">
        <xs:sequence>
          <xs:element ref="CIRCUS:ParamProcessDesc"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="InstantiationProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessE">
        <xs:sequence>
          <xs:element ref="CIRCUS:IndexedProcessDesc"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  -->
  
  <!-- Process Definition :: Unary :: Declaration :: Iterated -->
  <xs:complexType name="ParProcessIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessIte"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ParallelProcessIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcessIte">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Definition :: Unary :: Declaration :: Iterated :: Indexed -->
  <xs:complexType name="ParProcessIdx">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessIdx"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ParallelProcessIdx">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcessIdx">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Process Paragraphs complexTypes -->
  <xs:complexType name="NameSetPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ActionPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="CIRCUS:CircusAction"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Name Set Expression complexTypes -->
  <xs:complexType name="NameSet">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="CircusNameSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:NameSet">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <!-- Action complexType -->    
  <xs:complexType name="CircusAction">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Action1">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusAction"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Action2">    
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <!-- Because the new JAXB feature for XML read/writing does not allow
           multiple ref elements with the same type, we are forced to use lists.
           Nevertheless, we add via GnAST the necessary convenience methods.
           getCircusProcess().get(0) = getLeftProc
           getCircusProcess().get(1) = getRightProc                

           <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          --> 
          <xs:element ref="CIRCUS:CircusAction" minOccurs="2" maxOccurs="2"/>    
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionD">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>        
          <!-- Accommodate Z.xsd changes: using Z Standard DeclPart from (12.7.2)
          <xs:element ref="Z:Decl" minOccurs="1" maxOccurs="unbounded"/> 
          -->
          <!-- 
          In Circus, the only possibility is QualifiedDecl and the parser must rule others out.
          ConstDecl and InclDecl are to be avoided, as parameters in CSP do not come from schemas.
          -->
          <xs:element ref="Z:DeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionD"/>
    </xs:complexContent>
  </xs:complexType> 
  
  <xs:complexType name="CircusCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="SchExprAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <!-- 
          Z:Expr instead of Z:SchExpr or SchText because we want a schema action to be an expression. 
          That means, we can have a schema definition as well as an expression using schemas (as in 
          Spivey's SchExpr tree - that is not in the Z-Standard. From the CZT, these are reflected as 
          Z:SchExpr, Z:SchExpr2, and Z:HideExpr.
          -->          
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CallAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <!-- Accommodate Z.xsd changes to use ExprList (Z Standard 12.2.12) 
          <xs:element ref="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>                  
          -->
          <xs:element ref="Z:ExprList"/>
        </xs:sequence>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  
  <!-- CSP Action complexType -->
  <xs:complexType name="BasicAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction"/>
    </xs:complexContent>
  </xs:complexType>

  <!--
  <xs:complexType name="ActualParamAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:ParamActionDesc"/>          
          <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  -->

  <!-- CSP Action complexType :: Unary -->
  <xs:complexType name="MuAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GuardedAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="HideAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PrefixingAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="CIRCUS:Communication">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SubstitutionAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>                   
          <!-- Accommodate Z.xsd changes:
          <xs:element name="OldNames" type="Z:Name" minOccurs="1" maxOccurs="unbounded"/>
          <xs:element name="NewNames" type="Z:Name" minOccurs="1" maxOccurs="unbounded"/>
          -->
          <xs:element ref="Z:RenameList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- CSP Action complexType :: Unary :: Declaration :: Iterated -->
  <xs:complexType name="ParActionIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionIte">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ParallelActionIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParActionIte">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- CSP Action complexType :: Binary -->
  <xs:complexType name="ParAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action2">
        <xs:sequence>
          <!--
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftNameSet"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightNameSet"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          -->
          <xs:element ref="CIRCUS:NameSet" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ParallelAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AlphabetisedParallelAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParAction">
        <xs:sequence>
          <!--
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAlpha"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAlpha"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>            
          </xs:element>
          -->
          <xs:element ref="CIRCUS:ChannelSet" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Lists used by Circus terms --> 
  
  <xs:complexType name="ActionList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusActionList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionList">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusAction" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CommunicationList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusCommunicationList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CommunicationList">
        <xs:sequence>
          <xs:element ref="CIRCUS:Communication" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="FieldList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusFieldList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:FieldList">
        <xs:sequence>
          <xs:element ref="CIRCUS:Field" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="SignatureList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ZSignatureList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:SignatureList">
        <xs:sequence>
          <xs:element ref="Z:Signature" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ProcessSignatureList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:SignatureList">
        <xs:sequence>
          <xs:element ref="CIRCUS:ProcessSignature" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ActionSignatureList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:SignatureList">
        <xs:sequence>
          <xs:element ref="CIRCUS:ActionSignature" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  
  <xs:complexType name="StateUpdate">
    <xs:complexContent>
      <xs:extension base="Z:QntPred">
        <xs:sequence>
          <!-- At least you must have the types correct, even if absolutely nondeterministically
              e.g., St == [ x: \nat ].... Op == [ \Delta S ], here x' \in \nat, and that is it.
            -->
          <xs:element ref="CIRCUS:AssignmentPairs" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- CSP Communication complexType -->
  <xs:complexType name="Communication">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <!-- RefExpr because it can contain generic actuals -->
          <xs:element ref="Z:RefExpr">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ChannelExpr"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:FieldList"/>
        </xs:sequence>
        <xs:attribute name="CommKind" type="CIRCUS:CommKind" use="optional" default="Synch"/>
        <xs:attribute name="MultiSych" type="xs:nonNegativeInteger" use="optional" default="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <!-- 
    Invariant: 
      Synch = getFields().isEmpty() 
      Input = !getFields().isEmpty() && forall getField().get(i) instanceof InputField            
      Output= !getFields().isEmpty() && forall getField().get(i) instanceof OutputField || getField().get(i) instanceof DotField
      Mixed = !getFields().isEmpty() && there are more than one class: InputField, (OutputField/DotField).
  -->
  <xs:simpleType name="CommKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Synch"/>
      <xs:enumeration value="Input"/>
      <xs:enumeration value="Output"/>
      <xs:enumeration value="Mixed"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- CSP Communication parameters complexType -->
  
  <xs:complexType name="Field">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="InputField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <xs:element ref="Z:Name">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="VariableName"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Restriction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="DotField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Parameterised Commands complextype -->  
  <xs:complexType name="QualifiedDecl">
    <xs:complexContent>
      <xs:extension base="Z:Decl">
        <xs:sequence>
          <!-- Parser must inforce that minOccurs="1"! -->
          <xs:element ref="Z:NameList"/>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
        <xs:attribute name="ParamQualifier" type="CIRCUS:ParamQualifier" use="optional" default="Value"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="ParamQualifier">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Value"/>
      <xs:enumeration value="Result"/>
      <xs:enumeration value="ValueResult"/>
    </xs:restriction>
  </xs:simpleType>  

  <!-- Circus Commands complextype -->
  <xs:complexType name="SpecStmtCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>
          <!-- <xs:element name="Frame" type="Z:Name" minOccurs="1" maxOccurs="unbounded"/> -->
          <xs:element ref="Z:NameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Frame"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <!--
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Pre"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Post"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          -->
          <xs:element ref="Z:Pred" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AssignmentCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>                  
          <xs:element ref="CIRCUS:AssignmentPairs">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="IfGuardedCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>
          <!--
          <xs:element ref="CIRCUS:GuardedAction" minOccurs="1" maxOccurs="unbounded"/>
          -->
          <xs:element ref="CIRCUS:ActionList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="VarDeclCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>          
          <!-- Modified for consistency with other DeclList places.
               Accommodate Z.xsd changes: using Z Standard DeclPart from (12.7.2)                
          <xs:element ref="Z:VarDecl" minOccurs="1" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Declarations"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          !-->
          <!-- 
          In Circus, the possibilites are VarDecl and InclDecl only and the parser must rule out ConstDecl.
          Implementations should consider at least VarDecl, and InclDecl could be avoid for simplicity.
          -->
          <xs:element ref="Z:DeclList"/>
          <xs:element ref="CIRCUS:CircusAction"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Circus predicates -->
  
  <xs:complexType name="TransformerPred">
    <xs:complexContent>
      <xs:extension base="Z:Pred">
        <xs:sequence>
          <!-- Quantified alphabets -->
          <xs:element ref="Z:SchText"/>          
        </xs:sequence>
        <xs:attribute name="Transformation" type="CIRCUS:Transformation" use="optional" default="Refinement"/>        
        <xs:attribute name="Model" type="CIRCUS:Model" use="optional" default="FlDv"/>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
    
  <xs:simpleType name="Transformation">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Refinement"/>
      <xs:enumeration value="Equivalence"/>
      <xs:enumeration value="Simulation"/>
    </xs:restriction>
  </xs:simpleType>
  
  <xs:simpleType name="Model">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Tr"/>
      <xs:enumeration value="SFl"/>
      <xs:enumeration value="FlDv"/>
    </xs:restriction>
  </xs:simpleType>  
  
  <xs:complexType name="ActionTransformerPred">
    <xs:complexContent>
      <xs:extension base="CIRCUS:TransformerPred">
        <xs:sequence>
          <!--
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Spec"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Impl"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          -->
          <xs:element ref="CIRCUS:CircusAction" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ProcessTransformerPred">
    <xs:complexContent>
      <xs:extension base="CIRCUS:TransformerPred">
        <xs:sequence>          
          <!--
          <xs:element ref="CIRCUS:CircusProcess">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Spec"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusProcess">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Impl"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          -->
          <xs:element ref="CIRCUS:CircusProcess" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Additional Circus actions for Local Environments of the operational semantics -->
  <xs:complexType name="LetAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="LetMuAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:LetAction">
        <xs:sequence>
          <!-- List of ActionPara to handle mutual recursion -->
          <xs:element ref="Z:ParaList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="LetVarAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:LetAction">
        <xs:sequence>                             
          <!-- 
          In Circus, the possibilites are VarDecl, ConstDecl, and InclDecl.
          TODO:DESIGN: Maybe remove InclDecl, as ConstDecl is just syntactic sugar.          
          -->
          <xs:element ref="Z:DeclList"/>
          <!-- Invariant: getDeclarations().size()==getValues.size() -->          
          <xs:element ref="Z:ExprList"/>            
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="SigmaExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <xs:element ref="Z:RefExpr">          
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Channel"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element ref="Z:Expr">            
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Value"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Circus Types and Signatures -->  
  
  <xs:complexType name="CircusType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>          
          <xs:element ref="Z:Signature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <!--
  <xs:complexType name="ChannelSetType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>          
          <xs:element ref="Z:Signature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="NameSetType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>          
          <xs:element ref="Z:Signature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  -->
  <xs:complexType name="ProcessType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>
          <xs:element ref="CIRCUS:ProcessSignature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ActionType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>
          <xs:element ref="CIRCUS:ActionSignature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
      
  <xs:complexType name="CircusSignature">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <!-- maybe this is useless here: ActionSignature within actions do not have names -->
          <xs:element ref="Z:Name"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ProcessSignature">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusSignature">
        <xs:sequence>              
          <!-- Use concrete (rather than allowing Joker) names here -->
          <xs:element ref="Z:ZNameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenFormals"
                 generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <!--     
          <xs:element ref="Z:Signature" minOccurs="0">          
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ParamOrIndexes"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          getParamOrIndexes() = getSignature(0)          
          getUsedChannels()   = getSignature(1)
          --> 
          <!--
          Because BasicProcessSignature needs yet another Signature,
          we added a SignatureList to the main complex types :(
          Maybe this should be 
          
          getZSignature() = getSignature(2) for BasicProcessSignature!
          
          <xs:element ref="Z:Signature" minOccurs="2" maxOccurs="2"/>                              
          
          <xs:element ref="CIRCUS:SignatureList"/>
          -->          
          <!--
          Wow! Because BasicProcessSignature uses yet another SignatureList, 
          we need  more than one SignatureList, so we have a list of signature lists!
          So, we add through GnAST the following convenience methods:
          
          ZSignatureList getMainSignatures() = getSignatureList().get(0)
            a) Signature getParamOrIndexes() = getSignatureList().get(0).get(0)
            b) Signature getUsedChannels()   = getSignatureList().get(0).get(1)
            c) Signature getUsedNameSets()   = getSignatureList().get(0).get(2) (for BasicProcessSignature only)
            d) Signature getStateSignature() = getSignatureList().get(0).get(3) (for BasicProcessSignature only)
            
          
          The Signature returned by the above projections correspond to: 
            a) non-null (possibly empty) signature of param or indexes of a process 
            b) non-null (possibly empty) signature used channels as list of name type pairs within Signature
            c) non-null (possibly empty) signature used name sets as list of name type pairs within Signature
            d) non-null (possibly empty) signature of process state (empty = default state as [ | true]).
            
          ZSignatureList getLocalZSignatures()= getSignatureList().get(1)       (for BasicProcessSignature only)   
            This represents the local Z paragraphs within the basic process.
            
          ActionSignatureList getActionSignatures() = getSignatureList().get(2) (for BasicProcessSignature only)
            
          We leave it unbounded to allow further extension with new lists within the 
          list of SignatureLists!
          -->
          <xs:element ref="CIRCUS:SignatureList" minOccurs="2" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="Kind" type="CIRCUS:ProcessKind" use="optional" default="Parameterised"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <!-- A process might have neither formal parameters nor indexes, hence minOccurs="0" for Signature below. 
        Or it might have either of them (i.e. formal parameters or indexes) but never both. -->
  <xs:simpleType name="ProcessKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Parameterised"/>
      <xs:enumeration value="Indexed"/>
    </xs:restriction>
  </xs:simpleType>  

  <!-- 
  We need the "empty" complex type here just because we add via GnAST the
  necessary convinience methods to access the right signature lists mentioned above.
  --> 
  <xs:complexType name="BasicProcessSignature">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessSignature">
          <xs:sequence>   
              <!-- 
              For stateless processes, the typechecker must create an empty signature for the SchemaType.
              Moreover, it must also resolve any pending generic actual from either the schema or the process.              
              <xs:element ref="Z:SchemaType">
                <xs:annotation>
                  <xs:appinfo>
                    <jaxb:property name="StateType"
                      generateElementProperty="true"/>
                  </xs:appinfo>
                </xs:annotation>
              </xs:element>
              
              Refactored into SignatureList in ProcessSignature.
              -->               
              <!-- 
              Contains a list of all local paragraphs that are Z paragraphs.
              This includes the implicitly declared state.              
              <xs:element ref="Z:Signature" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                  <xs:appinfo>
                    <jaxb:property name="ZSignature"/>
                  </xs:appinfo>
                </xs:annotation>
              </xs:element> 
              
              Superseeded by SignatureList above in ProcessSignature
              -->
              
              <!--
              Contains a list of all actions pragraphs of the process.
              This includes the implicitly declared actions.
              <xs:element ref="CIRCUS:ActionSignature" minOccurs="0" maxOccurs="unbounded"/>                
              Superseeded by SignatureList above in ProcessSignature
              -->
              
              <!--
              Contains a list of all name set paragraphs of the process.
              Use concrete (rather than allowing Joker) names here 
              
              <xs:element ref="Z:NameList">                
                <xs:annotation>
                  <xs:appinfo>
                    <jaxb:property name="NameSet"
                      generateElementProperty="true"/>
                  </xs:appinfo>
                </xs:annotation>
              </xs:element>
              
              Superseeded by SignatureList above in ProcessSignature
              -->
              
          <!-- Added StateUpdate to BasicProcess: it must always have at most one -->
            <xs:element ref="CIRCUS:StateUpdate">
              <xs:annotation>
                <xs:appinfo>
                  <jaxb:property generateElementProperty="true"/>
                </xs:appinfo>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
      </xs:extension>
    </xs:complexContent>    
  </xs:complexType>
  
  <!-- TODO: flattening signature elements to a list for updated JAXB -->
  <xs:complexType name="ActionSignature">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusSignature">
        <xs:sequence>
          <!-- 
          <xs:element ref="Z:Signature">            
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="FormalParams"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Signature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LocalVars"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Signature" minOccurs="0">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="UsedChannels"
                  generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          
          Signature getFormalParams() = getSignatureList().get(0)
          Signature getLocalVars()    = getSignatureList().get(1)
          Signature getUsedChannels() = getSignatureList().get(2)          
          
          We leave it unbounded to allow further extension with new lists within the 
          list of SignatureLists!
          -->          
          <xs:element ref="CIRCUS:SignatureList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Term annotation complex types -->
  
  <xs:complexType name="CircusAnn">
    <xs:complexContent>
      <xs:extension base="Z:Ann"/>            
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ActionSignatureAnn">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAnn">            
        <xs:sequence>
           <xs:element ref="CIRCUS:ActionSignature">
              <xs:annotation>
                <xs:appinfo>
                  <jaxb:property generateElementProperty="true"/>
                </xs:appinfo>
              </xs:annotation>
            </xs:element>
        </xs:sequence>
      </xs:extension>        
    </xs:complexContent>
  </xs:complexType>    
  
  <xs:complexType name="ProcessSignatureAnn">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAnn">            
        <xs:sequence>
           <xs:element ref="CIRCUS:ProcessSignature">
              <xs:annotation>
                <xs:appinfo>
                  <jaxb:property generateElementProperty="true"/>
                </xs:appinfo>
              </xs:annotation>
            </xs:element>
        </xs:sequence>
      </xs:extension>        
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="StateUpdateAnn">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAnn">
        <xs:sequence>
           <xs:element ref="CIRCUS:StateUpdate">
              <xs:annotation>
                <xs:appinfo>
                  <jaxb:property generateElementProperty="true"/>
                </xs:appinfo>
              </xs:annotation>
            </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
</xs:schema>
