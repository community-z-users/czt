<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  targetNamespace="http://czt.sourceforge.net/zml"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="1.0">
  <xs:annotation>
    <xs:documentation>
      This XML schema defines XML markup for formal
      specifications written in the ISO Standard Z notation.
      $Id$

      Copyright (C) 2003, 2004, 2005, 2006, 2007 Mark Utting
      This file is part of the Community Z Tools (CZT) project.

      The CZT project contains free software; you can
      redistribute it and/or modify it under the terms
      of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of
      the License, or (at your option) any later version.

      The CZT project is distributed in the hope that it
      will be useful, but WITHOUT ANY WARRANTY; without
      even the implied warranty of MERCHANTABILITY or
      FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.

      You should have received a copy of the GNU General
      Public License along with CZT; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place,
      Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
      <jaxb:schemaBindings>
        <jaxb:package name="net.sourceforge.czt.z.jaxb.gen">
          <jaxb:javadoc>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
          </jaxb:javadoc>
        </jaxb:package>
      </jaxb:schemaBindings>
      <gnast:schemaBindings name="Standard Z">
        <gnast:package name="net.sourceforge.czt.z">
          <gnast:package id="ast" name="ast">
            <gnast:generate id="factory" class="ZFactory"
              template="CoreFactory.vm"/>
            <gnast:javadoc>
&lt;p&gt;
These interfaces represent the AST for Standard Z proposed in [&lt;a
href="#ZML"&gt;ZML&lt;/a&gt;].  The letters and numbers in brackets given
within the interface description refer to the corresponding chapters in
[&lt;a href="#ZST"&gt;ZST&lt;/a&gt;] where those Z constructs are discussed in
more detail.
&lt;/p&gt;

&lt;h3&gt;References&lt;/h3&gt;
 
&lt;p&gt;
  &lt;a name="ZML"&gt;&lt;b&gt;[ZML]&lt;/b&gt;&lt;/a&gt;
  Mark Utting, Ian Toyn, Jing Sun, Andrew Martin,
  Jin Song Dong, Nicholas Daley, and David Currie.
  &lt;i&gt;&lt;a href="http://www.cs.waikato.ac.nz/~marku/zml/master.ps.gz"&gt;
  ZML: XML Support for Standard Z.&lt;/a&gt;&lt;/i&gt; In:
  The 3rd International Conference of B and Z Users
  (&lt;a href="http://www.tucs.fi/zb2003/"&gt;ZB 2003&lt;/a&gt;),
  4-6 June 2003, Turku, Finland.
&lt;/p&gt;
&lt;p&gt;
  &lt;a name="ZST"&gt;&lt;b&gt;[ZST]&lt;/b&gt;&lt;/a&gt;
  ISO/IEC 13568:2002. Information Technology---Z Formal Specification
  Notation---Syntax, Type System and Semantics
&lt;/p&gt;
            </gnast:javadoc>
          </gnast:package>
          <gnast:package id="impl" name="impl">
            <gnast:generate
              id="factoryImpl"
              class="ZFactoryImpl"
              template="CoreFactoryImpl.vm"/>
          </gnast:package>
          <gnast:package id="visitor" name="visitor">
            <gnast:generate
              id="AstVisitor"
              class="ZVisitor"
              template="AstVisitor.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="convFactory" class="Factory"
              template="Factory.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="flyFactory" class="FlyweightFactory"
              template="FlyweightFactory.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="createVisitor" class="CreateVisitor"
              template="CreateVisitor.vm"/>
          </gnast:package>
          <gnast:package id="jaxb" name="jaxb">
            <gnast:generate
              id="AstToJaxb"
              class="AstToJaxb"
              template="AstToJaxb.vm"/>
            <gnast:generate
              id="JaxbToAst"
              class="JaxbToAst"
              template="JaxbToAst.vm"/>
          </gnast:package>
        </gnast:package>
      </gnast:schemaBindings>
    </xs:appinfo>
  </xs:annotation>

  <!-- A specification -->
  <xs:element name="Spec" type="Z:Spec">
    <xs:annotation>
      <xs:documentation>
        A specification (C.2).
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the Section hierarchy -->
  <xs:element name="Sect" type="Z:Sect" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract section.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ZSect" type="Z:ZSect" substitutionGroup="Z:Sect">
    <xs:annotation>
      <xs:documentation>
        A concrete section (C.3).
        Note that it may contain unparsed paragraphs.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="UnparsedZSect"
    type="Z:UnparsedZSect" substitutionGroup="Z:Sect">
    <xs:annotation>
      <xs:documentation>
        A completely unparsed section.
        It is used for representing possibly erroneous specifications.
        It may become one or more sections if it can be parsed.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="NarrSect" type="Z:NarrSect" substitutionGroup="Z:Sect">
    <xs:annotation>
      <xs:documentation>
        Narrative before or after sections.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the Paragraph hierarchy -->
  <xs:element name="Para" type="Z:Para" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract paragraph (C.4).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AxPara" type="Z:AxPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A (generic) axiomatic paragraph, (generic) schema definition,
        or (generic) horizontal definition
        <ul>
        <li>C.4.3 (Axiomatic description) and C.4.5 (Generic description).
          In this case, Box=AxBox.  NameList contains the generic parameters,
          so is empty for an axiomatic description.  For example,
          <code>\begin{axdef}     x,y: \nat \where x \neq y \end{axdef}</code>
          <code>\begin{gendef}[T] x,y: T \where x \neq y \end{gendef}</code>
          both translate into an AxPara with Box=AxBox and SchText containing
          the declaration of x and y, and the predicate x \neq y.  For the axdef
          example, NameList is empty, whereas for the gendef example it
          contains T.
        </li>        
        <li>C.4.4 (Schema definition) and C.4.6 (Generic schema definition).
          In this case, Box=SchBox.  For example,
          <code>\begin{schema}{S} x,y: \nat \where x \neq y \end{schema}</code>
          is translated into a nongeneric AxPara (see 12.2.3.1 or C.4.4.2)
          whose SchText contains a single ConstDecl, S == [x,y:\nat | x \neq y].
          A generic schema definition is similar but has a non empty NameList
          (see 12.2.3.2 or C.4.6.2).
        </li>                
        <li>C.4.7 (Horizontal definition) and
            C.4.8 (Generic horizontal definition).
          In this case, Box=OmitBox.  For example,
          <code>\begin{zed}S == [x,y: \nat | x \neq y]\end{zed}</code>
          is translated into a nongeneric AxPara (see 12.2.3.3 or C.4.7.2)
          whose SchText contains a single ConstDecl, S == [x,y:\nat | x \neq y].
          A generic horizontal definition is similar but has a non empty
          NameList (see 12.2.3.4 or C.4.8.2).
        </li>        
        </ul>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ConjPara" type="Z:ConjPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A (generic) conjecture paragraph (C.4.11, C.4.12).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="FreePara" type="Z:FreePara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A free types paragraph (C.4.10).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="GivenPara" type="Z:GivenPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A given types paragraph (C.4.2).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="NarrPara" type="Z:NarrPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A narrative paragraph.  It contains arbitrary unicode and markup.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OptempPara" type="Z:OptempPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        An operator template paragraph (C.4.13). This contains a list 
        of at least two Oper elements.  In fact, Oper has two subtypes
        (Operand and Operator) and the list must alternate between these.
        In other words, every Operand must be followed by an Operator
        (unless it is the last element in the list) and every Operator
        must be followed by an Operand (unless it is the last in the list).
        For example, an infix operator like '+' would be defined by
        Operand, Operator with Word="+", Operand.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="LatexMarkupPara" type="Z:LatexMarkupPara"
    substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A latex markup paragraph. This paragraph contains a list
        of latex mark-up directives (A.2.3).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="UnparsedPara" type="Z:UnparsedPara"
    substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A completely unparsed paragraph.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the Declaration hierarchy -->
  <xs:element name="Decl" type="Z:Decl" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract declaration.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ConstDecl" type="Z:ConstDecl" substitutionGroup="Z:Decl">
    <xs:annotation>
      <xs:documentation>
        A constant declaration (C.7).  Example: x==3.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InclDecl" type="Z:InclDecl" substitutionGroup="Z:Decl">
    <xs:annotation>
      <xs:documentation>
        An include declaration (C.7).  Example: \Delta S
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="VarDecl" type="Z:VarDecl" substitutionGroup="Z:Decl">
    <xs:annotation>
      <xs:documentation>
        A variable declaration (C.7).  Example: a,b:T
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the decoratable-names hierarchy -->
  <xs:element name="Name" type="Z:Name" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract name.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ZName" type="Z:ZName"
    substitutionGroup="Z:Name">
    <xs:annotation>
      <xs:documentation>
        A Z name.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the numerals hierarchy -->
  <xs:element name="Numeral" type="Z:Numeral" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract numeral.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ZNumeral" type="Z:ZNumeral" substitutionGroup="Z:Numeral">
    <xs:annotation>
      <xs:documentation>
        A Z numeral.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the Stroke (Decoration) hierarchy -->
  <xs:element name="Stroke" type="Z:Stroke" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract stroke.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InStroke" type="Z:Stroke" substitutionGroup="Z:Stroke">
    <xs:annotation>
      <xs:documentation>
        The stroke "?".
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OutStroke" type="Z:Stroke" substitutionGroup="Z:Stroke">
    <xs:annotation>
      <xs:documentation>
        The stroke "!".
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="NextStroke" type="Z:Stroke" substitutionGroup="Z:Stroke">
    <xs:annotation>
      <xs:documentation>
        The stroke "'".
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="NumStroke" type="Z:NumStroke" substitutionGroup="Z:Stroke">
    <xs:annotation>
      <xs:documentation>
        A digit stroke.  Note that multidigit strokes are not allowed.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the Expression hierarchy -->
  <xs:element name="Expr" type="Z:Expr" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract expression (C.6).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Expr1" type="Z:Expr1" abstract="true"
    substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        An abstract unary expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Expr2" type="Z:Expr2" abstract="true"
    substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        An abstract binary expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SchExpr2" type="Z:SchExpr2"
    abstract="true" substitutionGroup="Z:Expr2">
    <xs:annotation>
      <xs:documentation>
        An abstract binary schema expression.
        The type of both arguments is a set of bindings.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Expr0N" type="Z:Expr0N"
    abstract="true" substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        An abstract expression containing 0..N expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Expr2N" type="Z:Expr2N"
    abstract="true" substitutionGroup="Z:Expr0N">
    <xs:annotation>
      <xs:documentation>
        An abstract expression containing 2..N expressions.
        Currently the schema does not check that there are at least
        two expressions, but code should.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="QntExpr" type="Z:QntExpr"
    abstract="true" substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        An abstract quantifier-like expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Qnt1Expr" type="Z:Qnt1Expr"
    abstract="true" substitutionGroup="Z:QntExpr">
    <xs:annotation>
      <xs:documentation>
        An abstract quantifier-like expression with compulsory expression.
        Currently the schema does not check that the Expr is compulsory,
        but code should.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="BindExpr" type="Z:BindExpr" substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        A binding extension expression (C.6.35).
        It contains a list of declarations.  The restriction to ConstDecls
        is not validated by the schema, but code should check.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="CondExpr" type="Z:CondExpr" substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        A conditional expression (C.6.13).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="NumExpr" type="Z:NumExpr" substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        A number literal expression (C.6.30).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="RefExpr" type="Z:RefExpr" substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        A reference expression (C.6.21, C.6.28, C.6.29).
        <ul>
        <li>C.6.21 (Generic Operator Application).  For example: S \rel T.
                In this case, mixfix and explicit are always true,
                and the list of instantiating expressions is non-empty
                (it contains [S,T]).</li>
        <li>C.6.28 (Reference).  For example: \arithmos
                In this case, mixfix and explicit are always false
                and the list of instantiating expressions is empty.
                Another example before typechecking is \emptyset.
                The typechecker transforms \emptyset to a generic
                instantiation and explicit remains false (see 13.2.3.3).</li>
        <li>C.6.29 (Generic Instantiation).  For example: \emptyset[T].
                In this case, mixfix is always false and the list of 
                instantiating expressions is non-empty (it contains [T]).
                The explicit attribute indicates whether the instantiating
                expressions are explicitly given in the specification
                (explicit is true) or whether they were inferred by the
                typechecker (explicit is false).</li>
        </ul>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SchExpr" type="Z:SchExpr" substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        A schema construction expression (C.6.34).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="BindSelExpr" type="Z:BindSelExpr"
    substitutionGroup="Z:Expr1">
    <xs:annotation>
      <xs:documentation>
        A binding selection expression (C.6.25).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="DecorExpr" type="Z:DecorExpr" substitutionGroup="Z:Expr1">
    <xs:annotation>
      <xs:documentation>
        A schema decoration expression (C.6.23).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="HideExpr" type="Z:HideExpr" substitutionGroup="Z:Expr1">
    <xs:annotation>
      <xs:documentation>
        A schema hiding expression (C.6.16).
	The schema does not check that the NameList is non-empty, but
        code should.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="NegExpr" type="Z:Expr1" substitutionGroup="Z:Expr1">
    <xs:annotation>
      <xs:documentation>
        A schema negation expression (C.6.12).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="PowerExpr" type="Z:Expr1" substitutionGroup="Z:Expr1">
    <xs:annotation>
      <xs:documentation>
        A powerset expression (C.6.20).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="PreExpr" type="Z:Expr1" substitutionGroup="Z:Expr1">
    <xs:annotation>
      <xs:documentation>
        A schema precondition expression (C.6.18).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="RenameExpr" type="Z:RenameExpr"
    substitutionGroup="Z:Expr1">
    <xs:annotation>
      <xs:documentation>
        A schema renaming expression (C.6.24).
	The schema does not check that the RenameList is non-empty, but
        code should.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ThetaExpr" type="Z:ThetaExpr" substitutionGroup="Z:Expr1">
    <xs:annotation>
      <xs:documentation>
        A binding construction expression (C.6.27).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="TupleSelExpr" type="Z:TupleSelExpr"
    substitutionGroup="Z:Expr1">
    <xs:annotation>
      <xs:documentation>
        A tuple selection expression (C.6.26).
	The schema does not check that the numeral is positive, but
        code should.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ApplExpr" type="Z:ApplExpr" substitutionGroup="Z:Expr2">
    <xs:annotation>
      <xs:documentation>
        A function application (C.6.21, C.6.22).
        <ul>
        <li>C.6.21 (Function Operator Application).  For example: S + T.
                In this case, Mixfix=true, the first (left) expression is the
                name, (" _ + _ "), (that is, a RefExpr with Mixfix=false!) 
                and the second (right) expression is (S,T).</li>
        <li>C.6.22 (Application).  For example: (_ + _)(S, T).
                In this case, Mixfix=false, and the rest is the same as above
                (the first expression is the RefExpr with Mixfix=false and
                name (" _ + _ "), and the second expression is (S,T)).
                Another example: dom R.
                In this case, Mixfix=false, the first (left) expression is the
                function, dom, (again, a RefExpr with Mixfix=false) 
                and the second (right) expression is the argument R.</li>
        </ul>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="CompExpr" type="Z:SchExpr2" substitutionGroup="Z:SchExpr2">
    <xs:annotation>
      <xs:documentation>
        A schema composition expression (C.6.14).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="PipeExpr" type="Z:SchExpr2" substitutionGroup="Z:SchExpr2">
    <xs:annotation>
      <xs:documentation>
        A schema piping expression (C.6.15).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProjExpr" type="Z:SchExpr2" substitutionGroup="Z:SchExpr2">
    <xs:annotation>
      <xs:documentation>
        A schema projection expression (C.6.17).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AndExpr" type="Z:SchExpr2" substitutionGroup="Z:SchExpr2">
    <xs:annotation>
      <xs:documentation>
        A schema conjunction expression (C.6.11).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OrExpr" type="Z:SchExpr2" substitutionGroup="Z:SchExpr2">
    <xs:annotation>
      <xs:documentation>
        A schema disjunction expression (C.6.10).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ImpliesExpr" type="Z:SchExpr2"
    substitutionGroup="Z:SchExpr2">
    <xs:annotation>
      <xs:documentation>
        A schema implication expression (C.6.9).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IffExpr" type="Z:SchExpr2" substitutionGroup="Z:SchExpr2">
    <xs:annotation>
      <xs:documentation>
        A schema equivalence expression (C.6.8).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SetExpr" type="Z:Expr0N" substitutionGroup="Z:Expr0N">
    <xs:annotation>
      <xs:documentation>
        A set extension expression (C.6.31).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProdExpr" type="Z:Expr2N" substitutionGroup="Z:Expr2N">
    <xs:annotation>
      <xs:documentation>
        A Cartesian product expression (C.6.19).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="TupleExpr" type="Z:Expr2N" substitutionGroup="Z:Expr2N">
    <xs:annotation>
      <xs:documentation>
        A tuple extension expression (C.6.36).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="MuExpr" type="Z:QntExpr" substitutionGroup="Z:QntExpr">
    <xs:annotation>
      <xs:documentation>
        A (characteristic) definite description expression (C.6.6, C.6.37).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SetCompExpr" type="Z:QntExpr"
    substitutionGroup="Z:QntExpr">
    <xs:annotation>
      <xs:documentation>
        A (characteristic) set comprehension expression (C.6.32, C.6.33).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExistsExpr" type="Z:Qnt1Expr"
    substitutionGroup="Z:Qnt1Expr">
    <xs:annotation>
      <xs:documentation>
        A schema existential quantification (C.6.3).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Exists1Expr" type="Z:Qnt1Expr"
    substitutionGroup="Z:Qnt1Expr">
    <xs:annotation>
      <xs:documentation>
        A schema unique existential quantification (C.6.4).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ForallExpr" type="Z:Qnt1Expr"
    substitutionGroup="Z:Qnt1Expr">
    <xs:annotation>
      <xs:documentation>
        A schema univeral quantification expression (C.6.2).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="LambdaExpr" type="Z:Qnt1Expr"
    substitutionGroup="Z:Qnt1Expr">
    <xs:annotation>
      <xs:documentation>
        A function construction expression (C.6.5).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="LetExpr" type="Z:Qnt1Expr" substitutionGroup="Z:Qnt1Expr">
    <xs:annotation>
      <xs:documentation>
        A substitution expression (C.6.7).
        Note that the SchText should contain x==Expr only, and no predicate.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the ParaList hierarchy -->
  <xs:element name="ParaList" type="Z:ParaList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract paragraph list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ZParaList" type="Z:ZParaList"
    substitutionGroup="Z:ParaList">
    <xs:annotation>
      <xs:documentation>
        A paragraph list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the ExpressionList hierarchy -->
  <xs:element name="ExprList" type="Z:ExprList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract expression list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ZExprList" type="Z:ZExprList"
    substitutionGroup="Z:ExprList">
    <xs:annotation>
      <xs:documentation>
        An expression list (12.2.12).
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the RenameList hierarchy -->
  <xs:element name="RenameList" type="Z:RenameList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract rename list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ZRenameList" type="Z:ZRenameList"
    substitutionGroup="Z:RenameList">
    <xs:annotation>
      <xs:documentation>
        A rename list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the NameList hierarchy -->
  <xs:element name="NameList" type="Z:NameList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract name list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ZNameList" type="Z:ZNameList"
    substitutionGroup="Z:NameList">
    <xs:annotation>
      <xs:documentation>
        A name list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the BranchList hierarchy -->
  <xs:element name="BranchList" type="Z:BranchList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract branch list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ZBranchList" type="Z:ZBranchList"
    substitutionGroup="Z:BranchList">
    <xs:annotation>
      <xs:documentation>
        A branch list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the FreetypeList hierarchy -->
  <xs:element name="FreetypeList" type="Z:FreetypeList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract freetype list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ZFreetypeList" type="Z:ZFreetypeList"
    substitutionGroup="Z:FreetypeList">
    <xs:annotation>
      <xs:documentation>
        A freetype list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- The Predicate hierarchy -->
  <xs:element name="Pred" type="Z:Pred" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract predicate (C.5).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Fact" type="Z:Fact" abstract="true"
    substitutionGroup="Z:Pred">
    <xs:annotation>
      <xs:documentation>
        An abstract superclass for constant true/false facts.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Pred2" type="Z:Pred2" abstract="true"
    substitutionGroup="Z:Pred">
    <xs:annotation>
      <xs:documentation>
        An abstract binary predicate.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="QntPred" type="Z:QntPred" abstract="true"
    substitutionGroup="Z:Pred">
    <xs:annotation>
      <xs:documentation>
        An abstract quantifier like predicate.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExprPred" type="Z:ExprPred" substitutionGroup="Z:Pred">
    <xs:annotation>
      <xs:documentation>
        A schema predicate.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="MemPred" type="Z:MemPred" substitutionGroup="Z:Pred">
    <xs:annotation>
      <xs:documentation>
        A relation operator application (C.5.12).
        <ul>
        <li>Membership predicate.
            In this case, Mixfix=false, the first (left) expression is the
            element, and the second (right) expression is the set.
            For example, "n \in S" has left="n" and right="S".</li>
        <li>Equality.
            In this case, Mixfix=true, the first (left) expression is the
            left-hand side of the equality, and the second (right)
            expression is a singleton set containing the right-hand side
            of the equality.
            For example: "n = m" has left="n" and right="{m}".</li>
        <li>Other operator application.
            In this case, Mixfix=true, the first (left) expression is
            usually a tuple containing the corresponding number of arguments,
            and the second (right) expression is the operator name.
            However, for a unary operator, the left expression does not have
            to be a tuple.  
            For example, "n &lt; m" has left="(n,m)" and right=" _ &lt; _ ",
            "disjoint s" has left="s" and right="disjoint _ ", and
            if foo was declared as a unary postfix operator,
            then "(2,3) foo" would have left= "(2,3)" and right=" _ foo".  
            </li>
        </ul>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="NegPred" type="Z:NegPred" substitutionGroup="Z:Pred">
    <xs:annotation>
      <xs:documentation>
        A negation (C.5.11).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="FalsePred" type="Z:Fact" substitutionGroup="Z:Fact">
    <xs:annotation>
      <xs:documentation>
        Falsity (C.5.15).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="TruePred" type="Z:Fact" substitutionGroup="Z:Fact">
    <xs:annotation>
      <xs:documentation>
        Truth (C.5.14).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AndPred" type="Z:AndPred" substitutionGroup="Z:Pred2">
    <xs:annotation>
      <xs:documentation>
        A conjunction (C.5.5, C.5.6, C.5.10).
        The And attribute identifies the kind of conjunction:
        whether it is an /\, a semicolon, a newline,
        or a chain (an implicit conjunction like in a=b=c).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ImpliesPred" type="Z:Pred2" substitutionGroup="Z:Pred2">
    <xs:annotation>
      <xs:documentation>
        An implication (C.5.8).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IffPred" type="Z:Pred2" substitutionGroup="Z:Pred2">
    <xs:annotation>
      <xs:documentation>
        An equivalence (C.5.7).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OrPred" type="Z:Pred2" substitutionGroup="Z:Pred2">
    <xs:annotation>
      <xs:documentation>
        A disjunction (C.5.9).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExistsPred" type="Z:QntPred"
    substitutionGroup="Z:QntPred">
    <xs:annotation>
      <xs:documentation>
        An existential quantification (C.5.3).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Exists1Pred" type="Z:QntPred"
    substitutionGroup="Z:QntPred">
    <xs:annotation>
      <xs:documentation>
        An unique existential quantification (C.5.4).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ForallPred" type="Z:QntPred"
    substitutionGroup="Z:QntPred">
    <xs:annotation>
      <xs:documentation>
        An universal quantification (C.5.2).
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- The SchText hierarchy. -->
  <xs:element name="SchText" type="Z:SchText" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract schema text (C.7).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ZSchText" type="Z:ZSchText" substitutionGroup="Z:SchText">
    <xs:annotation>
      <xs:documentation>
        A schema text (C.7).
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- The DeclList hierarchy. -->
  <xs:element name="DeclList" type="Z:DeclList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract declaration list (12.2.7.2).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ZDeclList" type="Z:ZDeclList"
    substitutionGroup="Z:DeclList">
    <xs:annotation>
      <xs:documentation>
        A declaration list (12.2.7.2).
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the StrokeList hierarchy -->
  <xs:element name="StrokeList" type="Z:StrokeList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract stroke list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ZStrokeList" type="Z:ZStrokeList"
    substitutionGroup="Z:StrokeList">
    <xs:annotation>
      <xs:documentation>
        A stroke list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Miscellaneous Z elements -->
  <xs:element name="Parent" type="Z:Parent">
    <xs:annotation>
      <xs:documentation>
        The parents of a section.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Freetype" type="Z:Freetype">
    <xs:annotation>
      <xs:documentation>
        A free type (C.4.10).
	The schema does not check that the FreetypeList is non-empty, but
        code should.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Branch" type="Z:Branch">
    <xs:annotation>
      <xs:documentation>
        A branch of a free type (C.4.10).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Signature" type="Z:Signature">
    <xs:annotation>
      <xs:documentation>
        A signature (3.14).  It is a function from names to types,
        but the class just contains a list of pairs consisting of a
        name and a type.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="NewOldPair" type="Z:NewOldPair">
    <xs:annotation>
      <xs:documentation>
        A pair of two names.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="NameTypePair" type="Z:NameTypePair">
    <xs:annotation>
      <xs:documentation>
        A pair of a name and a type.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="NameSectTypeTriple" type="Z:NameSectTypeTriple">
    <xs:annotation>
      <xs:documentation>
        A tuple consisting of a name, a section, and a type.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Directive" type="Z:Directive">
    <xs:annotation>
      <xs:documentation>
        <p>
          A latex markup directive.  This is used to represent
          %%Zchar and %%Zword directives used in latex markup (A.2.3).
          The Command contains the complete latex command, including
          the leading backslash, whereas Unicode contains the corresponding
          unicode representation.  The attribute is used to distinguish
          the kind or type of directive, for instance whether it was a
          %%Zinchar, which corresponds to type "NONE",
          or %%Zinword in which case the type is "IN".
        </p>
        <p>
          Note that there is no unique tranlation back to a latex markup
          directive in latex since there could be several latex strings
          representing a unicode string.
          However, if one does want to translate back into latex markup
          directives, then directives with a single unicode character 
          should be translated into the various %%Z...char commands and 
          all other directives should be translated into %%Z...word
          commands (after translating each unicode character into a
          latex command).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- the annotation hierarchy -->
  <xs:element name="Ann" type="Z:Ann" abstract="true">
    <xs:annotation>
      <xs:documentation>
        This empty class is the base class for all 'official'
        annotations -- those defined for standard Z and the various
	extensions of standard Z.  This gives us the ability to add
        attributes to all such annotations in the future.  However,
        note that the Anns list within each Term object is not limited
        to just the subclasses of Ann -- arbitrary objects are allowed,
        so that new kinds of annotations can be added without having to
	define them in an XML schema etc.  
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="LocAnn" type="Z:LocAnn" substitutionGroup="Z:Ann">
    <xs:annotation>
      <xs:documentation>
        Location annotations define the source-code location of a construct.
        The Line and Col numbers, if present, refer to an identifying
        token within the construct, such as the equality token of an
	equality predicate, or the opening brace of a set comprehension.
	The Line and Col numbers start from (0,0), so may need adjusting
	to give correct positions in various editors.
	The Start number, if present, gives the position of the start 
	of the construct from the beginning of the document (0 means
	the first character of the document), and the Length number gives
	the number of characters from the beginning of the construct to 
	the end.  The Length may be zero if the construct exists in
	one markup, but is not visible in another markup.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParenAnn" type="Z:Ann" substitutionGroup="Z:Ann">
    <xs:annotation>
      <xs:documentation>
        This means unnecessary parentheses surrounded the annotated element.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SectTypeEnvAnn" type="Z:SectTypeEnvAnn"
    substitutionGroup="Z:Ann">
    <xs:annotation>
      <xs:documentation>
        A section-type environment (4.4 Table 22).
        It associates names of declarations with the name of the
        ancestral section that originally declared the name paired
        with its type.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <!--
  <xs:element name="SectWarningEnvAnn" type="Z:SectWarningEnvAnn"
    substitutionGroup="Z:Ann">
    <xs:annotation>
      <xs:documentation>
        Table of warnings per section. That is errors tagged as warnings
        or warnings directly. Ideally there should only be errors, but
        that will require ErrorAnn from the typechecker to be part of
        core java as well. Eventually we will get there.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  -->
  <xs:element name="SignatureAnn" type="Z:SignatureAnn"
    substitutionGroup="Z:Ann">
    <xs:annotation>
      <xs:documentation>
        A signature annotation.
        It gives the signature (the global declarations) of a paragraph.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="TypeAnn" type="Z:TypeAnn" substitutionGroup="Z:Ann">
    <xs:annotation>
      <xs:documentation>
        A type annotation.  It gives the type of an expression/term.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- The Base Type hierarchy.
       These usually appear inside annotations
       which are added by a typechecker -->
  <xs:element name="Type" type="Z:Type" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract base type.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Type2" type="Z:Type2" abstract="true"
    substitutionGroup="Z:Type">
    <xs:annotation>
      <xs:documentation>
        An abstract type which can occur in other types.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="GenericType" type="Z:GenericType"
    substitutionGroup="Z:Type">
    <xs:annotation>
      <xs:documentation>
        A generic type.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="GenParamType" type="Z:GenParamType"
    substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        A generic parameter type.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="GivenType" type="Z:GivenType"
    substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        A given type.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="PowerType" type="Z:PowerType"
    substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        A powerset type.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProdType" type="Z:ProdType"
    substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        A Cartesian product type.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SchemaType" type="Z:SchemaType"
    substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        A schema type.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- The Operator/Operand hierarchy, used within Operator Templates --> 
  <xs:element name="Oper" type="Z:Oper" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract parent of Operator/Operand.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Operator" type="Z:Operator" substitutionGroup="Z:Oper">
    <xs:annotation>
      <xs:documentation>
        An Operator Token, used within an Operator Template.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Operand" type="Z:Operand" substitutionGroup="Z:Oper">
    <xs:annotation>
      <xs:documentation>
        An Operator Argument, used within an Operator Template.
        If the List attribute is false, then this operand represents
        a single expression (written as an underscore).  If the List
        attribute is true, then this operand represents a comma-separated
        list of expressions (written as a pair of commas).
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Definitions of the complexTypes used above (same order as above) -->
  <xs:complexType name="Term" mixed="false">
    <xs:annotation>
      <xs:documentation>
        Supertype of all constructs.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Anns" minOccurs="0">
        <xs:complexType mixed="false">
          <xs:sequence>
            <xs:any namespace="##any" processContents="lax"
              maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="Spec">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:Sect" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="Version" type="xs:string"
          use="optional" default="1.0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Sect">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZSect">
    <xs:complexContent>
      <xs:extension base="Z:Sect">
        <xs:sequence>
          <xs:element name="Name" type="xs:string"/>
          <xs:element ref="Z:Parent" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:ParaList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="UnparsedZSect">
    <xs:complexContent>
      <xs:extension base="Z:Sect">
        <xs:sequence>
          <xs:element name="Content" type="xs:anyType"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NarrSect">
    <xs:complexContent>
      <xs:extension base="Z:Sect">
        <xs:sequence>
          <xs:element name="Content" type="xs:anyType"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Para">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AxPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:NameList"/>
          <xs:element ref="Z:SchText"/>
        </xs:sequence>
        <xs:attribute name="Box" type="Z:Box" use="optional" default="AxBox"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="Box">
    <xs:restriction base="xs:string">
      <xs:enumeration value="OmitBox"/>
      <xs:enumeration value="AxBox"/>
      <xs:enumeration value="SchBox"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="ConjPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:NameList"/>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="FreePara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:FreetypeList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GivenPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:NameList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NarrPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element name="Content" type="xs:anyType"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="OptempPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:Oper" minOccurs="2" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="Cat" type="Z:Cat"
          use="required"/>
        <xs:attribute name="Assoc" type="Z:Assoc"
          use="optional"/>
        <xs:attribute name="Prec" type="xs:nonNegativeInteger"
          use="optional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="Cat">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Relation"/>
      <xs:enumeration value="Function"/>
      <xs:enumeration value="Generic"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="Assoc">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Left"/>
      <xs:enumeration value="Right"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="LatexMarkupPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:Directive" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Directive">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element name="Command" type="xs:string"/>
          <xs:element name="Unicode" type="xs:string"/>
        </xs:sequence>
        <xs:attribute name="DirectiveType" type="Z:DirectiveType"
          use="optional" default="NONE"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="DirectiveType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NONE"/>
      <xs:enumeration value="IN"/>
      <xs:enumeration value="PRE"/>
      <xs:enumeration value="POST"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="UnparsedPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element name="Content" type="xs:anyType"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Decl">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ConstDecl">
    <xs:complexContent>
      <xs:extension base="Z:Decl">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="InclDecl">
    <xs:complexContent>
      <xs:extension base="Z:Decl">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="VarDecl">
    <xs:complexContent>
      <xs:extension base="Z:Decl">
        <xs:sequence>
          <xs:element ref="Z:NameList"/>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Name">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZName">
    <xs:complexContent>
      <xs:extension base="Z:Name">
        <xs:sequence>
          <xs:element name="Word" type="xs:string"/>
          <xs:element ref="Z:StrokeList"/>
        </xs:sequence>
        <xs:attribute name="Id" type="xs:string" use="optional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Stroke">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NumStroke">
    <xs:complexContent>
      <xs:extension base="Z:Stroke">
        <xs:attribute name="Digit" type="Z:Digit" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="Digit">
    <xs:annotation> 
      <xs:appinfo>
        <jaxb:javaType name="net.sourceforge.czt.base.ast.Digit" 
          parseMethod="net.sourceforge.czt.base.util.CztDatatypeConverter.parseDigit" 
          printMethod="net.sourceforge.czt.base.util.CztDatatypeConverter.printDigit"/>
      </xs:appinfo>
    </xs:annotation>  
    <xs:restriction base="xs:integer">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="9"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="Numeral">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZNumeral">
    <xs:complexContent>
      <xs:extension base="Z:Numeral">
        <xs:attribute name="Value" type="xs:nonNegativeInteger"
          use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Expr">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Expr1">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Expr2">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <xs:element ref="Z:Expr" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SchExpr2">
    <xs:complexContent>
      <xs:extension base="Z:Expr2"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Expr0N">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <xs:element ref="Z:ExprList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Expr2N">
    <xs:complexContent>
      <xs:extension base="Z:Expr0N"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="QntExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <xs:element ref="Z:SchText"/>
          <xs:element ref="Z:Expr" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Qnt1Expr">
    <xs:complexContent>
      <xs:extension base="Z:QntExpr"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BindExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <xs:element ref="Z:DeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CondExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
          <xs:element ref="Z:Expr" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NumExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <xs:element ref="Z:Numeral"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RefExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="Z:ExprList"/>
        </xs:sequence>
        <xs:attribute name="Mixfix" type="xs:boolean"
          use="optional" default="false"/>
        <xs:attribute name="Explicit" type="xs:boolean"
          use="optional" default="false"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SchExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <xs:element ref="Z:SchText"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BindSelExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr1">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="DecorExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr1">
        <xs:sequence>
          <xs:element ref="Z:Stroke"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="HideExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr1">
        <xs:sequence>
          <xs:element ref="Z:NameList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RenameExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr1">
        <xs:sequence>
          <xs:element ref="Z:RenameList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ThetaExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr1">
        <xs:sequence>
          <xs:element ref="Z:StrokeList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TupleSelExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr1">
        <xs:sequence>
          <xs:element ref="Z:Numeral"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ApplExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr2">
        <xs:attribute name="Mixfix" type="xs:boolean"
          use="optional" default="false"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ParaList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZParaList">
    <xs:complexContent>
      <xs:extension base="Z:ParaList">
        <xs:sequence>
          <xs:element ref="Z:Para" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ExprList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZExprList">
    <xs:complexContent>
      <xs:extension base="Z:ExprList">
        <xs:sequence>
          <xs:element ref="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RenameList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZRenameList">
    <xs:complexContent>
      <xs:extension base="Z:RenameList">
        <xs:sequence>
          <xs:element ref="Z:NewOldPair" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NameList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZNameList">
    <xs:complexContent>
      <xs:extension base="Z:NameList">
        <xs:sequence>
          <xs:element ref="Z:Name" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BranchList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZBranchList">
    <xs:complexContent>
      <xs:extension base="Z:BranchList">
        <xs:sequence>
          <xs:element ref="Z:Branch" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="FreetypeList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZFreetypeList">
    <xs:complexContent>
      <xs:extension base="Z:FreetypeList">
        <xs:sequence>
          <xs:element ref="Z:Freetype" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Pred">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Fact">
    <xs:complexContent>
      <xs:extension base="Z:Pred"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Pred2">
    <xs:complexContent>
      <xs:extension base="Z:Pred">
        <xs:sequence>
          <xs:element ref="Z:Pred" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="QntPred">
    <xs:complexContent>
      <xs:extension base="Z:Pred">
        <xs:sequence>
          <xs:element ref="Z:SchText"/>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ExprPred">
    <xs:complexContent>
      <xs:extension base="Z:Pred">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="MemPred">
    <xs:complexContent>
      <xs:extension base="Z:Pred">
        <xs:sequence>
          <xs:element ref="Z:Expr" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
        <xs:attribute name="Mixfix" type="xs:boolean"
          use="optional" default="false"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NegPred">
    <xs:complexContent>
      <xs:extension base="Z:Pred">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AndPred">
    <xs:complexContent>
      <xs:extension base="Z:Pred2">
        <xs:attribute name="And" type="Z:And" use="optional" default="Wedge"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="And">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Wedge"/>
      <xs:enumeration value="NL"/>
      <xs:enumeration value="Semi"/>
      <xs:enumeration value="Chain"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="SchText">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZSchText">
    <xs:complexContent>
      <xs:extension base="Z:SchText">
        <xs:sequence>
          <xs:element ref="Z:DeclList"/>
          <xs:element ref="Z:Pred" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="DeclList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZDeclList">
    <xs:complexContent>
      <xs:extension base="Z:DeclList">
        <xs:sequence>
          <xs:element ref="Z:Decl" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="StrokeList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZStrokeList">
    <xs:complexContent>
      <xs:extension base="Z:StrokeList">
        <xs:sequence>
          <xs:element ref="Z:Stroke" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Parent">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element name="Word" type="xs:string"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Freetype">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="Z:BranchList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Branch">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="Z:Expr" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Ann">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="LocAnn">
    <xs:complexContent>
      <xs:extension base="Z:Ann">
        <xs:attribute name="Loc" type="xs:anyURI"
          use="optional"/>
        <xs:attribute name="Line" type="xs:nonNegativeInteger"
          use="optional"/>
        <xs:attribute name="Col" type="xs:nonNegativeInteger"
          use="optional"/>
        <xs:attribute name="Start" type="xs:nonNegativeInteger"
          use="optional"/>
        <xs:attribute name="Length" type="xs:nonNegativeInteger"
          use="optional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SectTypeEnvAnn">
    <xs:complexContent>
      <xs:extension base="Z:Ann">
        <xs:sequence>
          <xs:element ref="Z:NameSectTypeTriple"
            minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- Cannot put ErrorAnn (in TypeChecker) or CztError (in Parser) or Term (in Util)! Use Ann instead? Creates other problems at JaxB. Leave out for now.
  <xs:complexType name="SectWarningEnvAnn">
    <xs:complexContent>
      <xs:extension base="Z:Ann">
        <xs:sequence>
          <xs:element ref="Z:Ann"
            minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Elements" generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  -->
  <xs:complexType name="SignatureAnn">
    <xs:complexContent>
      <xs:extension base="Z:Ann">
        <xs:sequence>
          <xs:element ref="Z:Signature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TypeAnn">
    <xs:complexContent>
      <xs:extension base="Z:Ann">
        <xs:sequence>
          <xs:element ref="Z:Type"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Type">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Type2">
    <xs:complexContent>
      <xs:extension base="Z:Type"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GenericType">
    <xs:complexContent>
      <xs:extension base="Z:Type">
        <xs:sequence>
          <xs:element ref="Z:NameList"/>
          <xs:element ref="Z:Type2" minOccurs="1" maxOccurs="2">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Type"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GenParamType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GivenType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PowerType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>
          <xs:element ref="Z:Type2">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Type"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProdType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>
          <xs:element ref="Z:Type2" minOccurs="2" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Type"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SchemaType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>
          <xs:element ref="Z:Signature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Signature">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:NameTypePair"
            minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Oper">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Operator">
    <xs:complexContent>
      <xs:extension base="Z:Oper">
        <xs:sequence>
          <xs:element name="Word" type="xs:string"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Operand">
    <xs:complexContent>
      <xs:extension base="Z:Oper">
        <xs:attribute name="List" type="xs:boolean" default="false"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NameTypePair">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="Z:Type"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NameSectTypeTriple" mixed="false">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element name="Sect" type="xs:string"/>
          <xs:element ref="Z:Type"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NewOldPair">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:Name" minOccurs="2" maxOccurs="2"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:schema>
