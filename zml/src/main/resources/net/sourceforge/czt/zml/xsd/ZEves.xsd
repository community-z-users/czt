<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  targetNamespace="http://czt.sourceforge.net/zeves"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:P="http://czt.sourceforge.net/zpatt"
  xmlns:ZEVES="http://czt.sourceforge.net/zeves"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="1.0">
  <xs:annotation>
    <xs:documentation>
      This XML schema defines proof support for parsing/manipulating Z/Eves
      proof scripts and provers result/output, which is itself in XML.

      $Id: ZEves.xsd leouk $

      Copyright (C) 2011, Leo Freitas
      This file is part of the Community Z Tools (CZT) project.

      The CZT project contains free software; you can
      redistribute it and/or modify it under the terms
      of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of
      the License, or (at your option) any later version.

      The CZT project is distributed in the hope that it
      will be useful, but WITHOUT ANY WARRANTY; without
      even the implied warranty of MERCHANTABILITY or
      FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.

      You should have received a copy of the GNU General
      Public License along with CZT; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place,
      Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
      <jaxb:schemaBindings>
        <jaxb:package name="net.sourceforge.czt.zeves.jaxb.gen">
          <jaxb:javadoc>
            &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
            &lt;html&gt;
            &lt;body&gt;
            &lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
          </jaxb:javadoc>
        </jaxb:package>
      </jaxb:schemaBindings>
      <gnast:schemaBindings name="ZEves">
        <gnast:package name="net.sourceforge.czt.zeves">
          <gnast:package id="ast" name="ast" template="AstInterface.vm">
            <gnast:generate id="factory" class="ZEvesFactory" template="CoreFactory.vm"/>
          </gnast:package>
          <gnast:package id="impl" name="impl" template="AstClass.vm">
            <gnast:generate id="factoryImpl" class="ZEvesFactoryImpl" template="CoreFactoryImpl.vm"/>
          </gnast:package>
          <gnast:package id="visitor" name="visitor"
            template="AstVisitorInterface.vm">
            <gnast:generate id="AstVisitor" class="ZEvesVisitor" template="AstVisitor.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="convFactory" class="Factory" template="Factory.vm"/>
          </gnast:package>
          <gnast:package id="jaxb" name="jaxb">
            <gnast:generate id="AstToJaxb" class="AstToJaxb" template="AstToJaxb.vm"/>
            <gnast:generate id="JaxbToAst" class="JaxbToAst" template="JaxbToAst.vm"/>
          </gnast:package>
          <gnast:package id="dom" name="dom">
            <gnast:generate id="AstToDom" class="AstToDom" template="AstToDom.vm"/>
          </gnast:package>
        </gnast:package>
      </gnast:schemaBindings>
    </xs:appinfo>
  </xs:annotation>

  <!-- NOTE: GnAST considers the first import only in the SchemaProject build phase,
             so always put ZPattern.xsd first for Circus.xsd (i.e. innermost parent).

       TODO: or should we just import from Z.xsd? Maybe not as Z/Eves allows for jokers as well
   -->
  <xs:import namespace="http://czt.sourceforge.net/zpatt" schemaLocation="ZPattern.xsd"/>
  <xs:import namespace="http://czt.sourceforge.net/zml" schemaLocation="Z.xsd"/>

  <!-- ********************************************************************* -->
  <!-- Definitions of the elements in the order of appearance in the grammar -->
  <!-- ********************************************************************* -->

  <!-- Section level paragraphs -->


  <xs:element name="ProofScript" type="ZEVES:ProofScript" substitutionGroup="Z:Para">
  <xs:annotation>
    <xs:documentation>
       Sequence of proof commands
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="ProofCommandList" type="ZEVES:ProofCommandList"/>

  <xs:element name="ProofCommand" type="ZEVES:ProofCommand" abstract="true">
  <xs:annotation>
    <xs:documentation>
       Abstract proof command
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <!-- The next three abstract proof command classes are useful to simplify the AST for proof commands as well as its tooling -->
  <xs:element name="WrappedCommand" type="ZEVES:WrappedCommand" substitutionGroup="ZEVES:ProofCommand" abstract="true">
  <xs:annotation>
    <xs:documentation>
       Abstract proof command that wraps up another proof command within it.
       This is like a tactical, yet not all "tactical"-like commands are Wrapped.
       Bare in mind Z/Eves is not a tactical theorem prover, and command combination
       is limited to general "waterfall"-like inferences. This is similar to ACL-2.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="ComplexCommand" type="ZEVES:ComplexCommand" substitutionGroup="ZEVES:WrappedCommand" abstract="true">
  <xs:annotation>
    <xs:documentation>
       Abstract complex command. It extends a wrapped command with other information like a specific
       predicate or expressions where the command is to be applied to. It also contains a list of names,
       which may be references to theorem names participating in the command's execution.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="SimplificationCommand" type="ZEVES:SimplificationCommand" substitutionGroup="ZEVES:ProofCommand">
  <xs:annotation>
    <xs:documentation>
       Term rewriting and simplification commands of various kinds. It contains flags determining whether the command
       is trivial or compound (tactical).
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="NormalizationCommand" type="ZEVES:NormalizationCommand" substitutionGroup="ZEVES:WrappedCommand">
  <xs:annotation>
    <xs:documentation>
       Term rewriting via normal forms. There three kinds: conjunctive and disjunctive normal form; or
       normalised forms of other commands (E.g., pushing ifs and imp inwards whilst rewriting). It also
       includes term rearrangement according to their lexicographic complexity.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="CaseAnalysisCommand" type="ZEVES:CaseAnalysisCommand" substitutionGroup="ZEVES:ProofCommand">
  <xs:annotation>
    <xs:documentation>
       Goal splitting and case analysis commands. It includes user-defined predicate splitting, as well
       as subgoal separation and walk-through.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="WithCommand" type="ZEVES:WithCommand" substitutionGroup="ZEVES:ComplexCommand">
  <xs:annotation>
    <xs:documentation>
       Compound commands involving either specific theorem names and/or expressions/predicates.
       It is one of the most complex / powerfull of commands available.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="SubstitutionCommand" type="ZEVES:SubstitutionCommand" substitutionGroup="ZEVES:ComplexCommand">
  <xs:annotation>
    <xs:documentation>
       Term substitution commands. These include equality substitution (globally or for an expression), and
       definition expansion (globally or for a particular name). It also involves the special case of decorated
       schema expansion or predicate expansion.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="InstantiationList" type="ZEVES:InstantiationList"/>
  <xs:element name="Instantiation" type="ZEVES:Instantiation">
    <xs:annotation>
      <xs:documentation>
        Encapsulates one instantiation or replacement for the instantiate or use commands. It belongs to a list of instantiations.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="InstantiationCommand" type="ZEVES:InstantiationCommand" substitutionGroup="ZEVES:ProofCommand" abstract="true">
  <xs:annotation>
    <xs:documentation>
       Abstract command for instantiations. It contains instantiations or replacements for either quantifiers or theorem usages.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="QuantifiersCommand" type="ZEVES:InstantiationCommand" substitutionGroup="ZEVES:InstantiationCommand">
  <xs:annotation>
    <xs:documentation>
       Quantifier manipulation and elimination. This includes skolemisation, as well as specific instantiation
       of both universal and existential quantifiers.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="UseCommand" type="ZEVES:UseCommand" substitutionGroup="ZEVES:InstantiationCommand">
  <xs:annotation>
    <xs:documentation>
       Theorem / axiom introduction with particular parameters / instantiations.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="ApplyCommand" type="ZEVES:ComplexCommand" substitutionGroup="ZEVES:ComplexCommand">
  <xs:annotation>
    <xs:documentation>
       Theorem application commands. Might have an extra expression (x)or predicate attached to it.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <!-- ***************************************************************** -->
  <!-- Definitions of complexTypes in the order of usage by the elements -->
  <!-- ***************************************************************** -->

  <!-- Outermost Paragraph Types -->
  <xs:complexType name="ProofScript">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="ZEVES:ProofCommandList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- TODO: should I have a ProofCmdList and ZEvesProofCmdList, just like NameList/ZNameList? NO (for now; no meta-proof [yet?]) -->
  <xs:complexType name="ProofCommandList">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="ZEVES:ProofCommand"  minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ProofCommand">
    <xs:complexContent>
      <xs:extension base="Z:Term">
          <!-- What proof step does this command represent. -->
          <xs:attribute name="ProofStep" type="xs:nonNegativeInteger" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- This could be called "Tactical" command, yet it's not quite right
       given RewriteCmd for ProveByReduce is also "tactical" in the TP-sense-->
  <xs:complexType name="WrappedCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:ProofCommand">
        <xs:sequence>
          <xs:element ref="ZEVES:ProofCommand" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ComplexCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:WrappedCommand">
        <xs:sequence>
          <xs:element ref="Z:NameList"/>
          <xs:element ref="Z:Expr" minOccurs="0"/>
          <xs:element ref="Z:Pred" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="SimplificationCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:ProofCommand">
        <xs:attribute name="Kind" type="ZEVES:RewriteKind" use="optional" default="Rewrite"/>
        <xs:attribute name="Power" type="ZEVES:RewritePower" use="optional" default="None"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="RewriteKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Simplify"/>
      <xs:enumeration value="Rewrite"/>
      <xs:enumeration value="Reduce"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="RewritePower">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Prove"/>
      <xs:enumeration value="Trivial"/>
      <xs:enumeration value="None"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="NormalizationCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:WrappedCommand">
        <!--
            conjunctive: Kind==Conjuncture and CMD == null
            disjunctive: Kind==Disjunctive and CMD == null
            rearrange  : Kind==Rearranghe  and CMD == null
            with normalization CMD: Kind==Command and CMD != null
        -->
        <xs:attribute name="Kind" type="ZEVES:NormalizationKind" use="optional" default="Command"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="NormalizationKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Command"/>
      <xs:enumeration value="Conjunctive"/>
      <xs:enumeration value="Disjunctive"/>
      <xs:enumeration value="Rearrange"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="CaseAnalysisCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:ProofCommand">
        <xs:sequence>
           <xs:element ref="Z:Pred" minOccurs="0"/>
        </xs:sequence>
        <!--
              cases  : Kind=Cases and P == null
              next   : Kind=Next  and P == null
              split P: Kind=Split and P != null
        -->
        <xs:attribute name="Kind" type="ZEVES:CaseAnalysisKind" use="optional" default="Cases"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="CaseAnalysisKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Cases"/>
      <xs:enumeration value="Next"/>
      <xs:enumeration value="Split"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="WithCommand">
    <xs:complexContent>
      <!--
           with expression E cmd : Expr != null and Pred = null and NameList = empty and Cmd != null
           with predicate P cmd  : Expr  = null and Pred = null and NameList = empty and Cmd = null
           with enabled NL cmd   : Expr  = null and Pred = null and NameLisst != empty and Cmd != null (same for disabled)
        -->
      <xs:extension base="ZEVES:ComplexCommand">
        <xs:attribute name="Enabled" type="xs:boolean" use="optional" default="true"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="SubstitutionCommand">
    <xs:complexContent>
      <!--
          equality substitute [Expr]: Pred = null and Name = null and (Expr != null or EQ)  [global eq subst]
          invoke predicate Pred     : Expr = null and Name = null and Pred != null
          invoke [Name]             : Expr = null and Pred = null and (Name != null or INVOKE) [global invoke]
      -->
      <xs:extension base="ZEVES:ComplexCommand">
        <xs:attribute name="Kind" type="ZEVES:SubstitutionKind" use="optional" default="Equality"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="SubstitutionKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Equality"/>
      <xs:enumeration value="Invoke"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="InstantiationCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:ProofCommand">
         <xs:sequence>
          <xs:element ref="ZEVES:InstantiationList">
              <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="InstantiationList">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="ZEVES:Instantiation"  minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="Instantiation">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
        <xs:attribute name="Kind" type="ZEVES:InstantiationKind" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- This attribute should in fact be of InstantiaitonList, given the list cannot have mixed instantiation kinds.
       But this gives a slightly more complicated parsing situation, so we leave it more flexible like this for now.
  -->
  <xs:simpleType name="InstantiationKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Quantifier"/>
      <xs:enumeration value="ThmReplacement"/>
    </xs:restriction>
  </xs:simpleType>


    <!--      prenex     : InstList = null or empty
          instantiate: InstList != null and != empty

          TODO: add for instantiate what kind of quantifier is it? No-->
      <!--  apply N          : NameList.size() == 1 and E == null and P == null and CMD == null
        apply N to pred P: NameList.size() == 1 and E == null and P != null and CMD == null
        apply N to expr E: NameList.size() == 1 and E != null and P == null and CMD == null
        -->
<!--
  <xs:complexType name="QuantifiersCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:InstantiationCommand"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ApplyCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:ComplexCommand"/>
    </xs:complexContent>
  </xs:complexType>
-->

  <xs:complexType name="UseCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:InstantiationCommand">
        <xs:sequence>
          <xs:element ref="Z:RefExpr">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="TheoremRef"
                               generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

</xs:schema>
