<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  targetNamespace="http://czt.sourceforge.net/zeves"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:ZEVES="http://czt.sourceforge.net/zeves"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="1.0">
  <xs:annotation>
    <xs:documentation>
      This XML schema defines proof support for parsing/manipulating Z/EVES
      proof scripts and provers result/output, which is itself in XML.

      $Id: ZEves.xsd leouk $

      Copyright (C) 2011, Leo Freitas
      This file is part of the Community Z Tools (CZT) project.

      The CZT project contains free software; you can
      redistribute it and/or modify it under the terms
      of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of
      the License, or (at your option) any later version.

      The CZT project is distributed in the hope that it
      will be useful, but WITHOUT ANY WARRANTY; without
      even the implied warranty of MERCHANTABILITY or
      FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.

      You should have received a copy of the GNU General
      Public License along with CZT; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place,
      Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
      <jaxb:schemaBindings>
        <jaxb:package name="net.sourceforge.czt.zeves.jaxb.gen">
          <jaxb:javadoc>
            &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
            &lt;html&gt;
            &lt;body&gt;
            &lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
          </jaxb:javadoc>
        </jaxb:package>
      </jaxb:schemaBindings>
      <gnast:schemaBindings name="ZEves">
        <gnast:package name="net.sourceforge.czt.zeves">
          <gnast:package id="ast" name="ast" template="AstInterface.vm">
            <gnast:generate id="factory" class="ZEvesFactory" template="CoreFactory.vm"/>
          </gnast:package>
          <gnast:package id="impl" name="impl" template="AstClass.vm">
            <gnast:generate id="factoryImpl" class="ZEvesFactoryImpl" template="CoreFactoryImpl.vm"/>
          </gnast:package>
          <gnast:package id="visitor" name="visitor"
            template="AstVisitorInterface.vm">
            <gnast:generate id="AstVisitor" class="ZEvesVisitor" template="AstVisitor.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="convFactory" class="Factory" template="Factory.vm"/>
          </gnast:package>
          <gnast:package id="jaxb" name="jaxb">
            <gnast:generate id="AstToJaxb" class="AstToJaxb" template="AstToJaxb.vm"/>
            <gnast:generate id="JaxbToAst" class="JaxbToAst" template="JaxbToAst.vm"/>
          </gnast:package>
          <gnast:package id="dom" name="dom">
            <gnast:generate id="AstToDom" class="AstToDom" template="AstToDom.vm"/>
          </gnast:package>
        </gnast:package>
      </gnast:schemaBindings>
    </xs:appinfo>
  </xs:annotation>

  <!-- For now, do not support ZPattern in Z/EVES. Until there is a need, assume that
       Z/EVES does not allow jokers. Therefore we do not import the ZPattern schema.
       
       GnAST considers the first import only, so if ZPattern was needed, it would need to
       go before Z.xsd (since ZPattern.xsd imports Z.xsd itself).
  <xs:import namespace="http://czt.sourceforge.net/zpatt" schemaLocation="ZPattern.xsd"/>
  -->
  <xs:import namespace="http://czt.sourceforge.net/zml" schemaLocation="Z.xsd"/>

  <!-- ********************************************************************* -->
  <!-- Definitions of the elements in the order of appearance in the grammar -->
  <!-- ********************************************************************* -->

  <!-- Typechecking paragraphs -->
  <xs:element name="ProofType" type="ZEVES:ProofType" substitutionGroup="Z:Type2">
  <xs:annotation>
    <xs:documentation>
       Proof command information collected to form a proof script type.
       This also means involved expressions, predicates, and names are checked.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="ProofCommandInfo" type="ZEVES:ProofCommandInfo"/>
  <xs:element name="ProofCommandInfoList" type="ZEVES:ProofCommandInfoList"/>
  
  <!-- Section level paragraphs -->

  <xs:element name="ProofScript" type="ZEVES:ProofScript" substitutionGroup="Z:Para">
  <xs:annotation>
    <xs:documentation>
       Sequence of proof commands
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="ProofCommandList" type="ZEVES:ProofCommandList"/>

  <xs:element name="ProofCommand" type="ZEVES:ProofCommand" abstract="true">
  <xs:annotation>
    <xs:documentation>
       Abstract proof command
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <!-- The next three abstract proof command classes are useful to simplify the AST for proof commands as well as its tooling -->
  <xs:element name="WrappedCommand" type="ZEVES:WrappedCommand" substitutionGroup="ZEVES:ProofCommand" abstract="true">
  <xs:annotation>
    <xs:documentation>
       Abstract proof command that wraps up another proof command within it.
       This is like a tactical, yet not all "tactical"-like commands are Wrapped.
       Bare in mind Z/EVES is not a tactical theorem prover, and command combination
       is limited to general "waterfall"-like inferences. This is similar to ACL-2.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="ComplexCommand" type="ZEVES:ComplexCommand" substitutionGroup="ZEVES:WrappedCommand" abstract="true">
  <xs:annotation>
    <xs:documentation>
       Abstract complex command. It extends a wrapped command with other information like a specific
       predicate or expressions where the command is to be applied to. It also contains a list of names,
       which may be references to theorem names participating in the command's execution.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="SimplificationCommand" type="ZEVES:SimplificationCommand" substitutionGroup="ZEVES:ProofCommand">
  <xs:annotation>
    <xs:documentation>
       Term rewriting and simplification commands of various kinds. It contains flags determining whether the command
       is trivial or compound (tactical).
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="NormalizationCommand" type="ZEVES:NormalizationCommand" substitutionGroup="ZEVES:WrappedCommand">
  <xs:annotation>
    <xs:documentation>
       Term rewriting via normal forms. There three kinds: conjunctive and disjunctive normal form; or
       normalised forms of other commands (E.g., pushing ifs and imp inwards whilst rewriting). It also
       includes term rearrangement according to their lexicographic complexity.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="CaseAnalysisCommand" type="ZEVES:CaseAnalysisCommand" substitutionGroup="ZEVES:ProofCommand">
  <xs:annotation>
    <xs:documentation>
       Goal splitting and case analysis commands. It includes user-defined predicate splitting, as well
       as subgoal separation and walk-through.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="WithCommand" type="ZEVES:WithCommand" substitutionGroup="ZEVES:ComplexCommand">
  <xs:annotation>
    <xs:documentation>
       Compound commands involving either specific theorem names and/or expressions/predicates.
       It is one of the most complex / powerfull of commands available.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="SubstitutionCommand" type="ZEVES:SubstitutionCommand" substitutionGroup="ZEVES:ComplexCommand">
  <xs:annotation>
    <xs:documentation>
       Term substitution commands. These include equality substitution (globally or for an expression), and
       definition expansion (globally or for a particular name). It also involves the special case of decorated
       schema expansion or predicate expansion.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="InstantiationList" type="ZEVES:InstantiationList" substitutionGroup="Z:RenameList">
     <xs:annotation>
      <xs:documentation>
        List of possible instantiations. It appears in proof commands (e.g., instantiate and use), as well
        as part of schema construction renaming like (THETA S [x := 10]), hence the RenameList substition group.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="Instantiation" type="ZEVES:Instantiation">
    <xs:annotation>
      <xs:documentation>
        Encapsulates one instantiation or replacement for the instantiate or use commands. It belongs to a list of instantiations.
        It can also appear in the extended renaming expression in ZEves, which allows for expressions in rename, instead of just names.
        In the parser, all renames will be from Name to Expr, even when they are just simple names, for uniformity.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="InstantiationCommand" type="ZEVES:InstantiationCommand" substitutionGroup="ZEVES:ProofCommand" abstract="true">
  <xs:annotation>
    <xs:documentation>
       Abstract command for instantiations. It contains instantiations or replacements for either quantifiers or theorem usages.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="QuantifiersCommand" type="ZEVES:InstantiationCommand" substitutionGroup="ZEVES:InstantiationCommand">
  <xs:annotation>
    <xs:documentation>
       Quantifier manipulation and elimination. This includes skolemisation, as well as specific instantiation
       of both universal and existential quantifiers.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="UseCommand" type="ZEVES:UseCommand" substitutionGroup="ZEVES:InstantiationCommand">
  <xs:annotation>
    <xs:documentation>
       Theorem / axiom introduction with particular parameters / instantiations.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="ApplyCommand" type="ZEVES:ComplexCommand" substitutionGroup="ZEVES:ComplexCommand">
  <xs:annotation>
    <xs:documentation>
       Theorem application commands. Might have an extra expression (x)or predicate attached to it.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="SorryCommand" type="ZEVES:SorryCommand" substitutionGroup="ZEVES:ProofCommand">
  <xs:annotation>
    <xs:documentation>
      Sorry and Oops - virtual - commands; inspired by Isabelle's meanings: sorry is give up on proving,
      yet keep the theorem; oops, gives up on proving, but don't keep the theorem albeit leave the goal.
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="ZEvesLabel" type="ZEVES:ZEvesLabel">
  <xs:annotation>
    <xs:documentation>
       Label to theorems and axiomatic predicates
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <xs:element name="ZEvesNote" type="ZEVES:ZEvesNote">
  <xs:annotation>
    <xs:documentation>
       Notes and comments from the user within formal text (not type checked)
    </xs:documentation>
  </xs:annotation>
  </xs:element>

  <!-- ***************************************************************** -->
  <!-- Definitions of complexTypes in the order of usage by the elements -->
  <!-- ***************************************************************** -->

  <xs:complexType name="ProofType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>
          <xs:element ref="ZEVES:ProofCommandInfoList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ProofCommandInfo">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <!-- TODO: discuss with Andrius
          <xs:sequence>
          <xs:element ref="Z:NameList"/> as the definitions used
          <xs:element ref="Z:NameList"/> as the theorems refered to
        </xs:sequence>
        -->
        <xs:attribute name="ProofStepRank"  type="xs:nonNegativeInteger" use="required"/>
        <xs:attribute name="ProofStepKind"  type="ZEVES:ProofStepKind" use="required"/>
        <xs:attribute name="ProofStepScope" type="ZEVES:ProofStepScope" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="ProofStepKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Trivial"/>
      <xs:enumeration value="Simple"/>
      <xs:enumeration value="Medium"/>
      <xs:enumeration value="Complex"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ProofStepScope">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Local"/>
      <xs:enumeration value="Global"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="ProofCommandInfoList">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="ZEVES:ProofCommandInfo"  minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Outermost Paragraph Types -->
  <xs:complexType name="ProofScript">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="ZEVES:ProofCommandList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- TODO: should I have a ProofCmdList and ZEvesProofCmdList, just like NameList/ZNameList? NO (for now; no meta-proof [yet?]) -->
  <xs:complexType name="ProofCommandList">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="ZEVES:ProofCommand"  minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ProofCommand">
    <xs:complexContent>
      <xs:extension base="Z:Term">
          <!-- What proof step does this command represent. -->
          <xs:attribute name="ProofStep" type="xs:nonNegativeInteger" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- This could be called "Tactical" command, yet it's not quite right
       given RewriteCmd for ProveByReduce is also "tactical" in the TP-sense-->
  <xs:complexType name="WrappedCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:ProofCommand">
        <xs:sequence>
          <xs:element ref="ZEVES:ProofCommand" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ComplexCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:WrappedCommand">
        <xs:sequence>
          <xs:element ref="Z:NameList"/>
          <xs:element ref="Z:Expr" minOccurs="0"/>
          <xs:element ref="Z:Pred" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="SimplificationCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:ProofCommand">
        <xs:attribute name="RewriteKind" type="ZEVES:RewriteKind" use="optional" default="Rewrite"/>
        <xs:attribute name="RewritePower" type="ZEVES:RewritePower" use="optional" default="None"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="RewriteKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Simplify"/>
      <xs:enumeration value="Rewrite"/>
      <xs:enumeration value="Reduce"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="RewritePower">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Prove"/>
      <xs:enumeration value="Trivial"/>
      <xs:enumeration value="None"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="NormalizationCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:WrappedCommand">
        <!--
            conjunctive: Kind==Conjuncture and CMD == null
            disjunctive: Kind==Disjunctive and CMD == null
            rearrange  : Kind==Rearrange  and CMD == null
            with normalization CMD: Kind==Command and CMD != null
        -->
        <xs:attribute name="NormalizationKind" type="ZEVES:NormalizationKind" use="optional" default="Command"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="NormalizationKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Command"/>
      <xs:enumeration value="Conjunctive"/>
      <xs:enumeration value="Disjunctive"/>
      <xs:enumeration value="Rearrange"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="CaseAnalysisCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:ProofCommand">
        <xs:sequence>
           <xs:element ref="Z:Pred" minOccurs="0"/>
        </xs:sequence>
        <!--
              cases  : Kind=Cases and P == null
              next   : Kind=Next  and P == null
              split P: Kind=Split and P != null
        -->
        <xs:attribute name="CaseAnalysisKind" type="ZEVES:CaseAnalysisKind" use="optional" default="Cases"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="CaseAnalysisKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Cases"/>
      <xs:enumeration value="Next"/>
      <xs:enumeration value="Split"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="WithCommand">
    <xs:complexContent>
      <!--
           with expression E cmd : Expr != null and Pred = null and NameList = empty and Cmd != null
           with predicate P cmd  : Expr  = null and Pred = null and NameList = empty and Cmd = null
           with enabled NL cmd   : Expr  = null and Pred = null and NameLisst != empty and Cmd != null (same for disabled)
        -->
      <xs:extension base="ZEVES:ComplexCommand">
        <xs:attribute name="Enabled" type="xs:boolean" use="optional" default="true"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="SubstitutionCommand">
    <xs:complexContent>
      <!--
          equality substitute [Expr]: Pred = null and Name = null and (Expr != null or EQ)  [global eq subst]
          invoke predicate Pred     : Expr = null and Name = null and Pred != null
          invoke [Name]             : Expr = null and Pred = null and (Name != null or INVOKE) [global invoke]
      -->
      <xs:extension base="ZEVES:ComplexCommand">
        <xs:attribute name="SubstitutionKind" type="ZEVES:SubstitutionKind" use="optional" default="Equality"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="SubstitutionKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Equality"/>
      <xs:enumeration value="Invoke"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="InstantiationCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:ProofCommand">
         <xs:sequence>
          <xs:element ref="ZEVES:InstantiationList">
              <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="InstantiationList">
    <xs:complexContent>
      <xs:extension base="Z:RenameList">
        <xs:sequence>
          <xs:element ref="ZEVES:Instantiation"  minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="Instantiation">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
        <xs:attribute name="InstantiationKind" type="ZEVES:InstantiationKind" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!-- This attribute should in fact be of InstantiaitonList, given the list cannot have mixed instantiation kinds.
       But this gives a slightly more complicated parsing situation, so we leave it more flexible like this for now.
  -->
  <xs:simpleType name="InstantiationKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Quantifier"/>
      <xs:enumeration value="ThmReplacement"/>
    </xs:restriction>
  </xs:simpleType>


    <!--      prenex     : InstList = null or empty
          instantiate: InstList != null and != empty

          TODO: add for instantiate what kind of quantifier is it? No-->
      <!--  apply N          : NameList.size() == 1 and E == null and P == null and CMD == null
        apply N to pred P: NameList.size() == 1 and E == null and P != null and CMD == null
        apply N to expr E: NameList.size() == 1 and E != null and P == null and CMD == null
        -->
<!--
  <xs:complexType name="QuantifiersCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:InstantiationCommand"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ApplyCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:ComplexCommand"/>
    </xs:complexContent>
  </xs:complexType>
-->

  <xs:complexType name="UseCommand">
    <xs:complexContent>
      <xs:extension base="ZEVES:InstantiationCommand">
        <xs:sequence>
          <xs:element ref="Z:RefExpr">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="TheoremRef"
                               generateElementProperty="true"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="SorryCommand">
    <xs:complexContent>
      <!--
           sorry;  false
           oops;   true
        -->
      <xs:extension base="ZEVES:ProofCommand">
        <xs:attribute name="KeepGoal" type="xs:boolean" use="optional" default="false"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

 <xs:complexType name="ZEvesLabel">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:Name"/>
        </xs:sequence>
        <xs:attribute name="LabelAbility" type="ZEVES:LabelAbility" use="optional" default="enabled"/>
        <xs:attribute name="LabelUsage" type="ZEVES:LabelUsage" use="optional" default="none"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="LabelAbility">
    <xs:restriction base="xs:string">
      <xs:enumeration value="enabled"/>
      <xs:enumeration value="disabled"/>
      <xs:enumeration value="none"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="LabelUsage">
    <xs:restriction base="xs:string">
      <xs:enumeration value="axiom"/>
      <xs:enumeration value="rule"/>
      <xs:enumeration value="grule"/>
      <xs:enumeration value="frule"/>
      <xs:enumeration value="none"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="ZEvesNote">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element name="Note" type="xs:string"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

</xs:schema>
