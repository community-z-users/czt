<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  targetNamespace="http://czt.sourceforge.net/zpatt"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:P="http://czt.sourceforge.net/zpatt"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="1.0">
  <xs:annotation>
    <xs:documentation>
      This XML schema defines proof and transformation rules for 
      specifications written in the ISO Standard Z notation.
      It defines various kinds of 'Joker' AST terms, to act as named
      placeholders for expressions, predicates, declaration lists etc.,
      plus two new kinds of paragraphs: Jokers associates names with
      a particular kind of joker AST term, and Rule defines a
      proof rule (with one conclusion and possible several antecedents).

      $Id$
      
      Copyright 2003 Mark Utting
      This file is part of the Community Z Tools (CZT) project.
      
      The CZT project contains free software; you can
      redistribute it and/or modify it under the terms
      of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of
      the License, or (at your option) any later version.
      
      The CZT project is distributed in the hope that it
      will be useful, but WITHOUT ANY WARRANTY; without
      even the implied warranty of MERCHANTABILITY or
      FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
      
      You should have received a copy of the GNU General
      Public License along with CZT; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place,
      Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
      <jaxb:schemaBindings>
        <jaxb:package name="net.sourceforge.czt.zpatt.jaxb.gen">
          <jaxb:javadoc>
            &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
            &lt;html&gt;
            &lt;body&gt;
            &lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
          </jaxb:javadoc>
        </jaxb:package>
      </jaxb:schemaBindings>
      <gnast:schemaBindings name="Z Pattern">
        <gnast:package name="net.sourceforge.czt.zpatt">
          <gnast:package id="ast" name="ast" template="AstInterface.vm">
            <gnast:generate id="factory" class="ZpattFactory" template="CoreFactory.vm"/>
          </gnast:package>
          <gnast:package id="impl" name="impl" template="AstClass.vm">
            <gnast:generate id="factoryImpl" class="ZpattFactoryImpl" template="CoreFactoryImpl.vm"/>
          </gnast:package>
          <gnast:package id="visitor" name="visitor"
            template="AstVisitorInterface.vm">
            <gnast:generate id="AstVisitor" class="ZpattVisitor" template="AstVisitor.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="convFactory" class="Factory" template="Factory.vm"/>
          </gnast:package>
          <gnast:package id="jaxb" name="jaxb">
            <gnast:generate id="AstToJaxb" class="AstToJaxb" template="AstToJaxb.vm"/>
            <gnast:generate id="JaxbToAst" class="JaxbToAst" template="JaxbToAst.vm"/>
          </gnast:package>
          <gnast:package id="dom" name="dom">
            <gnast:generate id="AstToDom" class="AstToDom" template="AstToDom.vm"/>
          </gnast:package>
        </gnast:package>
      </gnast:schemaBindings>
    </xs:appinfo>
  </xs:annotation>

  <xs:import namespace="http://czt.sourceforge.net/zml" schemaLocation="Z.xsd"/>

  <xs:element name="Rule" type="P:Rule" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        This is a proof/transformation rule with one conclusion sequent
        (the FIRST in the list of sequents) and optionally, several
        antecedent sequents.  
        Each sequent has the form Context |- Fact.
        The conclusion sequent must be a PredSequent.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="Jokers" type="P:Jokers" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        This records the names that have been declared as a particular
        kind of joker.  It is used by the parser to map those names to
        the appropriate kind of JokerXXX term, but is not needed later
        when rules are being used.  It is similar in purpose to the
        LaTeX markup directives in the standard Z XML schema.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="JokerExpr"     type="P:JokerExpr"     substitutionGroup="Z:Expr"/>
  <xs:element name="JokerExprList" type="P:JokerExprList" substitutionGroup="Z:Expr"/>
  <xs:element name="JokerPred"     type="P:JokerPred"     substitutionGroup="Z:Pred"/>
  <xs:element name="JokerDeclList" type="P:JokerDeclList" substitutionGroup="Z:Decl"/>
  <xs:element name="JokerName"     type="P:JokerName"     substitutionGroup="Z:DeclName"/>

  <xs:element name="SequentContext" type="P:SequentContext">
    <xs:annotation>
      <xs:documentation>
        The left-hand-side of a sequent is a sequence
        of names and Z paragraphs.  (More design needed
        here to decide exactly how to write this and what
        restrictions are necessary).
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="Sequent" type="P:Sequent" abstract="true">
    <xs:annotation>
      <xs:documentation>
        This is a abstract superclass of all the various kinds of
	sequents that are possible in a Z rule.  Each sequent has
        the form Context |- Conclusion.  The various subclasses of
	Sequence have different kinds of conclusions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="PredSequent" type="P:PredSequent" substitutionGroup="P:Sequent">
    <xs:annotation>
      <xs:documentation>
        The conclusion of this sequent is just a Z predicate, 
        which may contain joker variables.  The sequent is true
        when the predicate is provable from the context of the sequent.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="DefnSequent" type="P:DefnSequent" substitutionGroup="P:Sequent">
    <xs:annotation>
      <xs:documentation>
        The conclusion of this sequent is Name==Expr.
        The sequent is true when the context of the sequent
        contains the definition Name==Expr.
        TODO: extend this to handle generic definitions?
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="TypeSequent" type="P:TypeSequent" substitutionGroup="P:Sequent">
    <xs:annotation>
      <xs:documentation>
        The conclusion of this sequent is Expr:Type.
        The sequent is true when the typechecker can prove
        (from the context of the sequent) that the base type
        of Expr is Type.
      </xs:documentation>
    </xs:annotation>
  </xs:element>


  <xs:complexType name="Rule">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="P:Sequent"  minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="Jokers">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element name="Name" type="xs:string"  minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="Kind" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>


  <!-- The hierarchy of sequents -->
  <xs:complexType name="SequentContext"/>

  <xs:complexType name="Sequent">
    <xs:sequence>
      <xs:element ref="P:SequentContext"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="PredSequent">
    <xs:complexContent>
      <xs:extension base="P:Sequent">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="DefnSequent">
    <xs:complexContent>
      <xs:extension base="P:Sequent">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="TypeSequent">
    <xs:complexContent>
      <xs:extension base="P:Sequent">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
          <xs:element ref="Z:Type"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="JokerExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerExprList">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerPred">
    <xs:complexContent>
      <xs:extension base="Z:Pred">
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerDeclList">
    <xs:complexContent>
      <xs:extension base="Z:Decl">
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerName">
    <xs:complexContent>
      <xs:extension base="Z:DeclName">
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:schema>
