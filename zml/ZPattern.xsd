<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  targetNamespace="http://czt.sourceforge.net/zpatt"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:P="http://czt.sourceforge.net/zpatt"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="1.0">
  <xs:annotation>
    <xs:documentation>
      This XML schema defines proof and transformation rules for 
      specifications written in the ISO Standard Z notation.
      It defines various kinds of 'Joker' AST terms, to act as named
      placeholders for expressions, predicates, declaration lists etc.,
      plus two new kinds of paragraphs: Jokers associates names with
      a particular kind of joker AST term, and Rule defines a
      proof rule (with one conclusion and possible several antecedents).

      $Id$
      
      Copyright (C) 2003, 2005 Mark Utting
      This file is part of the Community Z Tools (CZT) project.
      
      The CZT project contains free software; you can
      redistribute it and/or modify it under the terms
      of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of
      the License, or (at your option) any later version.
      
      The CZT project is distributed in the hope that it
      will be useful, but WITHOUT ANY WARRANTY; without
      even the implied warranty of MERCHANTABILITY or
      FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
      
      You should have received a copy of the GNU General
      Public License along with CZT; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place,
      Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
      <jaxb:schemaBindings>
        <jaxb:package name="net.sourceforge.czt.zpatt.jaxb.gen">
          <jaxb:javadoc>
            &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
            &lt;html&gt;
            &lt;body&gt;
            &lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
          </jaxb:javadoc>
        </jaxb:package>
      </jaxb:schemaBindings>
      <gnast:schemaBindings name="Z Pattern">
        <gnast:package name="net.sourceforge.czt.zpatt">
          <gnast:package id="ast" name="ast" template="AstInterface.vm">
            <gnast:generate id="factory" class="ZpattFactory" template="CoreFactory.vm"/>
          </gnast:package>
          <gnast:package id="impl" name="impl" template="AstClass.vm">
            <gnast:generate id="factoryImpl" class="ZpattFactoryImpl" template="CoreFactoryImpl.vm"/>
          </gnast:package>
          <gnast:package id="visitor" name="visitor"
            template="AstVisitorInterface.vm">
            <gnast:generate id="AstVisitor" class="ZpattVisitor" template="AstVisitor.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="convFactory" class="Factory" template="Factory.vm"/>
          </gnast:package>
          <gnast:package id="jaxb" name="jaxb">
            <gnast:generate id="AstToJaxb" class="AstToJaxb" template="AstToJaxb.vm"/>
            <gnast:generate id="JaxbToAst" class="JaxbToAst" template="JaxbToAst.vm"/>
          </gnast:package>
          <gnast:package id="dom" name="dom">
            <gnast:generate id="AstToDom" class="AstToDom" template="AstToDom.vm"/>
          </gnast:package>
        </gnast:package>
      </gnast:schemaBindings>
    </xs:appinfo>
  </xs:annotation>

  <xs:import namespace="http://czt.sourceforge.net/zml" schemaLocation="Z.xsd"/>

  <xs:element name="Rule" type="P:Rule" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        This is a proof/transformation rule with one conclusion sequent
        (the FIRST in the list of sequents) and optionally, several
        antecedent sequents.  
        Each sequent has the form Context |- Fact.
        The conclusion sequent must be a PredSequent.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="Jokers" type="P:Jokers" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        This records the names that have been declared as a particular
        kind of joker.  It is used by the parser to map those names to
        the appropriate kind of JokerXXX term, but is not needed later
        when rules are being used.  It is similar in purpose to the
        LaTeX markup directives in the standard Z XML schema.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="JokerExpr"     type="P:JokerExpr"     substitutionGroup="Z:Expr"/>
  <xs:element name="JokerExprList" type="P:JokerExprList" substitutionGroup="Z:ExprList"/>
  <xs:element name="JokerPred"     type="P:JokerPred"     substitutionGroup="Z:Pred"/>
  <xs:element name="JokerDeclList" type="P:JokerDeclList" substitutionGroup="Z:DeclList"/>
  <xs:element name="HeadDeclList"  type="P:HeadDeclList" substitutionGroup="Z:DeclList"/>
  <xs:element name="JokerDeclName" type="P:JokerDeclName" substitutionGroup="Z:DeclName"/>
  <xs:element name="JokerRefName"  type="P:JokerRefName"  substitutionGroup="Z:RefName"/>

  <xs:element name="Binding" type="P:Binding" abstract="true">
    <xs:annotation>
      <xs:documentation>
	Base class for the various kinds of bindings within each joker.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="JokerExprBinding"     type="P:JokerExprBinding"     substitutionGroup="P:Binding"/>
  <xs:element name="JokerExprListBinding" type="P:JokerExprListBinding" substitutionGroup="P:Binding"/>
  <xs:element name="JokerPredBinding"     type="P:JokerPredBinding"     substitutionGroup="P:Binding"/>
  <xs:element name="JokerDeclListBinding" type="P:JokerDeclListBinding" substitutionGroup="P:Binding"/>
  <xs:element name="JokerDeclNameBinding" type="P:JokerDeclNameBinding" substitutionGroup="P:Binding"/>
  <xs:element name="JokerRefNameBinding"  type="P:JokerRefNameBinding"  substitutionGroup="P:Binding"/>

  <xs:element name="SequentContext" type="P:SequentContext">
    <xs:annotation>
      <xs:documentation>
        The left-hand-side of a sequent is a sequence
        of names and Z paragraphs.  (More design needed
        here to decide exactly how to write this and what
        restrictions are necessary).
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="Deduction" type="P:Deduction">
    <xs:annotation>
      <xs:documentation>
        A deduction is an application of a Rule to a PredSequent.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="Sequent" type="P:Sequent" abstract="true">
    <xs:annotation>
      <xs:documentation>
        This is an abstract superclass of all the various kinds of
	sequents that are possible in a Z rule.  Each sequent has
        the form Context |- Conclusion.  The various subclasses of
	Sequence have different kinds of conclusions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="PredSequent"
              type="P:PredSequent"
              substitutionGroup="P:Sequent">
    <xs:annotation>
      <xs:documentation>
        The conclusion of this sequent is just a Z predicate, 
        which may contain joker variables.  The sequent is true
        when the predicate is provable from the context of the sequent.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="Proviso" type="P:Proviso"
      abstract="true" substitutionGroup="P:Sequent"/>

  <xs:element name="LookupProviso" type="P:LookupProviso"
      abstract="true" substitutionGroup="P:Proviso">
    <xs:annotation>
      <xs:documentation>
        This is the abstract base class of all the lookup provisos.
        They search the context (which includes the specification)
        for a given kind of fact.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="LookupConstDeclProviso" 
              type="P:LookupConstDeclProviso"
              substitutionGroup="P:LookupProviso">
    <xs:annotation>
      <xs:documentation>
        The conclusion of this sequent is Expr1==Expr2.
        The sequent is true when the context of the sequent
        contains the definition Name[T1,...,Tn]==Expr
        (n may equal 0).  Note that Expr1 is usually written
        as an ExprJoker in the rules, and will be bound only
        to a RefExpr by this proviso.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="LookupPredProviso"
              type="P:LookupPredProviso"
              substitutionGroup="P:LookupProviso">
    <xs:annotation>
      <xs:documentation>
        The conclusion of this sequent is simply a predicate.
        The sequent is true when the context of the sequent
        contains a predicate that unifies with this predicate.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="CheckProviso"
              type="P:CheckProviso"
              substitutionGroup="P:Proviso">
    <xs:annotation>
      <xs:documentation>
        The conclusion of this sequent is a predicate that
        contains a restricted set of known operators, which
        check membership of signatures, not-free-in conditions etc.
        The sequent is true when this predicate evaluates to true.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="CalculateProviso"
              type="P:CalculateProviso"
              substitutionGroup="P:Proviso">
    <xs:annotation>
      <xs:documentation>
        The conclusion of this sequent is written as ExprJoker==Expr,
        where Expr contains a restricted set of known operators for
        calculating sets of names and performing substitutions etc.
        When the proviso is executed, it calculates the value of
        Expr and binds ExprJoker to that value.
        TODO: We also want to allow ExprJoker to be a list of names here?
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="TypeProviso" type="P:TypeProviso" substitutionGroup="P:Proviso">
    <xs:annotation>
      <xs:documentation>
        The conclusion of this sequent is Expr:Expr2, where
        Expr2 must contain only base type constructors and
        expression jokers.
        The sequent is true when the typechecker can prove
        (from the context of the sequent) that the base type
        of Expr is Expr2.
      </xs:documentation>
    </xs:annotation>
  </xs:element>


  <xs:complexType name="Rule">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="P:Sequent"  minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="Jokers">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element name="Name" type="xs:string"  minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="Kind" type="P:JokerType"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:simpleType name="JokerType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DeclList"/>
      <xs:enumeration value="Expr"/>
      <xs:enumeration value="Name"/>
      <xs:enumeration value="Pred"/>
      <xs:enumeration value="Type"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="Deduction">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="P:Binding" minOccurs="0" maxOccurs="unbounded"/>
          <xs:element ref="P:Sequent" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- The hierarchy of sequents -->
  <xs:complexType name="SequentContext">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="Sequent">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="P:SequentContext"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="PredSequent">
    <xs:complexContent>
      <xs:extension base="P:Sequent">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
          <xs:element ref="P:Deduction" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="Proviso">
    <xs:complexContent>
      <xs:extension base="P:Sequent"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="LookupProviso">
    <xs:complexContent>
      <xs:extension base="P:Proviso"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="LookupConstDeclProviso">
    <xs:complexContent>
      <xs:extension base="P:LookupProviso">
        <xs:sequence>
          <xs:element ref="Z:Expr">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftExpr"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Expr">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightExpr"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="LookupPredProviso">
    <xs:complexContent>
      <xs:extension base="P:LookupProviso">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="CheckProviso">
    <xs:complexContent>
      <xs:extension base="P:Proviso">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="CalculateProviso">
    <xs:complexContent>
      <xs:extension base="P:Proviso">
        <xs:sequence>
          <xs:element ref="Z:Expr">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftExpr"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Expr">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightExpr"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="TypeProviso">
    <xs:complexContent>
      <xs:extension base="P:Proviso">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
          <xs:element ref="Z:Expr">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Type"/>
              </xs:appinfo>
            </xs:annotation>
	  </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="JokerExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerExprList">
    <xs:complexContent>
      <xs:extension base="Z:ExprList">
        <xs:sequence>
          <xs:element ref="Z:ZExprList"/>
        </xs:sequence>
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerPred">
    <xs:complexContent>
      <xs:extension base="Z:Pred">
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerDeclList">
    <xs:complexContent>
      <xs:extension base="Z:DeclList">
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="HeadDeclList">
    <xs:complexContent>
      <xs:extension base="Z:DeclList">
        <xs:sequence>
          <xs:element ref="Z:ZDeclList"/>
          <xs:element ref="P:JokerDeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerDeclName">
    <xs:complexContent>
      <xs:extension base="Z:DeclName">
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerRefName">
    <xs:complexContent>
      <xs:extension base="Z:RefName">
        <xs:attribute name="Name" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="Binding">
    <xs:complexContent>
      <xs:extension base="Z:RefName"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerExprBinding">
    <xs:complexContent>
      <xs:extension base="P:Binding">
        <xs:sequence>
          <xs:element ref="P:JokerExpr"/>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerExprListBinding">
    <xs:complexContent>
      <xs:extension base="P:Binding">
        <xs:sequence>
          <xs:element ref="P:JokerExprList"/>
          <xs:element ref="Z:ExprList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerPredBinding">
    <xs:complexContent>
      <xs:extension base="P:Binding">
        <xs:sequence>
          <xs:element ref="P:JokerPred"/>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerDeclListBinding">
    <xs:complexContent>
      <xs:extension base="P:Binding">
        <xs:sequence>
          <xs:element ref="P:JokerDeclList"/>
          <xs:element ref="Z:DeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerDeclNameBinding">
    <xs:complexContent>
      <xs:extension base="P:Binding">
        <xs:sequence>
          <xs:element ref="P:JokerDeclName"/>
          <xs:element ref="Z:DeclName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="JokerRefNameBinding">
    <xs:complexContent>
      <xs:extension base="P:Binding">
        <xs:sequence>
          <xs:element ref="P:JokerRefName"/>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:schema>
