<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  targetNamespace="http://czt.sourceforge.net/circus"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:CIRCUS="http://czt.sourceforge.net/circus"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="0.1">
  <xs:annotation>
  	<xs:documentation>
    	 Copyright 2005 Leonardo Freitas
        
       This XML schema defines XML markup for formal specifications 
       written in Circus, a concurrent language for refinement that
       combines CSP, Z and the refinement calculus.
       More information at http://www.cs.york.ac.uk/~leo.
       
       This file is part of the Community Z Tools (CZT) project.
 
       The CZT project contains free software; you can
       redistribute it and/or modify it under the terms
       of the GNU General Public License as published by
       the Free Software Foundation; either version 2 of
       the License, or (at your option) any later version.
 
       The CZT project is distributed in the hope that it
       will be useful, but WITHOUT ANY WARRANTY; without
       even the implied warranty of MERCHANTABILITY or
       FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.
 
       You should have received a copy of the GNU General
       Public License along with CZT; if not, write to the
       Free Software Foundation, Inc., 59 Temple Place,
       Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
		      <jaxb:schemaBindings>
		        <jaxb:package name="net.sourceforge.czt.circus.jaxb.gen">
		          <jaxb:javadoc>
		            &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
		            &lt;html&gt;
		            &lt;body&gt;
		            &lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
		            &lt;/body&gt;
		            &lt;/html&gt;
		          </jaxb:javadoc>
		        </jaxb:package>
		      </jaxb:schemaBindings>
		      <gnast:schemaBindings name="Circus">
		        <gnast:package name="net.sourceforge.czt.circus">
		          <gnast:package id="ast" name="ast">
		            <gnast:generate id="factory" class="CircusFactory" template="CoreFactory.vm"/>
		          </gnast:package>
		          <gnast:package id="impl" name="impl">
		            <gnast:generate id="factoryImpl" class="CircusFactoryImpl" template="CoreFactoryImpl.vm"/>
		          </gnast:package>
		          <gnast:package id="visitor" name="visitor">
		            <gnast:generate id="AstVisitor" class="CircusVisitor" template="AstVisitor.vm"/>
		          </gnast:package>
							<gnast:package id="util" name="util">
								<gnast:generate id="convFactory" class="Factory" template="Factory.vm"/>
							</gnast:package>
		          <gnast:package id="jaxb" name="jaxb">
		            <gnast:generate id="AstToJaxb" class="AstToJaxb" template="AstToJaxb.vm"/>
		            <gnast:generate id="JaxbToAst" class="JaxbToAst" template="JaxbToAst.vm"/>
		          </gnast:package>
		          <gnast:package id="dom" name="dom">
		            <gnast:generate id="AstToDom" class="AstToDom" template="AstToDom.vm"/>
		          </gnast:package>
		        </gnast:package>
		      </gnast:schemaBindings>
     </xs:appinfo>
  </xs:annotation>
  
  <xs:import namespace="http://czt.sourceforge.net/zml" schemaLocation="Z.xsd"/>

<!-- ******************************************************************************************* -->
<!-- ******************************************************************************************* -->

	<!-- With homogeneous namespace Z for type-checking and validation with Altova XMLSpy Home Edition 2005 -->
	<!-- It is just a textual inclusion of Z_1_3.xsd, as the home edition does not allow import clause :(  -->

<!-- ******************************************************************************************* -->
<!-- ******************************************************************************************* -->

  <!-- Circus Program Specification -->
  <xs:element name="CircusProgram" type="CIRCUS:CircusProgram">
    <xs:annotation>
      <xs:documentation>
        A Circus program specification.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  
  <!-- Circus Section -->
  <xs:element name="CircusSect" type="CIRCUS:CircusSect" substitutionGroup="Z:Sect">
    <xs:annotation>
      <xs:documentation>
        A concrete Circus section. It is similar to a concrete Z section, but starting with Circus paragraphs.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  
  <!-- Extending the (Z)Paragraph hierarchy with production BNF:CircusParagraph -->
  <!-- However, as process definitions do not allow z paragraphs different from Z:Para, we cannot derive directly from Z:Para -->
  <xs:element name="CircusPara" type="CIRCUS:CircusPara" abstract="true">
    <xs:annotation>
    	<xs:documentation>
    		An abstract Circus paragraph. We adopt the convention "CPara" as a suffix for all kinds of Circus paragraphs.
    		Available extensions are Z paragraphs outside process definitions, channel and channel set declarations,
    		and process declarations.
    	</xs:documentation>
    </xs:annotation>
  </xs:element>   
  <xs:element name="ZParaCPara" type="CIRCUS:ZParaCPara" substitutionGroup="CIRCUS:CircusPara">
    <xs:annotation>
    	<xs:documentation>
    		A Z paragraph in a Circus specification. This is a wrapper class allowing us to differentiate
    		Z paragraphs outside a process definition. Since it is not an extension of Z:Para, we are able 
    		to inforce this restriction.
    	</xs:documentation>
    </xs:annotation>
  </xs:element>     
  <xs:element name="ChannelDeclCPara" type="CIRCUS:ChannelDeclCPara" substitutionGroup="CIRCUS:CircusPara">
    <xs:annotation>
    	<xs:documentation>
    		A channel declaration that introduces channel names with corresponding types. 
    		Channels are used in process definitions.
    	</xs:documentation>
    </xs:annotation>
  </xs:element>   
  <xs:element name="ChannelDeclSExprCPara" type="CIRCUS:ChannelDeclSExprCPara" substitutionGroup="CIRCUS:CircusPara">
    <xs:annotation>
    	<xs:documentation>
    		A special channel declaration that uses declared variables from a schema expression,
    		where the predicate part of the schema is ignored.
    	</xs:documentation>
    </xs:annotation>
  </xs:element>   
  <xs:element name="CSDeclCPara" type="CIRCUS:CSDeclCPara" substitutionGroup="CIRCUS:CircusPara">
    <xs:annotation>
    	<xs:documentation>A channel set declaration that introduces a name for a channel set expression.</xs:documentation>
    </xs:annotation>
  </xs:element>     
  <xs:element name="ProcDeclCPara" type="CIRCUS:ProcDeclCPara" substitutionGroup="CIRCUS:CircusPara">
		<xs:annotation>
			<xs:documentation>A process declaration that introduces a name for a process definition.</xs:documentation>
		</xs:annotation>
  </xs:element> 
  
  <!-- Generic type channel declaration are missing -->

  <!-- Channel Set Expressions: perhaps we could avoid the last three cases. -->
  <xs:element name="CSExpression" type="CIRCUS:CSExpression" abstract="true">
    <xs:annotation>
      <xs:documentation>
      	An abstract channel set expression. Although it is formed by a Z expression,
      	channel set expressions cannot appear wherever a Z expression can. 
      	They are only allowed in parallel operators.
      	To differente this from the CZT convetion and keep a meaningful name for channel set expression, 
      	we have expanded "Expr" to "Expression".
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="CSExpressionSet" type="CIRCUS:CSExpressionSet" substitutionGroup="CIRCUS:CSExpression">
		<xs:annotation>
			<xs:documentation>A channel set expression containing declared channel names (i.e. channel references).</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="CSExpressionRef" type="CIRCUS:CSExpressionRef" substitutionGroup="CIRCUS:CSExpression">
		<xs:annotation>
			<xs:documentation>A channel set expression referencing a declared channel set.</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="CSExpression2" type="CIRCUS:CSExpression2" abstract="true" substitutionGroup="CIRCUS:CSExpression">
    <xs:annotation>
      <xs:documentation>An abstract binary channel set expression.</xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="CSExpressionUnion" type="CIRCUS:CSExpression2" substitutionGroup="CIRCUS:CSExpression2">
		<xs:annotation>
			<xs:documentation>Set union over channel set expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="CSExpressionInter" type="CIRCUS:CSExpression2" substitutionGroup="CIRCUS:CSExpression2">
		<xs:annotation>
			<xs:documentation>Set intersection over channel set expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="CSExpressionDiff" type="CIRCUS:CSExpression2" substitutionGroup="CIRCUS:CSExpression2">
		<xs:annotation>
			<xs:documentation>Set difference over channel set expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>  
	
	<!-- Process Definition -->
	
  <xs:element name="PDef" type="CIRCUS:PDef" abstract="true">
		<xs:annotation>
			<xs:documentation>
				An abstract process paragraph definition. 
				We adopt the convention "PDef" as a suffix for all kinds of Process definitions.
				Available extensions are explicit process description; process call; 
				all forms of unary, binary, replicated, and indexed processes; processes involving expressions;
				and processes involving declarations.
			</xs:documentation>
		</xs:annotation>
	</xs:element>	  
  <xs:element name="DescPDef" type="CIRCUS:DescPDef" substitutionGroup="CIRCUS:PDef">
		<xs:annotation>
			<xs:documentation>
				A process description is an explicit process definition.
				It is formed by a (possibly empty) set of process paragraphs, 
				an optional process state given as a schema action,
				and a (mandatory) main action definition.
			</xs:documentation>
		</xs:annotation>
	</xs:element>		
	<xs:element name="CallPDef" type="CIRCUS:CallPDef" substitutionGroup="CIRCUS:PDef">
		<xs:annotation>
			<xs:documentation>Circus process reference call.</xs:documentation>
		</xs:annotation>
	</xs:element>		  	
  <xs:element name="PDef1" type="CIRCUS:PDef1" abstract="true" substitutionGroup="CIRCUS:PDef">
		<xs:annotation>
			<xs:documentation>An abstract unary Circus process.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="PDefE" type="CIRCUS:PDefE" abstract="true" substitutionGroup="CIRCUS:PDef1">
		<xs:annotation>
			<xs:documentation>An abstract unary Circus process involving expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="PDefD" type="CIRCUS:PDefD" abstract="true" substitutionGroup="CIRCUS:PDef1">
		<xs:annotation>
			<xs:documentation>An abstract unary Circus process with Z declarations.</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="PDefR" type="CIRCUS:PDefR" abstract="true" substitutionGroup="CIRCUS:PDefD">
		<xs:annotation>
			<xs:documentation>An abstract replicated Circus process with Z declarations.</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="PDefRI" type="CIRCUS:PDefRI" abstract="true" substitutionGroup="CIRCUS:PDefD">
		<xs:annotation>
			<xs:documentation>An abstract indexed and replicated Circus process with Z declarations.</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="PDef2" type="CIRCUS:PDef2" abstract="true" substitutionGroup="CIRCUS:PDef">
		<xs:annotation>
			<xs:documentation>An abstract binary Circus process.</xs:documentation>
		</xs:annotation>
	</xs:element>			
	
	<!-- Process Definition :: Unary  -->

	<xs:element name="HidePDef" type="CIRCUS:HidePDef" substitutionGroup="CIRCUS:PDef1">
		<xs:annotation>
			<xs:documentation>Circus process with event concealment through hiding.</xs:documentation>
		</xs:annotation>
	</xs:element>		  
	<xs:element name="RenamePDef" type="CIRCUS:RenamePDef" substitutionGroup="CIRCUS:PDef1">
		<xs:annotation>
			<xs:documentation>Circus process with channel renaming. As channels in Circus as strongly-typed, type-checking is expected here.</xs:documentation>
		</xs:annotation>
	</xs:element>		  
	<xs:element name="FormalGenPDef" type="CIRCUS:FormalGenPDef" substitutionGroup="CIRCUS:PDef1">
		<xs:annotation>
			<xs:documentation>Circus process with generic types, like in a generic axiomatic box.</xs:documentation>
		</xs:annotation>
	</xs:element>		  
	
	<!-- Process Definition :: Unary :: Expression -->
	
	<xs:element name="IntantiationPDef" type="CIRCUS:PDefE" substitutionGroup="CIRCUS:PDefE">
		<xs:annotation>
			<xs:documentation>Circus process instantiation for process defined with an indexing operator.</xs:documentation>
		</xs:annotation>
	</xs:element>		
	<xs:element name="ActualGenPDef" type="CIRCUS:PDefE" substitutionGroup="CIRCUS:PDefE">
		<xs:annotation>
			<xs:documentation>Circus process with resolved generic types.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ActualParamPDef" type="CIRCUS:PDefE" substitutionGroup="CIRCUS:PDefE">
		<xs:annotation>
			<xs:documentation>Circus process with actual parameters.</xs:documentation>
		</xs:annotation>
	</xs:element>				

	
	<!-- Process Definition :: Unary :: Declaration -->	

	<xs:element name="IndexedPDef" type="CIRCUS:PDefD" substitutionGroup="CIRCUS:PDefD">
		<xs:annotation>
			<xs:documentation>Circus process indexed on given declarations.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="FormalParamPDef" type="CIRCUS:PDefD" substitutionGroup="CIRCUS:PDefD">
		<xs:annotation>
			<xs:documentation>Circus process with formal parameters.</xs:documentation>
		</xs:annotation>
	</xs:element>				

	<!-- Process Definition :: Unary :: Declaration :: Replicated -->	

	<xs:element name="SeqPDefR" type="CIRCUS:PDefR" substitutionGroup="CIRCUS:PDefR">
		<xs:annotation>
			<xs:documentation>Circus process for replicated sequential composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="IntChoicePDefR" type="CIRCUS:PDefR" substitutionGroup="CIRCUS:PDefR">
		<xs:annotation>
			<xs:documentation>Circus process for replicated internal choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ExtChoicePDefR" type="CIRCUS:PDefR" substitutionGroup="CIRCUS:PDefR">
		<xs:annotation>
			<xs:documentation>Circus process for replicated external choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="InterleavePDefR" type="CIRCUS:PDefR" substitutionGroup="CIRCUS:PDefR">
		<xs:annotation>
			<xs:documentation>Circus process for replicated interleaving.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ParallelPDefR" type="CIRCUS:ParallelPDefR" substitutionGroup="CIRCUS:PDefR">
		<xs:annotation>
			<xs:documentation>Circus process for replicated parallel composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				

	<!-- Process Definition :: Unary :: Declaration :: Replicated :: Indexed -->	
	
	<xs:element name="SeqPDefRI" type="CIRCUS:PDefRI" substitutionGroup="CIRCUS:PDefRI">
		<xs:annotation>
			<xs:documentation>Circus process for indexed and replicated sequential composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="IntChoicePDefRI" type="CIRCUS:PDefRI" substitutionGroup="CIRCUS:PDefRI">
		<xs:annotation>
			<xs:documentation>Circus process for indexed and replicated internal choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ExtChoicePDefRI" type="CIRCUS:PDefRI" substitutionGroup="CIRCUS:PDefRI">
		<xs:annotation>
			<xs:documentation>Circus process for indexed and replicated external choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="InterleavePDefRI" type="CIRCUS:PDefRI" substitutionGroup="CIRCUS:PDefRI">
		<xs:annotation>
			<xs:documentation>Circus process for indexed and replicated interleaving.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ParallelPDefRI" type="CIRCUS:ParallelPDefRI" substitutionGroup="CIRCUS:PDefRI">
		<xs:annotation>
			<xs:documentation>Circus process for indexed and replicated parallel composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				

	<!-- Process Definition :: Binary -->	
	
	<xs:element name="SeqPDef2" type="CIRCUS:PDef2" substitutionGroup="CIRCUS:PDef2">
		<xs:annotation>
			<xs:documentation>Circus process for sequential composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="IntChoicePDef2" type="CIRCUS:PDef2" substitutionGroup="CIRCUS:PDef2">
		<xs:annotation>
			<xs:documentation>Circus process for internal choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ExtChoicePDef2" type="CIRCUS:PDef2" substitutionGroup="CIRCUS:PDef2">
		<xs:annotation>
			<xs:documentation>Circus process for external choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="InterleavePDef2" type="CIRCUS:PDef2" substitutionGroup="CIRCUS:PDef2">
		<xs:annotation>
			<xs:documentation>Circus process for interleaving.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ParallelPDef2" type="CIRCUS:ParallelPDef2" substitutionGroup="CIRCUS:PDef2">
		<xs:annotation>
			<xs:documentation>Circus process for parallel composition; it includes the synchronisation set.</xs:documentation>
		</xs:annotation>
	</xs:element>				

	<!-- Process Paragraphs -->
	
  <xs:element name="ProcPara" type="CIRCUS:ProcPara" abstract="true">
		<xs:annotation>
			<xs:documentation>
				An abstract process paragraph. 
				We adopt the convention "PPara" as a suffix for all kinds of paragraphs local to Processes.				
				Available extensions are Z paragraphs within a process description, and action and name set declarations.
			</xs:documentation>
		</xs:annotation>
	</xs:element>	  
  <xs:element name="ZParaPPara" type="CIRCUS:ZParaPPara" substitutionGroup="CIRCUS:ProcPara">
		<xs:annotation>
			<xs:documentation>
				A Z paragraph contained into a process definition. We need to declare it separately in order 
				ensure that a Z paragraph placed inside a process is also a process paragraph.
				That is different from a Z paragraph outside a process definition (see ZParaCPara).
				Both classes are needed in order to allow differentiation of Z paragraphs at different point 
				in the AST hierarchy.				
			</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="NSDeclPPara" type="CIRCUS:NSDeclPPara" substitutionGroup="CIRCUS:ProcPara">
    <xs:annotation>
    	<xs:documentation>A name set definition introduces a name (or reference) for a name set expression.</xs:documentation>
    </xs:annotation>
  </xs:element>     
  <xs:element name="ActDeclPPara" type="CIRCUS:ActDeclPPara" substitutionGroup="CIRCUS:ProcPara">
		<xs:annotation>
			<xs:documentation>An action declaration introduces a name for an action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>	
	

  <!-- Name Set Expressions: we might not give equivalent complexTypes to name and channel set expressions 				 -->
  <!-- 											 because CSExpression could possibly need to calculate the extensions/productions (FDR-like) -->
  <xs:element name="NSExpression" type="CIRCUS:NSExpression" abstract="true">
    <xs:annotation>
      <xs:documentation>
      	An abstract name set expression.
      	Although it is formed by a Z expression, name set expressions 
      	cannot appear wherever a Z expression can, hence we need TermA as the substitution group. 
				They are only allowed in parallel operators.
				To differente this from the CZT convetion and keep a meaningful name for channel set expression, 
				we have expanded "Expr" to "Expression".
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="NSExpressionSet" type="CIRCUS:NSExpressionSet" substitutionGroup="CIRCUS:NSExpression">
		<xs:annotation>
			<xs:documentation>A name set expression containing user state name set partition (i.e. user state variable name references).</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="NSExpressionRef" type="CIRCUS:NSExpressionRef" substitutionGroup="CIRCUS:NSExpression">
		<xs:annotation>
			<xs:documentation>A name set expression referencing a declared name set.</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="NSExpression2" type="CIRCUS:NSExpression2" abstract="true" substitutionGroup="CIRCUS:NSExpression">
    <xs:annotation>
      <xs:documentation>An abstract binary name set expression.</xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="NSExpressionUnion" type="CIRCUS:NSExpression2" substitutionGroup="CIRCUS:NSExpression2">
		<xs:annotation>
			<xs:documentation>Set union over name set expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="NSExpressionInter" type="CIRCUS:NSExpression2" substitutionGroup="CIRCUS:NSExpression2">
		<xs:annotation>
			<xs:documentation>Set intersection over name set expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="NSExpressionDiff" type="CIRCUS:NSExpression2" substitutionGroup="CIRCUS:NSExpression2">
		<xs:annotation>
			<xs:documentation>Set difference over name set expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>  


	<!-- Action Definition -->
	
  <xs:element name="ActDef" type="CIRCUS:ActDef" abstract="true">
		<xs:annotation>
			<xs:documentation>
				An abstract action definition.
				We adopt the convention "ADef" as a suffix for all kinds of Action definitions.
				Available extensions are action call; schema actions; and all forms of CSP actions.				
			</xs:documentation>
		</xs:annotation>
	</xs:element>	  
  <xs:element name="CallADef" type="CIRCUS:CallADef" substitutionGroup="CIRCUS:ActDef">
		<xs:annotation>
			<xs:documentation>Reference to an action call (i.e. recursion unfolding).</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="SchTextADef" type="CIRCUS:SchTextADef" substitutionGroup="CIRCUS:ActDef">
		<xs:annotation>
			<xs:documentation>An action given as a schema text.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="CSPADef" type="CIRCUS:CSPADef" abstract="true" substitutionGroup="CIRCUS:ActDef">
		<xs:annotation>
			<xs:documentation>An abstract CSP action.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="CSPADef1" type="CIRCUS:CSPADef1" abstract="true" substitutionGroup="CIRCUS:CSPADef">
		<xs:annotation>
			<xs:documentation>An abstract unary CSP action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="CSPADefD" type="CIRCUS:CSPADefD" abstract="true" substitutionGroup="CIRCUS:CSPADef1">
		<xs:annotation>
			<xs:documentation>An abstract unary CSP action definition with declarations.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="CSPADefR" type="CIRCUS:CSPADefR" abstract="true" substitutionGroup="CIRCUS:CSPADefD">
		<xs:annotation>
			<xs:documentation>An abstract replicated unary CSP action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="CSPADef2" type="CIRCUS:CSPADef2" abstract="true" substitutionGroup="CIRCUS:CSPADef">
		<xs:annotation>
			<xs:documentation>An abstract binary CSP action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="CmdADef" type="CIRCUS:CmdADef" abstract="true" substitutionGroup="CIRCUS:ActDef">
		<xs:annotation>
			<xs:documentation>
				An abstract command action definition.
				We adopt the convention "CmdADef" as a suffix for all kinds of Command Action definitions.
				Available extensions are specification statement in Carroll Morgan's style; (possibly multiple) assignment;
				if guards in Dijkstra's style; and (possibly multiple) variable declaration.
			</xs:documentation>
		</xs:annotation>
	</xs:element>		
	
	<!-- CSP Action :: Basic -->
	
  <xs:element name="BasicCSPADef" type="CIRCUS:BasicCSPADef" abstract="true" substitutionGroup="CIRCUS:CSPADef">
		<xs:annotation>
			<xs:documentation>An abstract basic CSP action.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="SkipADef" type="CIRCUS:BasicCSPADef" substitutionGroup="CIRCUS:BasicCSPADef">
		<xs:annotation>
			<xs:documentation>Basic CSP action for termination.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="StopADef" type="CIRCUS:BasicCSPADef" substitutionGroup="CIRCUS:BasicCSPADef">
		<xs:annotation>
			<xs:documentation>Basic CSP action for deadlock.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="ChaosADef" type="CIRCUS:BasicCSPADef" substitutionGroup="CIRCUS:BasicCSPADef">
		<xs:annotation>
			<xs:documentation>Basic CSP action for divergence.</xs:documentation>
		</xs:annotation>
	</xs:element>	

	<!-- CSP Action :: Unary -->

  <xs:element name="MuADef" type="CIRCUS:MuADef" substitutionGroup="CIRCUS:CSPADef1">
		<xs:annotation>
			<xs:documentation>The CSP mu operator defines a recursive action.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="GuardedADef" type="CIRCUS:GuardedADef" substitutionGroup="CIRCUS:CSPADef1">
		<xs:annotation>
			<xs:documentation>The CSP guarded action defines an action guarded by a Z predicate.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="HideADef" type="CIRCUS:HideADef" substitutionGroup="CIRCUS:CSPADef1">
		<xs:annotation>
			<xs:documentation>The CSP hide operator defines events concealment within an action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>		
  <xs:element name="PrefixingADef" type="CIRCUS:PrefixingADef" substitutionGroup="CIRCUS:CSPADef1">
		<xs:annotation>
			<xs:documentation>The CSP operator for actions prefixed with a communication.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="ActualParamADef" type="CIRCUS:ActualParamADef" substitutionGroup="CIRCUS:CSPADef1">
		<xs:annotation>
			<xs:documentation>The CSP operator for action call with actual parameters.</xs:documentation>
		</xs:annotation>
	</xs:element>		

	<!-- CSP Action :: Unary :: Declaration -->
	
	<xs:element name="FormalParamADef" type="CIRCUS:CSPADefD" substitutionGroup="CIRCUS:CSPADefD">
		<xs:annotation>
			<xs:documentation>The CSP operator for actions with formal parameters.</xs:documentation>
		</xs:annotation>
	</xs:element>		

	<!-- CSP Action :: Unary :: Declaration :: Replicated -->
	
	<xs:element name="SeqADefR" type="CIRCUS:CSPADefR" substitutionGroup="CIRCUS:CSPADefR">
		<xs:annotation>
			<xs:documentation>Circus action for replicated sequential composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="IntChoiceADefR" type="CIRCUS:CSPADefR" substitutionGroup="CIRCUS:CSPADefR">
		<xs:annotation>
			<xs:documentation>Circus action for replicated internal choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ExtChoiceADefR" type="CIRCUS:CSPADefR" substitutionGroup="CIRCUS:CSPADefR">
		<xs:annotation>
			<xs:documentation>Circus action for replicated external choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ParADefR" type="CIRCUS:ParADefR" abstract="true" substitutionGroup="CIRCUS:CSPADefR">
		<xs:annotation>
			<xs:documentation>An abstract Circus action for replicated parallel operators.</xs:documentation>
		</xs:annotation>
	</xs:element>			
	<xs:element name="InterleaveADefR" type="CIRCUS:ParADefR" substitutionGroup="CIRCUS:ParADefR">
		<xs:annotation>
			<xs:documentation>Circus action for replicated interleaving.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ParallelADefR" type="CIRCUS:ParallelADefR" substitutionGroup="CIRCUS:ParADefR">
		<xs:annotation>
			<xs:documentation>Circus action for replicated parallel composition.</xs:documentation>
		</xs:annotation>
	</xs:element>					
	
	<!-- CSP Action :: Binary -->

  <xs:element name="SeqADef" type="CIRCUS:CSPADef2" substitutionGroup="CIRCUS:CSPADef2">
		<xs:annotation>
			<xs:documentation>Sequential composition between two actions.</xs:documentation>
		</xs:annotation>
	</xs:element>		
  <xs:element name="IntChoiceADef" type="CIRCUS:CSPADef2" substitutionGroup="CIRCUS:CSPADef2">
		<xs:annotation>
			<xs:documentation>Internal choice between two actions.</xs:documentation>
		</xs:annotation>
	</xs:element>		
  <xs:element name="ExtChoiceADef" type="CIRCUS:CSPADef2" substitutionGroup="CIRCUS:CSPADef2">
		<xs:annotation>
			<xs:documentation>External choice between two actions.</xs:documentation>
		</xs:annotation>
	</xs:element>		
  <xs:element name="ParADef" type="CIRCUS:ParADef" abstract="true" substitutionGroup="CIRCUS:CSPADef2">
		<xs:annotation>
			<xs:documentation>An abstract parallel action definition; it includes the name set partitions of the state.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="InterleaveADef" type="CIRCUS:ParADef" substitutionGroup="CIRCUS:ParADef">
		<xs:annotation>
			<xs:documentation>Interleaving between two actions.</xs:documentation>
		</xs:annotation>
	</xs:element>		
  <xs:element name="ParallelADef" type="CIRCUS:ParallelADef" substitutionGroup="CIRCUS:ParADef">
		<xs:annotation>
			<xs:documentation>
				Parallel composition between two actions; it includes the channel set expression for the synchronisation set.
			</xs:documentation>
		</xs:annotation>
	</xs:element>		
	
	<!-- CSP Communication --> 
	
	<xs:element name="Comm" type="CIRCUS:Comm">
		<xs:annotation>
			<xs:documentation>A CSP communication that is part of a prefixing.</xs:documentation>
		</xs:annotation>
	</xs:element>		

	<!-- CSP Communication Parameters --> 

	<xs:element name="CommParam" type="CIRCUS:CommParam" abstract="true">
		<xs:annotation>
			<xs:documentation>
				An abstract CSP parameter that is part of a communication.
				We adopt the convention "CParam" as a suffix for all kinds of communication parameter definitions
				Available extensions are input, output, and mixed command parameters.
			</xs:documentation>
		</xs:annotation>
	</xs:element>		
	<xs:element name="InCParam" type="CIRCUS:InCParam" substitutionGroup="CIRCUS:CommParam">
		<xs:annotation>
			<xs:documentation>A CSP parameter that is part of an input communication.</xs:documentation>
		</xs:annotation>
	</xs:element>			
	<xs:element name="OutCParam" type="CIRCUS:OutCParam" substitutionGroup="CIRCUS:CommParam">
		<xs:annotation>
			<xs:documentation>A CSP parameter that is part of an output communication.</xs:documentation>
		</xs:annotation>
	</xs:element>			
	<xs:element name="MixedCParam" type="CIRCUS:MixedCParam" substitutionGroup="CIRCUS:CommParam">
		<xs:annotation>
			<xs:documentation>
				A CSP parameter that is part of mixed input and output communication with form "c?x:P!v -> A", for instance.				
			</xs:documentation>
		</xs:annotation>
	</xs:element>			
	
	<!-- Commands -->
	
  <xs:element name="SpecStmtCmdADef" type="CIRCUS:SpecStmtCmdADef" substitutionGroup="CIRCUS:CmdADef">
		<xs:annotation>
			<xs:documentation>Command declaring a specification statement in Carroll Morgan's style.</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="AssignmentCmdADef" type="CIRCUS:AssignmentCmdADef" substitutionGroup="CIRCUS:CmdADef">
		<xs:annotation>
			<xs:documentation>Command declaring a (possibly multiple) assignment.</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="IfGuardedCmdADef" type="CIRCUS:IfGuardedCmdADef" substitutionGroup="CIRCUS:CmdADef">
		<xs:annotation>
			<xs:documentation>
				Command declaring a if statement containing guarded actions in Dijkstra's style.
				Although semantically different, we can represent the AST for the production of guarded actions 
				from the BNF of if commands with the GuardedADef AST class. 
			</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="VarDeclCmdADef" type="CIRCUS:VarDeclCmdADef" substitutionGroup="CIRCUS:CmdADef">
		<xs:annotation>
			<xs:documentation>Command declaring (possibly multiple) variables local to an action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>		
	
	<!-- Miscellaneous Circus Elements--> 
  <xs:element name="AssignmentPair" type="CIRCUS:AssignmentPair">
    <xs:annotation>
      <xs:documentation>A pair containing a reference to a variable name and an expression for the assignment command.</xs:documentation>
    </xs:annotation>
  </xs:element>	

	<!-- ******************************************************************************************* -->
	<!-- ******************************************************************************************* -->
	
	<!-- Definitions of the complexTypes -->

	<!-- Circus program -->
  <xs:complexType name="CircusProgram">
    <xs:complexContent>
      <xs:extension base="Z:TermA">      
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusSect" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="Version" type="xs:string" use="optional" default="0.1"/>
        <xs:attribute name="Author" type="xs:string" use="optional"/>
        <xs:attribute name="Modified" type="xs:dateTime" use="optional"/>
        <xs:attribute name="Source" type="xs:anyURI" use="optional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
	
	<!-- Circus concrete section -->
	<xs:complexType name="CircusSect">
		<xs:complexContent>
			<xs:extension base="Z:Sect">
				<xs:sequence>
					<xs:element name="Name" type="xs:string"/>
					<xs:element ref="Z:Parent" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="CIRCUS:CircusPara" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	
	<!-- Circus paragraphs complexTypes -->
	<xs:complexType name="CircusPara">
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="ZParaCPara">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CircusPara">				
				<xs:sequence>
					<xs:element ref="Z:Para"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="ChannelDeclCPara">
		<xs:complexContent>
      <xs:extension base="CIRCUS:CircusPara">
        <xs:sequence>
					<!-- Channel names could have strokes but some restrictions might apply to avoid "?" or "!" for instance.  -->
					<!-- This perhaps goes directly into the code of the parser.																							 -->
					
					<!-- QUESTION: Should here be VarDecl? The only difference is on minOccurs="1"> -->
          <!-- <xs:element ref="Z:DeclName" minOccurs="1" maxOccurs="unbounded"/> -->
          <!-- <xs:element ref="Z:Expr"/> -->
          <xs:element ref="Z:VarDecl"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="ChannelDeclSExprCPara">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CircusPara">
				<xs:sequence>
					<xs:element ref="Z:SchExpr"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CSDeclCPara">
		<xs:complexContent>
      <xs:extension base="CIRCUS:CircusPara">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:CSExpression"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>				
	<xs:complexType name="ProcDeclCPara">
		<xs:complexContent>
      <xs:extension base="CIRCUS:CircusPara">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:PDef"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>
		
	<!-- Channel Set Expression complexTyzpes -->	
	<xs:complexType name="CSExpression">
		<xs:complexContent>
	    <xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="CSExpressionSet">
		<xs:complexContent>
      <xs:extension base="CIRCUS:CSExpression">
        <xs:sequence>
					<!-- Channel names could have strokes whenever they come from Schema expressions.  -->
					<!-- However, I don't know how input/output variables decorations are supposed to  -->
					<!-- be handled in channel declarations. -->
					<!-- At the moment, just leave it as RefName and restrict that in the code perhaps -->
          <xs:element ref="Z:RefName" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CSExpressionRef">
		<xs:complexContent>
      <xs:extension base="CIRCUS:CSExpression">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CSExpression2">
		<xs:complexContent>
	    <xs:extension base="CIRCUS:CSExpression">
				<xs:sequence>
					<xs:element name="LeftCSExpr" type="CIRCUS:CSExpression"/>
					<xs:element name="RightCSExpr" type="CIRCUS:CSExpression"/>
				</xs:sequence>		
			</xs:extension>				
		</xs:complexContent>
	</xs:complexType>			
	
	<!-- Process Definition complexType -->
	
	<xs:complexType name="PDef">
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CallPDef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDef">
				<xs:sequence>
					<xs:element ref="Z:RefName"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="DescPDef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDef">
				<!-- As it can appear in any order, does it matter to put here xs:any instead? -->
				<xs:sequence>
					<!-- <xs:element name="StateSchTextADef" type="CIRCUS:SchTextADef" minOccurs="0"/> -->
					<!-- Reference to a previously declared schema name; must enforce that the  -->					
					<xs:element name="StateSchemaRefName" type="Z:RefName"/>
					<xs:element ref="CIRCUS:ProcPara" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="MainAction" type="CIRCUS:ActDef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="PDef1">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDef">
				<xs:sequence>
					<xs:element ref="CIRCUS:PDef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="PDefE">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDef1">
				<xs:sequence>
					<xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="PDefD">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDef1">
				<xs:sequence>
					<!-- QUESTION: Should here be VarDecl? The only difference is on minOccurs="1"> -->
          <!-- <xs:element ref="Z:DeclName" minOccurs="1" maxOccurs="unbounded"/> -->
          <!-- <xs:element ref="Z:Expr"/> -->
          <xs:element ref="Z:VarDecl"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="PDefR">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDefD"/>
		</xs:complexContent>
	</xs:complexType>		
	<!-- Should PDefRI derive from PDefR? Think about it. Perhaps not. -->
	<xs:complexType name="PDefRI">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDefD"/>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="PDef2">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDef">
				<xs:sequence>
					<xs:element ref="CIRCUS:PDef">
						<xs:annotation>
							<xs:appinfo>
								<jaxb:property name="LeftProc"/>
							</xs:appinfo>
						</xs:annotation>
					</xs:element>
					<xs:element ref="CIRCUS:PDef">
					 <xs:annotation>
							<xs:appinfo>
								<jaxb:property name="RightProc"/>
							</xs:appinfo>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		

	<!-- Process Definition :: Unary -->
	
	<xs:complexType name="HidePDef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDef1">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpression"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>				
	<xs:complexType name="RenamePDef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDef1">
				<xs:sequence>
					<xs:element name="OldNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
					<xs:element name="NewNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="FormalGenPDef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDef1">
				<xs:sequence>
					<xs:element name="FormalGenTypes" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>				

	<!-- Process Definition :: Unary :: Declaration :: Replicated -->		
	
	<xs:complexType name="ParallelPDefR">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDefR">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpression"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>					

	<!-- Process Definition :: Unary :: Declaration :: Replicated :: Indexed -->		
	
	<xs:complexType name="ParallelPDefRI">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDefRI">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpression"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>					

	<!-- Process Definition :: Binary -->	
	
	<xs:complexType name="ParallelPDef2">
		<xs:complexContent>
			<xs:extension base="CIRCUS:PDef2">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpression"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>				
	
	<!-- Process Paragraphs complexTypes -->
	
	<xs:complexType name="ProcPara">
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>	
	<xs:complexType name="ZParaPPara">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcPara">
				<xs:sequence>					
					<xs:element ref="Z:Para"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="NSDeclPPara">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcPara">
				<xs:sequence>					
					<xs:element ref="Z:DeclName"/>
					<xs:element ref="CIRCUS:NSExpression"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActDeclPPara">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcPara">
				<xs:sequence>					
					<xs:element ref="Z:DeclName"/>
					<xs:element ref="CIRCUS:ActDef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<!-- Name Set Expression complexTyzpes -->	
	<xs:complexType name="NSExpression">
		<xs:complexContent>
	    <xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="NSExpressionSet">
		<xs:complexContent>
      <xs:extension base="CIRCUS:NSExpression">
        <xs:sequence>
          <xs:element ref="Z:RefName" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NSExpressionRef">
		<xs:complexContent>
      <xs:extension base="CIRCUS:NSExpression">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NSExpression2">
		<xs:complexContent>
	    <xs:extension base="CIRCUS:NSExpression">
				<xs:sequence>
					<xs:element name="LeftNSExpression" type="CIRCUS:NSExpression"/>
					<xs:element name="RightNSExpression" type="CIRCUS:NSExpression"/>
				</xs:sequence>		
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>				
	
	<!-- Action Definition complexType -->
	
	<xs:complexType name="ActDef">
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="CallADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ActDef">
				<xs:sequence>
					<!-- Action names are not supposed to have strokes, but are indeed reference to names -->
					<!-- At the moment, just leave it as RefName and restrict that in the code perhaps    -->
					<xs:element ref="Z:RefName"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>	
	<xs:complexType name="SchTextADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ActDef">			
				<xs:sequence>
					<!-- QUESTION: Should here be Z:SchExpr instead of SchText? yes, we want an action to be an expression. -->
				  <!-- <xs:element ref="Z:SchText"/> -->
				  <xs:element ref="Z:SchExpr"/>
        </xs:sequence>
      </xs:extension>  
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CSPADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ActDef"/>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CSPADef1">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPADef">
				<xs:sequence>
					<xs:element ref="CIRCUS:ActDef"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CSPADefD">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPADef1">
				<xs:sequence>
					<!-- QUESTION: Should here be VarDecl? The only difference is on minOccurs="1"> -->
          <!-- <xs:element ref="Z:DeclName" minOccurs="1" maxOccurs="unbounded"/> -->
          <!-- <xs:element ref="Z:Expr"/> -->
          <xs:element ref="Z:VarDecl"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CSPADefR">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPADefD"/>
		</xs:complexContent>
	</xs:complexType>		
  <xs:complexType name="CSPADef2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CSPADef">
        <xs:sequence>        	
          <xs:element ref="CIRCUS:ActDef">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ActDef">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>	
	<xs:complexType name="CmdADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ActDef"/>
		</xs:complexContent>
	</xs:complexType>		
	
	<!-- CSP Action complexType -->
	
	<xs:complexType name="BasicCSPADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPADef"/>
		</xs:complexContent>
	</xs:complexType>		
	
	<!-- CSP Action complexType :: Unary -->
	
	<xs:complexType name="MuADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPADef1">
				<xs:sequence>
					<xs:element ref="Z:DeclName"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="GuardedADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPADef1">
				<xs:sequence>
					<xs:element ref="Z:Pred"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="HideADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPADef1">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpression"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="PrefixingADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPADef1">
				<xs:sequence>
					<xs:element ref="CIRCUS:Comm"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="ActualParamADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPADef1">
				<xs:sequence>
					<xs:element ref="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>				

	<!-- CSP Action complexType :: Unary :: Declaration :: Replicated -->

	<xs:complexType name="ParADefR">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPADefR">
				<xs:sequence>
					<xs:element ref="CIRCUS:NSExpression">
					 <xs:annotation>
							<xs:appinfo>
								<jaxb:property name="LeftNS"/>
							</xs:appinfo>
						</xs:annotation>
					</xs:element>
					<xs:element ref="CIRCUS:NSExpression">
					 <xs:annotation>
							<xs:appinfo>
								<jaxb:property name="RightNS"/>
							</xs:appinfo>
						</xs:annotation>
					</xs:element>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="ParallelADefR">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ParADefR">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpression"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		  


	<!-- CSP Action complexType :: Binary -->

	<xs:complexType name="ParADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPADef2">
				<xs:sequence>
					<xs:element ref="CIRCUS:NSExpression">
						 <xs:annotation>
								<xs:appinfo>
									<jaxb:property name="LeftNS"/>
								</xs:appinfo>
							</xs:annotation>
						</xs:element>
					<xs:element ref="CIRCUS:NSExpression">
						 <xs:annotation>
								<xs:appinfo>
									<jaxb:property name="RightNS"/>
								</xs:appinfo>
							</xs:annotation>
						</xs:element>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="ParallelADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ParADef">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpression"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		  

	<!-- CSP Communication complexType -->
	
	<xs:complexType name="Comm">
		<xs:complexContent>
			<xs:extension base="Z:TermA">
				<xs:sequence>
					<xs:element name="ChanName" type="Z:RefName"/>
					<xs:element name="ChanCommParams" type="CIRCUS:CommParam" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="CommType" type="CIRCUS:CommType" use="optional" default="Synch"/>
				<xs:attribute name="MultiSych" type="xs:nonNegativeInteger" use="optional" default="0"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="CommType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Synch"/>
			<xs:enumeration value="Input"/>
			<xs:enumeration value="Output"/>
			<xs:enumeration value="Mixed"/>
		</xs:restriction>
	</xs:simpleType>	
	
	<!-- CSP Communication parameters complexType -->
	
	<xs:complexType name="CommParam">
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="InCParam">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CommParam">
				<xs:sequence>
					<xs:element name="Variable" type="Z:RefName"/>
					<xs:element name="Restriction" type="Z:Pred" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OutCParam">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CommParam">
				<xs:sequence>
					<xs:element name="Expression" type="Z:Expr"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>	
	<xs:complexType name="MixedCParam">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CommParam">
				<xs:sequence>
					<!-- At least one In or Out must be available; but in (or out) only is allowed. Can this be guaranteed at the schema? -->					
					<!-- Here the order does not matter, hence it could have been a xs any instead. -->
					<xs:element ref="CIRCUS:InCParam" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="CIRCUS:OutCParam" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>	

	<!-- CSP Commands complextype -->	

	<xs:complexType name="SpecStmtCmdADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CmdADef">
				<xs:sequence>				
					<xs:element name="Frame" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
					<xs:element name="Pre" type="Z:Pred"/>
					<xs:element name="Post" type="Z:Pred"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		  
	<xs:complexType name="AssignmentCmdADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CmdADef">
				<xs:sequence>				
					<!-- QUESTION: How to enforce that the card(LHS) = card(RHS)? Defining a pair?-->
					<!-- <xs:element name="LHS" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/> -->
					<!-- <xs:element name="RHS" type="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>		 -->
					<xs:element ref="CIRCUS:AssignmentPair" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		  
	<xs:complexType name="IfGuardedCmdADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CmdADef">
				<xs:sequence>									
					<xs:element name="GuardedActions" type="CIRCUS:GuardedADef" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		  
  <xs:complexType name="VarDeclCmdADef">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CmdADef">
				<xs:sequence>				
					<!-- Should here be VarDecl or DeclNames (unbounded) + Expr? -->
					<xs:element ref="Z:VarDecl"/>
					<xs:element ref="CIRCUS:ActDef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		  

	<!-- Miscellaneous Circus Elements -->
	
	<!-- Defined like NameExprPair from Z_1_3.xsd,v 1.1 2004/08/23 01:59:59; mixed=false, seems to make GnAST extend Term and not TermA -->
	<xs:complexType name="AssignmentPair" mixed="false">
		<xs:sequence>				
			<xs:element name="LHS" type="Z:RefName"/> 
			<xs:element name="RHS" type="Z:Expr"/>		 
		</xs:sequence>
	</xs:complexType>		  
  
</xs:schema>
