<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  targetNamespace="http://czt.sourceforge.net/circus"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:CIRCUS="http://czt.sourceforge.net/circus"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="0.1">
  <xs:annotation>
    <xs:documentation>
      Copyright 2005 Leonardo Freitas
      $Id$

      This XML schema defines XML markup for formal specifications 
      written in Circus, a concurrent language for refinement that
      combines CSP, Z and the refinement calculus.
      More information at http://www.cs.york.ac.uk/~leo.

      This file is part of the Community Z Tools (CZT) project.
 
      The CZT project contains free software; you can
      redistribute it and/or modify it under the terms
      of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of
      the License, or (at your option) any later version.
 
      The CZT project is distributed in the hope that it
      will be useful, but WITHOUT ANY WARRANTY; without
      even the implied warranty of MERCHANTABILITY or
      FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.

      You should have received a copy of the GNU General
      Public License along with CZT; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place,
      Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
      <jaxb:schemaBindings>
        <jaxb:package name="net.sourceforge.czt.circus.jaxb.gen">
          <jaxb:javadoc>
            &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
            &lt;html&gt;
            &lt;body&gt;
            &lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
          </jaxb:javadoc>
        </jaxb:package>
      </jaxb:schemaBindings>
      <gnast:schemaBindings name="Circus">
        <gnast:package name="net.sourceforge.czt.circus">
          <gnast:package id="ast" name="ast">
            <gnast:generate id="factory" class="CircusFactory" template="CoreFactory.vm"/>
          </gnast:package>
          <gnast:package id="impl" name="impl">
            <gnast:generate id="factoryImpl" class="CircusFactoryImpl" template="CoreFactoryImpl.vm"/>
          </gnast:package>
          <gnast:package id="visitor" name="visitor">
            <gnast:generate id="AstVisitor" class="CircusVisitor" template="AstVisitor.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="convFactory" class="Factory" template="Factory.vm"/>
          </gnast:package>
          <gnast:package id="jaxb" name="jaxb">
            <gnast:generate id="AstToJaxb" class="AstToJaxb" template="AstToJaxb.vm"/>
            <gnast:generate id="JaxbToAst" class="JaxbToAst" template="JaxbToAst.vm"/>
          </gnast:package>
          <gnast:package id="dom" name="dom">
            <gnast:generate id="AstToDom" class="AstToDom" template="AstToDom.vm"/>
          </gnast:package>
        </gnast:package>
      </gnast:schemaBindings>
    </xs:appinfo>
  </xs:annotation>

  <xs:import namespace="http://czt.sourceforge.net/zml" schemaLocation="Z.xsd"/>

  <!-- ************************************************************ -->
  <!-- Definitions of the elements                                  -->
  <!-- ************************************************************ -->

  <!-- Paragraphs -->
  <xs:element name="ChannelPara" type="CIRCUS:ChannelPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A channel declaration that introduces channel names
        with corresponding types. 
        Channels are used in process definitions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ChannelSetPara" type="CIRCUS:ChannelSetPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A channel set declaration that introduces a name
        for a channel set expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessPara" type="CIRCUS:ProcessPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A process declaration that introduces a name
        for a process definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Generic type channel declaration are missing -->

  <!-- Channel Set Expressions: perhaps avoid the last three cases? -->
  <xs:element name="ChannelSet" type="CIRCUS:ChannelSet" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract channel set expression. Although it is formed by
        a Z expression, channel set expressions cannot appear
        wherever a Z expression can.  They are only allowed in
        parallel operators.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="BasicChannelSet" type="CIRCUS:BasicChannelSet" substitutionGroup="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        A channel set expression containing declared channel names
        (i.e. channel references).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="RefChannelSet" type="CIRCUS:RefChannelSet" substitutionGroup="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        A channel set expression referencing a declared channel set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ChannelSet2" type="CIRCUS:ChannelSet2" abstract="true" substitutionGroup="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        An abstract binary channel set expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="UnionChannelSet" type="CIRCUS:ChannelSet2" substitutionGroup="CIRCUS:ChannelSet2">
    <xs:annotation>
      <xs:documentation>
        Set union over channel set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntersectChannelSet" type="CIRCUS:ChannelSet2" substitutionGroup="CIRCUS:ChannelSet2">
    <xs:annotation>
      <xs:documentation>
        Set intersection over channel set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="DifferenceChannelSet" type="CIRCUS:ChannelSet2" substitutionGroup="CIRCUS:ChannelSet2">
    <xs:annotation>
      <xs:documentation>
        Set difference over channel set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

	<!-- Process Description -->	
	
	<xs:element name="ProcessDesc" type="CIRCUS:ProcessDesc" abstract="true">
		<xs:annotation>
			<xs:documentation>
				An abstract process description.
				Available extensions process definition, parameterised process, and indexed process.
			</xs:documentation>
		</xs:annotation>
  </xs:element>
  <xs:element name="ParamProcessDesc" type="CIRCUS:ParamProcessDesc" substitutionGroup="CIRCUS:ProcessDesc">
    <xs:annotation>
      <xs:documentation>
        A parameterised process description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IndexedProcessDesc" type="CIRCUS:ParamProcessDesc" substitutionGroup="CIRCUS:ParamProcessDesc">
    <xs:annotation>
      <xs:documentation>
        An indexed process description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="ProcessDef" type="CIRCUS:ProcessDef" abstract="true" substitutionGroup="CIRCUS:ProcessDesc">
		<xs:annotation>
			<xs:documentation>
				An abstract process definition. It is a kind of process description without parameters or indexation.
				Available extensions are explicit process description; process call;
				all forms of unary, binary, replicated, and indexed processes;
				processes involving expressions; and processes involving declarations.
				Process would be a nicer name but this conflicts with the interface
				java.lang.Process.
			</xs:documentation>
		</xs:annotation>
  </xs:element>


  <!-- Process Definition -->  
  <xs:element name="BasicProcess" type="CIRCUS:BasicProcess" substitutionGroup="CIRCUS:ProcessDef">
    <xs:annotation>
      <xs:documentation>
        A process description is an explicit process definition.
        It is formed by a (possibly empty) set of process paragraphs,
        an optional process state given as a schema action,
        and a (mandatory) main action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Process1" type="CIRCUS:Process1" abstract="true" substitutionGroup="CIRCUS:ProcessDef">
    <xs:annotation>
      <xs:documentation>
        An abstract unary Circus process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="ProcessD" type="CIRCUS:ProcessD" abstract="true" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        An abstract Circus process with Z declarations.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessR" type="CIRCUS:ProcessR" abstract="true" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        An abstract replicated Circus process with Z declarations.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessRI" type="CIRCUS:ProcessRI" abstract="true" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        An abstract indexed and replicated Circus process with Z declarations.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Process2" type="CIRCUS:Process2" abstract="true" substitutionGroup="CIRCUS:ProcessDef">
    <xs:annotation>
      <xs:documentation>
        An abstract binary Circus process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
	<xs:element name="RenameProcess" type="CIRCUS:RenameProcess" substitutionGroup="CIRCUS:ProcessDef">
		<xs:annotation>
			<xs:documentation>
				Circus process with channel renaming. As channels in Circus are strongly-typed, type-checking is expected here.				
			</xs:documentation>
		</xs:annotation>
	</xs:element>


	<!-- Process Definition :: Calls -->

	<!-- DESIGN DECISION: There are two approaches here: the first is an unambigous and demands specialised CallType attribute on 
											 CallProcess; whereas the second introduces ambiguity and requires no special type of call. 

										 1) In the production tree, one is allowed to use a ProcessDesc for renaming (ProcessDesc[N^+ := N^+]). 	  									 			  									 		
												This allowed the definition of renaming on-the-fly (unamed) or via a call process.	  									 		
												Ex:  (c?x \then Skip)[c := b] or P = (c?x \then Skip), Q = P[c := b].	  									 		
												On the second case via CallProcess it means that the ProcessDef descendent of ProcessDesc is being selected.
												In turn, the type of ProcessDef is CallProcess and the list of renaming names are under RenameProcess.

												This allows both indexed and parameterised processes to use renaming because renaming used 
												ProcessDesc instead of Process1 on its complexType.	  									 	  
												For indexed and parameterised processes however, we cannot use ProcessDesc because 
												a parameterised process with "\lfloor Expr^+ \rfloor", or an indexed process with "( Expr^+ )" 
												are meaningless.  Therefore, we need to introduce the explicit type of calls for different kinds of 
												processes. 

												Tidying up everything we have the CallType attribute and the appropriate complexType definition for
												RenameProcess, InstantiationProcess, ActualParamProcess as

												RenameProcess 				-> uses ProcessDesc.
												InstantiationProcess	-> uses IndexedProcessDesc
												ActualParamProcess		-> uses ParamProcessDesc

										 2) An alternative would be to have the production of ProcessDesc defined as follows:

												ProcessDesc ::= ParamProcessDesc | IndexedProcessDesc
												ParamProcessDesc ::= Decl \spot ProcessDef | ProcessDef
												IndexedProcessDesc ::= Decl \odot ProcessDef | ProcessDef

												This would remove the special CallType for Indexed and parameterised process but not generic 
												type instantiation tough.
										 -->
  <xs:element name="CallProcess" type="CIRCUS:CallProcess" substitutionGroup="CIRCUS:ProcessDef">
    <xs:annotation>
      <xs:documentation>
      	Circus process reference call. 
      	It contains a reference name to lookup the process definition.
      	Moreover, it contains a list of expressions and an attribute defining the kind of call this reference is related too.
      	An empty list of expressions means a simple process call ``N''.
      	If the list of expressions is not empty, then the CallType attribute defines if this is an indexed 
      	process instantiation call, a parameterised process call, or a generic process instantiation call.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition :: Unary  -->
  <xs:element name="HideProcess" type="CIRCUS:HideProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        Circus process with event concealment through hiding.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process Definition :: ProcessDesc -->
  
  <xs:element name="ProcessE" type="CIRCUS:ProcessE" abstract="true" substitutionGroup="CIRCUS:ProcessDef">
    <xs:annotation>
      <xs:documentation>
        An abstract Circus process involving expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InstantiationProcess" type="CIRCUS:InstantiationProcess" substitutionGroup="CIRCUS:ProcessE">
    <xs:annotation>
      <xs:documentation>
        Defines a indexed Circus process on-the-fly with its actual instantiation
        This enables on-the-fly declaration of indexed parameterised processes.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
	<xs:element name="ActualParamProcess" type="CIRCUS:ActualParamProcess" substitutionGroup="CIRCUS:ProcessE">
		<xs:annotation>
			<xs:documentation>
				Defines a parameterised Circus process on-the-fly with its actual parameter.
				This enables on-the-fly declaration of parameterised indexed processes.
				
				Ex: (x: T \spot c.x \then Skip)~(0) \equiv c.0 \then Skip.
				Note that this is different from a parameterised process description with a reference name calling 
				it with the given actual parameters.
				Ex: P = (x: T \spot c.x \then Skip).
						Q = P~(0).
			</xs:documentation>
		</xs:annotation>
  </xs:element>

  <!-- Process Definition :: Unary :: Declaration :: Replicated -->
  <xs:element name="SeqProcessR" type="CIRCUS:ProcessR" substitutionGroup="CIRCUS:ProcessR">
    <xs:annotation>
      <xs:documentation>
        Circus process for replicated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcessR" type="CIRCUS:ProcessR" substitutionGroup="CIRCUS:ProcessR">
    <xs:annotation>
      <xs:documentation>
        Circus process for replicated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcessR" type="CIRCUS:ProcessR" substitutionGroup="CIRCUS:ProcessR">
    <xs:annotation>
      <xs:documentation>
        Circus process for replicated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcessR" type="CIRCUS:ProcessR" substitutionGroup="CIRCUS:ProcessR">
    <xs:annotation>
      <xs:documentation>
        Circus process for replicated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcessR" type="CIRCUS:ParallelProcessR" substitutionGroup="CIRCUS:ProcessR">
    <xs:annotation>
      <xs:documentation>
        Circus process for replicated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition :: Unary :: Declaration :: Replicated :: Indexed -->
  <xs:element name="SeqProcessRI" type="CIRCUS:ProcessRI" substitutionGroup="CIRCUS:ProcessRI">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and replicated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcessRI" type="CIRCUS:ProcessRI" substitutionGroup="CIRCUS:ProcessRI">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and replicated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcessRI" type="CIRCUS:ProcessRI" substitutionGroup="CIRCUS:ProcessRI">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and replicated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcessRI" type="CIRCUS:ProcessRI" substitutionGroup="CIRCUS:ProcessRI">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and replicated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcessRI" type="CIRCUS:ParallelProcessRI" substitutionGroup="CIRCUS:ProcessRI">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and replicated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition :: Binary -->
  <xs:element name="SeqProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcess" type="CIRCUS:ParallelProcess" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for parallel composition;
        it includes the synchronisation set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Name Set Paragraphs -->
  <xs:element name="NameSetPara" type="CIRCUS:NameSetPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A name set definition introduces a name (or reference)
        for a name set expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Action Para -->
  <xs:element name="ActionPara" type="CIRCUS:ActionPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        An action declaration introduces a name for an action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Name Set Expressions
       we might not give equivalent complexTypes to name
       and channel set expressions because ChannelSet could possibly need
       to calculate the extensions/productions (FDR-like) -->
  <xs:element name="NameSet" type="CIRCUS:NameSet" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract name set expression.
        Although it is formed by a Z expression, name set expressions 
        cannot appear wherever a Z expression can. 
        They are only allowed in parallel operators.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SetNameSet" type="CIRCUS:SetNameSet" substitutionGroup="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>
        A name set expression containing user state name set partition
        (i.e. user state variable name references).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="RefNameSet" type="CIRCUS:RefNameSet" substitutionGroup="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>
        A name set expression referencing a declared name set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="NameSet2" type="CIRCUS:NameSet2" abstract="true" substitutionGroup="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>
        An abstract binary name set expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="UnionNameSet" type="CIRCUS:NameSet2" substitutionGroup="CIRCUS:NameSet2">
    <xs:annotation>
      <xs:documentation>
        Set union over name set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntersectionNameSet" type="CIRCUS:NameSet2" substitutionGroup="CIRCUS:NameSet2">
    <xs:annotation>
      <xs:documentation>
        Set intersection over name set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="DifferenceNameSet" type="CIRCUS:NameSet2" substitutionGroup="CIRCUS:NameSet2">
    <xs:annotation>
      <xs:documentation>
        Set difference over name set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

	<!-- Action Description -->		
	<xs:element name="ActionDesc" type="CIRCUS:ActionDesc" abstract="true">
		<xs:annotation>
			<xs:documentation>
				An abstract action description.
				Available extensions action definition, and parameterised action.
			</xs:documentation>
		</xs:annotation>
  </xs:element>
  <xs:element name="ParamActionDesc" type="CIRCUS:ParamActionDesc" substitutionGroup="CIRCUS:ActionDesc">
    <xs:annotation>
      <xs:documentation>
        A parameterised action description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Action" type="CIRCUS:Action" abstract="true" substitutionGroup="CIRCUS:ActionDesc">
		<xs:annotation>
			<xs:documentation>
				An abstract action definition.
			</xs:documentation>
		</xs:annotation>
  </xs:element>

  <!-- Action Definition -->  
  <xs:element name="CallAction" type="CIRCUS:CallAction" substitutionGroup="CIRCUS:Action">
    <xs:annotation>
      <xs:documentation>
        Reference to an action call (i.e. recursion unfolding).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SchExprAction" type="CIRCUS:SchExprAction" substitutionGroup="CIRCUS:Action">
    <xs:annotation>
      <xs:documentation>
        An action given as a schema expression.
        In this way, schema expressions are included into the Action subtree
        in a similar way as schema expressions are included in the declaration and
        predicat subtrees.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Action1" type="CIRCUS:Action1" abstract="true" substitutionGroup="CIRCUS:Action">
    <xs:annotation>
      <xs:documentation>
        An abstract unary CSP action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ActionR" type="CIRCUS:ActionR" abstract="true" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        An abstract replicated unary CSP action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Action2" type="CIRCUS:Action2" abstract="true" substitutionGroup="CIRCUS:Action">
    <xs:annotation>
      <xs:documentation>
        An abstract binary CSP action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Command" type="CIRCUS:Command" abstract="true" substitutionGroup="CIRCUS:Action">
    <xs:annotation>
      <xs:documentation>
        An abstract command action definition.
        Available extensions are specification statement
        in Carroll Morgan's style; (possibly multiple) assignment;
        if guards in Dijkstra's style;
        and (possibly multiple) variable declaration.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
	<xs:element name="SubstitutionAction" type="CIRCUS:SubstitutionAction" substitutionGroup="CIRCUS:Action">
		<xs:annotation>
			<xs:documentation>
				Circus action variable substitution. As variables in Circus are strongly-typed, type-checking is expected here.				
			</xs:documentation>
		</xs:annotation>
	</xs:element>
  

	<!-- CSP Action :: ActionDesc -->
	
	<xs:element name="ActualParamAction" type="CIRCUS:ActualParamAction" substitutionGroup="CIRCUS:Action">
		<xs:annotation>
			<xs:documentation>
				The CSP operator for parameterised action defined on the fly with its actual parameters.
				Ex: (x: \nat \spot c.x \then Skip)(10)
			</xs:documentation>
		</xs:annotation>
	</xs:element>

  <!-- CSP Action :: Basic -->      
  <xs:element name="BasicAction" type="CIRCUS:BasicAction" abstract="true" substitutionGroup="CIRCUS:Action">
    <xs:annotation>
      <xs:documentation>
        An abstract basic CSP action.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SkipAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        Basic CSP action for termination.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="StopAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        Basic CSP action for deadlock.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ChaosAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        Basic CSP action for divergence.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Unary -->
  <xs:element name="MuAction" type="CIRCUS:MuAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The CSP mu operator defines a recursive action.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="GuardedAction" type="CIRCUS:GuardedAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The CSP guarded action defines an action guarded by a Z predicate.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="HideAction" type="CIRCUS:HideAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The CSP hide operator defines events concealment
        within an action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="PrefixingAction" type="CIRCUS:PrefixingAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The CSP operator for actions prefixed with a communication.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Unary :: Declaration :: Replicated -->
  <xs:element name="SeqActionR" type="CIRCUS:ActionR" substitutionGroup="CIRCUS:ActionR">
    <xs:annotation>
      <xs:documentation>
        Circus action for replicated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceActionR" type="CIRCUS:ActionR" substitutionGroup="CIRCUS:ActionR">
    <xs:annotation>
      <xs:documentation>
        Circus action for replicated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceActionR" type="CIRCUS:ActionR" substitutionGroup="CIRCUS:ActionR">
    <xs:annotation>
      <xs:documentation>
        Circus action for replicated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveActionR" type="CIRCUS:ActionR" substitutionGroup="CIRCUS:ActionR">
    <xs:annotation>
      <xs:documentation>
        Circus action for replicated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelActionR" type="CIRCUS:ParallelActionR" substitutionGroup="CIRCUS:ActionR">
    <xs:annotation>
      <xs:documentation>
        Circus action for replicated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Binary -->
  <xs:element name="SeqAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        Sequential composition between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        Internal choice between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        External choice between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParAction" type="CIRCUS:ParAction" abstract="true" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        An abstract parallel action definition;
        it includes the name set partitions of the state.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveAction" type="CIRCUS:ParAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        Interleaving between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelAction" type="CIRCUS:ParallelAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        Parallel composition between two actions;
        it includes the channel set expression for the synchronisation set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Communication --> 
  <xs:element name="Communication" type="CIRCUS:Communication">
    <xs:annotation>
      <xs:documentation>
        A CSP communication that is part of a prefixing.
        It can be either a communication for synchronisation, input, output, or mixed.
        Synchronisation has no fields. Input and Output has only input or output fields repectively. 
        Finally, mixed communication has both input and output fields, for example in "c?x:P!v -> A".
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Communication Fields --> 
  <xs:element name="Field" type="CIRCUS:Field" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract field is part of a CSP communication. 
        Available extensions are input, output, and mixed fields.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InputField" type="CIRCUS:InputField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        A CSP parameter that is part of an input communication.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OutputField" type="CIRCUS:OutputField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        A CSP parameter that is part of an output communication.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Commands -->
  <xs:element name="SpecStmtCommand" type="CIRCUS:SpecStmtCommand" substitutionGroup="CIRCUS:Command">
    <xs:annotation>
      <xs:documentation>
        Command declaring a specification statement
        in Carroll Morgan's style.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AssignmentCommand" type="CIRCUS:AssignmentCommand" substitutionGroup="CIRCUS:Command">
    <xs:annotation>
      <xs:documentation>
        Command declaring a (possibly multiple) assignment.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IfGuardedCommand" type="CIRCUS:IfGuardedCommand" substitutionGroup="CIRCUS:Command">
    <xs:annotation>
      <xs:documentation>
        Command declaring a if statement containing guarded actions
        in Dijkstra's style.
        Although semantically different, we can represent the AST
        for the production of guarded actions 
        from the BNF of if commands with the GuardedAction AST class. 
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  <xs:element name="VarDeclCommand" type="CIRCUS:VarDeclCommand" substitutionGroup="CIRCUS:Command">
    <xs:annotation>
      <xs:documentation>
        Command declaring (possibly multiple) variables
        local to an action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AssumptionCommand" type="CIRCUS:AssumptionCommand" substitutionGroup="CIRCUS:Command">
    <xs:annotation>
      <xs:documentation>
        An assumption encapsulates a predicate within the action commands hierarchy tree. 
      </xs:documentation>
    </xs:annotation>
  </xs:element>


  <!-- Miscellaneous Circus Elements-->
  <xs:element name="AssignmentPair" type="CIRCUS:AssignmentPair">
    <xs:annotation>
      <xs:documentation>
        A pair containing a reference to a variable name
        and an expression for the assignment command.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ProcessType" type="CIRCUS:ProcessType" substitutionGroup="Z:Type2">
		<xs:annotation>
			<xs:documentation>
				A process type contains its signature.
				Generic process parameters must be resolved.
			</xs:documentation>
		</xs:annotation>
  </xs:element>  
  <xs:element name="ProcessSignature" type="CIRCUS:ProcessSignature">
		<xs:annotation>
			<xs:documentation>
				A process signature consists of the process name, formal parameters or indexes, and the channels usage.
				Generic actuals must be resolved while type checking similarly to Z and ObjectZ (see ClassSignature and oz.TypeChecker).
				The channels usage is function from channel name to a set of usage flags.
				These flags can be either IN, OUT, SYNCH or HIDE.
				In the case of HIDE, all other flags are irrelevant.
				These usage flags are built up by collecting the channel usage from action signatures.
			</xs:documentation>
		</xs:annotation>
  </xs:element>
  <xs:element name="ProcessAnn" type="CIRCUS:ProcessAnn">
		<xs:annotation>
			<xs:documentation>
				A process annotation contains a process signature
			</xs:documentation>
		</xs:annotation>
  </xs:element>  
  <xs:element name="BasicProcessSignature" type="CIRCUS:BasicProcessSignature" substitutionGroup="CIRCUS:ProcessSignature">
		<xs:annotation>
			<xs:documentation>
				Extends process signature to contain basic process declarations of 
				local variables, actions, and name sets.
				Local variables comes from either VarDeclCommand, or action formal parameters.
			</xs:documentation>
		</xs:annotation>
  </xs:element>    
  <xs:element name="ActionType" type="CIRCUS:ActionType" substitutionGroup="Z:Type2">
		<xs:annotation>
			<xs:documentation>
				An action type contains its signature.				
			</xs:documentation>
		</xs:annotation>
  </xs:element>  
  <xs:element name="ActionSignature" type="CIRCUS:ActionSignature">
		<xs:annotation>
			<xs:documentation>
				An action signature consists of the action name, formal parameters, and the channels usage.				
				The channels usage is function from channel name to a set of usage flags.
				These flags can be either IN, OUT, SYNCH or HIDE.
				In the case of HIDE, all other flags are irrelevant.				
			</xs:documentation>
		</xs:annotation>
  </xs:element>
  <xs:element name="ActionAnn" type="CIRCUS:ActionAnn">
		<xs:annotation>
			<xs:documentation>
				An action annotation contains an action signature.
				Action types are not needed since actions are local in the process signature.
			</xs:documentation>
		</xs:annotation>
  </xs:element>
  

  <!-- ************************************************************ -->
  <!-- Definitions of the complexTypes                              -->
  <!-- ************************************************************ -->

  <xs:complexType name="ChannelPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <!-- Channel names could have strokes but some restrictions
               might apply to avoid "?" or "!" for instance.
               This should be checked by code. -->
          <xs:element ref="Z:Decl" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
	  <xs:complexType name="ChannelSetPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName">
	          <xs:annotation>
							<xs:appinfo>
								<jaxb:property name="DeclName"/>
							</xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:DeclName" minOccurs="1" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>
								<jaxb:property name="GenFormals"/>
							</xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ProcessDesc"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Channel Set Expression complexTypes -->
  <xs:complexType name="ChannelSet">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BasicChannelSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSet">
        <xs:sequence>
          <!-- Channel names could have strokes whenever they come from Schema expressions.
               However, I don't know how input/output variables decorations are supposed to be handled in channel 
               declarations via Schema expressions. At the moment, just leave it as RefName and the type checker 
               restrict that in the code perhaps. -->
          <xs:element ref="Z:RefName" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RefChannelSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSet">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ChannelSet2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSet">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftOperand"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightOperand"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

	<!-- Process Description complexType -->
	<xs:complexType name="ProcessDesc">
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ParamProcessDesc">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcessDesc">
				<xs:sequence>
					<xs:element ref="Z:VarDecl" minOccurs="1" maxOccurs="unbounded"/>
					<xs:element ref="CIRCUS:ProcessDesc"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
  </xs:complexType>
  

  <!-- Process Definition complexType -->
  <xs:complexType name="ProcessDef">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessDesc"/>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="BasicProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessDef">
        <!-- As it can appear in any order, does it matter
             to put here xs:any instead? -->
        <xs:sequence>          
          <!-- Reference to a previously declared schema name; must enforce that the schema name is within the Z:Para -->
          <xs:element name="StateSchemaRefName" type="Z:RefName"/>
          <xs:element ref="Z:Para" minOccurs="0" maxOccurs="unbounded">
	          <xs:annotation>
							<xs:appinfo>
								<jaxb:property name="DeclZParagraphs"/>
							</xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element name="DeclActions" type="CIRCUS:ActionPara" minOccurs="0" maxOccurs="unbounded">          
						<xs:annotation>
							<xs:appinfo>
								<jaxb:property name="DeclActions"/>
							</xs:appinfo>
						</xs:annotation>
					 </xs:element>
							<xs:element name="DeclNameSets" type="CIRCUS:NameSetPara" minOccurs="0" maxOccurs="unbounded">          
							<xs:annotation>
								<xs:appinfo>
									<jaxb:property name="DeclNameSets"/>
								</xs:appinfo>
							</xs:annotation>
					</xs:element>
          <xs:element ref="CIRCUS:Action">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="MainAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Process1">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessDef">
        <xs:sequence>
          <xs:element ref="CIRCUS:ProcessDef"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessD">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element ref="Z:VarDecl" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessR">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessD"/>
    </xs:complexContent>
  </xs:complexType>
  <!-- Should ProcessRI derive from ProcessR?
       Think about it. Perhaps not. -->
  <xs:complexType name="ProcessRI">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessD"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Process2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessDef">
        <xs:sequence>
          <xs:element ref="CIRCUS:ProcessDef">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftProc"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ProcessDef">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightProc"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
	<xs:complexType name="RenameProcess">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcessDef">
				<xs:sequence>
					<xs:element ref="CIRCUS:ProcessDesc"/>
					<xs:element name="OldNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>	 					
	 				<xs:element name="NewNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
  
  <!-- Process Definition :: Calls --> 
  
  <xs:complexType name="CallProcess">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcessDef">
				<xs:sequence>
					<xs:element ref="Z:RefName"/>
					<xs:element ref="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>					
				</xs:sequence>
				<xs:attribute name="CallType" type="CIRCUS:CallType" use="optional" default="Normal"/>
			</xs:extension>
		</xs:complexContent>
  </xs:complexType>
	<xs:simpleType name="CallType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Normal"/>
			<xs:enumeration value="Param"/>
			<xs:enumeration value="Index"/>
			<xs:enumeration value="Gen"/>
		</xs:restriction>
  </xs:simpleType>
  
  <!-- Process Definition :: ProcessDesc -->
  
  <xs:complexType name="ProcessE">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessDef">
        <xs:sequence>
          <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="InstantiationProcess">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcessE">
				<xs:sequence>
					<xs:element ref="CIRCUS:IndexedProcessDesc"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
  </xs:complexType>    
  <xs:complexType name="ActualParamProcess">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcessE">
				<xs:sequence>
					<xs:element ref="CIRCUS:ParamProcessDesc"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
  </xs:complexType>  

  <!-- Process Definition :: Unary -->
  <xs:complexType name="HideProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Definition :: Unary :: Declaration :: Replicated -->
  <xs:complexType name="ParallelProcessR">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessR">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Definition :: Unary :: Declaration :: Replicated :: Indexed -->
  <xs:complexType name="ParallelProcessRI">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessRI">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Definition :: Binary -->
  <xs:complexType name="ParallelProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process2">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Paragraphs complexTypes -->
  <xs:complexType name="NameSetPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:NameSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:ActionDesc"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Name Set Expression complexTyzpes -->
  <xs:complexType name="NameSet">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SetNameSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:NameSet">
        <xs:sequence>
          <xs:element ref="Z:RefName" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RefNameSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:NameSet">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NameSet2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:NameSet">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftOperand"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightOperand"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

	<!-- Action Description complexType -->	
	<xs:complexType name="ActionDesc">
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ParamActionDesc">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ActionDesc">
				<xs:sequence>
					<xs:element ref="Z:VarDecl" minOccurs="1" maxOccurs="unbounded"/>
					<xs:element ref="CIRCUS:Action"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
  </xs:complexType>
  
	<xs:complexType name="Action">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionDesc"/>
    </xs:complexContent>
  </xs:complexType>

  <!-- Action Definition complexType -->
  
  <xs:complexType name="CallAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Action">
				<xs:sequence>
          <!-- Action names are not supposed to have strokes, but are indeed reference to names
               At the moment, just leave it as RefName and restrict that in the code. -->
					<xs:element ref="Z:RefName"/>
					<xs:element ref="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>					
				</xs:sequence>
        <!-- For action, call type can only be either normal or Param as there are no indexed or generic action. -->
				<xs:attribute name="CallType" type="CIRCUS:CallType" use="optional" default="Normal"/>
			</xs:extension>
		</xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="SchExprAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action">
        <xs:sequence>
          <!-- Z:SchExpr instead of SchText because we want a schema action to be an expression. -->
          <xs:element ref="Z:SchExpr"/>          
        </xs:sequence>
        <xs:attribute name="IsState" type="xs:boolean" use="optional" default="false"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Action1">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action">
        <xs:sequence>
          <xs:element ref="CIRCUS:Action"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionR">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:VarDecl" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Action2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action">
        <xs:sequence>
          <xs:element ref="CIRCUS:Action">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:Action">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Command">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action"/>
    </xs:complexContent>
  </xs:complexType>
      
  <xs:complexType name="SubstitutionAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Action">
				<xs:sequence>
					<xs:element ref="CIRCUS:ActionDesc"/>
					<xs:element name="VarNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>	 					
					<xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
  
  <!-- CSP Action complexType -->
  <xs:complexType name="BasicAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ActualParamAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Action">
				<xs:sequence>
					<xs:element ref="CIRCUS:ParamActionDesc"/>
					<xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>  


  <!-- CSP Action complexType :: Unary -->
  <xs:complexType name="MuAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GuardedAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="HideAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PrefixingAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="CIRCUS:Communication"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- CSP Action complexType :: Unary :: Declaration :: Replicated -->
  <xs:complexType name="ParallelActionR">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionR">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftNameSet"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightNameSet"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- CSP Action complexType :: Binary -->
  <xs:complexType name="ParAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action2">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftNameSet"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightNameSet"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ParallelAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- CSP Communication complexType -->
  <xs:complexType name="Communication">
    <xs:complexContent>
      <xs:extension base="Z:TermA">
        <xs:sequence>
          <xs:element name="ChanName" type="Z:RefName"/>
          <xs:element ref="CIRCUS:Field" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ChanFields"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="CommType" type="CIRCUS:CommType" use="optional" default="Synch"/>
        <xs:attribute name="MultiSych" type="xs:nonNegativeInteger" use="optional" default="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="CommType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Synch"/>
      <xs:enumeration value="Input"/>
      <xs:enumeration value="Output"/>
      <xs:enumeration value="Mixed"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- CSP Communication parameters complexType -->
  <xs:complexType name="Field">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="InputField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <xs:element name="Variable" type="Z:RefName"/>
          <xs:element ref="Z:Pred" minOccurs="0">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Restriction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="OutputField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <xs:element ref="Z:Expr">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Expression"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- CSP Commands complextype -->
  <xs:complexType name="SpecStmtCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Command">
        <xs:sequence>
          <xs:element name="Frame" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Pre"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Post"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AssignmentCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Command">
        <xs:sequence>
          <xs:element ref="CIRCUS:AssignmentPair" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="IfGuardedCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Command">
        <xs:sequence>
          <xs:element ref="CIRCUS:GuardedAction" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="VarDeclCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Command">
        <xs:sequence>          
          <xs:element ref="Z:VarDecl" minOccurs="1" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>
								<jaxb:property name="Declarations"/>
							</xs:appinfo>
						</xs:annotation>
          </xs:element>          
          <xs:element ref="CIRCUS:Action"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AssumptionCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Command">
        <xs:sequence>          
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Miscellaneous Circus Elements -->
  <!-- Defined like NameExprPair; mixed=false instructs GnAST
       to extend it from Term and not TermA -->
  <xs:complexType name="AssignmentPair" mixed="false">
    <xs:sequence>
      <xs:element name="LHS" type="Z:RefName"/>
      <xs:element ref="Z:Expr">
        <xs:annotation>
          <xs:appinfo>
            <jaxb:property name="RHS"/>
          </xs:appinfo>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  
  <xs:complexType name="ProcessType">
		<xs:complexContent>
			<xs:extension base="Z:Type2">
				<xs:sequence>
					<xs:element ref="CIRCUS:ProcessSignature"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
  </xs:complexType>  
  
	<xs:complexType name="ProcessSignature" mixed="false">
		<xs:sequence>
			<xs:element name="ProcessName" type="Z:DeclName"/>
			<xs:element ref="Z:Signature">
				<xs:annotation>
					<xs:appinfo>
						<jaxb:property name="ParamsOrIndexes"/>
					</xs:appinfo>
				</xs:annotation>
			</xs:element>
			<!-- TODO: include channel usage latter on -->
			<!--<xs:element ref="CIRCUS:ChannelUsage" minOccurs="0" maxOccurs="unbounded"/>-->			
		</xs:sequence>
	</xs:complexType>	
		
	<xs:complexType name="BasicProcessSignature">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcessSignature">
				<xs:sequence>   
					<xs:element ref="Z:Signature">
						<xs:annotation>
							<xs:appinfo>
								<jaxb:property name="StateSignature"/>
							</xs:appinfo>
						</xs:annotation>
					</xs:element> 
					<xs:element ref="Z:Signature" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>
								<jaxb:property name="LocalZDeclsSignature"/>
							</xs:appinfo>
						</xs:annotation>
					</xs:element> 
					<xs:element ref="CIRCUS:ActionSignature" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>
								<jaxb:property name="ActionsSignature"/>
							</xs:appinfo>
						</xs:annotation>
					</xs:element>
					<xs:element ref="Z:DeclName" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>
								<jaxb:property name="DeclNameSets"/>
							</xs:appinfo>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
    </xs:complexContent>    
	</xs:complexType>
	
	<xs:complexType name="ProcessAnn">
	    <xs:complexContent>
	      <xs:extension base="Z:Ann">
	        <xs:sequence>
	          <xs:element ref="CIRCUS:ProcessSignature"/>
	        </xs:sequence>
	      </xs:extension>
	    </xs:complexContent>
  </xs:complexType>	
	<xs:complexType name="ActionAnn">
		<xs:complexContent>
			<xs:extension base="Z:Ann">
				<xs:sequence>
					<xs:element ref="CIRCUS:ActionSignature"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ActionType">
		<xs:complexContent>
			<xs:extension base="Z:Type2">
				<xs:sequence>
					<xs:element ref="CIRCUS:ActionSignature"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
  </xs:complexType>  
	<xs:complexType name="ActionSignature" mixed="false">
		<xs:sequence>
			<xs:element name="ActionName" type="Z:DeclName"/>
			<!-- Action formal parameters are treated as local variables -->
			<xs:element ref="Z:Signature">
				<xs:annotation>
					<xs:appinfo>
						<jaxb:property name="LocalVarsSignature"/>
					</xs:appinfo>
				</xs:annotation>
			</xs:element>
			<!-- TODO: include channel usage latter on -->
			<!--<xs:element ref="CIRCUS:ChannelUsage" minOccurs="0" maxOccurs="unbounded"/>-->			
		</xs:sequence>
	</xs:complexType>	
	
</xs:schema>
