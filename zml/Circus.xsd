<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  targetNamespace="http://czt.sourceforge.net/circus"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:CIRCUS="http://czt.sourceforge.net/circus"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="0.1">
  <xs:annotation>
    <xs:documentation>
      Copyright 2005 Leonardo Freitas
      $Id$

      This XML schema defines XML markup for formal specifications 
      written in Circus, a concurrent language for refinement that
      combines CSP, Z and the refinement calculus.
      More information at http://www.cs.york.ac.uk/~leo.

      This file is part of the Community Z Tools (CZT) project.
 
      The CZT project contains free software; you can
      redistribute it and/or modify it under the terms
      of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of
      the License, or (at your option) any later version.
 
      The CZT project is distributed in the hope that it
      will be useful, but WITHOUT ANY WARRANTY; without
      even the implied warranty of MERCHANTABILITY or
      FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.

      You should have received a copy of the GNU General
      Public License along with CZT; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place,
      Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
      <jaxb:schemaBindings>
        <jaxb:package name="net.sourceforge.czt.circus.jaxb.gen">
          <jaxb:javadoc>
            &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
            &lt;html&gt;
            &lt;body&gt;
            &lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
          </jaxb:javadoc>
        </jaxb:package>
      </jaxb:schemaBindings>
      <gnast:schemaBindings name="Circus">
        <gnast:package name="net.sourceforge.czt.circus">
          <gnast:package id="ast" name="ast">
            <gnast:generate id="factory" class="CircusFactory" template="CoreFactory.vm"/>
          </gnast:package>
          <gnast:package id="impl" name="impl">
            <gnast:generate id="factoryImpl" class="CircusFactoryImpl" template="CoreFactoryImpl.vm"/>
          </gnast:package>
          <gnast:package id="visitor" name="visitor">
            <gnast:generate id="AstVisitor" class="CircusVisitor" template="AstVisitor.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="convFactory" class="Factory" template="Factory.vm"/>
          </gnast:package>
          <gnast:package id="jaxb" name="jaxb">
            <gnast:generate id="AstToJaxb" class="AstToJaxb" template="AstToJaxb.vm"/>
            <gnast:generate id="JaxbToAst" class="JaxbToAst" template="JaxbToAst.vm"/>
          </gnast:package>
          <gnast:package id="dom" name="dom">
            <gnast:generate id="AstToDom" class="AstToDom" template="AstToDom.vm"/>
          </gnast:package>
        </gnast:package>
      </gnast:schemaBindings>
    </xs:appinfo>
  </xs:annotation>

  <xs:import namespace="http://czt.sourceforge.net/zml" schemaLocation="Z.xsd"/>

  <!-- Paragraphs -->
  <xs:element name="ChannelPara" type="CIRCUS:ChannelPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A channel declaration that introduces channel names
        with corresponding types. 
        Channels are used in process definitions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SchChannelPara" type="CIRCUS:SchChannelPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A special channel declaration that uses declared variables
        from a schema expression,
        where the predicate part of the schema is ignored.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ChannelSetPara" type="CIRCUS:ChannelSetPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A channel set declaration that introduces a name
        for a channel set expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessPara" type="CIRCUS:ProcessPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A process declaration that introduces a name
        for a process definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Generic type channel declaration are missing -->

  <!-- Channel Set Expressions: perhaps avoid the last three cases? -->
  <xs:element name="ChannelSet" type="CIRCUS:ChannelSet" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract channel set expression. Although it is formed by
        a Z expression, channel set expressions cannot appear
        wherever a Z expression can.  They are only allowed in
        parallel operators.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SetChannelSet" type="CIRCUS:SetChannelSet" substitutionGroup="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        A channel set expression containing declared channel names
        (i.e. channel references).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="RefChannelSet" type="CIRCUS:RefChannelSet" substitutionGroup="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        A channel set expression referencing a declared channel set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ChannelSet2" type="CIRCUS:ChannelSet2" abstract="true" substitutionGroup="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        An abstract binary channel set expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="UnionChannelSet" type="CIRCUS:ChannelSet2" substitutionGroup="CIRCUS:ChannelSet2">
    <xs:annotation>
      <xs:documentation>
        Set union over channel set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntersectChannelSet" type="CIRCUS:ChannelSet2" substitutionGroup="CIRCUS:ChannelSet2">
    <xs:annotation>
      <xs:documentation>
        Set intersection over channel set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="DifferenceChannelSet" type="CIRCUS:ChannelSet2" substitutionGroup="CIRCUS:ChannelSet2">
    <xs:annotation>
      <xs:documentation>
        Set difference over channel set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition -->
  <xs:element name="ProcessDef" type="CIRCUS:ProcessDef" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract process paragraph definition.
        Available extensions are explicit process description; process call;
        all forms of unary, binary, replicated, and indexed processes;
        processes involving expressions; and processes involving declarations.
        Process would be a nicer name but this conflicts with the interface
        java.lang.Process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="DescProcess" type="CIRCUS:DescProcess" substitutionGroup="CIRCUS:ProcessDef">
    <xs:annotation>
      <xs:documentation>
        A process description is an explicit process definition.
        It is formed by a (possibly empty) set of process paragraphs,
        an optional process state given as a schema action,
        and a (mandatory) main action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="CallProcess" type="CIRCUS:CallProcess" substitutionGroup="CIRCUS:ProcessDef">
    <xs:annotation>
      <xs:documentation>
        Circus process reference call.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Process1" type="CIRCUS:Process1" abstract="true" substitutionGroup="CIRCUS:ProcessDef">
    <xs:annotation>
      <xs:documentation>
        An abstract unary Circus process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessE" type="CIRCUS:ProcessE" abstract="true" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        An abstract unary Circus process involving expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessD" type="CIRCUS:ProcessD" abstract="true" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        An abstract unary Circus process with Z declarations.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessR" type="CIRCUS:ProcessR" abstract="true" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        An abstract replicated Circus process with Z declarations.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessRI" type="CIRCUS:ProcessRI" abstract="true" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        An abstract indexed and replicated Circus process with Z declarations.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Process2" type="CIRCUS:Process2" abstract="true" substitutionGroup="CIRCUS:ProcessDef">
    <xs:annotation>
      <xs:documentation>
        An abstract binary Circus process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition :: Unary  -->
  <xs:element name="HideProcess" type="CIRCUS:HideProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        Circus process with event concealment through hiding.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="RenameProcess" type="CIRCUS:RenameProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        Circus process with channel renaming.
        As channels in Circus as strongly-typed,
        type-checking is expected here.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="FormalGenProcess" type="CIRCUS:FormalGenProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        Circus process with generic types, like in a generic axiomatic box.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition :: Unary :: Expression -->
  <xs:element name="InstantiationProcess" type="CIRCUS:ProcessE" substitutionGroup="CIRCUS:ProcessE">
    <xs:annotation>
      <xs:documentation>
        Circus process instantiation for process defined with an
        indexing operator.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ActualGenProcess" type="CIRCUS:ProcessE" substitutionGroup="CIRCUS:ProcessE">
    <xs:annotation>
      <xs:documentation>
        Circus process with resolved generic types.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ActualParamProcess" type="CIRCUS:ProcessE" substitutionGroup="CIRCUS:ProcessE">
    <xs:annotation>
      <xs:documentation>
        Circus process with actual parameters.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition :: Unary :: Declaration -->
  <xs:element name="IndexedProcess" type="CIRCUS:ProcessD" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        Circus process indexed on given declarations.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="FormalParamProcess" type="CIRCUS:ProcessD" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        Circus process with formal parameters.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition :: Unary :: Declaration :: Replicated -->
  <xs:element name="SeqProcessR" type="CIRCUS:ProcessR" substitutionGroup="CIRCUS:ProcessR">
    <xs:annotation>
      <xs:documentation>
        Circus process for replicated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcessR" type="CIRCUS:ProcessR" substitutionGroup="CIRCUS:ProcessR">
    <xs:annotation>
      <xs:documentation>
        Circus process for replicated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcessR" type="CIRCUS:ProcessR" substitutionGroup="CIRCUS:ProcessR">
    <xs:annotation>
      <xs:documentation>
        Circus process for replicated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcessR" type="CIRCUS:ProcessR" substitutionGroup="CIRCUS:ProcessR">
    <xs:annotation>
      <xs:documentation>
        Circus process for replicated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcessR" type="CIRCUS:ParallelProcessR" substitutionGroup="CIRCUS:ProcessR">
    <xs:annotation>
      <xs:documentation>
        Circus process for replicated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition :: Unary :: Declaration :: Replicated :: Indexed -->
  <xs:element name="SeqProcessRI" type="CIRCUS:ProcessRI" substitutionGroup="CIRCUS:ProcessRI">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and replicated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcessRI" type="CIRCUS:ProcessRI" substitutionGroup="CIRCUS:ProcessRI">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and replicated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcessRI" type="CIRCUS:ProcessRI" substitutionGroup="CIRCUS:ProcessRI">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and replicated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcessRI" type="CIRCUS:ProcessRI" substitutionGroup="CIRCUS:ProcessRI">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and replicated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcessRI" type="CIRCUS:ParallelProcessRI" substitutionGroup="CIRCUS:ProcessRI">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and replicated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition :: Binary -->
  <xs:element name="SeqProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcess" type="CIRCUS:ParallelProcess" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for parallel composition;
        it includes the synchronisation set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Name Set Paragraphs -->
  <xs:element name="NameSetPara" type="CIRCUS:NameSetPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        A name set definition introduces a name (or reference)
        for a name set expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Action Para -->
  <xs:element name="ActionPara" type="CIRCUS:ActionPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        An action declaration introduces a name for an action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Name Set Expressions
       we might not give equivalent complexTypes to name
       and channel set expressions because ChannelSet could possibly need
       to calculate the extensions/productions (FDR-like) -->
  <xs:element name="NameSet" type="CIRCUS:NameSet" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract name set expression.
        Although it is formed by a Z expression, name set expressions 
        cannot appear wherever a Z expression can. 
        They are only allowed in parallel operators.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SetNameSet" type="CIRCUS:SetNameSet" substitutionGroup="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>
        A name set expression containing user state name set partition
        (i.e. user state variable name references).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="RefNameSet" type="CIRCUS:RefNameSet" substitutionGroup="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>
        A name set expression referencing a declared name set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="NameSet2" type="CIRCUS:NameSet2" abstract="true" substitutionGroup="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>
        An abstract binary name set expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="UnionNameSet" type="CIRCUS:NameSet2" substitutionGroup="CIRCUS:NameSet2">
    <xs:annotation>
      <xs:documentation>
        Set union over name set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntersectionNameSet" type="CIRCUS:NameSet2" substitutionGroup="CIRCUS:NameSet2">
    <xs:annotation>
      <xs:documentation>
        Set intersection over name set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="DifferenceNameSet" type="CIRCUS:NameSet2" substitutionGroup="CIRCUS:NameSet2">
    <xs:annotation>
      <xs:documentation>
        Set difference over name set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Action Definition -->
  <xs:element name="Action" type="CIRCUS:Action" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="CallAction" type="CIRCUS:CallAction" substitutionGroup="CIRCUS:Action">
    <xs:annotation>
      <xs:documentation>
        Reference to an action call (i.e. recursion unfolding).
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SchTextAction" type="CIRCUS:SchTextAction" substitutionGroup="CIRCUS:Action">
    <xs:annotation>
      <xs:documentation>
        An action given as a schema text.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Action1" type="CIRCUS:Action1" abstract="true" substitutionGroup="CIRCUS:Action">
    <xs:annotation>
      <xs:documentation>
        An abstract unary CSP action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ActionD" type="CIRCUS:ActionD" abstract="true" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        An abstract unary CSP action definition with declarations.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ActionR" type="CIRCUS:ActionR" abstract="true" substitutionGroup="CIRCUS:ActionD">
    <xs:annotation>
      <xs:documentation>
        An abstract replicated unary CSP action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Action2" type="CIRCUS:Action2" abstract="true" substitutionGroup="CIRCUS:Action">
    <xs:annotation>
      <xs:documentation>
        An abstract binary CSP action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Command" type="CIRCUS:Command" abstract="true" substitutionGroup="CIRCUS:Action">
    <xs:annotation>
      <xs:documentation>
        An abstract command action definition.
        Available extensions are specification statement
        in Carroll Morgan's style; (possibly multiple) assignment;
        if guards in Dijkstra's style;
        and (possibly multiple) variable declaration.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Basic -->      
  <xs:element name="BasicAction" type="CIRCUS:BasicAction" abstract="true" substitutionGroup="CIRCUS:Action">
    <xs:annotation>
      <xs:documentation>
        An abstract basic CSP action.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SkipAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        Basic CSP action for termination.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="StopAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        Basic CSP action for deadlock.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ChaosAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        Basic CSP action for divergence.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Unary -->
  <xs:element name="MuAction" type="CIRCUS:MuAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The CSP mu operator defines a recursive action.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="GuardedAction" type="CIRCUS:GuardedAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The CSP guarded action defines an action guarded by a Z predicate.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="HideAction" type="CIRCUS:HideAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The CSP hide operator defines events concealment
        within an action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="PrefixingAction" type="CIRCUS:PrefixingAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The CSP operator for actions prefixed with a communication.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ActualParamAction" type="CIRCUS:ActualParamAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The CSP operator for action call with actual parameters.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Unary :: Declaration -->
  <xs:element name="FormalParamAction" type="CIRCUS:ActionD" substitutionGroup="CIRCUS:ActionD">
    <xs:annotation>
      <xs:documentation>
        The CSP operator for actions with formal parameters.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Unary :: Declaration :: Replicated -->
  <xs:element name="SeqActionR" type="CIRCUS:ActionR" substitutionGroup="CIRCUS:ActionR">
    <xs:annotation>
      <xs:documentation>
        Circus action for replicated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceActionR" type="CIRCUS:ActionR" substitutionGroup="CIRCUS:ActionR">
    <xs:annotation>
      <xs:documentation>
        Circus action for replicated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceActionR" type="CIRCUS:ActionR" substitutionGroup="CIRCUS:ActionR">
    <xs:annotation>
      <xs:documentation>
        Circus action for replicated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveActionR" type="CIRCUS:ActionR" substitutionGroup="CIRCUS:ActionR">
    <xs:annotation>
      <xs:documentation>
        Circus action for replicated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelActionR" type="CIRCUS:ParallelActionR" substitutionGroup="CIRCUS:ActionR">
    <xs:annotation>
      <xs:documentation>
        Circus action for replicated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Binary -->
  <xs:element name="SeqAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        Sequential composition between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        Internal choice between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        External choice between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParAction" type="CIRCUS:ParAction" abstract="true" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        An abstract parallel action definition;
        it includes the name set partitions of the state.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveAction" type="CIRCUS:ParAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        Interleaving between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelAction" type="CIRCUS:ParallelAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        Parallel composition between two actions;
        it includes the channel set expression for the synchronisation set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Communication --> 
  <xs:element name="Communication" type="CIRCUS:Communication">
    <xs:annotation>
      <xs:documentation>
        A CSP communication that is part of a prefixing.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Communication Fields --> 
  <xs:element name="Field" type="CIRCUS:Field" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract field is part of a CSP communication. 
        Available extensions are input, output, and mixed fields.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InputField" type="CIRCUS:InputField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        A CSP parameter that is part of an input communication.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OutputField" type="CIRCUS:OutputField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        A CSP parameter that is part of an output communication.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="MixedField" type="CIRCUS:MixedField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        A CSP parameter that is part of mixed input and output communication
        with form "c?x:P!v -> A", for instance.                            
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Commands -->
  <xs:element name="SpecStmtCommand" type="CIRCUS:SpecStmtCommand" substitutionGroup="CIRCUS:Command">
    <xs:annotation>
      <xs:documentation>
        Command declaring a specification statement
        in Carroll Morgan's style.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AssignmentCommand" type="CIRCUS:AssignmentCommand" substitutionGroup="CIRCUS:Command">
    <xs:annotation>
      <xs:documentation>
        Command declaring a (possibly multiple) assignment.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IfGuardedCommand" type="CIRCUS:IfGuardedCommand" substitutionGroup="CIRCUS:Command">
    <xs:annotation>
      <xs:documentation>
        Command declaring a if statement containing guarded actions
        in Dijkstra's style.
        Although semantically different, we can represent the AST
        for the production of guarded actions 
        from the BNF of if commands with the GuardedAction AST class. 
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  <xs:element name="VarDeclCommand" type="CIRCUS:VarDeclCommand" substitutionGroup="CIRCUS:Command">
    <xs:annotation>
      <xs:documentation>
        Command declaring (possibly multiple) variables
        local to an action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Miscellaneous Circus Elements-->
  <xs:element name="AssignmentPair" type="CIRCUS:AssignmentPair">
    <xs:annotation>
      <xs:documentation>
        A pair containing a reference to a variable name
        and an expression for the assignment command.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- ************************************************************ -->
  <!-- Definitions of the complexTypes                              -->
  <!-- ************************************************************ -->

  <xs:complexType name="ChannelPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <!-- Channel names could have strokes but some restrictions
               might apply to avoid "?" or "!" for instance.
               This should be checked by code. -->
          <xs:element ref="Z:VarDecl"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SchChannelPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ChannelSetPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:ProcessDef"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Channel Set Expression complexTypes -->
  <xs:complexType name="ChannelSet">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SetChannelSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSet">
        <xs:sequence>
          <!-- Channel names could have strokes
               whenever they come from Schema expressions.
               However, I don't know how input/output variables decorations
               are supposed to be handled in channel declarations.
               At the moment, just leave it as RefName and restrict
               that in the code perhaps. -->
          <xs:element ref="Z:RefName" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RefChannelSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSet">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ChannelSet2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSet">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftOperand"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightOperand"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Definition complexType -->
  <xs:complexType name="ProcessDef">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CallProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessDef">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="DescProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessDef">
        <!-- As it can appear in any order, does it matter
             to put here xs:any instead? -->
        <xs:sequence>
          <!-- <xs:element name="StateSchTextAction" type="CIRCUS:SchTextAction" minOccurs="0"/> -->
          <!-- Reference to a previously declared schema name; must enforce that the  -->
          <xs:element name="StateSchemaRefName" type="Z:RefName"/>
          <xs:element ref="Z:Para" minOccurs="0" maxOccurs="unbounded"/>
          <xs:element ref="CIRCUS:Action">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="MainAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Process1">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessDef">
        <xs:sequence>
          <xs:element ref="CIRCUS:ProcessDef"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessE">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessD">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element ref="Z:VarDecl"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessR">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessD"/>
    </xs:complexContent>
  </xs:complexType>
  <!-- Should ProcessRI derive from ProcessR?
       Think about it. Perhaps not. -->
  <xs:complexType name="ProcessRI">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessD"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Process2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessDef">
        <xs:sequence>
          <xs:element ref="CIRCUS:ProcessDef">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftProc"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ProcessDef">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightProc"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Definition :: Unary -->
  <xs:complexType name="HideProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RenameProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element name="OldNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
          <xs:element name="NewNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="FormalGenProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element name="FormalGenTypes" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Definition :: Unary :: Declaration :: Replicated -->
  <xs:complexType name="ParallelProcessR">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessR">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Definition :: Unary :: Declaration :: Replicated :: Indexed -->
  <xs:complexType name="ParallelProcessRI">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessRI">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Definition :: Binary -->
  <xs:complexType name="ParallelProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process2">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Paragraphs complexTypes -->
  <xs:complexType name="NameSetPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:NameSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:Action"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Name Set Expression complexTyzpes -->
  <xs:complexType name="NameSet">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SetNameSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:NameSet">
        <xs:sequence>
          <xs:element ref="Z:RefName" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RefNameSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:NameSet">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NameSet2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:NameSet">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftOperand"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightOperand"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Action Definition complexType -->
  <xs:complexType name="Action">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CallAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action">
        <xs:sequence>
          <!-- Action names are not supposed to have strokes,
               but are indeed reference to names
               At the moment, just leave it as RefName and restrict that
               in the code perhaps. -->
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SchTextAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action">
        <xs:sequence>
          <!-- Z:SchExpr instead of SchText because we want a schema action
               to be a schema expression. -->
          <xs:element ref="Z:SchExpr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Action1">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action">
        <xs:sequence>
          <xs:element ref="CIRCUS:Action"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionD">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:VarDecl"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionR">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionD"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Action2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action">
        <xs:sequence>
          <xs:element ref="CIRCUS:Action">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:Action">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Command">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action"/>
    </xs:complexContent>
  </xs:complexType>

  <!-- CSP Action complexType -->
  <xs:complexType name="BasicAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action"/>
    </xs:complexContent>
  </xs:complexType>

  <!-- CSP Action complexType :: Unary -->
  <xs:complexType name="MuAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GuardedAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="HideAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PrefixingAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="CIRCUS:Communication"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActualParamAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- CSP Action complexType :: Unary :: Declaration :: Replicated -->
  <xs:complexType name="ParallelActionR">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionR">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftNameSet"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightNameSet"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- CSP Action complexType :: Binary -->
  <xs:complexType name="ParAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action2">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftNameSet"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightNameSet"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ParallelAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- CSP Communication complexType -->
  <xs:complexType name="Communication">
    <xs:complexContent>
      <xs:extension base="Z:TermA">
        <xs:sequence>
          <xs:element name="ChanName" type="Z:RefName"/>
          <xs:element ref="CIRCUS:Field" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ChanFields"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="CommType" type="CIRCUS:CommType" use="optional" default="Synch"/>
        <xs:attribute name="MultiSych" type="xs:nonNegativeInteger" use="optional" default="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="CommType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Synch"/>
      <xs:enumeration value="Input"/>
      <xs:enumeration value="Output"/>
      <xs:enumeration value="Mixed"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- CSP Communication parameters complexType -->
  <xs:complexType name="Field">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="InputField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <xs:element name="Variable" type="Z:RefName"/>
          <xs:element ref="Z:Pred" minOccurs="0">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Restriction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="OutputField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <xs:element ref="Z:Expr">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Expression"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="MixedField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <!-- At least one In or Out must be available;
               but in (or out) only is allowed.
               Can this be guaranteed at the schema?
               Here the order does not matter,
               hence it could have been a xs any instead. -->
          <xs:element ref="CIRCUS:InputField" minOccurs="0" maxOccurs="unbounded"/>
          <xs:element ref="CIRCUS:OutputField" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- CSP Commands complextype -->
  <xs:complexType name="SpecStmtCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Command">
        <xs:sequence>
          <xs:element name="Frame" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Pre"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Post"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AssignmentCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Command">
        <xs:sequence>
          <xs:element ref="CIRCUS:AssignmentPair" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="IfGuardedCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Command">
        <xs:sequence>
          <xs:element ref="CIRCUS:GuardedAction" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="VarDeclCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Command">
        <xs:sequence>
          <!-- Should here be VarDecl or DeclNames (unbounded) + Expr? -->
          <xs:element ref="Z:VarDecl"/>
          <xs:element ref="CIRCUS:Action"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Miscellaneous Circus Elements -->
  <!-- Defined like NameExprPair; mixed=false instructs GnAST
       to extend it from Term and not TermA -->
  <xs:complexType name="AssignmentPair" mixed="false">
    <xs:sequence>
      <xs:element name="LHS" type="Z:RefName"/>
      <xs:element ref="Z:Expr">
        <xs:annotation>
          <xs:appinfo>
            <jaxb:property name="RHS"/>
          </xs:appinfo>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
</xs:schema>
