<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  targetNamespace="http://czt.sourceforge.net/circus"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:CIRCUS="http://czt.sourceforge.net/circus"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="0.1">
  <xs:annotation>
  	<xs:documentation>
    	 Copyright 2005 Leonardo Freitas
        
       This XML schema defines XML markup for formal specifications 
       written in Circus, a concurrent language for refinement that
       combines CSP, Z and the refinement calculus.
       More information at http://www.cs.york.ac.uk/~leo.
       
       This file is part of the Community Z Tools (CZT) project.
 
       The CZT project contains free software; you can
       redistribute it and/or modify it under the terms
       of the GNU General Public License as published by
       the Free Software Foundation; either version 2 of
       the License, or (at your option) any later version.
 
       The CZT project is distributed in the hope that it
       will be useful, but WITHOUT ANY WARRANTY; without
       even the implied warranty of MERCHANTABILITY or
       FITNESS FOR A PARTICULAR PURPOSE.  See the
       GNU General Public License for more details.
 
       You should have received a copy of the GNU General
       Public License along with CZT; if not, write to the
       Free Software Foundation, Inc., 59 Temple Place,
       Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
		      <jaxb:schemaBindings>
		        <jaxb:package name="net.sourceforge.czt.circus.jaxb.gen">
		          <jaxb:javadoc>
		            &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
		            &lt;html&gt;
		            &lt;body&gt;
		            &lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
		            &lt;/body&gt;
		            &lt;/html&gt;
		          </jaxb:javadoc>
		        </jaxb:package>
		      </jaxb:schemaBindings>
		      <gnast:schemaBindings name="Circus">
		        <gnast:package name="net.sourceforge.czt.circus">
		          <gnast:package id="ast" name="ast">
		            <gnast:generate id="factory" class="CircusFactory" template="CoreFactory.vm"/>
		          </gnast:package>
		          <gnast:package id="impl" name="impl">
		            <gnast:generate id="factoryImpl" class="CircusFactoryImpl" template="CoreFactoryImpl.vm"/>
		          </gnast:package>
		          <gnast:package id="visitor" name="visitor">
		            <gnast:generate id="AstVisitor" class="CircusVisitor" template="AstVisitor.vm"/>
		          </gnast:package>
							<gnast:package id="util" name="util">
								<gnast:generate id="convFactory" class="Factory" template="Factory.vm"/>
							</gnast:package>
		          <gnast:package id="jaxb" name="jaxb">
		            <gnast:generate id="AstToJaxb" class="AstToJaxb" template="AstToJaxb.vm"/>
		            <gnast:generate id="JaxbToAst" class="JaxbToAst" template="JaxbToAst.vm"/>
		          </gnast:package>
		          <gnast:package id="dom" name="dom">
		            <gnast:generate id="AstToDom" class="AstToDom" template="AstToDom.vm"/>
		          </gnast:package>
		        </gnast:package>
		      </gnast:schemaBindings>
     </xs:appinfo>
  </xs:annotation>
  
  <xs:import namespace="http://czt.sourceforge.net/zml" schemaLocation="Z.xsd"/>

<!-- ******************************************************************************************* -->
<!-- ******************************************************************************************* -->

	<!-- With homogeneous namespace Z for type-checking and validation with Altova XMLSpy Home Edition 2005 -->
	<!-- It is just a textual inclusion of Z_1_3.xsd, as the home edition does not allow import clause :(  -->

<!-- ******************************************************************************************* -->
<!-- ******************************************************************************************* -->

  
  <!-- the Section hierarchy -->
  <xs:element name="CircusSect" type="CIRCUS:CircusSect" substitutionGroup="Z:Sect">
    <xs:annotation>
      <xs:documentation>
        A concrete Circus section. It is similar to a concrete Z section, but allowing Circus paragraphs.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  
  <!-- Extending the (Z)Paragraph hierarchy with production BNF:CircusParagraph -->
  <!-- However, as process definitions do not allow z paragraphs different from Z:Para, we cannot derive directly from Z:Para -->
  <xs:element name="CircusPara" type="CIRCUS:CircusPara" abstract="true">
    <xs:annotation>
    	<xs:documentation>
    		An abstract Circus paragraph. Available extensions are channel, channel set, and process declarations.
    	</xs:documentation>
    </xs:annotation>
  </xs:element>   
  <xs:element name="CircusZPara" type="CIRCUS:CircusZPara" substitutionGroup="CIRCUS:CircusPara">
    <xs:annotation>
    	<xs:documentation>
    		A Z paragraph in a Circus specification. This is a wrapper class allowing us to differentiate
    		Z paragraphs outside a process definition. This is important because (standard) Z paragraphs are allowed anywhere,
    		but Circus paragraphs are not allowed inside process definition. Therefore, a Circus paragraph cannot
    		directly extend a Z paragraph. With this distinction of Circus paragraph not being a Z paragraph extension, 
    		we can enforce that Circus paragraphs do not appear inside process definition.
    		At the same time, with a CircusZPara wrapper we ensure that a Circus specification can indeed contain
    		Z paragraph outside a process.
    	</xs:documentation>
    </xs:annotation>
  </xs:element>     
  <xs:element name="ChannelDecl" type="CIRCUS:ChannelDecl" substitutionGroup="CIRCUS:CircusPara">
    <xs:annotation>
    	<xs:documentation>A channel definition introduces channel names with corresponding types available for process definitions.</xs:documentation>
    </xs:annotation>
  </xs:element>   
  <xs:element name="ChannelDeclSExpr" type="CIRCUS:ChannelDeclSExpr" substitutionGroup="CIRCUS:CircusPara">
    <xs:annotation>
    	<xs:documentation>A special channel definition using declared variables from a schema expression.</xs:documentation>
    </xs:annotation>
  </xs:element>   
  <xs:element name="CSDecl" type="CIRCUS:CSDecl" substitutionGroup="CIRCUS:CircusPara">
    <xs:annotation>
    	<xs:documentation>A channel set definition introduces a name for a channel set expression.</xs:documentation>
    </xs:annotation>
  </xs:element>     
  <xs:element name="ProcDecl" type="CIRCUS:ProcDecl" substitutionGroup="CIRCUS:CircusPara">
		<xs:annotation>
			<xs:documentation>A process declaration introduces a name for a process definition.</xs:documentation>
		</xs:annotation>
  </xs:element>   

  <!-- Channel Set Expressions: perhaps we could avoid the last three cases. -->
  <xs:element name="CSExpr" type="CIRCUS:CSExpr" abstract="true" substitutionGroup="Z:Expr0N">
    <xs:annotation>
      <xs:documentation>An abstract channel set expression.</xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="CSExprSet" type="CIRCUS:CSExprSet" substitutionGroup="CIRCUS:CSExpr">
		<xs:annotation>
			<xs:documentation>A channel set expression containing declared channel names (i.e. references).</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="CSExprRef" type="CIRCUS:CSExprRef" substitutionGroup="CIRCUS:CSExpr">
		<xs:annotation>
			<xs:documentation>A channel set expression referencing a declared channel set.</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="CSExprUnion" type="CIRCUS:CSExpr">
		<xs:annotation>
			<xs:documentation>Set union over channel set expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="CSExprInter" type="CIRCUS:CSExpr">
		<xs:annotation>
			<xs:documentation>Set intersection over channel set expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="CSExprDiff" type="CIRCUS:CSExpr">
		<xs:annotation>
			<xs:documentation>Set difference over channel set expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>  
	
	<!-- Process Definition -->
	
  <xs:element name="ProcDef" type="CIRCUS:ProcDef" abstract="true">
		<xs:annotation>
			<xs:documentation>An abstract process definition.</xs:documentation>
		</xs:annotation>
	</xs:element>	  
  <xs:element name="ProcDesc" type="CIRCUS:ProcDesc" substitutionGroup="CIRCUS:ProcDef">
		<xs:annotation>
			<xs:documentation>
				A process description is an explicit process definition.
				It is formed by a (possibly empty) set of process paragraphs, 
				an optional process state given as a schema action,
				and a (mandatory) main action definition.
			</xs:documentation>
		</xs:annotation>
	</xs:element>		
	<xs:element name="CallProc" type="CIRCUS:CallProc" substitutionGroup="CIRCUS:ProcDef">
		<xs:annotation>
			<xs:documentation>Circus process reference call.</xs:documentation>
		</xs:annotation>
	</xs:element>		  	
  <xs:element name="Proc1" type="CIRCUS:Proc1" abstract="true" substitutionGroup="CIRCUS:ProcDef">
		<xs:annotation>
			<xs:documentation>An abstract unary Circus process.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="ProcE" type="CIRCUS:ProcE" abstract="true" substitutionGroup="CIRCUS:Proc1">
		<xs:annotation>
			<xs:documentation>An abstract unary Circus process involving expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="ProcD" type="CIRCUS:ProcD" abstract="true" substitutionGroup="CIRCUS:Proc1">
		<xs:annotation>
			<xs:documentation>An abstract Circus process with Z declarations.</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="ProcR" type="CIRCUS:ProcR" abstract="true" substitutionGroup="CIRCUS:ProcD">
		<xs:annotation>
			<xs:documentation>An abstract Circus process with Z declarations.</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="ProcRI" type="CIRCUS:ProcRI" abstract="true" substitutionGroup="CIRCUS:ProcR">
		<xs:annotation>
			<xs:documentation>An abstract Circus process with Z declarations.</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="Proc2" type="CIRCUS:Proc2" abstract="true" substitutionGroup="CIRCUS:ProcDef">
		<xs:annotation>
			<xs:documentation>An abstract binary Circus process.</xs:documentation>
		</xs:annotation>
	</xs:element>			
	
	<!-- Process Definition :: Unary  -->

	<xs:element name="HideProc" type="CIRCUS:HideProc" substitutionGroup="CIRCUS:Proc1">
		<xs:annotation>
			<xs:documentation>Circus process with event concealment through hiding like in CSP.</xs:documentation>
		</xs:annotation>
	</xs:element>		  
	<xs:element name="RenameProc" type="CIRCUS:RenameProc" substitutionGroup="CIRCUS:Proc1">
		<xs:annotation>
			<xs:documentation>Circus process with channel renaming. As channels in Circus as strongly-typed, type-checking is expected here.</xs:documentation>
		</xs:annotation>
	</xs:element>		  
	<xs:element name="FormalGenProc" type="CIRCUS:FormalGenProc" substitutionGroup="CIRCUS:Proc1">
		<xs:annotation>
			<xs:documentation>Circus process with generic types, like in a generic axiomatic box.</xs:documentation>
		</xs:annotation>
	</xs:element>		  
	
	<!-- Process Definition :: Unary :: Expression -->
	
	<xs:element name="IntantiationProc" type="CIRCUS:ProcE" substitutionGroup="CIRCUS:ProcE">
		<xs:annotation>
			<xs:documentation>Circus process instantiation for process defined with indexing operator.</xs:documentation>
		</xs:annotation>
	</xs:element>		
	<xs:element name="ActualGenProc" type="CIRCUS:ProcE" substitutionGroup="CIRCUS:ProcE">
		<xs:annotation>
			<xs:documentation>Circus process with resolved generic types.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ActualParamProc" type="CIRCUS:ProcE" substitutionGroup="CIRCUS:ProcE">
		<xs:annotation>
			<xs:documentation>Circus process with actual parameters.</xs:documentation>
		</xs:annotation>
	</xs:element>				

	
	<!-- Process Definition :: Unary :: Declaration -->	

	<xs:element name="IndexedProc" type="CIRCUS:ProcD" substitutionGroup="CIRCUS:ProcD">
		<xs:annotation>
			<xs:documentation>Circus process indexed on given declarations.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="FormalParamProc" type="CIRCUS:ProcD" substitutionGroup="CIRCUS:ProcD">
		<xs:annotation>
			<xs:documentation>Circus process with formal parameters.</xs:documentation>
		</xs:annotation>
	</xs:element>				

	<!-- Process Definition :: Unary :: Declaration :: Replicated -->	

	<xs:element name="RepSeqCompProc" type="CIRCUS:ProcR" substitutionGroup="CIRCUS:ProcR">
		<xs:annotation>
			<xs:documentation>Circus process for replicated sequential composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="RepIntChProc" type="CIRCUS:ProcR" substitutionGroup="CIRCUS:ProcR">
		<xs:annotation>
			<xs:documentation>Circus process for replicated internal choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="RepExtChProc" type="CIRCUS:ProcR" substitutionGroup="CIRCUS:ProcR">
		<xs:annotation>
			<xs:documentation>Circus process for replicated external choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="RepInterleaveProc" type="CIRCUS:ProcR" substitutionGroup="CIRCUS:ProcR">
		<xs:annotation>
			<xs:documentation>Circus process for replicated interleaving.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="RepParallelCompProc" type="CIRCUS:RepParallelCompProc" substitutionGroup="CIRCUS:ProcR">
		<xs:annotation>
			<xs:documentation>Circus process for replicated parallel composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				

	<!-- Process Definition :: Unary :: Declaration :: Replicated :: Indexed -->	
	
	<xs:element name="IdxRepSeqCompProc" type="CIRCUS:ProcRI" substitutionGroup="CIRCUS:ProcRI">
		<xs:annotation>
			<xs:documentation>Circus process for indexed and replicated sequential composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="IdxRepIntChProc" type="CIRCUS:ProcRI" substitutionGroup="CIRCUS:ProcRI">
		<xs:annotation>
			<xs:documentation>Circus process for indexed and replicated internal choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="IdxRepExtChProc" type="CIRCUS:ProcRI" substitutionGroup="CIRCUS:ProcRI">
		<xs:annotation>
			<xs:documentation>Circus process for indexed and replicated external choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="IdxRepInterleaveProc" type="CIRCUS:ProcRI" substitutionGroup="CIRCUS:ProcRI">
		<xs:annotation>
			<xs:documentation>Circus process for indexed and replicated interleaving.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="IdxRepParallelCompProc" type="CIRCUS:IdxRepParallelCompProc" substitutionGroup="CIRCUS:ProcRI">
		<xs:annotation>
			<xs:documentation>Circus process for indexed and replicated parallel composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				

	<!-- Process Definition :: Binary -->	
	
	<xs:element name="SeqCompProc" type="CIRCUS:Proc2" substitutionGroup="CIRCUS:Proc2">
		<xs:annotation>
			<xs:documentation>Circus process for sequential composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ExtChoiceProc" type="CIRCUS:Proc2" substitutionGroup="CIRCUS:Proc2">
		<xs:annotation>
			<xs:documentation>Circus process for external choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="IntChoiceProc" type="CIRCUS:Proc2" substitutionGroup="CIRCUS:Proc2">
		<xs:annotation>
			<xs:documentation>Circus process for external choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="InterleaveProc" type="CIRCUS:Proc2" substitutionGroup="CIRCUS:Proc2">
		<xs:annotation>
			<xs:documentation>Circus process for interleaving.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="ParallelCompProc" type="CIRCUS:ParallelCompProc" substitutionGroup="CIRCUS:Proc2">
		<xs:annotation>
			<xs:documentation>Circus process for parallel composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				

	<!-- Process Paragraphs -->
	
  <xs:element name="ProcPara" type="CIRCUS:ProcPara" abstract="true">
		<xs:annotation>
			<xs:documentation>
				An abstract process paragraph. Available extensions are Z paragraph within a process description,
				and action and name set declarations.
			</xs:documentation>
		</xs:annotation>
	</xs:element>	  
  <xs:element name="ProcZPara" type="CIRCUS:ProcZPara" substitutionGroup="CIRCUS:ProcPara">
		<xs:annotation>
			<xs:documentation>
				A Z paragraph contained into a process definition. We need to declare it separately in order 
				ensure that a Z paragraph placed inside a process is also a process paragraph.
				That is different from a Z paragraph outside a process definition (see CircusZPara).
				Both classes are needed in order to allow differentiation of Z paragraphs at different point 
				in the AST hierarchy.				
			</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="NSDecl" type="CIRCUS:NSDecl" substitutionGroup="CIRCUS:ProcPara">
    <xs:annotation>
    	<xs:documentation>A name set definition introduces a name (or reference) for a name set expression.</xs:documentation>
    </xs:annotation>
  </xs:element>     
  <xs:element name="ActionDecl" type="CIRCUS:ActionDecl" substitutionGroup="CIRCUS:ProcPara">
		<xs:annotation>
			<xs:documentation>An action declaration introduces a name for an action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>	
	

  <!-- Name Set Expressions: we might not give equivalent complexTypes to name and channel set expressions 				 -->
  <!-- 											 because CSExpr could possibly need to calculate the extensions/productions (FDR-like) -->
  <xs:element name="NSExpr" type="CIRCUS:NSExpr" abstract="true" substitutionGroup="Z:Expr0N">
    <xs:annotation>
      <xs:documentation>An abstract channel set expression.</xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="NSExprSet" type="CIRCUS:NSExprSet" substitutionGroup="CIRCUS:NSExpr">
		<xs:annotation>
			<xs:documentation>A name set expression containing user state name set partition (i.e. references).</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="NSExprRef" type="CIRCUS:NSExprRef" substitutionGroup="CIRCUS:NSExpr">
		<xs:annotation>
			<xs:documentation>A name set expression referencing a declared name set.</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="NSExprUnion" type="CIRCUS:NSExpr">
		<xs:annotation>
			<xs:documentation>Set union over name set expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="NSExprInter" type="CIRCUS:NSExpr">
		<xs:annotation>
			<xs:documentation>Set intersection over name set expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>
  <xs:element name="NSExprDiff" type="CIRCUS:NSExpr">
		<xs:annotation>
			<xs:documentation>Set difference over name set expressions.</xs:documentation>
		</xs:annotation>
	</xs:element>  


	<!-- Action Definition -->
	
  <xs:element name="ActionDef" type="CIRCUS:ActionDef" abstract="true">
		<xs:annotation>
			<xs:documentation>An abstract action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>	  
  <xs:element name="SchemaAction" type="CIRCUS:SchemaAction" substitutionGroup="CIRCUS:ActionDef">
		<xs:annotation>
			<xs:documentation>An action as a schema expression.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="CSPAction" type="CIRCUS:CSPAction" abstract="true" substitutionGroup="CIRCUS:ActionDef">
		<xs:annotation>
			<xs:documentation>An abstract CSP action.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="CSPAction1" type="CIRCUS:CSPAction1" abstract="true" substitutionGroup="CIRCUS:CSPAction">
		<xs:annotation>
			<xs:documentation>An abstract unary action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="CSPActionD" type="CIRCUS:CSPActionD" abstract="true" substitutionGroup="CIRCUS:CSPAction1">
		<xs:annotation>
			<xs:documentation>An abstract unary action definition with declarations.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="CSPActionR" type="CIRCUS:CSPActionR" abstract="true" substitutionGroup="CIRCUS:CSPActionD">
		<xs:annotation>
			<xs:documentation>An abstract replicated unary action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="CSPAction2" type="CIRCUS:CSPAction2" abstract="true" substitutionGroup="CIRCUS:CSPAction">
		<xs:annotation>
			<xs:documentation>An abstract binary action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="Command" type="CIRCUS:Command" abstract="true" substitutionGroup="CIRCUS:ActionDef">
		<xs:annotation>
			<xs:documentation>An abstract command.</xs:documentation>
		</xs:annotation>
	</xs:element>	
	
	<!-- CSP Action :: Basic -->
	
  <xs:element name="CSPBasicAction" type="CIRCUS:CSPBasicAction" abstract="true" substitutionGroup="CIRCUS:CSPAction">
		<xs:annotation>
			<xs:documentation>An abstract basic CSP action.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="SkipAction" type="CIRCUS:CSPBasicAction" substitutionGroup="CIRCUS:CSPBasicAction">
		<xs:annotation>
			<xs:documentation>Basic CSP action for termination.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="StopAction" type="CIRCUS:CSPBasicAction" substitutionGroup="CIRCUS:CSPBasicAction">
		<xs:annotation>
			<xs:documentation>Basic CSP action for deadlock.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="ChaosAction" type="CIRCUS:CSPBasicAction" substitutionGroup="CIRCUS:CSPBasicAction">
		<xs:annotation>
			<xs:documentation>Basic CSP action for divergence.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="CallAction" type="CIRCUS:CallAction" substitutionGroup="CIRCUS:CSPBasicAction">
		<xs:annotation>
			<xs:documentation>Basic CSP action for action call (i.e. recursive unfolding).</xs:documentation>
		</xs:annotation>
	</xs:element>	

	<!-- CSP Action :: Unary -->

  <xs:element name="MuAction" type="CIRCUS:MuAction" substitutionGroup="CIRCUS:CSPAction1">
		<xs:annotation>
			<xs:documentation>The CSP mu operator defines a recursive action.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="GuardedAction" type="CIRCUS:GuardedAction" substitutionGroup="CIRCUS:CSPAction1">
		<xs:annotation>
			<xs:documentation>The CSP guarded action defines an action guarded by a Z predicate.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="HideAction" type="CIRCUS:HideAction" substitutionGroup="CIRCUS:CSPAction1">
		<xs:annotation>
			<xs:documentation>The CSP hide operator defines event concealment within an action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>		
  <xs:element name="PrefixingAction" type="CIRCUS:PrefixingAction" substitutionGroup="CIRCUS:CSPAction1">
		<xs:annotation>
			<xs:documentation>An abstract CSP operator for actions prefixed with a communication.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="ActualParamAction" type="CIRCUS:ActualParamAction" substitutionGroup="CIRCUS:CSPAction1">
		<xs:annotation>
			<xs:documentation>The CSP operator for actions with actual parameters.</xs:documentation>
		</xs:annotation>
	</xs:element>		

	<!-- CSP Action :: Unary :: Declaration -->
	
	<xs:element name="FormalParamAction" type="CIRCUS:CSPActionD" substitutionGroup="CIRCUS:CSPActionD">
		<xs:annotation>
			<xs:documentation>The CSP operator for actions with actual parameters.</xs:documentation>
		</xs:annotation>
	</xs:element>		

	<!-- CSP Action :: Unary :: Declaration :: Replicated -->
	
	<xs:element name="RepSeqCompAction" type="CIRCUS:CSPActionR" substitutionGroup="CIRCUS:CSPActionR">
		<xs:annotation>
			<xs:documentation>Circus action for replicated sequential composition.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="RepIntChAction" type="CIRCUS:CSPActionR" substitutionGroup="CIRCUS:CSPActionR">
		<xs:annotation>
			<xs:documentation>Circus action for replicated internal choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="RepExtChAction" type="CIRCUS:CSPActionR" substitutionGroup="CIRCUS:CSPActionR">
		<xs:annotation>
			<xs:documentation>Circus action for replicated external choice.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="RepParallelAction" type="CIRCUS:RepParallelAction" abstract="true" substitutionGroup="CIRCUS:CSPActionR">
		<xs:annotation>
			<xs:documentation>An abstract Circus action for replicated parallel operators.</xs:documentation>
		</xs:annotation>
	</xs:element>			
	<xs:element name="RepInterleaveAction" type="CIRCUS:RepParallelAction" substitutionGroup="CIRCUS:RepParallelAction">
		<xs:annotation>
			<xs:documentation>Circus action for replicated interleaving.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="RepParallelCompAction" type="CIRCUS:RepParallelCompAction" substitutionGroup="CIRCUS:RepParallelAction">
		<xs:annotation>
			<xs:documentation>Circus action for replicated parallel composition.</xs:documentation>
		</xs:annotation>
	</xs:element>					
	
	<!-- CSP Action :: Binary -->

  <xs:element name="SeqCompAction" type="CIRCUS:CSPAction2" substitutionGroup="CIRCUS:CSPAction2">
		<xs:annotation>
			<xs:documentation>Sequential composition of two actions.</xs:documentation>
		</xs:annotation>
	</xs:element>		
  <xs:element name="IntChoiceAction" type="CIRCUS:CSPAction2" substitutionGroup="CIRCUS:CSPAction2">
		<xs:annotation>
			<xs:documentation>Internal choice between two actions.</xs:documentation>
		</xs:annotation>
	</xs:element>		
  <xs:element name="ExtChoiceAction" type="CIRCUS:CSPAction2" substitutionGroup="CIRCUS:CSPAction2">
		<xs:annotation>
			<xs:documentation>External choice between two actions.</xs:documentation>
		</xs:annotation>
	</xs:element>		
  <xs:element name="ParallelAction" type="CIRCUS:ParallelAction" abstract="true" substitutionGroup="CIRCUS:CSPAction2">
		<xs:annotation>
			<xs:documentation>An abstract parallel action definition; it includes the name set partitions of the state.</xs:documentation>
		</xs:annotation>
	</xs:element>	
  <xs:element name="InterleaveAction" type="CIRCUS:ParallelAction" substitutionGroup="CIRCUS:ParallelAction">
		<xs:annotation>
			<xs:documentation>Interleaving between two actions.</xs:documentation>
		</xs:annotation>
	</xs:element>		
  <xs:element name="ParallelCompAction" type="CIRCUS:ParallelCompAction" substitutionGroup="CIRCUS:ParallelAction">
		<xs:annotation>
			<xs:documentation>
				Parallel composition between two actions; it includes the channel set expression for the synchronisation set.
			</xs:documentation>
		</xs:annotation>
	</xs:element>		
	
	<!-- CSP Communication --> 
	
	<xs:element name="Comm" type="CIRCUS:Comm">
		<xs:annotation>
			<xs:documentation>A CSP communication that is part of a prefixing.</xs:documentation>
		</xs:annotation>
	</xs:element>		

	<!-- CSP Communication Parameters --> 

	<xs:element name="CommParam" type="CIRCUS:CommParam" abstract="true">
		<xs:annotation>
			<xs:documentation>A CSP parameter that is part of a communication.</xs:documentation>
		</xs:annotation>
	</xs:element>		
	<xs:element name="CommIn" type="CIRCUS:CommIn" substitutionGroup="CIRCUS:CommParam">
		<xs:annotation>
			<xs:documentation>A CSP parameter that is part of an input communication.</xs:documentation>
		</xs:annotation>
	</xs:element>			
	<xs:element name="CommOut" type="CIRCUS:CommOut" substitutionGroup="CIRCUS:CommParam">
		<xs:annotation>
			<xs:documentation>A CSP parameter that is part of an input communication.</xs:documentation>
		</xs:annotation>
	</xs:element>			
	<xs:element name="CommMixed" type="CIRCUS:CommMixed" substitutionGroup="CIRCUS:CommParam">
		<xs:annotation>
			<xs:documentation>A CSP parameter that is part of an input communication.</xs:documentation>
		</xs:annotation>
	</xs:element>			
	
	<!-- Commands -->
	
  <xs:element name="SpecStmtCmd" type="CIRCUS:SpecStmtCmd" substitutionGroup="CIRCUS:Command">
		<xs:annotation>
			<xs:documentation>Command declaring a specification statement.</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="AssignmentCmd" type="CIRCUS:AssignmentCmd" substitutionGroup="CIRCUS:Command">
		<xs:annotation>
			<xs:documentation>Command declaring an assignment.</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="IfGuardedCmd" type="CIRCUS:IfGuardedCmd" substitutionGroup="CIRCUS:Command">
		<xs:annotation>
			<xs:documentation>
				Command declaring a if statement containing guarded actions.
				Although semantically different, we can represent the AST for the production of GuardedActions 
				from the BNF of if commands with the GuardedAction AST class. 
			</xs:documentation>
		</xs:annotation>
	</xs:element>			
  <xs:element name="VarDeclCmd" type="CIRCUS:VarDeclCmd" substitutionGroup="CIRCUS:Command">
		<xs:annotation>
			<xs:documentation>Command declaring variables local to an action definition.</xs:documentation>
		</xs:annotation>
	</xs:element>		
	
	<!-- Miscellaneous Circus Elements--> 
  <xs:element name="AssignmentPair" type="CIRCUS:AssignmentPair">
    <xs:annotation>
      <xs:documentation>A pair of a reference to a variable name and an expression for assignment.</xs:documentation>
    </xs:annotation>
  </xs:element>	

	<!-- ******************************************************************************************* -->
	<!-- ******************************************************************************************* -->
	
	<!-- Definitions of the complexTypes -->

	<!-- Circus program -->
  <xs:complexType name="CircusProgram">
    <xs:complexContent>
      <xs:extension base="Z:TermA">      
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusSect" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="Version" type="xs:string" use="optional" default="0.1"/>
        <xs:attribute name="Author" type="xs:string" use="optional"/>
        <xs:attribute name="Modified" type="xs:dateTime" use="optional"/>
        <xs:attribute name="Source" type="xs:anyURI" use="optional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
	
	<!-- Circus concrete section -->
	<xs:complexType name="CircusSect">
		<xs:complexContent>
			<xs:extension base="Z:Sect">
				<xs:sequence>
					<xs:element name="Name" type="xs:string"/>
					<xs:element ref="Z:Parent" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="CIRCUS:CircusPara" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	
	<!-- Circus paragraphs complexTypes -->
	<xs:complexType name="CircusPara">
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CircusZPara">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CircusPara">				
				<xs:sequence>
					<xs:element ref="Z:Para"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="ChannelDecl">
		<xs:complexContent>
      <xs:extension base="CIRCUS:CircusPara">
        <xs:sequence>
					<!-- Channel names could have strokes but some restrictions might apply to avoid "?" or "!" for instance.  -->
					<!-- This perhaps goes directly into the code of the parser.																							 -->
					
					<!-- QUESTION: Should here be VarDecl? The only difference is on minOccurs="1"> -->
          <!-- <xs:element ref="Z:DeclName" minOccurs="1" maxOccurs="unbounded"/> -->
          <!-- <xs:element ref="Z:Expr"/> -->
          <xs:element ref="Z:VarDecl"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="ChannelDeclSExpr">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CircusPara">
				<xs:sequence>
					<xs:element ref="Z:SchExpr"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CSDecl">
		<xs:complexContent>
      <xs:extension base="CIRCUS:CircusPara">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:CSExpr"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>				
	<xs:complexType name="ProcDecl">
		<xs:complexContent>
      <xs:extension base="CIRCUS:CircusPara">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:ProcDef"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>
		
	<!-- Channel Set Expression complexTyzpes -->	
	<xs:complexType name="CSExpr">
		<xs:complexContent>
	    <xs:extension base="Z:Expr0N"/>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="CSExprSet">
		<xs:complexContent>
      <xs:extension base="CIRCUS:CSExpr">
        <xs:sequence>
					<!-- Channel names could have strokes whenever they come from Schema expressions.  -->
					<!-- However, I don't know how input/output variables decorations are supposed to  -->
					<!-- be handled in channel declarations. -->
					<!-- At the moment, just leave it as RefName and restrict that in the code perhaps -->
          <xs:element ref="Z:RefName" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CSExprRef">
		<xs:complexContent>
      <xs:extension base="CIRCUS:CSExpr">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<!-- Process Definition complexType -->
	
	<xs:complexType name="ProcDef">
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CallProc">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcDef">
				<xs:sequence>
					<xs:element ref="Z:RefName"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="ProcDesc">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcDef">
				<!-- As it can appear in any order, does it matter to put here xs:any instead? -->
				<xs:sequence>
					<xs:element name="StateSchemaAction" type="CIRCUS:SchemaAction" minOccurs="0"/>
					<xs:element ref="CIRCUS:ProcPara" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="CIRCUS:ActionDef" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="Proc1">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcDef">
				<xs:sequence>
					<xs:element ref="CIRCUS:ProcDef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="ProcE">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Proc1">
				<xs:sequence>
					<xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="ProcD">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Proc1">
				<xs:sequence>
					<!-- QUESTION: Should here be VarDecl? The only difference is on minOccurs="1"> -->
          <!-- <xs:element ref="Z:DeclName" minOccurs="1" maxOccurs="unbounded"/> -->
          <!-- <xs:element ref="Z:Expr"/> -->
          <xs:element ref="Z:VarDecl"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="ProcR">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcD"/>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="ProcRI">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcR"/>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="Proc2">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcDef">
				<xs:sequence>
					<xs:element ref="CIRCUS:ProcDef">
                                          <xs:annotation>
                                            <xs:appinfo>
                                              <jaxb:property name="LeftProc"/>
                                            </xs:appinfo>
                                          </xs:annotation>
                                        </xs:element>
					<xs:element ref="CIRCUS:ProcDef">
                                         <xs:annotation>
                                            <xs:appinfo>
                                              <jaxb:property name="RightProc"/>
                                            </xs:appinfo>
                                          </xs:annotation>
                                        </xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		

	<!-- Process Definition :: Unary -->
	
	<xs:complexType name="HideProc">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Proc1">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpr"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>				
	<xs:complexType name="RenameProc">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Proc1">
				<xs:sequence>
					<xs:element name="OldNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
					<xs:element name="NewNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="FormalGenProc">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Proc1">
				<xs:sequence>
					<xs:element name="FormalGenTypes" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>				

	<!-- Process Definition :: Unary :: Declaration :: Replicated -->		
	
	<xs:complexType name="RepParallelCompProc">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcR">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpr"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>					

	<!-- Process Definition :: Unary :: Declaration :: Replicated :: Indexed -->		
	
	<xs:complexType name="IdxRepParallelCompProc">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcRI">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpr"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>					

	<!-- Process Definition :: Binary -->	
	
	<xs:complexType name="ParallelCompProc">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Proc2">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpr"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>				
	
	<!-- Process Paragraphs complexTypes -->
	
	<xs:complexType name="ProcPara">
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>	
	<xs:complexType name="ProcZPara">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcPara">
				<xs:sequence>					
					<xs:element ref="Z:Para"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="NSDecl">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcPara">
				<xs:sequence>					
					<xs:element ref="Z:DeclName"/>
					<xs:element ref="CIRCUS:NSExpr"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActionDecl">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ProcPara">
				<xs:sequence>					
					<xs:element ref="Z:DeclName"/>
					<xs:element ref="CIRCUS:ActionDef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<!-- Name Set Expression complexTyzpes -->	
	<xs:complexType name="NSExpr">
		<xs:complexContent>
	    <xs:extension base="Z:Expr0N"/>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="NSExprSet">
		<xs:complexContent>
      <xs:extension base="CIRCUS:NSExpr">
        <xs:sequence>
          <xs:element ref="Z:RefName" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NSExprRef">
		<xs:complexContent>
      <xs:extension base="CIRCUS:NSExpr">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	
	<!-- Action Definition complexType -->
	
	<xs:complexType name="ActionDef">
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="SchemaAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ActionDef">			
				<xs:sequence>
				  <xs:element ref="Z:SchExpr"/>
        </xs:sequence>
      </xs:extension>  
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CSPAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ActionDef"/>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CSPAction1">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPAction">
				<xs:sequence>
					<xs:element ref="CIRCUS:ActionDef"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CSPActionD">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPAction1">
				<xs:sequence>
					<!-- QUESTION: Should here be VarDecl? The only difference is on minOccurs="1"> -->
          <!-- <xs:element ref="Z:DeclName" minOccurs="1" maxOccurs="unbounded"/> -->
          <!-- <xs:element ref="Z:Expr"/> -->
          <xs:element ref="Z:VarDecl"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CSPActionR">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPActionD"/>
		</xs:complexContent>
	</xs:complexType>		
  <xs:complexType name="CSPAction2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CSPAction">
        <xs:sequence>
        	<!-- Check wether GnAST likes this form or the other on given in ParallelAction -->
          <xs:element ref="CIRCUS:ActionDef">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ActionDef">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>	
	<xs:complexType name="Command">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ActionDef"/>
		</xs:complexContent>
	</xs:complexType>		
	
	<!-- CSP Action complexType -->
	
	<xs:complexType name="CSPBasicAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPAction"/>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="CallAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPBasicAction">
				<xs:sequence>
					<!-- Action names are not supposed to have strokes, but are indeed reference to names -->
					<!-- At the moment, just leave it as RefName and restrict that in the code perhaps    -->
					<xs:element ref="Z:RefName"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>	
	
	<!-- CSP Action complexType :: Unary -->
	
	<xs:complexType name="MuAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPAction1">
				<xs:sequence>
					<xs:element ref="Z:DeclName"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="GuardedAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPAction1">
				<xs:sequence>
					<xs:element ref="Z:Pred"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="HideAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPAction1">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpr"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="PrefixingAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPAction1">
				<xs:sequence>
					<xs:element ref="CIRCUS:Comm"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>			
	<xs:complexType name="ActualParamAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPAction1">
				<xs:sequence>
					<xs:element ref="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>				

	<!-- CSP Action complexType :: Unary :: Declaration :: Replicated -->

	<xs:complexType name="RepParallelAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPActionR">
				<xs:sequence>
					<xs:element ref="CIRCUS:NSExpr">
                                         <xs:annotation>
                                            <xs:appinfo>
                                              <jaxb:property name="LeftNS"/>
                                            </xs:appinfo>
                                          </xs:annotation>
                                        </xs:element>
					<xs:element ref="CIRCUS:NSExpr">
                                         <xs:annotation>
                                            <xs:appinfo>
                                              <jaxb:property name="RightNS"/>
                                            </xs:appinfo>
                                          </xs:annotation>
                                        </xs:element>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="RepParallelCompAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:RepParallelAction">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpr"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		  


	<!-- CSP Action complexType :: Binary -->

	<xs:complexType name="ParallelAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CSPAction2">
				<xs:sequence>
					<xs:element ref="CIRCUS:NSExpr">
                                         <xs:annotation>
                                            <xs:appinfo>
                                              <jaxb:property name="LeftNS"/>
                                            </xs:appinfo>
                                          </xs:annotation>
                                        </xs:element>
					<xs:element ref="CIRCUS:NSExpr">
                                         <xs:annotation>
                                            <xs:appinfo>
                                              <jaxb:property name="RightNS"/>
                                            </xs:appinfo>
                                          </xs:annotation>
                                        </xs:element>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		
	<xs:complexType name="ParallelCompAction">
		<xs:complexContent>
			<xs:extension base="CIRCUS:ParallelAction">
				<xs:sequence>
					<xs:element ref="CIRCUS:CSExpr"/>
        </xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		  

	<!-- CSP Communication complexType -->
	
	<xs:complexType name="Comm">
		<xs:complexContent>
			<xs:extension base="Z:TermA">
				<xs:sequence>
					<xs:element ref="Z:RefName"/>
					<xs:element ref="CIRCUS:CommParam" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="CommType" type="CIRCUS:CommType" use="optional" default="Synch"/>
				<xs:attribute name="MultiSych" type="xs:nonNegativeInteger" use="optional" default="0"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="CommType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Synch"/>
			<xs:enumeration value="Input"/>
			<xs:enumeration value="Output"/>
			<xs:enumeration value="Mixed"/>
		</xs:restriction>
	</xs:simpleType>	
	
	<!-- CSP Communication parameters complexType -->
	
	<xs:complexType name="CommParam">
		<xs:complexContent>
			<xs:extension base="Z:TermA"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CommIn">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CommParam">
				<xs:sequence>
					<xs:element ref="Z:RefName"/>
					<xs:element ref="Z:Pred" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CommOut">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CommParam">
				<xs:sequence>
					<xs:element ref="Z:Expr"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>	
	<xs:complexType name="CommMixed">
		<xs:complexContent>
			<xs:extension base="CIRCUS:CommParam">
				<xs:sequence>
					<!-- At least one In or Out must be available; but in (or out) only is allowed. Can this be guaranteed at the schema? -->					
					<!-- Here the order does not matter, hence it could have been a xs any instead. -->
					<xs:element ref="CIRCUS:CommIn" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="CIRCUS:CommOut" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>	

	<!-- CSP Commands complextype -->	

	<xs:complexType name="SpecStmtCmd">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Command">
				<xs:sequence>				
					<xs:element name="Frame" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
					<xs:element name="Pre" type="Z:Pred"/>
					<xs:element name="Post" type="Z:Pred"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		  
	<xs:complexType name="AssignmentCmd">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Command">
				<xs:sequence>				
					<!-- QUESTION: How to enforce that the card(LHS) = card(RHS)? Defining a pair?-->
					<!-- <xs:element name="LHS" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/> -->
					<!-- <xs:element name="RHS" type="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>		 -->
					<xs:element ref="CIRCUS:AssignmentPair" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		  
	<xs:complexType name="IfGuardedCmd">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Command">
				<xs:sequence>									
					<xs:element name="GuardedActions" type="CIRCUS:GuardedAction" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		  
  <xs:complexType name="VarDeclCmd">
		<xs:complexContent>
			<xs:extension base="CIRCUS:Command">
				<xs:sequence>				
					<!-- Should here be VarDecl or DeclNames (unbounded) + Expr? -->
					<xs:element ref="Z:VarDecl"/>
					<xs:element ref="CIRCUS:ActionDef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>		  

	<!-- Miscellaneous Circus Elements -->
	
	<!-- Defined like NameExprPair from Z_1_3.xsd,v 1.1 2004/08/23 01:59:59; mixed=false, seems to make GnAST extend Term and not TermA -->
	<xs:complexType name="AssignmentPair" mixed="false">
		<xs:sequence>				
			<xs:element name="LHS" type="Z:RefName"/> 
			<xs:element name="RHS" type="Z:Expr"/>		 
		</xs:sequence>
	</xs:complexType>		  
  
</xs:schema>
