<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  targetNamespace="http://czt.sourceforge.net/circus"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:CIRCUS="http://czt.sourceforge.net/circus"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="0.1">
  <xs:annotation>
    <xs:documentation>
      Copyright 2005 Leonardo Freitas
      $Id$

      This XML schema defines XML markup for formal specifications 
      written in Circus, a concurrent language for refinement that
      combines CSP, Z and the refinement calculus.
      More information at <a href="http://www.cs.york.ac.uk/~circus">Circus main web page</a>
      or at <a href="http://www.cs.york.ac.uk/~leo">the author'ss web page</a>.

      This file is part of the Community Z Tools (CZT) project.
 
      The CZT project contains free software; you can
      redistribute it and/or modify it under the terms
      of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of
      the License, or (at your option) any later version.
 
      The CZT project is distributed in the hope that it
      will be useful, but WITHOUT ANY WARRANTY; without
      even the implied warranty of MERCHANTABILITY or
      FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.

      You should have received a copy of the GNU General
      Public License along with CZT; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place,
      Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
      <jaxb:schemaBindings>
        <jaxb:package name="net.sourceforge.czt.circus.jaxb.gen">
          <jaxb:javadoc>
            &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
            &lt;html&gt;
            &lt;body&gt;
            &lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
          </jaxb:javadoc>
        </jaxb:package>
      </jaxb:schemaBindings>
      <gnast:schemaBindings name="Circus">
        <gnast:package name="net.sourceforge.czt.circus">
          <gnast:package id="ast" name="ast">
            <gnast:generate id="factory" class="CircusFactory" template="CoreFactory.vm"/>
          </gnast:package>
          <gnast:package id="impl" name="impl">
            <gnast:generate id="factoryImpl" class="CircusFactoryImpl" template="CoreFactoryImpl.vm"/>
          </gnast:package>
          <gnast:package id="visitor" name="visitor">
            <gnast:generate id="AstVisitor" class="CircusVisitor" template="AstVisitor.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="convFactory" class="Factory" template="Factory.vm"/>
          </gnast:package>
          <gnast:package id="jaxb" name="jaxb">
            <gnast:generate id="AstToJaxb" class="AstToJaxb" template="AstToJaxb.vm"/>
            <gnast:generate id="JaxbToAst" class="JaxbToAst" template="JaxbToAst.vm"/>
          </gnast:package>
          <gnast:package id="dom" name="dom">
            <gnast:generate id="AstToDom" class="AstToDom" template="AstToDom.vm"/>
          </gnast:package>
        </gnast:package>
      </gnast:schemaBindings>
    </xs:appinfo>
  </xs:annotation>

  <xs:import namespace="http://czt.sourceforge.net/zml" schemaLocation="Z.xsd"/>

  <!-- ********************************************************************* -->
  <!-- Definitions of the elements in the order of appearance in the grammar -->
  <!-- ********************************************************************* -->

  <!-- Paragraphs -->
  <xs:element name="ChannelPara" type="CIRCUS:ChannelPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel paragraph that declares channel names with corresponding types, possibly generic. 
        Channels are used in process definitions. Strokes are not allowed in channel names, and this is
        ensured by the parser. 
        </p>
        <p>
        It represents the <b>channel</b> <code>ChannelDecl</code> grammar rule.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ChannelSetPara" type="CIRCUS:ChannelSetPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel set paragraph that declares a name for a channel set expression.
        Strokes are not allowed in channel set names, and this is ensured by the parser.
        </p>
        <p>
        It represents the <b>channelset</b> <code>N == CSExpression</code> grammar rule, 
        where <code>N</code> is a <code>DeclName</code>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessPara" type="CIRCUS:ProcessPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
        A process paragraph that introduces a name for a process definition.
        Strokes are not allowed in process names, and this is ensured by the parser.
        </p>
        <p>
        This element represents the <b>ProcessDeclaration</b> grammar rule.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Channel Declaration -->
  
  <xs:element name="ChannelDecl" type="CIRCUS:ChannelDecl" substitutionGroup="Z:Decl">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel declaration is a Z declaration that accepts generic types.
        It represents the <b>SimpleCDeclaration</b> grammar rule.
        </p>
        <p>
        Channels can be declared only through variable declaration or schema inclusion.
        <code>ConstDecl</code> is forbidden by the parser grammar rules.
        </p>
        <p>
        Invariant: <code>Decl</code> is always <code>VarDecl</code> or <code>InclDecl</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Channel Set Expressions -->
  <xs:element name="ChannelSet" type="CIRCUS:ChannelSet" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract channel set expression. It represents the <b>CSExpression</b> grammar rule.
        </p>
        <p>
        Although it is formed by a Z expression, channel set expressions cannot appear wherever a Z expression can;
        they are only allowed in parallel operators. We have chosen to keep it separate from the <code>Expr</code>
        tree for simplicity.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="BasicChannelSet" type="CIRCUS:BasicChannelSet" substitutionGroup="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel set expression containing a set of references to previously declared channel names (i.e. channel references).
        It represents the grammar rules for empty and enumerated channel sets.
        </p>
        <p>
        As GnAST represents unbounded occurrences with <code>List</code>, the parser must enforce that 
        given <code>RefName</code> are unique (i.e. forms a <code>Set</code>. A well typed <code>BasicChannelSet</code>
        channel set must ensure that the given names refers to previously declared channel names.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="RefChannelSet" type="CIRCUS:RefChannelSet" substitutionGroup="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel set expression referencing a declared channel set paragraph. 
        It represents the grammar rule for channel set reference.
        </p>
        <p>
        A well typed <code>RefChannelSet</code> must ensure that the given name refers to previously 
        declared channel set.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- DESIGN DECISION + MODIFICATION:
  
    It is interesting to generalise channel and name set operations for any operation in Z, such as operators 
    and function applications. Therefore, we have to encapsulate them as a Z Expr with the following production.
    A similar change happens for NameSet. To avoid duplicated complexTypes, we have used the same complexTypes
    structure for both ChannelSets and NameSets.
    
    The only expressions allowed are RefExpr for RefChannelSet, SetExpr for BasicChannelSet and ApplExpr for 
    any operation needed.
    As the grammar already have explicit productions for Channel sets, and to avoid mixing with the (rather complex) Z:Expr tree, 
    we provide these classes separately here. The only complicated one we have no scape is ApplExpr as defined by the new 
    ApplChannelSet element.     
 
  <xs:element name="ChannelSet2" type="CIRCUS:ChannelSet2" abstract="true" substitutionGroup="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        An abstract binary channel set expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="UnionChannelSet" type="CIRCUS:ChannelSet2" substitutionGroup="CIRCUS:ChannelSet2">
    <xs:annotation>
      <xs:documentation>
        Set union over channel set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntersectionChannelSet" type="CIRCUS:ChannelSet2" substitutionGroup="CIRCUS:ChannelSet2">
    <xs:annotation>
      <xs:documentation>
        Set intersection over channel set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="DifferenceChannelSet" type="CIRCUS:ChannelSet2" substitutionGroup="CIRCUS:ChannelSet2">
    <xs:annotation>
      <xs:documentation>
        Set difference over channel set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  -->
  <xs:element name="ApplChannelSet" type="CIRCUS:ApplChannelSet" substitutionGroup="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel set application. It represents the application of any Z function where the 
        result is a set of names, through the encapsulation of an <code>ApplExpr</code>. 
        It represents the grammar rules involving applied functions to channel sets.
        </p>
        <p>
        As operators and function applications can sometimes be given as <code>RefExpr</code>, 
        it is the task of the parser to generate the appropriate <code>RefExpr</code> or <code>ApplExpr</code> classes.
        Moreover, a well typed <code>ApplChannelSet</code> can accept any parameter and must return a set of <code>RefName</code>s.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
        
  <!-- Process Description -->                
  <!-- DESIGN DECISION
      In order to allow a more uniform implementation, we avoided having an explicit ProcessDesc hierarchy tree.
      Instead, we expect the parser to actually manage the appropriate creation, hence allowing productions such as:      
      (x: \nat @ c \then STOP) \extchoice (y: \nat @ d \then STOP).
      
      This decision allows one to have a uniform/intuitive implementation of Declaration::Unary processes as expected. 
      That is, ParamProcessDesc and IndexedProcessDesc are considered unary as well.

  <xs:element name="ProcessDesc" type="CIRCUS:ProcessDesc" abstract="true">
      <xs:annotation>
          <xs:documentation>
              An abstract process description.
              Available extensions process definition, parameterised process, and indexed process.
          </xs:documentation>
      </xs:annotation>
  </xs:element>
  <xs:element name="ParamProcessDesc" type="CIRCUS:ParamProcessDesc" substitutionGroup="CIRCUS:ProcessDesc">
    <xs:annotation>
      <xs:documentation>
        A parameterised process description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IndexedProcessDesc" type="CIRCUS:ParamProcessDesc" substitutionGroup="CIRCUS:ProcessDesc">
    <xs:annotation>
      <xs:documentation>
        An indexed process description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>      
  -->

  <!-- Processes -->    
  <xs:element name="CircusProcess" type="CIRCUS:CircusProcess" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract Circus process definition. It represents the <b>ProcessDefinition</b> grammar rule.
        Available extensions are basic process description; recursion; prefixing; guarded process; 
        process call; all forms of unary, binary, iterated, and indexed processes;
        processes involving expressions; and processes involving declarations. 
        </p>
        <p>
        The parser is responsible to enforce restrictions over process definitions involving parameters 
        or indexes within some binary productions. For instance, the parse must rule out cases such as 
        <code>(x: nat @ A) [] (y: nat @ B)</code>, since parameterised process can only appear in an 
        external choice whenever the actual parameters are given.
        </p>
        <p>        
        This allows us to represent the grammar rules <b>ProcessDefinition</b> and <b>Process</b> with 
        a single class. The main advantage is that we can treat unary process definitions uniformly 
        through a single hierarchy tree.
        </p>
        <p>
        Naming this class <code>Process</code> would have been a better choice but unfortunately this would 
        conflict with the interface <code>java.lang.Process</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Process1" type="CIRCUS:Process1" abstract="true" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract unary Circus process.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="Process2" type="CIRCUS:Process2" abstract="true" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract binary Circus process.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessD" type="CIRCUS:ProcessD" abstract="true" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract unary Circus process with Z declarations.</p>
        <p>The parser must enforce that the declared variables do not have strokes via <code>VarDecl</code>,
           that strokes should be ignored via <code>InclDecl</code> (schema inclusion), and that <code>ConstDecl</code>
           is not allowed at all.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessIte" type="CIRCUS:ProcessIte" abstract="true" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract iterated Circus process with Z declarations.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <!-- DESIGN DECISION:
    Originally the substitution group for ProcessIdx was ProcessD, hence the two subtrees for iterated and
    indexed iterated processes were siblings. However, yet RI is not a simple syntactic sugar due to the 
    special renaming that changes the channel types, one can see it as a replication followed by a kind of 
    renaming. Therefore, by deriving from ProcessIte instead of ProcessD, we give the user the chance to reuse
    visiting code for replication and then further add the necessary renaming functionality. If, on the other 
    hand, a different treatment of replication becomes necessary, one just needs to ignore the superclass 
    implementation from ProcessIte and provide a new one for the replication task.
  -->
  <xs:element name="ProcessIdx" type="CIRCUS:ProcessIdx" abstract="true" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract indexed and iterated Circus process with Z declarations.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process :: Unary with Declaration -->
  <xs:element name="ParamProcess" type="CIRCUS:ProcessD" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        <p>
        A parameterised process definition. It represents grammar rule <b>Declaration @ ProcessDefinition</b>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IndexedProcess" type="CIRCUS:ProcessD" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        An indexed process definition. It represents grammar rule <b>Declaration odot ProcessDefinition</b>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>     

  <!-- Process :: Basic -->

  <xs:element name="BasicProcess" type="CIRCUS:BasicProcess" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>
        A process definition for an explicit process declaration.
        It is formed by a (possibly empty) set of process paragraphs,
        an optional process state given as a schema action,
        and a (mandatory) main action definition.
        </p>
        <p>
        It represents the grammar rule <b>begin</b> <code>PParagraph*</code> <b>state</b> <code>Schema-Exp PParagraph*</code>
        <b>@</b> <code>Action</code> <b>end</b>.
        </p>
        <p>
                For the process state, the corresponding action (as a SchExprAction) or Z paragraph (as a Schema or HorizontalDef) 
                must contain a <code>CircusStateAnn</code> annotation.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="CircusStateAnn" type="CIRCUS:CircusStateAnn" substitutionGroup="Z:Ann">
    <xs:annotation>
        <xs:documentation>
            Defines if a given paragraph is the process state. The parser must enforce such a paragraph is a schema.
        </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="OnTheFlyDefAnn" type="CIRCUS:OnTheFlyDefAnn" substitutionGroup="Z:Ann">
    <xs:annotation>
        <xs:documentation>
            Defines an on-the-fly definition annotation used for both processes and actions.
            It must be included into <code>ParamAction</code> and <code>ParamProcess</code> by 
            the parser whenever an on-the-fly definition occurs.
        </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process :: Call -->

  <!-- DESIGN DECISION: 
  
    As Circus allows calls over definitions given on-the-fly, we need a more powerful approach for a call,
    rather than a simple RefName. There are two approaches for the implementation of process/action calls.
    We have taken the first one in order to simplify the implementation of visitor of different tools.
    
    The first demands specialised CallType attribute on CallProcess, whereas the second introduces specialised classes      
    for each special production. For processes, these are actual parameters, indexes, and actual types. For action 
    these are actual parameters, and command parameters.
    
    Another interesting issue is that in the production tree, one is allowed to use a Process for renaming 
    (Process[N^+ := N^+]).  This allowed the definition of renaming on-the-fly (unnamed) or via a call processes.                                                
    Ex:  (c?x \then Skip)[c := b] or P = (c?x \then Skip), Q = P[c := b].
    On the second case via CallProcess it means that the CircusProcess descendent of ProcessDesc is being selected.
    In turn, the kind of CircusProcess is CallProcess and the list of renaming names are under RenameProcess.
    This allows both indexed and parameterised processes to use renaming hence creating a undesired ambiguity.
    
    The second approach is to have individual classes for this on-the-fly declaration and call directly,
    together with a base case of call with simple name on it. See more details below at ActualParamProcess.     
  -->
  <xs:element name="CallProcess" type="CIRCUS:CallProcess" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus process reference call. In other words, it permits a name to be a process.
        That is, it contains a reference name to lookup the process definition.
        </p>
        <p>
        Moreover, it contains a list of expressions and an attribute defining the kind of call this 
        reference is related too. An empty list of expressions means a simple process call of the grammar rule <b>N</b>,
        where <b>N</b> is the process name.
        If the list of expressions is not empty, then the <code>CallType</code> attribute defines if this is an indexed 
        process instantiation call, a parameterised process call, or a generic process instantiation call.
        </p>
        <p>
        It represents the grammar rules: <b>N, N(Expr+), N[Expr+], N lfloor Expr+ rfloor</b>
        </p>
        <p>
        The <code>CallType</code> invariant is as follows:        
        <ul>
          <li>Normal = nonempty name and empty parameters. </li>
          <li>Param  = nonempty parameters. Empty name for on-the-fly, nonempty name for previously declared paragraph. </li>
          <li>Index  = same as Param with the different token recognition.</li>
          <li>Gen    = nonempty name and nonempty parameters.</li>
          <li>GenParam = nonempty name and nonempty parameters.</li>
          <li>GenIndex = nonempty name and nonempty parameters.</li>
        </ul>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process :: Unary  -->  
  <xs:element name="MuProcess" type="CIRCUS:MuProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        <p>The mu operator defines a recursive process.</p>
        <p>The parser must enforce that the given name does not have strokes.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="GuardedProcess" type="CIRCUS:GuardedProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        <p>The CSP guarded process defines a process guarded by a Z predicate.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="HideProcess" type="CIRCUS:HideProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        Circus process with event concealment through hiding.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="PrefixingProcess" type="CIRCUS:PrefixingProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        The CSP operator for processes prefixed with a communication.
      </xs:documentation>
    </xs:annotation>        
  </xs:element>
  <xs:element name="RenameProcess" type="CIRCUS:RenameProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        Circus process with channel renaming. As channels in Circus are strongly-typed, type-checking is expected.
        Note that, since the class derives from <code>Process1</code>, the grammar does not accept on-the-fly renaming 
        of parameterised processes. ex: (x: \nat @ c!x -> Stop)[c := b]. This is a design decision for uniformity purposes only.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  

  <!-- Process Definition :: Binary -->
  <xs:element name="SeqProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParProcess" type="CIRCUS:ParProcess" substitutionGroup="CIRCUS:Process2" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract circus process for parallel operators.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcess" type="CIRCUS:ParProcess" substitutionGroup="CIRCUS:ParProcess">
    <xs:annotation>
      <xs:documentation>
        Circus process for interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcess" type="CIRCUS:ParallelProcess" substitutionGroup="CIRCUS:ParProcess">
    <xs:annotation>
      <xs:documentation>
        Circus process for parallel composition;
        it includes the synchronisation set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelProcess" type="CIRCUS:AlphabetisedParallelProcess" substitutionGroup="CIRCUS:ParProcess">
    <xs:annotation>
      <xs:documentation>
        Circus alphabetised parallel process; it includes the two alphabets as channel sets.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process Definition :: Expressions -->

  <!--
    DESIGN DECISION: 
      The next element was used for on-the-fly declaration of parameters for processes. 
      A similar construction needed to be created for indexes, and actual types. 
      Actions and commands also have similar constructs.
      
      These constructs usually appear through refinement steps from tools rather than directly by the user.           
      As the treatment of each of these cases is very similar, having separate AST nodes would possibly mean 
      repeated code (versioning and maintenance problems). 
      
      Instead, as the treatment of each of these cases is equivalent to a CallProcess with the appropriate call 
      type determining the meaning of the list of expressions, we assume that the Circus parser will interpret
      these cases appropriately by generating internal ProcessPara on-the-fly with reserved names not allowed to
      be declared by the user.

  <xs:element name="ProcessE" type="CIRCUS:ProcessE" abstract="true" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        An abstract Circus process involving expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
    <xs:element name="ActualParamProcess" type="CIRCUS:ActualParamProcess" substitutionGroup="CIRCUS:ProcessE">
      <xs:annotation>
        <xs:documentation>
          Defines a parameterised Circus process on-the-fly with its actual parameter.
          This enables on-the-fly declaration of parameterised indexed processes.             
          Ex: (x: T \spot c.x \then Skip)~(0) \equiv c.0 \then Skip.
          Note that this is different from a parameterised process description with a reference name calling 
          it with the given actual parameters.
          Ex: P = (x: T \spot c.x \then Skip).
                  Q = P~(0).
        </xs:documentation>
      </xs:annotation>
  </xs:element>
  <xs:element name="InstantiationProcess" type="CIRCUS:InstantiationProcess" substitutionGroup="CIRCUS:ProcessE">
    <xs:annotation>
      <xs:documentation>
        Defines a indexed Circus process on-the-fly with its actual instantiation
        This enables on-the-fly declaration of indexed parameterised processes.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  -->

  <!-- Process Definition :: Unary :: Declaration :: Iterated -->
  <xs:element name="SeqProcessIte" type="CIRCUS:ProcessIte" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcessIte" type="CIRCUS:ProcessIte" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcessIte" type="CIRCUS:ProcessIte" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParProcessIte" type="CIRCUS:ParProcessIte" substitutionGroup="CIRCUS:ProcessIte" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract circus iterated parallel process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcessIte" type="CIRCUS:ParProcessIte" substitutionGroup="CIRCUS:ParProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcessIte" type="CIRCUS:ParallelProcessIte" substitutionGroup="CIRCUS:ParProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="AlphabetisedParallelProcessIte" type="CIRCUS:ParallelProcessIte" substitutionGroup="CIRCUS:ParProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for alphabetised iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition :: Unary :: Declaration :: Iterated :: Indexed -->
  <xs:element name="SeqProcessIdx" type="CIRCUS:ProcessIdx" substitutionGroup="CIRCUS:ProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcessIdx" type="CIRCUS:ProcessIdx" substitutionGroup="CIRCUS:ProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="IntChoiceProcessIdx" type="CIRCUS:ProcessIdx" substitutionGroup="CIRCUS:ProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParProcessIdx" type="CIRCUS:ParProcessIdx" substitutionGroup="CIRCUS:ProcessIdx" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract circus indexed iterated parallel process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="InterleaveProcessIdx" type="CIRCUS:ParProcessIdx" substitutionGroup="CIRCUS:ParProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcessIdx" type="CIRCUS:ParallelProcessIdx" substitutionGroup="CIRCUS:ParProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelProcessIdx" type="CIRCUS:ParallelProcessIdx" substitutionGroup="CIRCUS:ParProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for alphabetised indexed and iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Action Para -->
  <xs:element name="ActionPara" type="CIRCUS:ActionPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
        A action paragraph that declares a name for an action definition.
        Strokes are not allowed in channel set names, and this is ensured by the parser.
        </p>
        <p>
        This element represents the <code>N == ParAction</code> grammar rule, where,
        where <code>N</code> is a <code>DeclName</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Name Set Paragraphs -->
  <xs:element name="NameSetPara" type="CIRCUS:NameSetPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>        
        <p>
        A name set declaration that introduces a name for a name set expression.
        Strokes are not allowed in channel set names, and this is ensured by the parser.
        </p>
        <p>
        It represents the <b>nameset</b> <code>N == NSExpression</code> grammar rule, 
        where <code>N</code> is a <code>DeclName</code>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Name Set Expressions -->
  <xs:element name="NameSet" type="CIRCUS:NameSet" abstract="true">
    <xs:annotation>
      <xs:documentation>        
        <p>
        An abstract name set expression. It represents the <b>NSExpression</b> grammar rule.
        </p>
        <p>
        Although it is formed by a Z expression, name set expressions cannot appear wherever a Z expression can;
        they are only allowed in parallel operators. We have chosen to keep it separate from the <code>Expr</code>
        tree for simplicity.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="BasicNameSet" type="CIRCUS:BasicNameSet" substitutionGroup="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>
        <p>
        A name set expression containing a set of references to user state declared names (i.e. state variable references).
        It represents the grammar rules for empty and enumerated name sets.
        </p>
        <p>
        As GnAST represents unbounded occurrences with <code>List</code>, the parser must enforce that 
        given <code>RefName</code> are unique (i.e. forms a <code>Set</code>. A well typed <code>BasicNameSet</code>
        channel set must ensure that the given names refers to previously declared channel names.
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="RefNameSet" type="CIRCUS:RefNameSet" substitutionGroup="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>
        <p>
        A name set expression referencing a declared name set paragraph. 
        It represents the grammar rule for name set reference.
        </p>
        <p>
        A well typed <code>RefNameSet</code> must ensure that the given name refers to previously 
        declared name set.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <!-- See further comments at ChannelSet2
  <xs:element name="NameSet2" type="CIRCUS:NameSet2" abstract="true" substitutionGroup="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>
        An abstract binary name set expression.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="UnionNameSet" type="CIRCUS:NameSet2" substitutionGroup="CIRCUS:NameSet2">
    <xs:annotation>
      <xs:documentation>
        Set union over name set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntersectionNameSet" type="CIRCUS:NameSet2" substitutionGroup="CIRCUS:NameSet2">
    <xs:annotation>
      <xs:documentation>
        Set intersection over name set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="DifferenceNameSet" type="CIRCUS:NameSet2" substitutionGroup="CIRCUS:NameSet2">
    <xs:annotation>
      <xs:documentation>
        Set difference over name set expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  -->
  <xs:element name="ApplNameSet" type="CIRCUS:ApplNameSet" substitutionGroup="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>
        <p>
        A name set application. It represents the application of any Z function where the 
        result is a set of names, through the encapsulation of an <code>ApplExpr</code>. 
        It represents the grammar rules involving applied functions to name sets.
        </p>
        <p>
        As operators and function applications can sometimes be given as <code>RefExpr</code>, 
        it is the task of the parser to generate the appropriate <code>RefExpr</code> or <code>ApplExpr</code> classes.
        Moreover, a well typed <code>ApplNameSet</code> can accept any parameter and must return a set of <code>RefName</code>s.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
    
  <!-- Action Description -->     
  <!-- See ProcessDesc above 
  <xs:element name="ActionDesc" type="CIRCUS:ActionDesc" abstract="true">
      <xs:annotation>
          <xs:documentation>
              An abstract action description.
              Available extensions action definition, and parameterised action.
          </xs:documentation>
      </xs:annotation>
  </xs:element>
  <xs:element name="ParamActionDesc" type="CIRCUS:ParamActionDesc" substitutionGroup="CIRCUS:ActionDesc">
    <xs:annotation>
      <xs:documentation>
        A parameterised action description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  -->
  
  <!-- Actions -->    
  <xs:element name="CircusAction" type="CIRCUS:CircusAction" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract Circus action definition. It represents the <b>ParAction</b> grammar rule.
        Available extensions are recursion; prefixing; guarded actions; action call; 
        all forms of unary, binary, iterated, and indexed actions;
        actions involving expressions; and actions involving declarations. 
        </p>
        <p>
        The parser is responsible to enforce restrictions over action definitions involving parameters 
        within some binary productions. For instance, the parse must rule out cases such as 
        <code>(x: nat @ A) [] (y: nat @ B)</code>, since parameterised actions can only appear in an 
        external choice whenever the actual parameters are given.
        </p>
        <p>        
        This allows us to represent the grammar rules <b>ParAction</b>, <b>Action</b>, and <b>CSPAction</b>
        with a single class. The main advantage is that we can treat unary action definitions uniformly 
        through a single hierarchy tree.
        </p>
        <p>
        Naming this class <code>Action</code> would have been a better choice but it often conflicts with 
        other main stream Java libraries class names.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Action1" type="CIRCUS:Action1" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        An abstract unary Circus action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="Action2" type="CIRCUS:Action2" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        An abstract binary Circus action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="ActionD" type="CIRCUS:ActionD" abstract="true" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract unary Circus action with Z declarations.
        </p>
        <p>
        The parser must enforce that the declared variables do not have strokes via <code>VarDecl</code>,
        that strokes should be ignored via <code>InclDecl</code> (schema inclusion), and that <code>ConstDecl</code>
        is not allowed at all.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="ActionIte" type="CIRCUS:ActionIte" abstract="true" substitutionGroup="CIRCUS:ActionD">
    <xs:annotation>
      <xs:documentation>
        An abstract iterated unary Circus action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Action :: Unary with Declaration -->
  <xs:element name="ParamAction" type="CIRCUS:ActionD" substitutionGroup="CIRCUS:ActionD">
    <xs:annotation>
      <xs:documentation>
        A parameterised action definition. It represents grammar rule <b>Declaration @ ParAction</b>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Action :: Commands (base class) -->
  <xs:element name="CircusCommand" type="CIRCUS:CircusCommand" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract command action definition. Available extensions are specification statement
        in Carroll Morgan's style; (possibly multiple) assignment; if guards in Dijkstra's style;
        (possibly multiple) variable declaration; and parameterised commands with qualified declarations.
        </p>
        <p>It represents the grammar rule <b>ParCommand</b> as the base class of Circus commands.</p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>    

  <!-- Action :: Schema-Exp -->  
  
  <xs:element name="SchExprAction" type="CIRCUS:SchExprAction" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        An action given as a schema expression.
        In this way, schema expressions are included into the <code>CircusAction</code> subtree
        in a similar way as schema expressions are included in the declaration and predicate subtrees.
        </p>
        <p>
        As one might use a schema expression for defining a Z schema (i.e. S and T), this class contains an 
        Z <code>Expr</code> instead of <code>SchExpr</code>. The parser is responsible to rule out other 
        possibilities and ensure that only well formed schema expressions are allowed.
        From the CZT these came through <code>SchExpr</code>, <code>SchExpr2</code>, <code>DecorExpr</code>,
        <code>NegExpr</code>, and <code>RenameExpr</code>. (TODO: Check this carefully).
        </p>        
        <p>
        For the process state, this action or a the corresponding Z paragraph must contain a <code>CircusStateAnn</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Action :: Call -->  
  <xs:element name="CallAction" type="CIRCUS:CallAction" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus action reference call. In other words, it permits a name to be an action.
        That is, it contains a reference name to lookup the action definition.
        </p>
        <p>
        Moreover, it contains a list of expressions and an attribute defining the kind of call this 
        reference is related too. An empty list of expressions means a simple action call of the grammar rule <b>N</b>,
        where <b>N</b> is the action name.
        If the list of expressions is not empty, then the <code>CallType</code> attribute defines if this is a 
        parameterised action/command call.
        </p>
        <p>
        It represents the grammar rules: <b>N, N(Expr+)</b> for CSP actions and commands.
        </p>
        <p>
        The <code>CallType</code> invariant is as follows:        
        <ul>
          <li>Normal = nonempty name and empty parameters. </li>
          <li>Param  = nonempty parameters. Internal name for on-the-fly, user given name for previously declared paragraph. </li>
          <li>Index  = INVALID as actions do not have indexes.</li>
          <li>Gen    = INVALID as actions do not have generic types.</li>
          <li>GenParam = nonempty name and nonempty parameters.</li>
          <li>GenIndex = nonempty name and nonempty parameters.</li>
        </ul>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

    <!-- CSP Action :: ActionDesc -->
    
    <!-- 
    <xs:element name="ActualParamAction" type="CIRCUS:ActualParamAction" substitutionGroup="CIRCUS:CircusAction">
      <xs:annotation>
        <xs:documentation>
          The CSP operator for parameterised action defined on the fly with its actual parameters.
          Ex: (x: \nat \spot c.x \then Skip)(10)
        </xs:documentation>
      </xs:annotation>
    </xs:element>
    -->

  <!-- CSP Action :: Basic -->      
  <xs:element name="BasicAction" type="CIRCUS:BasicAction" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract class for basic Circus action.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SkipAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus action that represents successful silent termination. That is, an action that has 
        terminated (i.e. ok' = true and wait' = false) and no modification in the trace has 
        occurred (i.e. trace' = trace).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="StopAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus action that represents deadlock. That is, an action that refuses every possible event
        and is still waiting (i.e. wait' = false).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ChaosAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Chaotic Circus action as defined by the UTP (see also Hoare's CSP CHAOS process, 
        as well as Roscoe's CSP <b>div</b> process).
        </p>
        <p>
        Theoretically, it represents the bottom element of the Circus lattice of 
        failures-divergences with embedded imperative features. 
        Implementations should usually treat this element as the base case for the 
        <b>possibility</b> (not certainty) of divergence.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Unary -->  
  <xs:element name="MuAction" type="CIRCUS:MuAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        <p>The mu operator defines a recursive action.</p>
        <p>The parser must enforce that the given name does not have strokes.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="GuardedAction" type="CIRCUS:GuardedAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The Circus guarded action defines an action guarded by a Z predicate.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="HideAction" type="CIRCUS:HideAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The Circus hide operator defines events concealment within an action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="PrefixingAction" type="CIRCUS:PrefixingAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The Circus operator for actions prefixed with a communication.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SubstitutionAction" type="CIRCUS:SubstitutionAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus action variable substitution. As variables in Circus are strongly-typed, type-checking is expected here.
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>  

  <!-- CSP Action :: Binary -->
  <xs:element name="SeqAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        Sequential composition between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        External choice between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        Internal choice between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParAction" type="CIRCUS:ParAction" abstract="true" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract parallel action definition;
        it includes the name set partitions of the state.
        </p>
        <p>
        As empty name disjoint sets are often used in parallel actions, syntactic sugar for these cases
        is provided in the grammar rules for interleaving, parallel composition, and alphabetised parallel 
        composition, so that we do not need explicit AST classes. 
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveAction" type="CIRCUS:ParAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Interleaving between two actions.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelAction" type="CIRCUS:ParallelAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        Parallel composition between two actions;
        it includes the channel set expression for the synchronisation set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelAction" type="CIRCUS:AlphabetisedParallelAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        Alphabetised Parallel composition between two actions;
        it includes the channel set expression for both alphabets as synchronisation sets.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Unary :: Declaration :: Iterated -->
  <xs:element name="SeqActionIte" type="CIRCUS:ActionIte" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceActionIte" type="CIRCUS:ActionIte" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceActionIte" type="CIRCUS:ActionIte" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParActionIte" type="CIRCUS:ParActionIte" abstract="true" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract parallel iterated action definition.
        it includes the name set partitions of the state.
        </p>
        <p>
        As empty name disjoint sets are often used in iterated parallel actions, syntactic sugar for these cases
        is provided in the grammar rules for iterated interleaving, iterated parallel composition, and iterated 
        alphabetised parallel composition, so that we do not need explicit AST classes. 
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveActionIte" type="CIRCUS:ParActionIte" substitutionGroup="CIRCUS:ParActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelActionIte" type="CIRCUS:ParallelActionIte" substitutionGroup="CIRCUS:ParActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelActionIte" type="CIRCUS:ParallelActionIte" substitutionGroup="CIRCUS:ParActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for alphabetised iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Communication --> 
  <xs:element name="Communication" type="CIRCUS:Communication">
    <xs:annotation>
      <xs:documentation>
        <p>
        A CSP communication that is part of a prefixing process or action. 
        If the communicating channel has been declared with generic types, the communication 
        must carry the generic actual expressions. It represents the <b>Communication</b> grammar rule.
        </p>
        <p>
        A communication can be either a communication for synchronisation, input, output, or mixed.
        Synchronisation has no fields. Input and Output has only input or output fields respectively. 
        Mixed communication has both input and output fields, such as <code>c?x:P!v -> A</code>.
        </p>
        <p>
        The semantics of dot (c.x) and output (c!x) is equivalent. 
        However, for some applications/tools, their evaluation can be done differently.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Communication Fields --> 
  <xs:element name="Field" type="CIRCUS:Field" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract field is part of a communication. 
        Available extensions are input, dot, and output fields.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InputField" type="CIRCUS:InputField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        <p>
        An input field that is part of a communication.
        It represents grammar rules <b>?N</b> and <b>?N: Pred</b>.
        </p>
        <p>
        The parse must ensure that the declared name <b>N</b> does not have strokes.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="DotField" type="CIRCUS:DotField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        <p>
        A field that is part of a communication and contains an expression.
        It represents the grammar rule <b>.Expr</b>.
        </p>
        <p>
        In general, the ``dot'' is treated as output communication.
        However, depending on the purpose of use, it can be considered as a reading or writing synchronisation point.        
        </p>
        <p>        
        Another example where the differentiation between dot and output fields is relevant comes from CSP_M and FDR,
        where ``dot'' fields are used for resolved expressions, whereas ``output'' fields can be used for expressions 
        yet to be resolved. 
        Roscoe's give some insight on further interesting possibilities that motivates such differentiation in 
        his CSP book (p.27).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OutputField" type="CIRCUS:DotField" substitutionGroup="CIRCUS:DotField">
    <xs:annotation>
      <xs:documentation>
        <p>
        A field that is part of a communication and contains an expression.
        It represents the grammar rule <b>!Expr</b>.        
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>       
  
  <!-- Parameterised Commands -->
  <xs:element name="ParamCommand" type="CIRCUS:ParamCommand" abstract="true" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract parameterised command action definition. 
        It represents the grammar rule <b>(ParDeclaration @ Command)</b>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>     
  <xs:element name="QualifiedDecl" type="CIRCUS:QualifiedDecl" substitutionGroup="Z:Decl">
    <xs:annotation>
      <xs:documentation>
        A Z declaration with an additional qualifier attribute.
      </xs:documentation>
    </xs:annotation>
  </xs:element>      
 
  <!-- Circus Commands -->
  <xs:element name="SpecStmtCommand" type="CIRCUS:SpecStmtCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus command declaring a specification statement in Carroll Morgan's style.
        It represents the grammar rule <code>N+:[Pred,Pred]</code>.
        The parser is responsible to ensure that no strokes are allowed in the frame variables.
        </p>
        <p>
        As assumption and coercion are syntactic sugar for often used specification statements,
        they do not have an explicit AST class. Instead, assumption (grammar rule <code>{Pred}</code>)
        is represented by a specification statement with empty frame, <code>Pred</code> precondition, 
        and true postcondition. Similarly, coercion (grammar rule <code>[Pred]</code>) is represented by 
        a specification statement with empty frame, true precondition, and <code>Pred</code> postcondition.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AssignmentCommand" type="CIRCUS:AssignmentCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        Circus command declaring (possibly) multiple assignment.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IfGuardedCommand" type="CIRCUS:IfGuardedCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
        Command declaring a if statement containing guarded actions in Dijkstra's style.
        Although semantically different, we can represent the AST for the production of guarded actions 
        from the BNF of if commands with the <code>GuardedAction</code> AST class, hence minimising the 
        AST classes. 
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  <xs:element name="VarDeclCommand" type="CIRCUS:VarDeclCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
        Command declaring (possibly multiple) variables local to an action definition.
        The parser is responsible to ensure that no strokes are allowed in the frame variables.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- ***************************************************************** -->
  <!-- Definitions of complexTypes in the order of usage by the elements -->
  <!-- ***************************************************************** -->

  <!-- Outermost Paragraph Types -->
  <xs:complexType name="ChannelPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>          
          <xs:element ref="CIRCUS:ChannelDecl" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ChannelDecl">
    <xs:complexContent>
      <xs:extension base="Z:Decl">
        <xs:sequence>
          <!-- Generic types, possibly empty -->
          <xs:element ref="Z:DeclName" minOccurs="0" maxOccurs="unbounded"/>
          <xs:element ref="Z:Decl"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ChannelSetPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ProcessPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="DeclName"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:DeclName" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenFormals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusProcess"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Channel Set Expression complexTypes -->
  <xs:complexType name="ChannelSet">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BasicChannelSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSet">
        <xs:sequence>
          <!-- Changed to accommodate Z.xsd updates -->
          <!-- <xs:element ref="Z:RefName" minOccurs="0" maxOccurs="unbounded"/> -->
          <xs:element ref="Z:RefNameList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RefChannelSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSet">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!--
  <xs:complexType name="ChannelSet2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSet">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftOperand"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightOperand"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  -->
  <xs:complexType name="ApplChannelSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ChannelSet">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
    
  <!-- Process Definition complexType -->
  <xs:complexType name="CircusProcess">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="Process1">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusProcess"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessD">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>        
          <!-- Accommodate Z.xsd changes: using Z Standard DeclPart from (12.7.2)
          <xs:element ref="Z:Decl" minOccurs="1" maxOccurs="unbounded"/> 
          -->
          <xs:element ref="Z:DeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessD"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ProcessIdx">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessIte"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Process2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusProcess">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftProc"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusProcess">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightProc"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>     

  <!-- Bssic Process -->
  <xs:complexType name="BasicProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>          
          <!-- 
            Reference to a previously declared schema name; must enforce that the schema name is within the Z:Para or ActionPara 
            Originally we had here a Z:RefName pointing to a previously declared schema name. Although that is usually 
            the case, it is also possible to have a Schema expression, such as conjunction, as the state schema!
            Therefore, we need to have a Z:Expr instead. For the usual cases, the Z:Expr will be a Z:RefExpr.          
          
            TODO: NORMALISE THE paragraph below whenever the parser handles this properly.
            From the parsing rules, we reached a convention that is as follows:
                    State schemas can be defined using AxPara (Schema), Horizontal def (Schema) or on-the-fly with a Schema expression
                    such as S \land T. For the first two cases, we already have a declared "name" to refer to whereas for the last case
                    "ex: \circstate\ S \land T", we translate the on-the-fly description to the following convention:
                    "ex: \circstate\ \begin{schema}{[ProcessName]_$$state} S \land T\end{schema}
          -->
          <xs:element name="StateSchema" type="Z:RefName"/>
          <xs:element name="ZPara" type="Z:Para" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ZPara"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element name="CircusActionPara" type="CIRCUS:ActionPara" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="CircusActionPara"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element name="OnTheFlyActionPara" type="CIRCUS:ActionPara" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="OnTheFlyActionPara"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element name="CircusNameSetPara" type="CIRCUS:NameSetPara" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="CircusNameSetPara"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="MainAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusStateAnn">
    <xs:complexContent>
      <xs:extension base="Z:Ann"/>
    </xs:complexContent>
  </xs:complexType>        

  <xs:complexType name="OnTheFlyDefAnn">
    <xs:complexContent>
      <xs:extension base="Z:Ann"/>            
    </xs:complexContent>
  </xs:complexType>

  
  <!-- Process Definition :: Calls --> 
  
  <xs:complexType name="CallProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>          
          <xs:element ref="Z:RefName"/>
          <!-- Accommodate Z.xsd changes to use ExprList (Z Standard 12.2.12) 
          <xs:element name="Actuals" type="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>
          <xs:element name="GenActuals" type="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>
          -->
          <xs:element name="Actuals" type="Z:ExprList"/>
          <xs:element name="GenActuals" type="Z:ExprList"/>
        </xs:sequence>
        <xs:attribute name="CallType" type="CIRCUS:CallType" use="optional" default="Normal"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:simpleType name="CallType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Normal"/>
      <xs:enumeration value="Param"/>
      <xs:enumeration value="Index"/>
      <xs:enumeration value="Gen"/>
      <xs:enumeration value="GenParam"/>
      <xs:enumeration value="GenIndex"/>
    </xs:restriction>
  </xs:simpleType> 
  

  <!-- Process Definition :: Unary -->
  <xs:complexType name="MuProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GuardedProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PrefixingProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element ref="CIRCUS:Communication"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="HideProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RenameProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>                   
          <!-- Accommodate Z.xsd changes: RenameList 
          <xs:element name="OldNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>                      
          <xs:element name="NewNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
          -->
          <xs:element ref="Z:RenameList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
    
  <!-- Process Definition :: Binary -->
  
  <xs:complexType name="ParProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process2"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ParallelProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcess">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="AlphabetisedParallelProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcess">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAlpha"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAlpha"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <!-- Process Definition :: Expressions -->  
  
  <!--
  <xs:complexType name="ProcessE">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>          
          <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>          
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  <xs:complexType name="ActualParamProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessE">
        <xs:sequence>
          <xs:element ref="CIRCUS:ParamProcessDesc"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="InstantiationProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessE">
        <xs:sequence>
          <xs:element ref="CIRCUS:IndexedProcessDesc"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  -->
  
  <!-- Process Definition :: Unary :: Declaration :: Iterated -->
  <xs:complexType name="ParProcessIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessIte"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ParallelProcessIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcessIte">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Definition :: Unary :: Declaration :: Iterated :: Indexed -->
  <xs:complexType name="ParProcessIdx">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessIdx"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ParallelProcessIdx">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcessIdx">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Process Paragraphs complexTypes -->
  <xs:complexType name="NameSetPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:NameSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ActionPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:CircusAction"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>


<!-- Name Set Expression complexTypes -->
  <xs:complexType name="NameSet">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BasicNameSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:NameSet">
        <xs:sequence>
          <!-- <xs:element ref="Z:RefName" minOccurs="0" maxOccurs="unbounded"/> -->
          <xs:element ref="Z:RefNameList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RefNameSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:NameSet">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ApplNameSet">
    <xs:complexContent>
      <xs:extension base="CIRCUS:NameSet">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Action complexType -->     
  
  <xs:complexType name="CircusAction">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Action1">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusAction"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Action2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionD">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>        
          <!-- Accommodate Z.xsd changes: using Z Standard DeclPart from (12.7.2)
          <xs:element ref="Z:Decl" minOccurs="1" maxOccurs="unbounded"/> 
          -->
          <xs:element ref="Z:DeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionD"/>
    </xs:complexContent>
  </xs:complexType>  
  
  
  <xs:complexType name="CircusCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction"/>
    </xs:complexContent>
  </xs:complexType>
    
  <xs:complexType name="SchExprAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <!-- 
          Z:Expr instead of Z:SchExpr or SchText because we want a schema action to be an expression. 
          That means, we can have a schema definition as well as an expression using schemas (as in 
          Spivey's SchExpr tree - that is not in the Z-Standard. From the CZT, these are reflected as 
          Z:SchExpr, Z:SchExpr2, and Z:HideExpr.
          -->          
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CallAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
          <!-- Accommodate Z.xsd changes to use ExprList (Z Standard 12.2.12) 
          <xs:element ref="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>                  
          -->
          <xs:element ref="Z:ExprList"/>
        </xs:sequence>
        <xs:attribute name="CallType" type="CIRCUS:CallType" use="optional" default="Normal"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  
  <!-- CSP Action complexType -->
  <xs:complexType name="BasicAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction"/>
    </xs:complexContent>
  </xs:complexType>

  <!--
  <xs:complexType name="ActualParamAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:ParamActionDesc"/>          
          <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  -->

  <!-- CSP Action complexType :: Unary -->
  <xs:complexType name="MuAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GuardedAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="HideAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PrefixingAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="CIRCUS:Communication"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SubstitutionAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>                   
          <!-- Accommodate Z.xsd changes:
          <xs:element name="OldNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
          <xs:element name="NewNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
          -->
          <xs:element ref="Z:RenameList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- CSP Action complexType :: Unary :: Declaration :: Iterated -->
  <xs:complexType name="ParActionIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionIte">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ParallelActionIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParActionIte">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- CSP Action complexType :: Binary -->
  <xs:complexType name="ParAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action2">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftNameSet"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightNameSet"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ParallelAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AlphabetisedParallelAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAlpha"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAlpha"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- CSP Communication complexType -->
  <xs:complexType name="Communication">
    <xs:complexContent>
      <xs:extension base="Z:TermA">
        <xs:sequence>
          <xs:element name="ChanName" type="Z:RefName"/>
          <!-- <xs:element ref="Z:Expr" minOccurs="0" maxOccurs="unbounded"> -->
          <xs:element ref="Z:ExprList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenActuals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element ref="CIRCUS:Field" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ChanFields"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="CommType" type="CIRCUS:CommType" use="optional" default="Synch"/>
        <xs:attribute name="MultiSych" type="xs:nonNegativeInteger" use="optional" default="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <!-- 
    Invariant: 
      Synch = getFields().isEmpty() 
      Input = !getFields().isEmpty() && forall getField().get(i) instanceof InputField            
      Output= !getFields().isEmpty() && forall getField().get(i) instanceof OutputField || getField().get(i) instanceof DotField
      Mixed = !getFields().isEmpty() && there are more than one class: InputField, (OutputField/DotField).
  -->
  <xs:simpleType name="CommType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Synch"/>
      <xs:enumeration value="Input"/>
      <xs:enumeration value="Output"/>
      <xs:enumeration value="Mixed"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- CSP Communication parameters complexType -->
  <xs:complexType name="Field">
    <xs:complexContent>
      <xs:extension base="Z:TermA"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="InputField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <xs:element name="Variable" type="Z:RefName"/>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Restriction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="DotField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <xs:element ref="Z:Expr">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Expression"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Parameterised Commands complextype -->
  <xs:complexType name="ParamCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>
          <xs:element ref="CIRCUS:QualifiedDecl" minOccurs="1" maxOccurs="unbounded"/>
          <xs:element ref="CIRCUS:CircusCommand"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="QualifiedDecl">
    <xs:complexContent>
      <xs:extension base="Z:Decl">
        <xs:sequence>          
          <xs:element ref="Z:Decl"/>
        </xs:sequence>
        <xs:attribute name="ParamQualifier" type="CIRCUS:ParamQualifier" use="optional" default="Value"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:simpleType name="ParamQualifier">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Value"/>
      <xs:enumeration value="Result"/>
      <xs:enumeration value="ValueResult"/>
    </xs:restriction>
  </xs:simpleType>  

  <!-- Circus Commands complextype -->
  <xs:complexType name="SpecStmtCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>
          <!-- <xs:element name="Frame" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/> -->
          <xs:element name="Frame" type="Z:RefNameList"/>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Pre"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Post"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AssignmentCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>                  
          <!-- <xs:element ref="Z:RefName" minOccurs="1" maxOccurs="unbounded"> -->
          <xs:element ref="Z:RefNameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LHS"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>      
          <!-- <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"> -->
          <xs:element ref="Z:ExprList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RHS"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>     
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="IfGuardedCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>
          <xs:element ref="CIRCUS:GuardedAction" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="VarDeclCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>          
          <xs:element ref="Z:VarDecl" minOccurs="1" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Declarations"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element ref="CIRCUS:CircusAction"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:schema>
