<?xml version="1.0" encoding="UTF-8"?>
<xs:schema
  targetNamespace="http://czt.sourceforge.net/circus"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:CIRCUS="http://czt.sourceforge.net/circus"
  xmlns:Z="http://czt.sourceforge.net/zml"
  xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" jaxb:version="1.0"
  xmlns:gnast="http://czt.sourceforge.net/gnast"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
  version="0.1">
  <xs:annotation>
    <xs:documentation>
      Copyright 2005, 2006 Leonardo Freitas
      $Id$

      This XML schema defines XML markup for formal specifications 
      written in Circus, a concurrent language for refinement that
      combines CSP, Z and the refinement calculus.
      More information at <a href="http://www.cs.york.ac.uk/~circus">Circus main web page</a>
      or at <a href="http://www.cs.york.ac.uk/~leo">the author'ss web page</a>.

      This file is part of the Community Z Tools (CZT) project.
 
      The CZT project contains free software; you can
      redistribute it and/or modify it under the terms
      of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of
      the License, or (at your option) any later version.
 
      The CZT project is distributed in the hope that it
      will be useful, but WITHOUT ANY WARRANTY; without
      even the implied warranty of MERCHANTABILITY or
      FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.

      You should have received a copy of the GNU General
      Public License along with CZT; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place,
      Suite 330, Boston, MA  02111-1307  USA
    </xs:documentation>
    <xs:appinfo>
      <jaxb:schemaBindings>
        <jaxb:package name="net.sourceforge.czt.circus.jaxb.gen">
          <jaxb:javadoc>
            &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
            &lt;html&gt;
            &lt;body&gt;
            &lt;p&gt;Classes generated by Jaxb.&lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
          </jaxb:javadoc>
        </jaxb:package>
      </jaxb:schemaBindings>
      <gnast:schemaBindings name="Circus">
        <gnast:package name="net.sourceforge.czt.circus">
          <gnast:package id="ast" name="ast">
            <gnast:generate id="factory" class="CircusFactory" template="CoreFactory.vm"/>
          </gnast:package>
          <gnast:package id="impl" name="impl">
            <gnast:generate id="factoryImpl" class="CircusFactoryImpl" template="CoreFactoryImpl.vm"/>
          </gnast:package>
          <gnast:package id="visitor" name="visitor">
            <gnast:generate id="AstVisitor" class="CircusVisitor" template="AstVisitor.vm"/>
          </gnast:package>
          <gnast:package id="util" name="util">
            <gnast:generate id="convFactory" class="Factory" template="Factory.vm"/>
          </gnast:package>
          <gnast:package id="jaxb" name="jaxb">
            <gnast:generate id="AstToJaxb" class="AstToJaxb" template="AstToJaxb.vm"/>
            <gnast:generate id="JaxbToAst" class="JaxbToAst" template="JaxbToAst.vm"/>
          </gnast:package>
          <gnast:package id="dom" name="dom">
            <gnast:generate id="AstToDom" class="AstToDom" template="AstToDom.vm"/>
          </gnast:package>
        </gnast:package>
      </gnast:schemaBindings>
    </xs:appinfo>
  </xs:annotation>

  <xs:import namespace="http://czt.sourceforge.net/zml" schemaLocation="Z.xsd"/>

  <!-- ********************************************************************* -->
  <!-- Definitions of the elements in the order of appearance in the grammar -->
  <!-- ********************************************************************* -->

  <!-- Section level paragraphs -->
  
  <xs:element name="ChannelPara" type="CIRCUS:ChannelPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel paragraph that declares channel names with corresponding types, possibly generic. 
        Channels are used in process definitions. Strokes are not allowed in channel names, and this is
        ensured by the parser. 
        </p>
        <p>
        It represents the <b>channel</b> <code>ChannelDecl</code> grammar rule.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ChannelSetPara" type="CIRCUS:ChannelSetPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel set paragraph that declares a name for a channel set.
        A channel set encapsulates a Z <code>Expr</code>.
        </p>
        <p>
        It represents the <b>channelset</b> <code>N == CSExpression</code> grammar rule, 
        where <code>N</code> is a <code>DeclName</code>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="ProcessPara" type="CIRCUS:ProcessPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
        A process paragraph that introduces a name for a process definition.
        Strokes are not allowed in process names, and this is ensured by the parser.
        </p>
        <p>
        This element represents the <b>ProcessDeclaration</b> grammar rule.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
    
  <xs:element name="CircusConjPara" type="CIRCUS:CircusConjPara" substitutionGroup="Z:Para" abstract="true">
    <xs:annotation>
      <xs:documentation>
        A (generic) Circus conjecture paragraph. It is used by tools to ensure that
        certain special properties hold.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="RefinementConjPara" type="CIRCUS:RefinementConjPara" substitutionGroup="CIRCUS:CircusConjPara">
    <xs:annotation>
      <xs:documentation>
        Refinement conjecture between two circus specifications.
      </xs:documentation>
    </xs:annotation>        
  </xs:element>
  
  <!-- Section level declarations -->  
  <!-- Channel declaration -->
  
  <xs:element name="ChannelDecl" type="CIRCUS:ChannelDecl" substitutionGroup="Z:Decl">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel declaration is a Z declaration that accepts generic types.
        It represents the <b>SimpleCDeclaration</b> grammar rule.
        </p>
        <p>
        Channels can be declared either as typed or synchronisation. 
        They can als have generic types or come from a previously declared schema.
        </p>
        <p>
        The structure of the complex type associated with this class is a follows:
        <ul>
          <li>Typed  channels = optional generics, nonempty list of declnames, no null Expr. </li>
          <li>Synch. channels = empty generics, nonempty list of declnames, null Expr. </li>
          <li>Schema channels = optional generics, null list of declnames, no null RefExpr. </li>          
        </ul>
        This invariant is to be enforced by the parser, and further unfolded by the typechecker.
        That is, channels declared through schemas must be expanded to their typed declaration form.
        Such unfolding must take into account both sets of generic formals comming from the channel 
        declaration as well as the schema generic formals. In this sense, the user is allowed to
        change the pattern of generic formals inside the schema through the generic formals of the
        channel declaration (see <code>./parser/tests/cirus/channels.tex</code> for an example).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Channel Set Expressions -->
  <xs:element name="ChannelSet" type="CIRCUS:ChannelSet">
    <xs:annotation>
      <xs:documentation>
        <p>
        An channel set expression is a special kind of expression used in Circus that is
        not within the Z expressions subtree. It represents the <b>CSExpression</b> grammar rule.
        </p>
        <p>
        Although it is formed by a Z expression, channel set expressions cannot appear wherever a Z expression can;
        they are only allowed in some operators such parallelism and hiding. For this it encpasulates a Z expression
        within the <code>ChannelSet</code> class.
        </p>
        <p>
        The most common Z expressions used in channel sets are set extensions, the empty set, and application expressions.
        The most common application expressions are set union, intersection, and diference. Other (possibly user defined) 
        functions can also be used.
        </p>
        <p>
        In any case, a channel set expression is well-typed only if the names it refer to are from previously declared channels,
        or a previously declared channel set. That is, a well-typed <code>ChannelSet</code> must be a power type of previously declared
        channel names.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <xs:element name="BasicChannelSetExpr" type="Z:Expr0N" substitutionGroup="Z:Expr0N">
    <xs:annotation>
      <xs:documentation>
        <p>
        A channel set expression containing a set of references to previously declared channel names (i.e. channel references).
        It represents the grammar rules for empty and enumerated channel sets. It is just like a set extension but the parser
        identifies differently due to the spceial channel set braces.        
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
        
  <!-- Process Description -->                
  <!-- DESIGN DECISION
      In order to allow a more uniform implementation, we avoided having an explicit ProcessDesc hierarchy tree.
      Instead, we expect the parser to actually manage the appropriate creation, hence allowing productions such as:      
      (x: \nat @ c \then STOP) \extchoice (y: \nat @ d \then STOP).
      
      This decision allows one to have a uniform/intuitive implementation of Declaration::Unary processes as expected. 
      That is, ParamProcessDesc and IndexedProcessDesc are considered unary as well.

  <xs:element name="ProcessDesc" type="CIRCUS:ProcessDesc" abstract="true">
      <xs:annotation>
          <xs:documentation>
              An abstract process description.
              Available extensions process definition, parameterised process, and indexed process.
          </xs:documentation>
      </xs:annotation>
  </xs:element>
  <xs:element name="ParamProcessDesc" type="CIRCUS:ParamProcessDesc" substitutionGroup="CIRCUS:ProcessDesc">
    <xs:annotation>
      <xs:documentation>
        A parameterised process description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IndexedProcessDesc" type="CIRCUS:ParamProcessDesc" substitutionGroup="CIRCUS:ProcessDesc">
    <xs:annotation>
      <xs:documentation>
        An indexed process description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>      
  -->

  <!-- Processes -->    
  <xs:element name="CircusProcess" type="CIRCUS:CircusProcess" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract Circus process definition. It represents the <b>ProcessDefinition</b> grammar rule.
        Available extensions are basic process description; recursion; prefixing; guarded process; 
        process call; all forms of unary, binary, iterated, and indexed processes;
        processes involving expressions; and processes involving declarations. 
        </p>
        <p>
        The parser is responsible to enforce restrictions over process definitions involving parameters 
        or indexes within some binary productions. For instance, the parse must rule out cases such as 
        <code>(x: nat @ A) [] (y: nat @ B)</code>, since parameterised process can only appear in an 
        external choice whenever the actual parameters are given.
        </p>
        <p>        
        This allows us to represent the grammar rules <b>ProcessDefinition</b> and <b>Process</b> with 
        a single class. The main advantage is that we can treat unary process definitions uniformly 
        through a single hierarchy tree.
        </p>
        <p>
        Naming this class <code>Process</code> would have been a better choice but unfortunately this would 
        conflict with the interface <code>java.lang.Process</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Process1" type="CIRCUS:Process1" abstract="true" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract unary Circus process.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="Process2" type="CIRCUS:Process2" abstract="true" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract binary Circus process.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessD" type="CIRCUS:ProcessD" abstract="true" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract unary Circus process with Z declarations.</p>
        <p>The parser must enforce that the declared variables do not have strokes via <code>VarDecl</code>,
           that strokes should be ignored via <code>InclDecl</code> (schema inclusion), and that <code>ConstDecl</code>
           is not allowed at all.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ProcessIte" type="CIRCUS:ProcessIte" abstract="true" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract iterated Circus process with Z declarations.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <!-- DESIGN DECISION:
    Originally the substitution group for ProcessIdx was ProcessD, hence the two subtrees for iterated and
    indexed iterated processes were siblings. However, yet replicated and iterated processes are not simply 
    syntactic sugar due to the special renaming that changes the channel types, one can see it as a replication 
    followed by a kind of renaming. Therefore, by deriving from ProcessIte instead of ProcessD, we give the user 
    the chance to reuse visiting code for replication and then further add the necessary renaming functionality. 
    If, on the other hand, a different treatment of replication becomes necessary, one just needs to ignore the 
    superclass implementation from ProcessIte and provide a new one for the replication task.
  -->
  <xs:element name="ProcessIdx" type="CIRCUS:ProcessIdx" abstract="true" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract indexed and iterated Circus process with Z declarations.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process :: Unary with Declaration -->
  <xs:element name="ParamProcess" type="CIRCUS:ProcessD" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        <p>
        A parameterised process definition. It represents grammar rule <b>Declaration @ ProcessDefinition</b>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IndexedProcess" type="CIRCUS:ProcessD" substitutionGroup="CIRCUS:ProcessD">
    <xs:annotation>
      <xs:documentation>
        An indexed process definition. It represents grammar rule <b>Declaration odot ProcessDefinition</b>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>     

  <!-- Process :: Basic -->

  <xs:element name="BasicProcess" type="CIRCUS:BasicProcess" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>
        A process definition for an explicit process declaration.
        It is formed by a (possibly empty) set of process paragraphs,
        an optional process state given as a schema and a (mandatory) 
        main action definition.
        </p>
        <p>
        It represents the grammar rule <b>begin</b> <code>PParagraph*</code> <b>state</b> <code>Schema-Exp PParagraph*</code>
        <b>@</b> <code>Action</code> <b>end</b>.
        </p>
        <p>
                For the process state, the corresponding action (as a SchExprAction) or Z paragraph (as a Schema or HorizontalDef) 
                must contain a <code>CircusStateAnn</code> annotation.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <xs:element name="CircusStateAnn" type="CIRCUS:CircusStateAnn" substitutionGroup="Z:Ann">
    <xs:annotation>
        <xs:documentation>
            Defines if a given paragraph is the process state. 
            The parser must enforce such a paragraph is a schema.
        </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="OnTheFlyDefAnn" type="CIRCUS:OnTheFlyDefAnn" substitutionGroup="Z:Ann">
    <xs:annotation>
        <xs:documentation>
            Defines an on-the-fly definition annotation used for both Process and Action terms.            
            It must be included into <code>ParamAction</code> and <code>ParamProcess</code> by 
            the parser whenever an on-the-fly definition occurs. It is also used for on-the-fly
            schema definitions.
        </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process :: Call -->

  <!-- DESIGN DECISION: 
  
    As Circus allows calls over definitions given on-the-fly, we need a more powerful approach for a call,
    rather than a simple RefName. There are two approaches for the implementation of process/action calls.
    We have taken the first one in order to simplify the implementation of visitor of different tools.
    
    The first demands specialised CallKind attribute on CallProcess, whereas the second introduces specialised classes      
    for each special production. For processes, these are actual parameters, indexes, and actual types. For action 
    these are actual parameters, and command parameters.
    
    Another interesting issue is that in the production tree, one is allowed to use a Process for renaming 
    (Process[N^+ := N^+]).  This allowed the definition of renaming on-the-fly (unnamed) or via a call processes.                                                
    Ex:  (c?x \then Skip)[c := b] or P = (c?x \then Skip), Q = P[c := b].
    On the second case via CallProcess it means that the CircusProcess descendent of ProcessDesc is being selected.
    In turn, the kind of CircusProcess is CallProcess and the list of renaming names are under RenameProcess.
    This allows both indexed and parameterised processes to use renaming hence creating a undesired ambiguity.
    
    The second approach is to have individual classes for this on-the-fly declaration and call directly,
    together with a base case of call with simple name on it. See more details below at ActualParamProcess.     
  -->
  <xs:element name="CallProcess" type="CIRCUS:CallProcess" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus process reference call. In other words, it permits a name to be a process.
        That is, it contains a reference name to lookup the process definition.
        </p>
        <p>
        Moreover, it contains two list of expressions and an attribute defining the kind of call this 
        reference is related too. The first list is related to generic actuals, whereas the second list is 
        related to actual parameters or indexes. 
        An empty list of generic actuals means that refering process is not generic.
        An empty list of expressions means a simple process call of the grammar rules <b>N, N[Expr+]</b>,
        where <b>N</b> is the process name.
        If the list of expressions is not empty, then the <code>CallKind</code> attribute defines if this is an indexed 
        process instantiation call, a parameterised process call.
        It represents the grammar rules: <b>N(Expr+), N lfloor Expr+ rfloor</b>
        </p>
        <p>        
        The invariant is as follows:  TODO: THIS COMMENT NEEDS UPDATE (See Parser.xml)
        <ul>
          <li>N        = nonempty name, empty generic actuals, and empty parameters/indexes. </li>
          <li>N[Expr+] = nonempty name, nonempty generic actuals, and empty parameters/indexes. </li>
          <li>N(Expr+) = empty generic actuals, nonempty parameters. 
                         Internal name for on-the-fly, user given name for previously declared action. 
                         The call type defines whether the expressions are actual parameters or indexes.</li>
          <li>N[Expr+](Expr+) = nonempty generic actuals, nonempty parameters. 
                         Internal name for on-the-fly, user given name for previously declared action. 
                         The call type defines whether the expressions are actual parameters or indexes.</li>          
        </ul>
        The case for parameterised and indexed process is not present in the grammar. 
        The default value of CallKind is <b>Param</b> and need to be inspected only for the case where the 
        second expression list demands attention.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process :: Unary  -->  
  <xs:element name="HideProcess" type="CIRCUS:HideProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        Circus process with event concealment through hiding.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="RenameProcess" type="CIRCUS:RenameProcess" substitutionGroup="CIRCUS:Process1">
    <xs:annotation>
      <xs:documentation>
        Circus process with channel renaming. As channels in Circus are strongly-typed, type-checking is expected.
        Note that, since the class derives from <code>Process1</code>, the grammar does not accept on-the-fly renaming 
        of parameterised processes. ex: (x: \nat @ c!x -> Stop)[c := b]. This is a design decision for uniformity purposes only.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <xs:element name="AssignmentPairs" type="CIRCUS:AssignmentPairs">
    <xs:annotation>
      <xs:documentation>
        Encapsulates two lists used for assignments, either of channels in <code>RenamingProcess</code>,
        or of variables in assignment command. It represents two lists of equal size for the 
        left and right hand sides. Moreover, for <code>RenamingProcess</code>, the RHS list
        can only contain <code>RefExpr</code>, as channels might have generic actuals.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process Definition :: Binary -->
  <xs:element name="SeqProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcess" type="CIRCUS:Process2" substitutionGroup="CIRCUS:Process2">
    <xs:annotation>
      <xs:documentation>
        Circus process for internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParProcess" type="CIRCUS:ParProcess" substitutionGroup="CIRCUS:Process2" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract circus process for parallel operators.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcess" type="CIRCUS:ParProcess" substitutionGroup="CIRCUS:ParProcess">
    <xs:annotation>
      <xs:documentation>
        Circus process for interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcess" type="CIRCUS:ParallelProcess" substitutionGroup="CIRCUS:ParProcess">
    <xs:annotation>
      <xs:documentation>
        Circus process for parallel composition;
        it includes the synchronisation set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelProcess" type="CIRCUS:AlphabetisedParallelProcess" substitutionGroup="CIRCUS:ParProcess">
    <xs:annotation>
      <xs:documentation>
        Circus alphabetised parallel process; it includes the two alphabets as channel sets.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Process Definition :: Expressions -->

  <!--
    DESIGN DECISION: 
      The next element was used for on-the-fly declaration of parameters for processes. 
      A similar construction needed to be created for indexes, and actual types. 
      Actions and commands also have similar constructs.
      
      These constructs usually appear through refinement steps from tools rather than directly by the user.           
      As the treatment of each of these cases is very similar, having separate AST nodes would possibly mean 
      repeated code (versioning and maintenance problems). 
      
      Instead, as the treatment of each of these cases is equivalent to a CallProcess with the appropriate call 
      type determining the meaning of the list of expressions, we assume that the Circus parser will interpret
      these cases appropriately by generating internal ProcessPara on-the-fly with reserved names not allowed to
      be declared by the user.

  <xs:element name="ProcessE" type="CIRCUS:ProcessE" abstract="true" substitutionGroup="CIRCUS:CircusProcess">
    <xs:annotation>
      <xs:documentation>
        An abstract Circus process involving expressions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
    <xs:element name="ActualParamProcess" type="CIRCUS:ActualParamProcess" substitutionGroup="CIRCUS:ProcessE">
      <xs:annotation>
        <xs:documentation>
          Defines a parameterised Circus process on-the-fly with its actual parameter.
          This enables on-the-fly declaration of parameterised indexed processes.             
          Ex: (x: T \spot c.x \then Skip)~(0) \equiv c.0 \then Skip.
          Note that this is different from a parameterised process description with a reference name calling 
          it with the given actual parameters.
          Ex: P = (x: T \spot c.x \then Skip).
                  Q = P~(0).
        </xs:documentation>
      </xs:annotation>
  </xs:element>
  <xs:element name="InstantiationProcess" type="CIRCUS:InstantiationProcess" substitutionGroup="CIRCUS:ProcessE">
    <xs:annotation>
      <xs:documentation>
        Defines a indexed Circus process on-the-fly with its actual instantiation
        This enables on-the-fly declaration of indexed parameterised processes.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  -->

  <!-- Process Definition :: Unary :: Declaration :: Iterated -->
  <xs:element name="SeqProcessIte" type="CIRCUS:ProcessIte" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcessIte" type="CIRCUS:ProcessIte" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceProcessIte" type="CIRCUS:ProcessIte" substitutionGroup="CIRCUS:ProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParProcessIte" type="CIRCUS:ParProcessIte" substitutionGroup="CIRCUS:ProcessIte" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract circus iterated parallel process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveProcessIte" type="CIRCUS:ParProcessIte" substitutionGroup="CIRCUS:ParProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcessIte" type="CIRCUS:ParallelProcessIte" substitutionGroup="CIRCUS:ParProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="AlphabetisedParallelProcessIte" type="CIRCUS:ParallelProcessIte" substitutionGroup="CIRCUS:ParProcessIte">
    <xs:annotation>
      <xs:documentation>
        Circus process for alphabetised iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Process Definition :: Unary :: Declaration :: Iterated :: Indexed -->
  <xs:element name="SeqProcessIdx" type="CIRCUS:ProcessIdx" substitutionGroup="CIRCUS:ProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceProcessIdx" type="CIRCUS:ProcessIdx" substitutionGroup="CIRCUS:ProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="IntChoiceProcessIdx" type="CIRCUS:ProcessIdx" substitutionGroup="CIRCUS:ProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParProcessIdx" type="CIRCUS:ParProcessIdx" substitutionGroup="CIRCUS:ProcessIdx" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Abstract circus indexed iterated parallel process.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="InterleaveProcessIdx" type="CIRCUS:ParProcessIdx" substitutionGroup="CIRCUS:ParProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelProcessIdx" type="CIRCUS:ParallelProcessIdx" substitutionGroup="CIRCUS:ParProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for indexed and iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelProcessIdx" type="CIRCUS:ParallelProcessIdx" substitutionGroup="CIRCUS:ParProcessIdx">
    <xs:annotation>
      <xs:documentation>
        Circus process for alphabetised indexed and iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Action Para -->
  <xs:element name="ActionPara" type="CIRCUS:ActionPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>
        <p>
        A action paragraph that declares a name for an action definition.
        Strokes are not allowed in channel set names, and this is ensured by the parser.
        </p>
        <p>
        This element represents the <code>N == ParAction</code> grammar rule, where,
        where <code>N</code> is a <code>DeclName</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Name Set Paragraphs -->
  <xs:element name="NameSetPara" type="CIRCUS:NameSetPara" substitutionGroup="Z:Para">
    <xs:annotation>
      <xs:documentation>        
        <p>
        A name set paragraph that introduces a name for a name set.
        A name set encapsulates a Z <code>Expr</code>.
        </p>
        <p>
        It represents the <b>nameset</b> <code>N == NSExpression</code> grammar rule, 
        where <code>N</code> is a <code>DeclName</code>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Name Set Expressions -->
  <xs:element name="NameSet" type="CIRCUS:NameSet">
    <xs:annotation>
      <xs:documentation>        
        <p>
        A name set expression is a special kind of expression used in Circus that is
        not within the Z expressions subtree. It represents the <b>NSExpression</b> grammar rule.
        </p>
        <p>
        Although it is formed by a Z expression, name set expressions cannot appear wherever a Z expression can;
        they are only allowed in some operators such as parallelism. For this it encpasulates a Z expression
        within the <code>NameSet</code> class.
        </p>
        <p>
        The most common Z expressions used in name sets are set extensions, the empty set, and application expressions.
        The most common application expressions are set union, intersection, and diference. Other (possibly user defined) 
        functions can also be used.
        </p>
        <p>
        In any case, a name set expression is well-typed only if the names it refer to are from previously declared state variables,
        or a previously declared name set. That is, a well-typed <code>NameSet</code> must be a power type of previously declared
        state variable names.
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
    
  <!-- Action Description -->     
  <!-- See ProcessDesc above 
  <xs:element name="ActionDesc" type="CIRCUS:ActionDesc" abstract="true">
      <xs:annotation>
          <xs:documentation>
              An abstract action description.
              Available extensions action definition, and parameterised action.
          </xs:documentation>
      </xs:annotation>
  </xs:element>
  <xs:element name="ParamActionDesc" type="CIRCUS:ParamActionDesc" substitutionGroup="CIRCUS:ActionDesc">
    <xs:annotation>
      <xs:documentation>
        A parameterised action description.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  -->
  
  <!-- Actions -->    
  <xs:element name="CircusAction" type="CIRCUS:CircusAction" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract Circus action definition. It represents the <b>ParAction</b> grammar rule.
        Available extensions are recursion; prefixing; guarded actions; action call; 
        all forms of unary, binary, iterated, and indexed actions;
        actions involving expressions; and actions involving declarations. 
        </p>
        <p>
        The parser is responsible to enforce restrictions over action definitions involving parameters 
        within some binary productions. For instance, the parse must rule out cases such as 
        <code>(x: nat @ A) [] (y: nat @ B)</code>, since parameterised actions can only appear in an 
        external choice whenever the actual parameters are given.
        </p>
        <p>        
        This allows us to represent the grammar rules <b>ParAction</b>, <b>Action</b>, and <b>CSPAction</b>
        with a single class. The main advantage is that we can treat unary action definitions uniformly 
        through a single hierarchy tree.
        </p>
        <p>
        Naming this class <code>Action</code> would have been a better choice but it often conflicts with 
        other main stream Java libraries class names.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="Action1" type="CIRCUS:Action1" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        An abstract unary Circus action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="Action2" type="CIRCUS:Action2" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        An abstract binary Circus action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="ActionD" type="CIRCUS:ActionD" abstract="true" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract unary Circus action with Z declarations.
        </p>
        <p>
        The parser must enforce that the declared variables do not have strokes via <code>VarDecl</code>,
        that strokes should be ignored via <code>InclDecl</code> (schema inclusion), and that <code>ConstDecl</code>
        is not allowed at all.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="ActionIte" type="CIRCUS:ActionIte" abstract="true" substitutionGroup="CIRCUS:ActionD">
    <xs:annotation>
      <xs:documentation>
        An abstract iterated unary Circus action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Action :: Unary with Declaration -->
  <xs:element name="ParamAction" type="CIRCUS:ActionD" substitutionGroup="CIRCUS:ActionD">
    <xs:annotation>
      <xs:documentation>
        A parameterised action definition. It represents grammar rule <b>Declaration @ ParAction</b>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Action :: Commands (base class) -->
  <xs:element name="CircusCommand" type="CIRCUS:CircusCommand" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract command action definition. Available extensions are specification statement
        in Carroll Morgan's style; (possibly multiple) assignment; if guards in Dijkstra's style;
        (possibly multiple) variable declaration; and parameterised commands with qualified declarations.
        </p>
        <p>It represents the grammar rule <b>ParCommand</b> as the base class of Circus commands.</p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>    

  <!-- Action :: Schema-Exp -->  
    
  <xs:element name="SchExprAction" type="CIRCUS:SchExprAction" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        An action given as a schema expression.
        In this way, schema expressions are included into the <code>CircusAction</code> subtree
        in a similar way as schema expressions are included in the declaration and predicate subtrees.
        </p>
        <p>
        As one might use a schema expression for defining a Z schema (i.e. S and T), this class contains an 
        Z <code>Expr</code> instead of <code>SchExpr</code>. The parser is responsible to rule out other 
        possibilities and ensure that only well formed schema expressions are allowed.
        From the CZT these came through <code>SchExpr</code>, <code>SchExpr2</code>, <code>DecorExpr</code>,
        <code>NegExpr</code>, and <code>RenameExpr</code>. (TODO: Check this carefully).
        </p>        
        <p>
        For the process state, this action or a the corresponding Z paragraph must contain a <code>CircusStateAnn</code>.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  

  <!-- Action :: Call -->  
  <xs:element name="CallAction" type="CIRCUS:CallAction" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus action reference call. In other words, it permits a name to be an action.
        That is, it contains a reference name to lookup the action definition.
        </p>
        <p>
        Moreover, it contains a list of expressions representing possible actual parameters.
        An empty list of expressions means a simple action call of the grammar rule <b>N</b>,
        where <b>N</b> is the action name.
        If the list of expressions is not empty, then the this is a parameterised action.
        It represents the grammar rule <b>N(Expr+)</b> for CSP actions and commands.
        </p>
        <p>
        The invariant is as follows:        
        <ul>
          <li>N        = nonempty name and empty parameters. </li>
          <li>N(Expr+) = nonempty parameters. Internal name for on-the-fly, user given name for previously declared action. </li>
        </ul>
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

    <!-- CSP Action :: ActionDesc -->
    
    <!-- 
    <xs:element name="ActualParamAction" type="CIRCUS:ActualParamAction" substitutionGroup="CIRCUS:CircusAction">
      <xs:annotation>
        <xs:documentation>
          The CSP operator for parameterised action defined on the fly with its actual parameters.
          Ex: (x: \nat \spot c.x \then Skip)(10)
        </xs:documentation>
      </xs:annotation>
    </xs:element>
    -->

  <!-- CSP Action :: Basic -->      
  <xs:element name="BasicAction" type="CIRCUS:BasicAction" abstract="true" substitutionGroup="CIRCUS:CircusAction">
    <xs:annotation>
      <xs:documentation>
        <p>An abstract class for basic Circus action.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SkipAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus action that represents successful silent termination. That is, an action that has 
        terminated (i.e. ok' = true and wait' = false) and no modification in the trace has 
        occurred (i.e. trace' = trace).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="StopAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus action that represents deadlock. That is, an action that refuses every possible event
        and is still waiting (i.e. wait' = false).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ChaosAction" type="CIRCUS:BasicAction" substitutionGroup="CIRCUS:BasicAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Chaotic Circus action as defined by the UTP (see also Hoare's CSP CHAOS process, 
        as well as Roscoe's CSP <b>div</b> process).
        </p>
        <p>
        Theoretically, it represents the bottom element of the Circus lattice of 
        failures-divergences with embedded imperative features. 
        Implementations should usually treat this element as the base case for the 
        <b>possibility</b> (not certainty) of divergence.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Unary -->  
  <xs:element name="MuAction" type="CIRCUS:MuAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        <p>The mu operator defines a recursive action.</p>
        <p>The parser must enforce that the given name does not have strokes.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="GuardedAction" type="CIRCUS:GuardedAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The Circus guarded action defines an action guarded by a Z predicate.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="HideAction" type="CIRCUS:HideAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The Circus hide operator defines events concealment within an action definition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="PrefixingAction" type="CIRCUS:PrefixingAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        The Circus operator for actions prefixed with a communication.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="SubstitutionAction" type="CIRCUS:SubstitutionAction" substitutionGroup="CIRCUS:Action1">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus action variable substitution. As variables in Circus are strongly-typed, type-checking is expected here.
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>  

  <!-- CSP Action :: Binary -->
  <xs:element name="SeqAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        Sequential composition between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        External choice between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceAction" type="CIRCUS:Action2" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        Internal choice between two actions.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParAction" type="CIRCUS:ParAction" abstract="true" substitutionGroup="CIRCUS:Action2">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract parallel action definition;
        it includes the name set partitions of the state.
        </p>
        <p>
        As empty name disjoint sets are often used in parallel actions, syntactic sugar for these cases
        is provided in the grammar rules for interleaving, parallel composition, and alphabetised parallel 
        composition, so that we do not need explicit AST classes. 
        </p>        
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveAction" type="CIRCUS:ParAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        <p>
        Interleaving between two actions.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelAction" type="CIRCUS:ParallelAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        Parallel composition between two actions;
        it includes the channel set expression for the synchronisation set.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelAction" type="CIRCUS:AlphabetisedParallelAction" substitutionGroup="CIRCUS:ParAction">
    <xs:annotation>
      <xs:documentation>
        Alphabetised Parallel composition between two actions;
        it includes the channel set expression for both alphabets as synchronisation sets.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- CSP Action :: Unary :: Declaration :: Iterated -->
  <xs:element name="SeqActionIte" type="CIRCUS:ActionIte" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated sequential composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExtChoiceActionIte" type="CIRCUS:ActionIte" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated external choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IntChoiceActionIte" type="CIRCUS:ActionIte" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated internal choice.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParActionIte" type="CIRCUS:ParActionIte" abstract="true" substitutionGroup="CIRCUS:ActionIte">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract parallel iterated action definition.
        it includes the name set partitions of the state.
        </p>
        <p>
        As empty name disjoint sets are often used in iterated parallel actions, syntactic sugar for these cases
        is provided in the grammar rules for iterated interleaving, iterated parallel composition, and iterated 
        alphabetised parallel composition, so that we do not need explicit AST classes. 
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InterleaveActionIte" type="CIRCUS:ParActionIte" substitutionGroup="CIRCUS:ParActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated interleaving.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ParallelActionIte" type="CIRCUS:ParallelActionIte" substitutionGroup="CIRCUS:ParActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AlphabetisedParallelActionIte" type="CIRCUS:ParallelActionIte" substitutionGroup="CIRCUS:ParActionIte">
    <xs:annotation>
      <xs:documentation>
        Circus action for alphabetised iterated parallel composition.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Communication --> 
  <xs:element name="Communication" type="CIRCUS:Communication">
    <xs:annotation>
      <xs:documentation>
        <p>
        A CSP communication that is part of a prefixing process or action. 
        If the communicating channel has been declared with generic types, the communication 
        must carry the generic actual expressions, hence we have a <code>RefExpr</code> rather than
        a <code>RefName</code>. It represents the <b>Communication</b> grammar rule.
        </p>
        <p>
        A communication can be either a communication for synchronisation, input, output, or mixed.
        Synchronisation has no fields. Input and Output has only input or output fields respectively. 
        Mixed communication has both input and output fields, such as <code>c?x:P!v -> A</code>.
        </p>
        <p>
        The semantics of dot (c.x) and output (c!x) is equivalent. 
        However, for some applications/tools, their evaluation can be done differently.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Communication Fields --> 
  <xs:element name="Field" type="CIRCUS:Field" abstract="true">
    <xs:annotation>
      <xs:documentation>
        <p>
        An abstract field is part of a communication. 
        Available extensions are input, dot, and output fields.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="InputField" type="CIRCUS:InputField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        <p>
        An input field that is part of a communication.
        It represents grammar rules <b>?N</b> and <b>?N: Pred</b>.
        </p>
        <p>
        The parse must ensure that the declared name <b>N</b> does not have strokes.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="DotField" type="CIRCUS:DotField" substitutionGroup="CIRCUS:Field">
    <xs:annotation>
      <xs:documentation>
        <p>
        A field that is part of a communication and contains an expression.
        It represents the grammar rule <b>.Expr</b>.
        </p>
        <p>
        In general, the ``dot'' is treated as output communication.
        However, depending on the purpose of use, it can be considered as a reading or writing synchronisation point.        
        </p>
        <p>        
        Another example where the differentiation between dot and output fields is relevant comes from CSP_M and FDR,
        where ``dot'' fields are used for resolved expressions, whereas ``output'' fields can be used for expressions 
        yet to be resolved. 
        Roscoe's give some insight on further interesting possibilities that motivates such differentiation in 
        his CSP book (p.27).
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OutputField" type="CIRCUS:DotField" substitutionGroup="CIRCUS:DotField">
    <xs:annotation>
      <xs:documentation>
        <p>
        A field that is part of a communication and contains an expression.
        It represents the grammar rule <b>!Expr</b>.        
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>       
  
  <!-- Circus declarations -->  
  <xs:element name="QualifiedDecl" type="CIRCUS:QualifiedDecl" substitutionGroup="Z:Decl">
    <xs:annotation>
      <xs:documentation>
        This is like <code>VarDecl</code>, but it includes qualifier attributes for each <code>DeclName</code>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>      
 
  <!-- Circus Commands -->
  <xs:element name="SpecStmtCommand" type="CIRCUS:SpecStmtCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
        Circus command declaring a specification statement in Carroll Morgan's style.
        It represents the grammar rule <code>N+:[Pred,Pred]</code>.
        The parser is responsible to ensure that no strokes are allowed in the frame variables.
        </p>
        <p>
        As assumption and coercion are syntactic sugar for often used specification statements,
        they do not have an explicit AST class. Instead, assumption (grammar rule <code>{Pred}</code>)
        is represented by a specification statement with empty frame, <code>Pred</code> precondition, 
        and true postcondition. Similarly, coercion (grammar rule <code>[Pred]</code>) is represented by 
        a specification statement with empty frame, true precondition, and <code>Pred</code> postcondition.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="AssignmentCommand" type="CIRCUS:AssignmentCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        Circus command declaring (possibly) multiple assignment.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="IfGuardedCommand" type="CIRCUS:IfGuardedCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
        Command declaring a if statement containing guarded actions in Dijkstra's style.
        Although semantically different, we can represent the AST for the production of guarded actions 
        from the BNF of if commands with the <code>GuardedAction</code> AST class, hence minimising the 
        AST classes. 
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  <xs:element name="VarDeclCommand" type="CIRCUS:VarDeclCommand" substitutionGroup="CIRCUS:CircusCommand">
    <xs:annotation>
      <xs:documentation>
        <p>
        Command declaring (possibly multiple) variables local to an action definition.
        The parser is responsible to ensure that no strokes are allowed in the frame variables.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Special Circus actions used on post-parsing. 
       They are related to scope for mutual recursion and variable declaration.
    -->  
  
  <xs:element name="LetAction" type="CIRCUS:LetAction" substitutionGroup="CIRCUS:Action1" abstract="true">
    <xs:annotation>
        <xs:documentation>
            Abstract local environment.
        </xs:documentation>
    </xs:annotation>     
  </xs:element>      
  <xs:element name="LetMuAction" type="CIRCUS:LetMuAction" substitutionGroup="CIRCUS:LetAction">
    <xs:annotation>
      <xs:documentation>
        Local environment for mu actions.
      </xs:documentation>
    </xs:annotation>     
  </xs:element>    
  <xs:element name="LetVarAction" type="CIRCUS:LetVarAction" substitutionGroup="CIRCUS:LetAction">
    <xs:annotation>
      <xs:documentation>
        Local environment for prefixing actions involving input fields, parameterised actions, and variable commands.
      </xs:documentation>
    </xs:annotation>     
  </xs:element>    
  
  <!-- Additional top-level types in Circus -->
  
  <xs:element name="ChannelType" type="CIRCUS:ChannelType" substitutionGroup="Z:Type">
    <xs:annotation>
      <xs:documentation>
        A channel type is like a generic type, where the type can be <code>null</code> for synchronisation channels.
        The <code>OptionalType</code> is the resolved type after instantiation via generic actuals or type inference.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="ChannelSetType" type="CIRCUS:ChannelSetType" substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        A channel set type contains the signature of the set of names it represents, where synchronisation channels have null type.
        The signature contains the channel name and its corresponding ChannelType. So, synchronisation channels will have 
        in their signature a name with a <code>ChannelType</code> whose <code>getType()==null</code>.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  <xs:element name="ProcessType" type="CIRCUS:ProcessType" substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        A process type contains its signature.
        Generic process parameters must be resolved.
      </xs:documentation>
    </xs:annotation>
  </xs:element> 
  
  <!-- Additional process-level types in Circus -->

  
  <xs:element name="SigmaExpr" type="CIRCUS:SigmaExpr" substitutionGroup="Z:Expr">
    <xs:annotation>
      <xs:documentation>
        <p>
        Expression for channel selections, such as c.x or c.true for channel c. 
        It is set of pairs, where the first element is the channel reference and 
        the second element is the expression corresponding to the value to be
        communicaticated. The channel reference is a RefExpr, as channel can 
        contain generic actuals. It denotes set of the all the possible values a 
        channel can communicate.
        </p>
        <p>
        These expressions require special typechecking to ensure that elements are 
        well typed with respect to the (RefExpr X Expr) pair, rather than the structure 
        of the expressions. That is, SigmaExpr unify even when the expression have different
        types, so that we can create the Sigma environment.
        </p>
      </xs:documentation>
    </xs:annotation>     
  </xs:element>
  
  <xs:element name="ActionType" type="CIRCUS:ActionType" substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        An action type contains the action signature.              
      </xs:documentation>
    </xs:annotation>
  </xs:element>    
  <xs:element name="NameSetType" type="CIRCUS:NameSetType" substitutionGroup="Z:Type2">
    <xs:annotation>
      <xs:documentation>
        A name set type contains the signature of the set of names it represents.
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <!-- Additional top-level signatures in Circus -->
  
  <xs:element name="ProcessSignature" type="CIRCUS:ProcessSignature">
    <xs:annotation>
      <xs:documentation>
        <p>
        A process signature consists of the process name, possibly empty generic formal parameters, 
        possibly empty formal parameters or indexes, and the channels usage.
        Generic actuals must be resolved while type checking similarly to Z and ObjectZ (see ClassSignature and oz.TypeChecker).
        </p>
        <p>
        The channels usage is a function from channel name to a set of usage flags.
        These flags can be either IN, OUT, SYNCH or HIDE.
        In the case of HIDE, all other flags are irrelevant.        
        These usage flags are built up by collecting the channel usage from action signatures.
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="BasicProcessSignature" type="CIRCUS:BasicProcessSignature" substitutionGroup="CIRCUS:ProcessSignature">
    <xs:annotation>
      <xs:documentation>
        <p>
        Extends process signature to contain information about basic processes.
        Those are declarations of state variables, local variables, actions, and name sets.
        Local variables comes from either <code>VarDeclCommand</code>, or action formal parameters.
        In the case of a stateless process, the state variables signatures is empty (as oposed to null).
        </p>
      </xs:documentation>      
    </xs:annotation>
  </xs:element>     
  
  <!-- Additional process-level signatures in Circus -->
  
  <xs:element name="ActionSignature" type="CIRCUS:ActionSignature">
    <xs:annotation>
      <xs:documentation>
        <p>
        An action signature consists of the action name, formal parameters, and the channels usage.             
        The channels usage is function from channel name to a set of usage flags.
        These flags can be either IN, OUT, SYNCH or HIDE.
        In the case of HIDE, all other flags are irrelevant.                
        </p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>  
  
  <!-- Lists used by Circus elements -->
  
  <!-- the RefNameList hierarchy -->
  <xs:element name="FieldList" type="CIRCUS:FieldList" abstract="true">
    <xs:annotation>
      <xs:documentation>
        An abstract communication fields list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="CircusFieldList" type="CIRCUS:CircusFieldList"
    substitutionGroup="CIRCUS:FieldList">
    <xs:annotation>
      <xs:documentation>
        A communication fields list.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- ***************************************************************** -->
  <!-- Definitions of complexTypes in the order of usage by the elements -->
  <!-- ***************************************************************** -->

  <!-- Outermost Paragraph Types -->
  <xs:complexType name="ChannelPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>          
          <!--<xs:element ref="CIRCUS:ChannelDecl" minOccurs="0" maxOccurs="unbounded"/>-->
          <xs:element ref="Z:DeclList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ChannelDecl"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ChannelDecl">
    <xs:complexContent>
      <xs:extension base="Z:Decl">
        <xs:sequence>
          <!-- Generic types, possibly empty but not null? -->                    
          <xs:element ref="Z:DeclNameList">          
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenFormals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <!-- List of channel names for channel, or null for channelFrom -->        
          <xs:element ref="Z:DeclNameList"/>          
          <!-- Channel type for typed channels, null for synchronisation channels, or RefExpr for ChannelFrom -->
          <xs:element ref="Z:Expr" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>           
      
  <xs:complexType name="ChannelSetPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclNameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenFormals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:DeclName"/>            
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ProcessPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <!-- Although the syntax is \circprocess [X, Y] N \defs ...,
               I couldn't figure out how to put the generics before the
               name without causing an ambiguity complaint by the XML
               validator :( -->
          <xs:element ref="Z:DeclName">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ProcessName"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:DeclNameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenFormals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusProcess"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusConjPara">
    <xs:complexContent>
      <xs:extension base="Z:Para"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="RefinementConjPara">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusConjPara">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Specification"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Implementation"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>  
        <xs:attribute name="Model" type="CIRCUS:Model" use="optional" default="FlDv"/>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:simpleType name="Model">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Tr"/>
      <xs:enumeration value="SFl"/>
      <xs:enumeration value="FlDv"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- Channel Set Expression complexTypes -->
  <xs:complexType name="ChannelSet">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
    
  <!-- Process Definition complexType -->
  <xs:complexType name="CircusProcess">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="Process1">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusProcess"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessD">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>        
          <!-- Accommodate Z.xsd changes: using Z Standard DeclPart from (12.7.2)
          <xs:element ref="Z:Decl" minOccurs="1" maxOccurs="unbounded"/> 
          -->
          <!-- 
          In Circus, the only possibility is QualifiedDecl and the parser must rule others out.
          ConstDecl and InclDecl are to be avoided, as parameters in CSP do not come from schemas.
          -->
          <xs:element ref="Z:DeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProcessIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessD"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ProcessIdx">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessIte"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Process2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusProcess">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftProc"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusProcess">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightProc"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>     

  <!-- Bssic Process -->
  <xs:complexType name="BasicProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>          
          <!-- 
            It is simpler to just allow a Para to be the state.
            Such paragraph contains a CircusStateAnn annotation on it.
            The parser allows schema boxes, horizontal schemas, and schema actions.
            That rules out generic schemas (or generic abbreviations), as the 
            geneirc types on schemas must come from the process generic formals.
            
            Also, we allow implicit circus state to be declared on the fly,
            where the default name is "$$defaultSt". That is, we allow
            Expr production after \circstate\ as well. For example,
            "\circstate\ S \land T", we translate the on-the-fly description 
            to the following convention: "\circstate\ $$defaultState == S \land T".
            
            In the case of a BasicProcess without state, the typechecker ought to 
            include an empty schema for it as if it had been declared as 
            "\circstate $$defaultSt == [~ | true ~]". 
            
            TODO:Make sure typechecker does that!(Check other places where typechecer is mentioned as well).
          -->
          <xs:element ref="Z:Para">          
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="StatePara"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <!-- 
            Contains both Z and Circus paragraphs, where the StatePara
            is annotated with a CircusStateAnn.  
          -->
          <xs:element ref="Z:ParaList">           
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LocalPara"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>        
          <!-- 
            Contains implicitly declared ActionPara or state schema 
            (as ActionPara with SchExprAction). This includes the 
            main action.
            Elements are annotated with an OnTheFlyDefAnn to be used by
            the typechecker. If it is a state, a CircusStateAnn is also
            included. ActionPara are named as $$implicitActN, whereas 
            the state is named "$$defaultSt" and the main action
            "$$mainAction".
           -->          
          <xs:element ref="Z:ParaList">                      
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="OnTheFlyPara"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>        
          <!--
            The main action is the action within the ActionPara inside
            OnTheFlyPara. It is annotated with an OnTheFlyDefAnn.
          -->
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="MainAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CircusStateAnn">
    <xs:complexContent>
      <xs:extension base="Z:Ann"/>
    </xs:complexContent>
  </xs:complexType>        

  <xs:complexType name="OnTheFlyDefAnn">
    <xs:complexContent>
      <xs:extension base="Z:Ann"/>            
    </xs:complexContent>
  </xs:complexType>

  
  <!-- Process Definition :: Calls --> 
  
  <xs:complexType name="CallProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>          
          <!-- CallExpr because it can contain generic actuals -->
          <xs:element ref="Z:RefExpr">                    
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="CallExpr"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element ref="Z:ExprList">          
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Actuals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>       
        </xs:sequence>
        <xs:attribute name="CallKind" type="CIRCUS:CallKind" use="optional" default="Param"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:simpleType name="CallKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Param"/>
      <xs:enumeration value="Index"/>
      <!-- 
      <xs:enumeration value="Normal"/>      
      <xs:enumeration value="Gen"/>
      <xs:enumeration value="GenParam"/>
      <xs:enumeration value="GenIndex"/>
      -->
    </xs:restriction>
  </xs:simpleType> 
  

  <!-- Process Definition :: Unary -->
  <xs:complexType name="HideProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RenameProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process1">
        <xs:sequence>                   
          <!-- Accommodate Z.xsd changes: RenameList 
          <xs:element name="OldNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>                      
          <xs:element name="NewNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
          -->
          <xs:element ref="CIRCUS:AssignmentPairs"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="AssignmentPairs">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
            <!-- <xs:element ref="Z:RefName" minOccurs="1" maxOccurs="unbounded"> -->
            <xs:element ref="Z:RefNameList">
              <xs:annotation>
                <xs:appinfo>
                  <jaxb:property name="LHS"/>
                </xs:appinfo>
              </xs:annotation>
            </xs:element>      
            <!-- <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"> -->
            <xs:element ref="Z:ExprList">
              <xs:annotation>
                <xs:appinfo>
                  <jaxb:property name="RHS"/>
                </xs:appinfo>
              </xs:annotation>
            </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
          
  <!-- Process Definition :: Binary -->
  
  <xs:complexType name="ParProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Process2"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ParallelProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcess">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="AlphabetisedParallelProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcess">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAlpha"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAlpha"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 

  <!-- Process Definition :: Expressions -->  
  
  <!--
  <xs:complexType name="ProcessE">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusProcess">
        <xs:sequence>          
          <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>          
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  <xs:complexType name="ActualParamProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessE">
        <xs:sequence>
          <xs:element ref="CIRCUS:ParamProcessDesc"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="InstantiationProcess">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessE">
        <xs:sequence>
          <xs:element ref="CIRCUS:IndexedProcessDesc"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  -->
  
  <!-- Process Definition :: Unary :: Declaration :: Iterated -->
  <xs:complexType name="ParProcessIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessIte"/>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ParallelProcessIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcessIte">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Process Definition :: Unary :: Declaration :: Iterated :: Indexed -->
  <xs:complexType name="ParProcessIdx">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessIdx"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ParallelProcessIdx">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParProcessIdx">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Process Paragraphs complexTypes -->
  <xs:complexType name="NameSetPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:NameSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="ActionPara">
    <xs:complexContent>
      <xs:extension base="Z:Para">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
          <xs:element ref="CIRCUS:CircusAction"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Name Set Expression complexTypes -->
  <xs:complexType name="NameSet">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <!-- Action complexType -->    
  <xs:complexType name="CircusAction">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Action1">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusAction"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Action2">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:CircusAction">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionD">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>        
          <!-- Accommodate Z.xsd changes: using Z Standard DeclPart from (12.7.2)
          <xs:element ref="Z:Decl" minOccurs="1" maxOccurs="unbounded"/> 
          -->
          <!-- 
          In Circus, the only possibility is QualifiedDecl and the parser must rule others out.
          ConstDecl and InclDecl are to be avoided, as parameters in CSP do not come from schemas.
          -->
          <xs:element ref="Z:DeclList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ActionIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionD"/>
    </xs:complexContent>
  </xs:complexType> 
  
  <xs:complexType name="CircusCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="SchExprAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <!-- 
          Z:Expr instead of Z:SchExpr or SchText because we want a schema action to be an expression. 
          That means, we can have a schema definition as well as an expression using schemas (as in 
          Spivey's SchExpr tree - that is not in the Z-Standard. From the CZT, these are reflected as 
          Z:SchExpr, Z:SchExpr2, and Z:HideExpr.
          -->          
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="CallAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="Z:RefName"/>
          <!-- Accommodate Z.xsd changes to use ExprList (Z Standard 12.2.12) 
          <xs:element ref="Z:Expr" minOccurs="0" maxOccurs="unbounded"/>                  
          -->
          <xs:element ref="Z:ExprList"/>
        </xs:sequence>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  
  <!-- CSP Action complexType -->
  <xs:complexType name="BasicAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction"/>
    </xs:complexContent>
  </xs:complexType>

  <!--
  <xs:complexType name="ActualParamAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:ParamActionDesc"/>          
          <xs:element ref="Z:Expr" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  -->

  <!-- CSP Action complexType :: Unary -->
  <xs:complexType name="MuAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:DeclName"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GuardedAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="Z:Pred"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="HideAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PrefixingAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>
          <xs:element ref="CIRCUS:Communication"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SubstitutionAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1">
        <xs:sequence>                   
          <!-- Accommodate Z.xsd changes:
          <xs:element name="OldNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
          <xs:element name="NewNames" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/>
          -->
          <xs:element ref="Z:RenameList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- CSP Action complexType :: Unary :: Declaration :: Iterated -->
  <xs:complexType name="ParActionIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ActionIte">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <xs:complexType name="ParallelActionIte">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParActionIte">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- CSP Action complexType :: Binary -->
  <xs:complexType name="ParAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action2">
        <xs:sequence>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftNameSet"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:NameSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightNameSet"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ParallelAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AlphabetisedParallelAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ParAction">
        <xs:sequence>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LeftAlpha"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="CIRCUS:ChannelSet">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="RightAlpha"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="FieldList">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CircusFieldList">
    <xs:complexContent>
      <xs:extension base="CIRCUS:FieldList">
        <xs:sequence>
          <xs:element ref="CIRCUS:Field" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- CSP Communication complexType -->
  <xs:complexType name="Communication">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <!-- Channel expression because it can contain generic actuals -->
          <xs:element ref="Z:RefExpr">          
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ChannelExpr"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>       
          <xs:element ref="CIRCUS:CircusFieldList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ChanFields"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="CommKind" type="CIRCUS:CommKind" use="optional" default="Synch"/>
        <xs:attribute name="MultiSych" type="xs:nonNegativeInteger" use="optional" default="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  <!-- 
    Invariant: 
      Synch = getFields().isEmpty() 
      Input = !getFields().isEmpty() && forall getField().get(i) instanceof InputField            
      Output= !getFields().isEmpty() && forall getField().get(i) instanceof OutputField || getField().get(i) instanceof DotField
      Mixed = !getFields().isEmpty() && there are more than one class: InputField, (OutputField/DotField).
  -->
  <xs:simpleType name="CommKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Synch"/>
      <xs:enumeration value="Input"/>
      <xs:enumeration value="Output"/>
      <xs:enumeration value="Mixed"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- CSP Communication parameters complexType -->
  
  <xs:complexType name="Field">
    <xs:complexContent>
      <xs:extension base="Z:Term"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="InputField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <xs:element ref="Z:RefName">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Variable"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Restriction"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="DotField">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Field">
        <xs:sequence>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Parameterised Commands complextype -->  
  <xs:complexType name="QualifiedDecl">
    <xs:complexContent>
      <xs:extension base="Z:Decl">
        <xs:sequence>
          <!-- Parser must inforce that minOccurs="1"! -->
          <xs:element ref="Z:DeclNameList"/>
          <xs:element ref="Z:Expr"/>
        </xs:sequence>
        <xs:attribute name="ParamQualifier" type="CIRCUS:ParamQualifier" use="optional" default="Value"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="ParamQualifier">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Value"/>
      <xs:enumeration value="Result"/>
      <xs:enumeration value="ValueResult"/>
    </xs:restriction>
  </xs:simpleType>  

  <!-- Circus Commands complextype -->
  <xs:complexType name="SpecStmtCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>
          <!-- <xs:element name="Frame" type="Z:RefName" minOccurs="1" maxOccurs="unbounded"/> -->
          <xs:element ref="Z:RefNameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Frame"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Pre"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Pred">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Post"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AssignmentCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>                  
          <xs:element ref="CIRCUS:AssignmentPairs"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="IfGuardedCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>
          <xs:element ref="CIRCUS:GuardedAction" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="VarDeclCommand">
    <xs:complexContent>
      <xs:extension base="CIRCUS:CircusCommand">
        <xs:sequence>          
          <!-- Modified for consistency with other DeclList places.
               Accommodate Z.xsd changes: using Z Standard DeclPart from (12.7.2)                
          <xs:element ref="Z:VarDecl" minOccurs="1" maxOccurs="unbounded">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Declarations"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          !-->
          <!-- 
          In Circus, the possibilites are VarDecl and InclDecl only and the parser must rule out ConstDecl.
          Implementations should consider at least VarDecl, and InclDecl could be avoid for simplicity.
          -->
          <xs:element ref="Z:DeclList"/>
          <xs:element ref="CIRCUS:CircusAction"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Additional Circus actions for Local Environments of the operational semantics -->
  <xs:complexType name="LetAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:Action1"/>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="LetMuAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:LetAction">
        <xs:sequence>
          <!-- List of ActionPara to handle mutual recursion -->
          <xs:element ref="Z:ParaList"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="LetVarAction">
    <xs:complexContent>
      <xs:extension base="CIRCUS:LetAction">
        <xs:sequence>                             
          <!-- 
          In Circus, the possibilites are VarDecl, ConstDecl, and InclDecl.
          TODO:DESIGN: Maybe remove InclDecl, as ConstDecl is just syntactic sugar.          
          -->
          <xs:element ref="Z:DeclList"/>
          <!-- Invariant: getDeclarations().size()==getValues.size() -->          
          <xs:element ref="Z:ExprList"/>            
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="SigmaExpr">
    <xs:complexContent>
      <xs:extension base="Z:Expr">
        <xs:sequence>
          <xs:element ref="Z:RefExpr">          
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Channel"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element ref="Z:Expr">            
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="Value"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- Circus Types and Signatures -->
  
  <xs:complexType name="ChannelType">
    <xs:complexContent>
      <xs:extension base="Z:Type">
        <xs:sequence>
          <xs:element ref="Z:DeclNameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenFormals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <!-- How to make this possibly empty? -->
          <xs:element ref="Z:Type2">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="DeclaredType"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Type2" minOccurs="0">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ResolvedType"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ChannelSetType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>          
          <xs:element ref="Z:Signature"/>          
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ProcessType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>
          <xs:element ref="CIRCUS:ProcessSignature"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>  
  
  <xs:complexType name="ActionType">
    <xs:complexContent>
        <xs:extension base="Z:Type2">
            <xs:sequence>
                <xs:element ref="CIRCUS:ActionSignature"/>
            </xs:sequence>
        </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  <xs:complexType name="NameSetType">
    <xs:complexContent>
      <xs:extension base="Z:Type2">
        <xs:sequence>          
          <xs:element ref="Z:Signature"/>                      
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>    
  
  <xs:complexType name="ProcessSignature">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:DeclName">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ProcessName"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>          
          <xs:element ref="Z:DeclNameList">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="GenFormals"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Signature" minOccurs="0">          
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ParamOrIndexes"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="Kind" type="CIRCUS:ProcessKind" use="optional" default="Parameterised"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>   

  <!-- A process might have neither formal parameters nor indexes, hence minOccurs="0" for Signature below. 
        Or it might have either of them (i.e. formal parameters or indexes) but never both. -->
  <xs:simpleType name="ProcessKind">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Parameterised"/>
      <xs:enumeration value="Indexed"/>
    </xs:restriction>
  </xs:simpleType>  

  <!-- 
  The typechecker must spread the information from LocalPara and OnTheFlyPara 
  across the three different options, depending on the kind of paragraph, as 
  described below.
  --> 
  <xs:complexType name="BasicProcessSignature">
    <xs:complexContent>
      <xs:extension base="CIRCUS:ProcessSignature">
          <xs:sequence>   
              <!-- 
              For stateless processes, the typechecker must create an empty signature for the SchemaType.
              Moreover, it must also resolve any pending generic actual from either the schema or the process.
              --> 
              <xs:element ref="Z:SchemaType">
                <xs:annotation>
                  <xs:appinfo>
                    <jaxb:property name="StateType"/>
                  </xs:appinfo>
                </xs:annotation>
              </xs:element>
              <!-- 
              Contains a list of alll local paragraphs that are Z paragraphs.
              This includes the implicitly declared state.
              -->
              <xs:element ref="Z:Signature" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                  <xs:appinfo>
                    <jaxb:property name="ZSignature"/>
                  </xs:appinfo>
                </xs:annotation>
              </xs:element> 
              <!--
              Contains a list of all actions pragraphs of the process.
              This includes the implicitly declared actions.
              -->
              <xs:element ref="CIRCUS:ActionSignature" minOccurs="0" maxOccurs="unbounded"/>                
              <!--
              Contains a list of all name set paragraphs of the process.
              -->
              <xs:element ref="Z:ZRefNameList">                
                <xs:annotation>
                  <xs:appinfo>
                    <jaxb:property name="NameSet"/>
                  </xs:appinfo>
                </xs:annotation>
              </xs:element>
          </xs:sequence>
      </xs:extension>
    </xs:complexContent>    
  </xs:complexType>
  
  <xs:complexType name="ActionSignature">
    <xs:complexContent>
      <xs:extension base="Z:Term">
        <xs:sequence>
          <xs:element ref="Z:DeclName">          
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="ActionName"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Signature">            
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="FormalParams"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Signature">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="LocalVars"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element ref="Z:Signature" minOccurs="0">
            <xs:annotation>
              <xs:appinfo>
                <jaxb:property name="UsedChannels"/>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
        
</xs:schema>
