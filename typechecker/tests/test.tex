NOTE 1
\begin{zed}
\generic (\power \_)
\end{zed}
$\power$ has already been introduced in this International Standard
(see 8.3),
so this operator template is not necessary.
However, it may be a convenient way of introducing to a tool
the association of $\power$ with the appropriate token and precedence,
especially in preparation for the toolkit's $\power_1$ (see B.3.6).
A tool may introduce $\cross$ here similarly,
that being the only other Z core notation whose precedence
lies amongst those of user-defined operators.

%\begin{zed}
%\generic 8 \rightassoc (\_ \cross \_)
%\end{zed}

\begin{zed}
[\arithmos]
\end{zed}

The given type $\arithmos$, pronounced ``arithmos'', provides
a supply of values for use in specifying number systems.

\begin{axdef}
\nat : \power \arithmos
\end{axdef}

The set of natural numbers, $\nat$, is a subset of $\arithmos$.

%the original definition doesn't seem right... should be an axdef?
%Changed by Tim Miller
%\begin{zed}
%number_literal_0: \nat
%number_literal_1: \nat
%\end{zed}

\begin{axdef}
  number\_literal\_0 : \nat\\
  number\_literal\_1 : \nat
\end{axdef}

$0$ and $1$ are natural numbers, all uses of which are transformed
to references to these declarations (see 12.2.6.9).

\begin{zed}
\function 30 \leftassoc (\_ + \_)
\end{zed}

\begin{axdef}
\_ + \_ : \power ((\arithmos \cross \arithmos) \cross \arithmos)
\where
\forall m, n: \nat @ \exists_1 p: ( \_ + \_ ) @ p.1 = (m, n)\\
\forall m, n: \nat @ m + n \in \nat\\
\forall m, n: \nat | m + 1 = n + 1 @ m = n\\
\forall n: \nat @ \lnot n + 1 = 0\\
\forall w: \power \nat | 0 \in w \land (\forall y: w @ y + 1 \in w) @ w = \nat\\
\forall m: \nat @ m + 0 = m\\
\forall m, n: \nat @ m + (n + 1) = (m + n) + 1
\end{axdef}


\end{document}

\begin{axdef}
  a : \power \nat\\
  b : \power \nat
\end{axdef}

\begin{axdef}
  powerProdExpr : \power (a \cross b)\\
  prodExpr : a \cross b
\where
  \forall ppe : powerProdExpr @ first ppe = second ppe
\end{axdef}

\begin{gendef}[X, Y]
  numExprSet : \{1,2,3\}\\
  setCompExpr : \power \{ x, y : \nat \}\\
  setCompWithExpr : \{ x, y : \nat ; gen : X @ ((y, gen).1, (y, gen).2)\}\\
  setCompNoExpr1 : \{ x : \nat \}\\
  setCompNoExprMany : \{ x : \nat; gen : Y \}\\
  constDecl == \{1,2,3\}
\end{gendef}

\begin{zed}
  Normal ::= normalish \ldata \nat \rdata &
  TREE ::= leaf | branch \ldata \nat \cross TREE \cross TREE \rdata
\end{zed}

\begin{schema}{S}
  s, t : \nat
\end{schema}

\begin{schema}{T}
  t, u : \nat\\
  v : \power \nat
\end{schema}

\begin{schema}{Incl}
  S\\
  p : \nat
\end{schema}

\begin{zed}
  forallExpr == \forall p : \nat @ Incl\\
  lambdaExprSingle == \lambda s : \nat @ 1\\
  lambdaExprMany == \lambda s, z : \nat @ leaf\\
  lambdaExprSchema == \lambda s : \nat @ Incl\\
\end{zed}

\begin{zed}
  muExpr == \mu x == 1 ; n == \nat @ ( \mu y : n @ y )\\
  letExpr == \LET x == 1 ; y == 2 @ (x, y)
\end{zed}

\begin{zed}
  andExpr == S \land T\\
  negExpr == \lnot S
\end{zed}

\begin{zed}
  condExpr == \IF true \THEN 1 \ELSE 2
\end{zed}

\begin{schema}{left}
  s, s' : \nat
\end{schema}

\begin{schema}{right}
  s, s' : \nat\\
  t, t' : \nat
\end{schema}

\begin{zed}
  %compExpr == left \semi right
  hideExpr == right \hide (s', t)\\
  projExpr == right \project left
\end{zed}

\begin{schema}{decor}
  right\\
  n?, n! : \nat
\end{schema}

\begin{zed}
  preExpr == \pre decor
\end{zed}
