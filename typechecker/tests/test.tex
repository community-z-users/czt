\begin{zsection}
\SECTION prelude
\end{zsection}


NOTE 1
\begin{zed}
\generic (\power \_)
\end{zed}
$\power$ has already been introduced in this International Standard
(see 8.3),
so this operator template is not necessary.
However, it may be a convenient way of introducing to a tool
the association of $\power$ with the appropriate token and precedence,
especially in preparation for the toolkit's $\power_1$ (see B.3.6).
A tool may introduce $\cross$ here similarly,
that being the only other Z core notation whose precedence
lies amongst those of user-defined operators.

%\begin{zed}
%\generic 8 \rightassoc (\_ \cross \_)
%\end{zed}

\begin{zed}
[\arithmos]
\end{zed}

The given type $\arithmos$, pronounced ``arithmos'', provides
a supply of values for use in specifying number systems.

\begin{axdef}
\nat : \power \arithmos
\end{axdef}

The set of natural numbers, $\nat$, is a subset of $\arithmos$.

%the original definition doesn't seem right... should be an axdef?
%Changed by Tim Miller
%\begin{zed}
%number_literal_0: \nat
%number_literal_1: \nat
%\end{zed}

\begin{axdef}
  number\_literal\_0 : \nat\\
  number\_literal\_1 : \nat
\end{axdef}

$0$ and $1$ are natural numbers, all uses of which are transformed
to references to these declarations (see 12.2.6.9).

\begin{zed}
\function 30 \leftassoc (\_ + \_)
\end{zed}

\begin{axdef}
\_ + \_ : \power ((\arithmos \cross \arithmos) \cross \arithmos)
\where
\forall m, n: \nat @ \exists_1 p: ( \_ + \_ ) @ p.1 = (m, n)\\
\forall m, n: \nat @ m + n \in \nat\\
\forall m, n: \nat | m + 1 = n + 1 @ m = n\\
\forall n: \nat @ \lnot n + 1 = 0\\
\forall w: \power \nat | 0 \in w \land (\forall y: w @ y + 1 \in w) @ w = \nat\\
\forall m: \nat @ m + 0 = m\\
\forall m, n: \nat @ m + (n + 1) = (m + n) + 1
\end{axdef}

\begin{zsection}
 \SECTION test
\end{zsection}

\begin{axdef}
  a : \power \nat\\
  b : \power \nat
\end{axdef}

\begin{axdef}
  powerProdExpr : \power (a \cross b)\\
  prodExpr : a \cross b
\where
  \forall ppe : powerProdExpr @ first ppe = second ppe
\end{axdef}

\begin{gendef}[X, Y]
  numExprSet : \{1,2,3\}\\
  setCompExpr : \power \{ x, y : \nat \}\\
  setCompWithExpr : \{ x, y : \nat ; gen : X @ ((y, gen).1, (y, gen).2)\}\\
  setCompNoExpr1 : \{ x : \nat \}\\
  setCompNoExprMany : \{ x : \nat; gen : Y \}\\
  constDecl == \{1,2,3\}
\end{gendef}

\begin{zed}
  Normal ::= normalish \ldata \nat \rdata &
  TREE ::= leaf | branch \ldata \nat \cross TREE \cross TREE \rdata
\end{zed}

\begin{schema}{S}
  s, t : \nat
\end{schema}

\begin{schema}{T}
  t, u : \nat\\
  v : \power \nat
\end{schema}

\begin{schema}{Incl}
  S\\
  p : \nat
\end{schema}

\begin{zed}
  forallExpr == \forall p : \nat @ Incl\\
  lambdaExprSingle == \lambda s : \nat @ 1\\
  lambdaExprMany == \lambda s, z : \nat @ leaf\\
  lambdaExprSchema == \lambda s : \nat @ Incl\\
\end{zed}

\begin{zed}
  muExpr == \mu x == 1 ; n == \nat @ ( \mu y : n @ y )\\
  letExpr == \LET x == 1 ; y == 2 @ (x, y)
\end{zed}

\begin{zed}
  andExpr == S \land T\\
  negExpr == \lnot S
\end{zed}

\begin{zed}
  condExpr == \IF true \THEN 1 \ELSE 2
\end{zed}

\begin{schema}{left}
  s, s' : \nat
\end{schema}

\begin{schema}{right}
  s, s' : \nat\\
  t, t' : \nat
\end{schema}

\begin{zed}
  %compExpr == left \semi right
  hideExpr == right \hide (s', t)\\
  projExpr == right \project left
\end{zed}

\begin{schema}{decor}
  right\\
  n?, n! : \nat
\end{schema}

\begin{zed}
  preExpr == \pre decor
\end{zed}

\begin{zed}
\function  ( PRE~ \_)
\end{zed}

\begin{gendef}[X,Y]
  PRE~ \_ : \power (X \cross \power X)\\
  f       : \power ((X \cross X) \cross X)
\end{gendef}

\begin{zed}
  PRE\_appl == PRE~ 1\\
  f\_appl == f ~ (1,2)\\
  %f\_appl2 == (f ~ S) \cross (f ~ \{1\})
\end{zed}

\begin{zed}
\generic 5 \rightassoc (\_ \rel \_)
\end{zed}

\begin{zed}
X \rel Y == \power ( X \cross Y )
\end{zed}

\begin{zed}
\generic 5 \rightassoc (\_ \fun \_)
\end{zed}

\begin{zed}
 X \fun Y == \{~ f : X \rel Y | \forall x : X @ \exists_1 y : Y @ (x , y) \in f ~\}
\end{zed}


\begin{axdef}
  myRelTest : \nat \fun \power (\nat \fun \nat)
\end{axdef}

\begin{zed}
\relation (\_ \neq \_)
\end{zed}

\begin{gendef}[X]
\_ \neq \_ : X \rel X
\where
\forall x , y : X @ x \neq y \iff \lnot x = y
\end{gendef}

\begin{zed}
\relation (\_ \notin \_)
\end{zed}

\begin{gendef}[X]
\_ \notin \_ : X \rel \power X
\where
\forall x : X ; a : \power X @ x \notin a \iff \lnot x \in a
\end{gendef}

\begin{zed}
\emptyset [ X ] == \{~ x : X | false ~\}
\end{zed}

\begin{zed}
\generic 5 \rightassoc (\_ \pinj \_)
\end{zed}

\begin{zed}
X \pinj Y == \{~ f : X \rel Y | \forall p, q : f @ p.1 = q.1 \iff p.2 = q.2 ~\}
\end{zed}

\begin{zed}
\function 40 \leftassoc (\_ \cap \_)
\end{zed}

\begin{gendef}[X]
\_ \cap \_ : \power X \cross \power X \fun \power X
\where
\forall a , b : \power X @ a \cap b = \{~ x : X | x \in a \land x \in b 
~\}
\end{gendef}

\begin{zed}
\generic 5 \rightassoc (\_ \inj \_)
\end{zed}

\begin{zed}
X \inj Y == ( X \pinj Y ) \cap ( X \fun Y )
\end{zed}

\begin{zed}
  capTest == \nat \cap \nat
\end{zed}

\begin{zed}
  \generic (GENPRE~ \_)
\end{zed}

\begin{zed}
  GENPRE ~ X == \power X
\end{zed}
