\begin{zsection}
   \SECTION test\_circustime\_process \parents circustime\_toolkit
\end{zsection}

\begin{axdef}
   tval: \nat
\where
   tval > 20 \land tval<30
\end{axdef}

\begin{circus}
     \circchannel\ c: \nat \\
     \circchannel\ d: \nat \\
\end{circus}

%Let, Mu, Conditional, Binding and Tuple expressions
\begin{zed}
  letExpr == \LET x == 1 @ x\\
  muExpr1 == (\mu x : \nat @ x)\\
  muExpr2 == (\mu x : \nat | true)\\
  condExpr == \IF true \THEN 1 \ELSE 2\\
  bindExpr == \lblot one == 1 \rblot\\
  tupleExpr == (1, \{2\}, \power \{3\})\\
\end{zed}

\begin{circus}
    \circprocess P \circdef \circbegin \circspot c?x \then \Skip \circend \\
    \circprocess Q \circdef \circbegin \circspot d?x \then \Skip \circend \\

%Positive Test Cases
   
    %Tests production rule:  LCIRCTIME expression:e RCIRCTIME CIRCSTARTBY process:pr
    \circprocess Test1 \circdef \lcirctime 20 \rcirctime \circstartby P \\
    \circprocess Test2 \circdef \lcirctime tval \rcirctime \circstartby P \\
    \circprocess Test3 \circdef \lcirctime 10 + tval \rcirctime \circstartby P \\
    %Let expression is allowed  when expression type is arithmos only
    \circprocess Test4 \circdef \lcirctime letExpr \rcirctime \circstartby P \\
    %Mu expression is allowed  when expression type is arithmos only
    \circprocess Test5 \circdef \lcirctime muExpr1 \rcirctime \circstartby P \\
    \circprocess Test6 \circdef \lcirctime muExpr2 \rcirctime \circstartby P \\
    %Conditional expression is allowed  when expression type is arithmos only
    \circprocess Test7 \circdef \lcirctime condExpr \rcirctime \circstartby P \\
    %Binding expression is allowed  when expression type is arithmos only
    \circprocess Test8 \circdef \lcirctime bindExpr.one \rcirctime \circstartby P \\
    %Tuple expression is allowed  when expression type is arithmos only
    \circprocess Test9 \circdef \lcirctime tupleExpr.1 \rcirctime \circstartby P \\


%Negative Test Cases 

% Negative expression is not allowed 
%\circprocess Test1 \circdef \lcirctime -10 \rcirctime \circstartby P \\

%Power type is not allowed with startby operator
%\begin{axdef}
%  x : \power \nat
%\end{axdef}
%\circprocess Test2 \circdef \lcirctime x \rcirctime \circstartby P \\

%Theta, Schema, Lambda, Let, Mu, Negative, Hide, Conditional, Binding, Project, Quantifier and Tuple exppressions 
%\begin{zed}
%  S == [x : \nat; y : \power \nat]
%  schExpr == [a : \nat]\\
%  lambdaExpr == \lambda y : \nat @ y\\
%  letExpr == \LET x == 1 @ \{x\}\\
%  muExpr == (\mu x : \nat @ \{x\})\\
%  negExpr == \lnot [x : \nat | x = 7]\\
%  hideExpr == [x : \nat] \hide (x) \\
%  condExpr == \IF false \THEN \{1\} \ELSE \{\}\\
%  bindExpr1 == \lblot \rblot\\
%  bindExpr2 == \lblot one == 1 \rblot\\
%  projExpr == [z : \nat] \project [z : \nat]\\
%  qntExpr == \exists x  : \nat @ [x : \nat]\\
%  tupleExpr == (1, \{2\}, \power \{3\})\\
%\end{zed}

%\circprocess Test3 \circdef \lcirctime \theta S \rcirctime \circstartby P \\
%\circprocess Test4 \circdef \lcirctime schExpr \rcirctime \circstartby P \\
%\circprocess Test5 \circdef \lcirctime lambdaExpr \rcirctime \circstartby P \\
%\circprocess Test6 \circdef \lcirctime letExpr \rcirctime \circstartby P \\
%\circprocess Test7 \circdef \lcirctime muExpr \rcirctime \circstartby P \\
%\circprocess Test8 \circdef \lcirctime negExpr \rcirctime \circstartby P \\
%\circprocess Test9 \circdef \lcirctime hideExpr \rcirctime \circstartby P \\
%\circprocess Test10 \circdef \lcirctime condExpr \rcirctime \circstartby P \\
%\circprocess Test11 \circdef \lcirctime bindExpr1 \rcirctime \circstartby P \\
%\circprocess Test12 \circdef \lcirctime bindExpr2 \rcirctime \circstartby P \\
%\circprocess Test13 \circdef \lcirctime projExpr \rcirctime \circstartby P \\
%\circprocess Test14 \circdef \lcirctime qntExpr \rcirctime \circstartby P \\
%\circprocess Test15 \circdef \lcirctime tupleExpr.2 \rcirctime \circstartby P \\
\end{circus}
