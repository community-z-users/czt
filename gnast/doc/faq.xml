<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="faq2html.xsl"?>
<document>

  <faqsection title="General Questions">
    <faq id="latest-version">
      <question>Where do I find the latest version of this document?</question>
      <answer>
        <p>The latest version can be found at
        <a href="http://ant.apache.org/faq.html">http://czt.sourceforge.net/gnast/faq.html</a>.</p>
      </answer>
    </faq>

    <faq id="what-is-it">
      <question>What is Gnast?</question>
      <answer>
        <p>Gnast is a source code generator that generates Java interfaces and classes
           from a W3C XML Schema.  It was designed to generate an annotated syntax
           tree (AST) for standard Z from the schema describing
           <a href="http://czt.sourceforge.net/zml/">ZML</a>, an XML markup
           for the Z specification language. But Gnast can also
           be used to generate ASTs for Schemas describing Z extensions,
           and even Schemas that have nothing to do with the Z language.
        </p>
      </answer>
    </faq>

    <faq id="name">
      <question>What does the name Gnast mean?</question>
      <answer>
        <p>Gnast is short for GeNerate AST.</p>
      </answer>
    </faq>
  </faqsection>

  <faqsection title="How does Gnast work">
    <faq id="diff">
      <question>How is Gnast different from other source code generators
                like those included in Castor and JAXB?
      </question>
      <answer>
        <p>Castor and JAXB are XML data binding frameworks that aim at providing
           a direct mapping between an XML document and Java objects
           as well as methods to translate between the two.
        </p>
        <p>The code generated by Gnast was not designed to serve as an XML data
           binding framework.
           The purpose of Gnast is to generate user-friendly interfaces and a
           set of implementing classes for the objects described in the Schema.
           Even though the Java objects do contain the data of the corresponding
           XML document, the interfaces and classes are not designed to directly
           map to the XML document. They may, for instance, contain additional
           data or methods.
        </p>
        <p>An important feature of the classes generated by Gnast is that they
           support the extensive use of the visitor design pattern. This enables
           the user of these classes to easily add functionality without changing
           the classes itself. Furthermore, a user is free to use the generated
           implementing classes or to provide its own implementation.
        </p>
        <p>
           Gnast was born since none of the data binding frameworks
           provided all the required features for our classes. Meanwhile the
           tools have matured and its probably possible to customise at least
           some of them appropriately.
        </p>
      </answer>
    </faq>

    <faq id="features">
      <question>Which XML Schema structures and features are supported by Gnast?</question>
      <answer>
        <p>Gnast supports only a very limited subset of the rich XML Schema language.
           Supported Schema structures include:
           <ul>
             <li>Extensions of complex types</li>
             <li>...</li>
           </ul>
           Unsupported Schema structures include:
           <ul>
             <li>Restriction of complex types</li>
             <li>...</li>
           </ul>
        </p>
      </answer>
    </faq>

    <faq id="design">
      <question>How should I design my Schema if I want Gnast to be able to handle it?</question>
      <answer>
        <p>Use global Schema elements and the substitutionGroup attribute a lot.
           Since the class hierarchy generated by Gnast is derived from the substitution
           group hierarchy of the global Schema elements, you should use these structures
           extensively.
        </p>
        <p>Try to avoid using the type attribute for local Schema elements.
           Gnast handles the type attribute of local Schema elements
           as strings.  It does not check whether these strings refer to existing
           classes, or whether they are valid Java class names or Java types.
           However, you may provide a mapping file, this is basically a substitution
           which is applied before the code is generated. You could, for instance, provide
           a substitution from the Schema type <code>xs:string</code> to the Java type
           <code>String</code>, or from <code>Foo</code> to <code>MyClass</code>.
           But be aware that it is your responsibility to make sure that the results of
           the substitution really represent the type defined in the Schema.
         </p>
      </answer>
    </faq>
  </faqsection>
</document>