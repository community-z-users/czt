<!--
     Copyright (C) 2004 Tim Miller
     Copyright (C) 2004, 2006 Petra Malik
     This file is part of the CZT project.

     The CZT project contains free software;
     you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with CZT; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<parser xmlns:add="http://czt.sourceforge.net/templates/additional">

package <package/>;

import java.lang.reflect.*;

import net.sourceforge.czt.java_cup.runtime.Scanner;
import net.sourceforge.czt.java_cup.runtime.Symbol;

import net.sourceforge.czt.parser.util.*;
import net.sourceforge.czt.util.CztException;

/**
 * &lt;p&gt;This is a NL lexer
 * (part of context-sensitive lexis) for
<add:z> * Z</add:z>
<add:oz> * Object Z</add:oz>
<add:zpatt>* Z pattern </add:zpatt>
<add:circuspatt>* Circus pattern </add:circuspatt>
<add:circus>* Circus </add:circus><add:tcoz> and TCOZ</add:tcoz>
 * specifications in unicode format.&lt;/p&gt;
 */
public class <class/>
  implements Scanner
{
  /**
   * The tokens that can have soft new lines both before and after.
   */
  private int [] nlBoth_ =
    new int [] {Sym.LEFTASSOC, Sym.PARENTS,
                Sym.RIGHTASSOC, Sym.ELSE, Sym.THEN, Sym.DEFFREE,
                Sym.BAR, Sym.LDATA, Sym.ANDALSO,
                Sym.LISTARG, Sym.AND, Sym.OR,
                Sym.IMP, Sym.IFF, Sym.CROSS, Sym.SLASH,
                Sym.EQUALS, Sym.MEM, Sym.DEFEQUAL, Sym.COLON,
                Sym.COMMA, Sym.DOT, Sym.SEMICOLON, Sym.SPOT,
                Sym.ZHIDE, Sym.ZPROJ, Sym.ZCOMP, Sym.ZPIPE,
                Sym.I, Sym.IP, Sym.EL, Sym.ELP, Sym.ERE,
                Sym.EREP, Sym.ES, Sym.SS, Sym.SRE, Sym.SREP,
<add:zpatt>
                Sym.RULELINE, Sym.RULE, Sym.JOKER, Sym.RULELINE,
</add:zpatt>
<add:circuspatt>
                Sym.CIRCUSJOKER, Sym.CIRCUSACTIONLAW, Sym.CIRCUSPROCESSLAW,
</add:circuspatt>
<add:oz>
                Sym.CLASS, Sym.GENCLASS, Sym.STATE, Sym.INIT, Sym.OPSCH,
                Sym.PARALLEL, Sym.ASSOPARALLEL, Sym.GCH, 
                Sym.SDEF, Sym.CLASSUNION, Sym.SCOPE,
</add:oz>
<add:tcoz>
                Sym.NEXTPRO, Sym.INTCHOICE, Sym.INTERLEAVE,
                Sym.INTERRUPT, Sym.TIMEOUT, Sym.TIMEEND,               
</add:tcoz>
<add:circus>
                /* Circus LaTeX environments */
                Sym.CIRCUSACTION,
                
                /* Everything infix comes here */
                Sym.CIRCDEF, Sym.CIRCINDEX, Sym.CIRCTHEN, Sym.CIRCELSE, 
                Sym.PREFIXTHEN, Sym.PREFIXCOLON, 
                /* Sym.CIRCGUARD, // removed, see Parser.xml terminal section for an explanation */
                Sym.CIRCSEQ, Sym.INTERLEAVE, Sym.CIRCHIDING, 
                Sym.EXTCHOICE, Sym.INTCHOICE, Sym.CIRCASSIGN,
                Sym.CIRCREFINES, Sym.CIRCSIMULATES,
                
                /* Those shall be allowed new soft lines on both sides for formatting purposes */
                Sym.LPAR, Sym.LINTER, Sym.RPAR, Sym.RINTER
</add:circus>
    };

  /**
   * &lt;p&gt;
   * The tokens that can only have soft new lines after.
   * &lt;/p&gt;
   * &lt;p&gt;
   * In the ISO standard, "function", "generic", "relation", and
   * "section" are in the "both" category, but a new line before one of
   * these is possible if multiple paragraphs are permitted inside in
   * a zed paragraph, so have been moved into the "after" category
   * &lt;/p&gt;
   */
  private int [] nlAfter_ =
    new int [] {Sym.IF, Sym.LET, Sym.ZPRE,
                Sym.FUNCTION, Sym.GENERIC, Sym.RELATION, Sym.SECTION,
                Sym.LSQUARE, Sym.ARG, Sym.NOT, Sym.ALL,
                Sym.EXI, Sym.EXIONE, Sym.LPAREN, Sym.LBRACE,
                Sym.LBIND, Sym.LAMBDA, Sym.MU, Sym.THETA,
                Sym.PRE, Sym.PREP, Sym.L, Sym.LP, Sym.CONJECTURE, 
                Sym.ZED, Sym.AX, Sym.SCH, Sym.GENAX, Sym.GENSCH,
<add:zpatt>
                Sym.PROVISO,
</add:zpatt>
<add:oz>
                Sym.DCNJ, Sym.DGCH, Sym.DSQC, Sym.POLY, Sym.OPNAME,
                Sym.DEFNAME,
</add:oz>
<add:tcoz>
                Sym.DIL, Sym.DIC, Sym.DPARA,
</add:tcoz>
<add:circus>
                /* Everything prefix comes here */                
                Sym.CIRCMU, Sym.REPINTERLEAVE, Sym.REPPARALLEL, Sym.REPEXTCHOICE, 
                Sym.REPINTCHOICE, /* Sym.REPSEQ, // removed, see Parser.xml terminal section for an explanation */
                
                /* Sym.CIRCIF, // removed, see Parser.xml terminal section for an explanation */
                Sym.CIRCDO, Sym.CIRCVAR, Sym.CIRCVAL,
                Sym.CIRCRES, Sym.CIRCVRES, Sym.CIRCCHAN, Sym.CIRCCHANFROM, 
                Sym.CIRCCHANSET, Sym.CIRCNAMESET, Sym.CIRCPROC, Sym.CIRCASSERTREF,
                
                Sym.LCIRCCHANSET, Sym.CIRCLINST, Sym.LCIRCGUARD, 
                Sym.LSCHEXPRACT, Sym.LCIRCRENAME, Sym.CIRCSTATE, Sym.CIRCBEGIN
</add:circus>
    };

  /**
   * The tokens that can only have soft new lines before.
   * RDATA has been moved from "both" to "before".
   */
  private int [] nlBefore_ =
    new int [] {Sym.RSQUARE, Sym.RPAREN, Sym.RBRACE,
                Sym.RBIND, Sym.POST, Sym.POSTP, Sym.ER,
                Sym.ERP, Sym.SR, Sym.SRP, Sym.RDATA, Sym.END,
<add:oz>
                Sym.CONTAINMENT
</add:oz>
<add:circus>
                /* Everything posfix comes here */
                Sym.CIRCFI, Sym.CIRCOD, /* Are these postfix or no fix? */

                Sym.RCIRCCHANSET, Sym.CIRCRINST, Sym.RCIRCGUARD, 
                Sym.RSCHEXPRACT, Sym.RCIRCRENAME, Sym.CIRCEND
</add:circus>
    };
    /* These are NOFIX, hence not included 
     *
     * Sym.CIRCSKIP, Sym.CIRCSTOP, Sym.CIRCCHAOS,         
     */

  /**
   * The token returned via the last call to #next_token,
   * or &lt;code&gt;null&lt;/code&gt; if #next_token has not yet been called.
   */
  private Symbol symbol_ = null;

  /**
   * The token stream from which NL tokens are to be removed.
   * Should never be &lt;code&gt;null&lt;/code&gt;.
   */
  private TokenStack tokens_;

  <class/>(Scanner scanner)
  {
    tokens_ = new TokenStack(scanner);
  }

  public Symbol next_token()
    throws Exception
  {
    symbol_ = next();
    return symbol_;
  }

  private Symbol next()
    throws Exception
  {
    Symbol symbol = tokens_.pop();
    if (symbol.sym == Sym.NL &amp;&amp;
        (previousAllowsNewline() ||
         nextAllowsNewline())) {
      return next();
    }
    return symbol;
  }

  private boolean previousAllowsNewline()
  {
    if (symbol_ == null) return true;
    final int sym = symbol_.sym;
    return contains(nlBoth_, sym) || contains(nlAfter_, sym);
  }

  private boolean nextAllowsNewline()
    throws Exception
  {
    Symbol next = tokens_.pop();
    // consecutive NLs are treated the same as a single NL
    while (next.sym == Sym.NL) {
      next = tokens_.pop();
    }
    final int sym = next.sym;
    tokens_.push(next);
    return contains(nlBoth_, sym) || contains(nlBefore_, sym);
  }

  /**
   * Returns true if and only if a symbol is in an array of symbols.
   */
  protected boolean contains(int [] symbols, int symbol)
  {
    boolean result = false;
    for (int i = 0; i &lt; symbols.length; i++) {
      if (symbols[i] == symbol) {
        result = true;
        break;
      }
    }
    return result;
  }
}
</parser>
