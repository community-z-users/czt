<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright (C) 2004, 2007 Petra Malik
     This file is part of the czt project.
     
     The czt project contains free software;
     you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     
     The czt project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     
     You should have received a copy of the GNU General Public License
     along with czt; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
     -->

<scanner xmlns:add="http://czt.sourceforge.net/templates/additional">
package <package/>;

import java.io.*;
import java.util.ArrayList;
import java.util.List;

import net.sourceforge.czt.java_cup.runtime.Scanner;
import net.sourceforge.czt.java_cup.runtime.Symbol;
import net.sourceforge.czt.parser.util.Decorword;
import net.sourceforge.czt.parser.util.LocInfo;
import net.sourceforge.czt.parser.util.LocInfoImpl;
import net.sourceforge.czt.parser.util.ParseException;
import net.sourceforge.czt.parser.util.TokenStack;
import net.sourceforge.czt.parser.z.ZParseError;
import net.sourceforge.czt.parser.z.ZParseMessage;
import net.sourceforge.czt.z.ast.Parent;
import net.sourceforge.czt.z.ast.ZSect;
import net.sourceforge.czt.z.util.Factory;
import net.sourceforge.czt.z.util.ZString;

/**
 * This is a scanner that creates SECTHEAD tokens of type ZSect
 * for section headers.
 * In most cases, it just forwards the stream of tokens unchanged
 * via the #next_token method.  When it encounters a ZED token followed
 * by a SECTION token (the beginning of a section header), it parses untill
 * the end of the section header definition and returns a SECTHEAD token
 * whos type is a ZSect containing all the parsed information.  If no section
 * header definition can be found, one is included before the first non-text
 * token.  Parser using this scanner do not need to care about anonymous
 * specifications.
 *
 * @author Petra Malik
 */
public class SectHeadScanner
  implements Scanner
{
  private TokenStack lookahead_;
  private Factory factory_ = new Factory();
  private ZSect sectHead_ = null;
  private static final String ANONYMOUS_SECT_NAME = "Specification";
  private static final String ANONYMOUS_PARENT = "standard_toolkit";

  public SectHeadScanner(Scanner scanner)
  {
    lookahead_ = new TokenStack(scanner);
  }

  public Symbol next_token()
    throws Exception
  {
    Symbol result = lookahead_.pop();
    if (result != null &amp;&amp; result.sym != Sym.TEXT) {
      Symbol nextToken = lookahead_.pop();
      if (isSectHead(result, nextToken))
      {
        sectHead_ = parseSectHead();
        assert sectHead_ != null;
        return new Symbol(Sym.SECTHEAD, result.left, result.right, sectHead_);
      }
      if (sectHead_ == null) {
        lookahead_.push(nextToken);
        lookahead_.push(result);
        sectHead_ = anonymousZSect();
        assert sectHead_ != null;
        return new Symbol(Sym.SECTHEAD, sectHead_);
      }
      lookahead_.push(nextToken);
    }
    return result;
  }

  private ZSect anonymousZSect()
  {
    Parent parent = factory_.createParent(ANONYMOUS_PARENT);
    List&lt;Parent&gt; parentlist = new ArrayList&lt;Parent&gt;();
    parentlist.add(parent);
    ZSect result = factory_.createZSect(ANONYMOUS_SECT_NAME, parentlist, null);
    return result;
  }


  private boolean isSectHead(Symbol first, Symbol second)
  {
    final boolean firstIsZed =
      first != null &amp;&amp; first.sym == Sym.ZED;
    final boolean secondIsSection =
      second != null &amp;&amp; second.sym == Sym.SECTION;
    return firstIsZed &amp;&amp; secondIsSection;
  }

  private void reportError()
    throws ParseException
  {
    ZParseMessage msg = ZParseMessage.MSG_SYNTAX_ERROR_IN_SECTION_HEADER;
    ZParseError error = new ZParseError(msg, null, null);
    throw new ParseException(error);
  }

  private void reportError(int left, int right)
    throws ParseException
  {
    ZParseMessage msg = ZParseMessage.MSG_SYNTAX_ERROR_IN_SECTION_HEADER;
    LocInfo locInfo = new LocInfoImpl("unknown", left, right);
    ZParseError error = new ZParseError(msg, null, locInfo);
    throw new ParseException(error);
  }

  private ZSect parseSectHead()
    throws Exception
  {
    final Symbol nametok = lookahead_.pop();
    final Symbol next = lookahead_.pop();
    if (nametok == null) {
      reportError();
    }
    if (next == null || nametok.sym != Sym.DECORWORD) {
      reportError(nametok.left, nametok.right);
    }
    assert nametok.value != null;
    final String name = ((Decorword) nametok.value).getName();
    assert name.length() > 0;
    List&lt;Parent&gt; parentList = new ArrayList&lt;Parent&gt;();
    if (next.sym == Sym.PARENTS) {
      parseParentList(parentList);
    }
    else if (next.sym != Sym.END) {
      reportError(next.left, next.right);
    }
    return factory_.createZSect(name, parentList, null);
  }

  private void parseParentList(List&lt;Parent&gt; parentList)
    throws Exception
  {
    final Symbol parentName = lookahead_.pop();
    final Symbol next = lookahead_.pop();
    if (parentName == null) {
      reportError();
    }
    if (next == null || parentName.sym != Sym.DECORWORD) {
      reportError(parentName.left, parentName.right);
    }
    final String name = ((Decorword) parentName.value).getName();
    Parent parent = factory_.createParent(name);
    parentList.add(parent);
    if (next.sym == Sym.DECORWORD &amp;&amp;
             ZString.COMMA.equals(((Decorword) next.value).getName())) {
      parseParentList(parentList);
    }
    else if (next.sym != Sym.END) {
      reportError(next.left, next.right);
    }
  }

  public static boolean isAnonymous(ZSect zsect)
  {
    boolean result = false;
    String name = zsect.getName();
    List parents = zsect.getParent();
    if (parents.size() == 1) {
      Parent parent = (Parent) parents.get(0);
      String parentName = parent.getWord();
      if (ANONYMOUS_SECT_NAME.equals(name) &amp;&amp;
          ANONYMOUS_PARENT.equals(parentName)) {
        result = true;
      }
    }
    return result;
  }
}
</scanner>
