<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright (C) 2003, 2004, 2005, 2006, 2007 Petra Malik, Tim Miller
     This file is part of the CZT project: http://czt.sourceforge.net

     The CZT project contains free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License as published
     by the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License along
     with CZT; if not, write to the Free Software Foundation, Inc.,
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<scanner xmlns:add="http://czt.sourceforge.net/templates/additional">
/* --------------------------Usercode Section------------------------ */
package <package/>;

import java.io.*;
import java.net.URL;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

<add:oz>
import net.sourceforge.czt.oz.util.OzString;
</add:oz>
<add:tcoz>
import net.sourceforge.czt.tcoz.util.TcozString;
</add:tcoz>
<add:circus>
import net.sourceforge.czt.circus.util.CircusString;
</add:circus>
<add:zpatt>
import net.sourceforge.czt.zpatt.util.ZPattString;
</add:zpatt>

import net.sourceforge.czt.parser.util.ErrorType;
import net.sourceforge.czt.parser.util.LatexMarkupFunction;
import net.sourceforge.czt.parser.util.LatexSym;
import net.sourceforge.czt.parser.util.LocInfo;
import net.sourceforge.czt.parser.util.LocInfoImpl;
import net.sourceforge.czt.parser.util.LocToken;
import net.sourceforge.czt.parser.util.LocTokenImpl;
import net.sourceforge.czt.parser.util.ParsePropertiesKeys;
import net.sourceforge.czt.parser.util.ScanException;
import net.sourceforge.czt.parser.z.ZParseError;
import net.sourceforge.czt.parser.z.ZParseMessage;
import net.sourceforge.czt.session.*;
import net.sourceforge.czt.util.CztLogger;
import net.sourceforge.czt.z.util.ZString;

/**
 * &lt;p&gt;
*   The low-level latex to unicode scanner for <add:oz>Object </add:oz>Z<add:circus> Circus </add:circus><add:tcoz> and TCOZ</add:tcoz>.
 *   See {@link LatexToUnicode} for a high level latex to unicode converter.
 * &lt;/p&gt;
 * &lt;p&gt;
 *   This is a JFlex generated scanner for translating
 *   <add:oz>Object </add:oz>Z
 *   specifications written in the latex mark-up language into unicode.
 *   It provides tokens (instances of class {@link Symbol}) whos values
 *   are unicode strings and which contain line and column number
 *   information of the original latex file or stream.
 *   See {@link LatexSym} for a list of possible token kinds.
 * &lt;/p&gt;
 * &lt;p&gt;
 *   In order to work properly, a map containing the latex mark-up function
 *   of the current section to be scanned is needed.  This map must be
 *   updated when a new section header is recognised.
 *   The {@link LatexMarkupParser} is
 *   responsible for this task, and should process the output of an instance
 *   of this class before it can be processed further.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Limitations:
 * &lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;
 *     The name of a generic schema definition should not contain
 *     nested braces.
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *     Latex markup directive are only recognised outside of a formal section
 *     or paragraph.
 *   &lt;/li&gt;
 * &lt;/ul&gt;
 */
%%

/* -----------------Options and Declarations Section----------------- */

%class <class/>
%public
%unicode
%line
%column
%char
%implements ParsePropertiesKeys
%implements LatexMarkupParser.LatexLexer
%function next
%type LocToken

%{
  private static final Logger LOGGER = CztLogger.getLogger(<class/>.class);

  private static String RESOURCE_NAME =
    "net.sourceforge.czt.parser.z.ZParseResourceBundle";

  /**
   * &lt;p&gt;
   * The latex markup function for the current section to be scanned.
   * It must be kept up to date by another class that recognises
   * section headers.
   * &lt;/p&gt;
   */
  private LatexMarkupFunction latexCommands_ = null;

<add:oz>
  /**
   * Records whether the current paragraph is nested within an
   * Object-Z class paragraph
   */
  private boolean nested_ = false;
</add:oz>

  /**
   * A stack of BraceType.
   * Each "{"-token pushs a BraceType on the stack,
   * each "}"-token pops a BraceType from the stack.
   *
   * A "^"-token followed by "{"-token pushs
   * a &lt;code&gt;BraceType.SUPER&lt;/code&gt;
   * (no space to be inserted after the scripts)
   * or &lt;code&gt;BraceType.SUPER_SPACE&lt;/code&gt;
   * (space has to be inserted after
   * the scripts) on the stack.  A "_"-token followed by "{"-token pushs
   * a &lt;code&gt;BraceType.SUB&lt;/code&gt;
   * (no space to be inserted after the scripts)
   * or &lt;code&gt;BraceType.SUB_SPACE&lt;/code&gt;
   * (space has to be inserted after
   * the scripts) on the stack.
   * The "{"-token that encloses a schema name
   * pushes a  &lt;code&gt;BraceType.NAME&lt;/code&gt;
   * (space has to be inserted after closing brace) on the stack.
   * All other "{"-token just push a
   * &lt;code&gt;BraceType.BRACE&lt;/code&gt; on the stack.
   */
  private Stack braceStack_ = new Stack();

  /**
   * A boolean indicating whether a space has to inserted after all
   * following subscripts and superscripts.
   */
  private boolean addSpace_ = false;

  /**
   * True iff we are scanning a directive.
   */
  private boolean directive_ = false;

  /**
   * The source to be scanned.
   */
  private Source source_ = null;

  private SectionInfo sectInfo_;

  private Properties properties_;

  /**
   * A stack of open \begin{something} commands.
   * The stack just contains the string inside the braces
   * ("something" in the example above).
   * This information is only used to check whether every \begin command
   * has a corresponding \end command (making it possible to
   * provide an error message and warning if not). It is not needed
   * by the scanner itself.
   */
  private Stack&lt;String&gt; openBeginCommands_ = new Stack();

  /**
   * Creates a new scanner for the source.
   */
  public <class/>(Source source, SectionInfo sectInfo, Properties properties)
    throws IOException
  {
    this(source.getReader());
    source_ = source;
    sectInfo_ = sectInfo;
    properties_ = properties;
  }

  public Source getSource()
  {
    return source_;
  }

  private String getLoc()
  {
    return source_.toString();
  }

  private LocInfo getLocation()
  {
    return new LocInfoImpl(getLoc(),
                           yyline, yycolumn,
                           yychar, yytext().length());
  }

  private boolean getBooleanProperty(String propertyKey)
  {
    if (properties_ == null) {
      return false;
    }
    return "true".equals(properties_.getProperty(propertyKey));
  }

  private LocToken result(String spelling)
    throws IOException
  {
    return result(LatexSym.UNICODE, spelling);
  }

  private LocToken result(LatexSym sym)
    throws IOException
  {
    return result(sym, yytext());
  }

  private LocToken result(LatexSym sym, String spelling)
    throws IOException
  {
    return new LocTokenImpl(sym, spelling, getLocation());
  }

  /**
   * Writes a space to the output and sets
   * &lt;code&gt;addSpace_&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;
   * if &lt;code&gt;addSpace_&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.
   * Does nothing if &lt;code&gt;addSpace_&lt;/code&gt; is
   * &lt;code&gt;false&lt;/code&gt;.
   */
  private String addSpace()
    throws IOException
  {
    if (addSpace_) {
      addSpace_ = false;
      return ZString.SPACE;
    }
    return "";
  }

  /**
   * Returns a north east arrow if &lt;code&gt;string&lt;/code&gt;
   * equals "^" and a south east arrow if
   * &lt;code&gt;string&lt;/code&gt; equalas "_".
   * Throws an IllegalArgumentException for all other strings.
   */
  private String beginScript(String string)
  {
    if ("^".equals(string)) return ZString.NE;
    if ("_".equals(string)) return ZString.SE;
    throw new IllegalArgumentException();
  }

  /**
   * Returns a south west arrow if &lt;code&gt;string&lt;/code&gt;
   * equals "^" and a north west arrow if
   * &lt;code&gt;string&lt;/code&gt; equalas "_".
   * Throws an IllegalArgumentException for all other strings.
   */
  private String endScript(String string)
  {
    if ("^".equals(string)) return ZString.SW;
    if ("_".equals(string)) return ZString.NW;
    throw new IllegalArgumentException();
  }

  /**
   * Returns the latex mark-up function.
   * @see #setMarkupFunction
   */
  public LatexMarkupFunction getMarkupFunction()
  {
    return latexCommands_;
  }

  /**
   * Sets the latex mark-up function.  This is a mapping
   * from string (representing a latex command)
   * to {@link LatexCommand} containing the unicode representation.
   *
   * This map must be kept up to date to ensure proper working of
   * instances of this class.
   */
  public void setMarkupFunction(LatexMarkupFunction markupFunction)
  {
    latexCommands_ = markupFunction;
  }

  /**
   * Returns an unicode string representation of the given latex
   * command.
   *
   * @param latexCommand the latex command.
   * @param spaces indicates whether spaces should be added or not.
   * @return the unicode represention of the given latex command,
   *          or null if the command cannot be found.  Spaces are
   *          added (depending on the type of the command) if spaces
   *          is true.
   */
  private String toUnicode(String latexCommand, boolean spaces)
  {
    if (latexCommands_ == null) {
      System.out.println("Should not happen");
      return null;
    }
    LatexMarkupFunction.MarkupDirective directive =
      (LatexMarkupFunction.MarkupDirective)
      latexCommands_.getCommandDirective(latexCommand);
    if (directive == null) {
      return null;
    }
    String result = directive.getUnicode();
    if (spaces) {
      if (directive.addLeftSpace()) result = ZString.SPACE + result;
      if (directive.addRightSpace()) addSpace_ = true;
    }
    return result;
  }

  private void reportError(ErrorType type, ZParseMessage msg, String arg0)
  {
    final Level level =
      ErrorType.ERROR.equals(type) ? Level.SEVERE : Level.WARNING;
    final LocInfo locInfo = getLocation();
    final Object[] args = { arg0, locInfo, };
    LOGGER.logrb(level,
                 getClass().toString(),
                 "",
                 RESOURCE_NAME,
                 msg.toString(),
                 args);
    ZParseError.report(sectInfo_, getSource(), type, msg, args, locInfo);
  }

  private void reportUnknownLatexCommand(String command)
  {
    ErrorType errorType = ErrorType.ERROR;
    if (getBooleanProperty(PROP_IGNORE_UNKNOWN_LATEX_COMMANDS)) {
      errorType = ErrorType.WARNING;
    }
    reportError(errorType,
                ZParseMessage.MSG_UNKNOWN_LATEX_COMMAND,
                command);
  }

  private void begin(String name)
  {
    openBeginCommands_.push(name);
  }

  private void end(String name)
  {
    if (openBeginCommands_.empty()) {
      reportError(ErrorType.ERROR,
                  ZParseMessage.MSG_UNMATCHED_BEGIN_END,
                  name);
    }
    else {
      String openCommand = openBeginCommands_.pop();
      if (! name.equals(openCommand)) {
        reportError(ErrorType.ERROR,
                    ZParseMessage.MSG_UNMATCHED_BEGIN_END,
                    openCommand);
      }
    }
  }

  /**
   * A brace type enumeration.
   */
  private enum BraceType
  {
    /**
     * Subscript enclosed in braces.
     */
    SUB,

    /**
     * Superscript enclodes in braces.
     */
    SUPER,

    /**
     * Subscript enclosed in braces and space has to be added after
     * all superscripts and subscripts.
     */
    SUB_SPACE,

    /**
     * Superscript enclosed in braces and space has to be added after
     * all superscripts and subscripts.
     */
    SUPER_SPACE,

    /**
     * The brace that starts a name, for example a schema name.
     */
    NAME,

    /**
     * All remaining braces.
     */
    BRACE;
  }
%}




/* white spaces */
NL = "\n" | "\r" | "\r\n"
WS = [\ \t\b\012] | {NL}

/* hard spaces */
HS = "~" | "\\," | "\\:" | "\\;" | "\\ "
  | "\\t1" | "\\t2" | "\\t3" | "\\t4" | "\\t5" | "\\t6" | "\\t7"
  | "\\t8" | "\\t9"
NOT_NL = !(![^] | {NL})
COMMENT = "%" ~{NL}
IGNORE = {WS} | {COMMENT}

LETTER = [a-zA-Z]
NOT_LETTER = !(![^] | {LETTER})

COMMAND = "\\" . | "\\" {LETTER}*
SCRIPT = "^" | "_"
FUNCTION = "*" | "+" | "|"
PUNCTATION = ";" | ","
RELATION = ":" | "&lt;" | "=" | "&gt;"

START_COMMENT = "%"
CHAR_MARKUP = "%%Zchar" {NOT_NL}* {NL}?
         | "%%Zinchar" {NOT_NL}* {NL}?
         | "%%Zprechar" {NOT_NL}* {NL}?
         | "%%Zpostchar" {NOT_NL}* {NL}?
WORD_MARKUP = "%%Zword"
INWORD_MARKUP = "%%Zinword"
PREWORD_MARKUP = "%%Zpreword"
POSTWORD_MARKUP = "%%Zpostword"

SPECIAL = "\\" | "%"
NOT_SPECIAL = !(![^] | {SPECIAL})
TEXT = {NOT_SPECIAL}*

NOT_LB = !(![^] | "{")
NAME =   {NOT_LB}*
       | {NOT_LB}* "{" {NOT_LB}* "}" {NOT_LB}*
%state ZED
%state MARKUP
%state COMMENT_STATE
%state ERROR
<add:oz>
%state CLASSCOM
</add:oz>
<add:tcoz>
%state NETTOPOLOGY
</add:tcoz>

%%
/* ------------------------Lexical Rules Section---------------------- */

&lt;YYINITIAL&gt; {
  "\\begin" {IGNORE}* "{axdef}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("axdef");
          return result(ZString.AX);
        }
  "\\begin" {IGNORE}* "{gendef}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("gendef");
          return result(ZString.GENAX);
        }
  "\\begin" {IGNORE}* "{schema}" {IGNORE}* "{" / {NAME} "}" {IGNORE}* "["
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("schema");
          braceStack_.push(BraceType.NAME);
          return result(ZString.SCHCHAR + ZString.GENCHAR);
        }
  "\\begin" {IGNORE}* "{schema}" {IGNORE}* "{"
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("schema");
          braceStack_.push(BraceType.NAME);
          return result(ZString.SCH);
        }
  "\\begin" {IGNORE}* "{schema}" {IGNORE}*
        {
          yybegin(ERROR);
        }
  "\\begin" {IGNORE}* "{zed}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("zed");
          return result(ZString.ZED);
        }
  "\\begin" {IGNORE}* "{zsection}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("zsection");
          return result(LatexSym.SECT, ZString.ZED);
        }
  "\\begin" {IGNORE}* "{theorem}" "{" {NAME} "}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("theorem");
          return result(ZString.ZED);
        }
<add:zpatt>
  "\\begin" {IGNORE}* "{zedjoker}" {IGNORE}* "{"
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("zedjoker");
          braceStack_.push(BraceType.NAME);
          return result(ZPattString.JOKER);
        }
  "\\begin" {IGNORE}* "{zedjoker}" {IGNORE}*
        {
          yybegin(ERROR);
        }
  "\\begin" {IGNORE}* "{zedrule}" {IGNORE}* "{"
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("zedrule");
          braceStack_.push(BraceType.NAME);
          return result(ZPattString.RULE);
        }
  "\\begin" {IGNORE}* "{zedrule}" {IGNORE}*
        {
          yybegin(ERROR);
        }
</add:zpatt>
<add:circus>
  "\\begin" {IGNORE}* "{circus}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("circus");
          return result(ZString.ZED);
        }
</add:circus>
<add:oz>
  //look ahead to see if this is a generic class
  //this also supports the "[" inside the "{..}" because the latex
  //style does not print it correctly otherwise
  "\\begin" {IGNORE}* "{class}" {IGNORE}* "{" / {NOT_NL}* "["
        {
          yybegin(ZED);
          nested_ = true;
          assert ! addSpace_;
          String result = ZString.SCH + ZString.SPACE + "genclass" + ZString.SPACE;
          begin("class");
          braceStack_.push(BraceType.NAME);
          return result(result);
        }
  "\\begin" {IGNORE}* "{class}" {IGNORE}* "{"
        {
          yybegin(ZED);
          nested_ = true;
          assert ! addSpace_;
          String result = ZString.SCH + ZString.SPACE + "class" + ZString.SPACE;
          begin("class");
          braceStack_.push(BraceType.NAME);
          return result(result);
        }
  "\\begin" {IGNORE}* "{class}" {IGNORE}*
        {
          yybegin(ERROR);
        }
</add:oz>
  ^{CHAR_MARKUP}
        {
          return result(LatexSym.CHAR_MARKUP);
        }
  ^{WORD_MARKUP}
        {
          yybegin(MARKUP);
          directive_ = true;
          return result(LatexSym.WORD_MARKUP, null);
        }
  ^{INWORD_MARKUP}
        {
          yybegin(MARKUP);
          directive_ = true;
          return result(LatexSym.INWORD_MARKUP, null);
        }
  ^{PREWORD_MARKUP}
        {
          yybegin(MARKUP);
          directive_ = true;
          return result(LatexSym.PREWORD_MARKUP, null);
        }
  ^{POSTWORD_MARKUP}
        {
          yybegin(MARKUP);
          directive_ = true;
          return result(LatexSym.POSTWORD_MARKUP, null);
        }
  {START_COMMENT}
        {
          yybegin(COMMENT_STATE);
        }

  {TEXT}
        {
          return result(LatexSym.TEXT);
        }
  [^]
        {
          return result(LatexSym.TEXT);
        }
}

&lt;ZED&gt; {
  {NL}
        {
          if (directive_) {
            yybegin(YYINITIAL);
            directive_ = false;            
            addSpace_ = false; // TODO: what about spaces?
            return result(LatexSym.END_MARKUP);
          }
        }

  {IGNORE}
        {
          /* ignore whitespace (except NL) and comments */
        }
  {HS}
        {
          String result = addSpace();
          result += ZString.SPACE;
          return result(result);
        }
  "\\\\" | "\\also" | "\\znewpage"
        {
          String result = addSpace();
          return result(result + ZString.NLCHAR);
        }
  "\\end" {IGNORE}* "{theorem}"
        {
          end("theorem");
<add:oz>
          if (!nested_) {
</add:oz>
             yybegin(YYINITIAL);
<add:oz>
          }
</add:oz>
          String result = addSpace() + ZString.END;
          return result(LatexSym.END, result);
        }
  "\\end" {IGNORE}* "{axdef}"
        {
          end("axdef");
<add:oz>
          if (!nested_) {
</add:oz>
             yybegin(YYINITIAL);
<add:oz>
          }
</add:oz>
          String result = addSpace() + ZString.END;
          return result(LatexSym.END, result);
        }
  "\\end" {IGNORE}* "{gendef}"
        {
          end("gendef");
<add:oz>
          if (!nested_) {
</add:oz>
             yybegin(YYINITIAL);
<add:oz>
          }
</add:oz>
          String result = addSpace() + ZString.END;
          return result(LatexSym.END, result);
        }
  "\\end" {IGNORE}* "{schema}"
        {
          end("schema");
<add:oz>
          if (!nested_) {
</add:oz>
             yybegin(YYINITIAL);
<add:oz>
          }
</add:oz>
          String result = addSpace() + ZString.END;
          return result(LatexSym.END, result);
        }
  "\\end" {IGNORE}* "{zed}"
        {
          end("zed");
<add:oz>
          if (!nested_) {
</add:oz>
             yybegin(YYINITIAL);
<add:oz>
          }
</add:oz>
          String result = addSpace() + ZString.END;
          return result(LatexSym.END, result);
        }
  "\\end" {IGNORE}* "{zsection}"
        {
          end("zsection");
<add:oz>
          if (!nested_) {
</add:oz>
             yybegin(YYINITIAL);
<add:oz>
          }
</add:oz>
          String result = addSpace() + ZString.END;
          return result(LatexSym.END, result);
        }
<add:zpatt>
  "\\end" {IGNORE}* "{zedjoker}"
        {
          end("zedjoker");
          yybegin(YYINITIAL);
          String result = addSpace() + ZString.END;
          return result(LatexSym.END, result);
        }
  "\\end" {IGNORE}* "{zedrule}"
        {
          end("zedrule");
          yybegin(YYINITIAL);
          String result = addSpace() + ZString.END;
          return result(LatexSym.END, result);
        }
</add:zpatt>
<add:circus>
  "\\end" {IGNORE}* "{circus}"
        {
          end("circus");
             yybegin(YYINITIAL);
          String result = addSpace() + ZString.END;
          return result(LatexSym.END, result);
        }
</add:circus>
<add:oz>
  "\\begin" {IGNORE}* "{classcom}"
        {
          yybegin(CLASSCOM);
          assert ! addSpace_;
          begin("classcom");
          //return result(OzString.CLASSCOM);
        }
  "\\begin" {IGNORE}* "{axdef}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("axdef");
          return result(ZString.AX);
        }
  "\\begin" {IGNORE}* "{gendef}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("gendef");
          return result(ZString.GENAX);
        }
  "\\begin" {IGNORE}* "{op}" {IGNORE}* "{"
 	{
          yybegin(ZED);
          assert ! addSpace_;
          begin("op");
          braceStack_.push(BraceType.NAME);
          return result(ZString.SCH + "op" + ZString.SPACE);
        }
  "\\begin" {IGNORE}* "{op}" {IGNORE}*
        {
          yybegin(ERROR);
        }
  "\\begin" {IGNORE}* "{schema}" {IGNORE}* "{" / {NAME} "}" {IGNORE}* "["
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("schema");
          braceStack_.push(BraceType.NAME);
          return result(ZString.SCHCHAR + ZString.GENCHAR);
        }
  "\\begin" {IGNORE}* "{schema}" {IGNORE}* "{"
        {
          yybegin(ZED);
          assert ! addSpace_;
          begin("schema");
          braceStack_.push(BraceType.NAME);
          return result(ZString.SCH);
        }
  "\\begin" {IGNORE}* "{schema}" {IGNORE}*
        {
          yybegin(ERROR);
        }
  "\\end" {IGNORE}* "{class}"
        {
          end("class");
          yybegin(YYINITIAL);
          nested_ = false;
          String result = addSpace();
          return result(result + ZString.END);
        }
  "\\end" {IGNORE}* ("{state}" | "{anonschema}")
        {
          end("state");
          String result = addSpace();
          return result(result + ZString.END);
        }
  "\\end" {IGNORE}* "{init}"
        {
          end("init");
          String result = addSpace();
          return result(result + ZString.END);
        }
  "\\end" {IGNORE}* "{op}"
        {
          end("op");
          String result = addSpace();
          return result(result + ZString.END);
        }
  "\\begin" {IGNORE}* ("{state}" | "{anonschema}")
        {
          String result = addSpace();
          begin("state");
          return result(result + ZString.SCH + ZString.ZEDCHAR);
        }
  "\\begin" {IGNORE}* "{init}"
        {
          String result = addSpace();
          begin("init");
          return result(result + ZString.SCH + ZString.SPACE + OzString.INITWORD + ZString.SPACE);
        }
    "\\begin" {IGNORE}* "{sidebyside}"
        {
          //do nothing
        }
  "\\end" {IGNORE}* "{sidebyside}"
        {
          //do nothing
        }
  "\\nextside"
        {
          //do nothing
        }
</add:oz>
<add:tcoz>
  "\\chrel"
        {
          yybegin(NETTOPOLOGY);
        }
</add:tcoz>
  "\\where"
        {
          String result = addSpace();
          return result(result + ZString.SPACE + ZString.VL + ZString.SPACE);
        }
  "@"
        {
          String result = addSpace();
          return result(result + ZString.SPACE + ZString.SPOT + ZString.SPACE);
        }
  "'"
        {
          String result = addSpace();
          return result(result + ZString.PRIME);
        }
  "-"
        {
          String result = addSpace();
          return result(result + ZString.SPACE + ZString.MINUS + ZString.SPACE);
        }
  {SCRIPT} {IGNORE}* ({RELATION}|{PUNCTATION}|{FUNCTION}|{LETTER}|[0-9])
        {
          String script = yytext().substring(0, 1);
          return result(beginScript(script)
                        + yytext().substring(yytext().length() - 1)
                        + endScript(script));
        }
  {SCRIPT} {IGNORE}* {COMMAND}
        {
          String result = "";
          String script = yytext().substring(0, 1);
          String command = yytext().substring(yytext().indexOf("\\"));
          String zstring = toUnicode(command, false);
          result += beginScript(script);
          if (zstring != null) {
            result += zstring;
          } else {
            reportUnknownLatexCommand(command);
            result += command.substring(1);
          }
          result += endScript(script);
          return result(result);
        }
  {SCRIPT} {IGNORE}* "{"
        {
          String script = yytext().substring(0, 1);
          if ("^".equals(script)) {
            if (addSpace_) {
              braceStack_.push(BraceType.SUPER_SPACE);
            } else {
              braceStack_.push(BraceType.SUPER);
            }
          } else if ("_".equals(script)) {
            if (addSpace_) {
              braceStack_.push(BraceType.SUB_SPACE);
            } else {
              braceStack_.push(BraceType.SUB);
            }
          }
          addSpace_ = false;
          return result(beginScript(script));
        }
  {SCRIPT} {IGNORE}* .
        {
          String message = "Unexpected subscript or superscript " + yytext();
          throw new ScanException(message, getLocation());
        }
  "\\_" | "\\{" | "\\}"
        {
          String result = addSpace();
          return result(result + yytext().substring(1));
        }
  "\\SECTION"
        {
          String result = addSpace() + "section";
          addSpace_ = true;
          return result(LatexSym.SECTION, result);
        }
  "\\parents"
        {
          String result = addSpace() + ZString.SPACE + "parents";
          addSpace_ = true;
          return result(LatexSym.PARENTS, result);
        }
  {COMMAND}
        {
          String result = addSpace();
          boolean spaces = braceStack_.empty();
          String zstring = toUnicode(yytext(), spaces);
          if (zstring != null) {
            result += zstring;
          }
          else {
            reportUnknownLatexCommand(yytext());
            if (spaces) result += ZString.SPACE;
            result += yytext().substring(1);
            if (spaces) result += ZString.SPACE;
          }
          return result(result);
        }
  "{"
        {
          String result = addSpace();
          braceStack_.push(BraceType.BRACE);
          return result(result);
        }
  "}"
        {
          String result = "";
          if (braceStack_.empty()) {
            final ErrorType errorType = ErrorType.ERROR;
            reportError(errorType, ZParseMessage.MSG_UNMATCHED_BRACES, "}");
            return result(result);
          }
          BraceType brace = (BraceType) braceStack_.pop();
          assert ! addSpace_;
          if (brace.equals(BraceType.SUPER)) {
            result += ZString.SW;
          } else if (brace.equals(BraceType.SUPER_SPACE)) {
            result += ZString.SW;
            addSpace_ = true;
          } else if (brace.equals(BraceType.SUB)) {
            result += ZString.NW;
          } else if (brace.equals(BraceType.SUB_SPACE)) {
            result += ZString.NW;
            addSpace_ = true;
          } else if (brace.equals(BraceType.NAME)) {
            result += ZString.SPACE;
          }
          return result(result);
        }
  {FUNCTION} | {RELATION}({RELATION}|{WS})*
        {
          String result = addSpace();
          if (braceStack_.empty()) {
            result += ZString.SPACE;
          }
          result += yytext().replaceAll("[ ]", "");
          if (braceStack_.empty()) {
            addSpace_ = true;
          }
          return result(result);
        }
  {PUNCTATION}
        {
          String result = addSpace();
          result += yytext();
          if (braceStack_.empty()) addSpace_ = true;
          return result(result);
        }
  ({LETTER} | [0-9])*
        {
          String result = addSpace();
          result += yytext();
          return result(result);
        }
  .
        {
          String result = addSpace();
          result += yytext();
          return result(result);
        }
}

&lt;MARKUP&gt; {
  {WS}
        {
          /* ignore whitespaces */
        }
  {COMMAND}
        {
          yybegin(ZED);
          return result(LatexSym.NAME);
        }
  .
        {
          yybegin(YYINITIAL);
          reportError(ErrorType.ERROR,
                      ZParseMessage.MSG_UNEXPECTED_TOKEN,
                      yytext());
        }
}

&lt;COMMENT_STATE&gt; {
  {NL}
       {
         yybegin(YYINITIAL);
       }
  .
       {
         // do nothing
       }
}

<add:oz>
&lt;CLASSCOM&gt; {
  "\\end" {IGNORE}* "{classcom}"
       {
         end("classcom");
         yybegin(ZED);
         //return result(OzString.ENDCLASSCOM);
       }  
  .|\n
       {
         // for now, do nothing
         //return result(LatexSym.TEXT);
       }
}
</add:oz>

<add:tcoz>
&lt;NETTOPOLOGY&gt; {
  "{" 
       {
         return result(TcozString.NETTOPLEFT);
       }
  "}"
       {
         yybegin(ZED);
         return result(TcozString.NETTOPRIGHT);
       }
  {PUNCTATION}
        {
          String result = addSpace();
          result += yytext();
          if (braceStack_.empty()) addSpace_ = true;
          return result(result);
        }
  ({LETTER} | [0-9])*
        {
          String result = addSpace();
          result += yytext();
          return result(result);
        }
  .
        {
          String result = addSpace();
          result += yytext();
          return result(result);
        }
}
</add:tcoz>

&lt;ERROR&gt; {
  .
        {
          yybegin(YYINITIAL);
          reportError(ErrorType.ERROR,
                      ZParseMessage.MSG_UNEXPECTED_TOKEN,
                      yytext());
        }
}
</scanner>
