<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright 2003, 2004, 2005 Mark Utting.  marku@cs.waikato.ac.nz
     This file is part of the CZT project: http://czt.sourceforge.net

     The CZT project contains free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License as published
     by the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License along
     with CZT; if not, write to the Free Software Foundation, Inc.,
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<scanner xmlns:add="http://czt.sourceforge.net/templates/additional">

package <package/>;

import java.io.IOException;
import java.util.*;
import net.sourceforge.czt.java_cup.runtime.Symbol;

import net.sourceforge.czt.parser.util.*;

<add:circus>
import java.util.EnumSet;
</add:circus>

/**
 * &lt;p&gt;
 *   Looks ahead in the token stream to resolve some Z ambiguities.
 * &lt;/p&gt;
 *
 * &lt;p&gt;As described in the ISO Z standard (Section 8.4, p37), the Z
 * grammar has several ambiguities.  This class 'buffers' the token
 * stream, so that it can look ahead in the token stream if necessary,
 * to help resolve the ambiguities.&lt;/p&gt;
 *
 * &lt;p&gt;For example, in {x,y,z...}, if the x,y,z is followed by
 * ':', then it is part of a declaration (a set comprehension) and
 * declares new variables x,y,z, otherwise it is a set extension, and
 * x,y,z must already have been declared.  To resolve this, whenever
 * we come to a DECORWORD, this class looks ahead over (COMMA, name)
 * pairs where name is either a single DECORWORD or an operator name, to see
 * if they are followed by a COLON (:) token.  If they are, it returns
 * those names as DECLNAME tokens rather than DECORWORD tokens.&lt;/p&gt;
 *
<add:oz>
 * This class also resolves ambiguities in Object-Z. To resolve the
 * problem of whether the first name seen after a class name is a
 * reference to an inheriting class or a reference to a name, we use
 * lookahead. If the token after the name is ::= or ==, the smart
 * scanner returns a DEFNAME instead of a DECORWORD. If the token is
 * \sdef, we return an OPNAME instead of a DECORWORD.
</add:oz>
 */
class <class/> implements net.sourceforge.czt.java_cup.runtime.Scanner
{
  //indicates whether the previous token is a named box token
  //i.e. SCH, GENSCH, CLASS, OPSCH
  private boolean inBoxName = false;

<add:circus>
  //indicates whether the previous token is CIRCBEGIN - that is, if a
  //basic process is starting -, since communication only take place
  //within an action declaration
  private boolean inCircusBasicProcess = false;
  
  //after their names, actions MUST have a CIRCDEF token, which is 
  //marked by this flag. That is, it is true whenever we have started
  //a basic process and have encountered a CIRCDEF. It is switched off
  //either when CIRCEND (i.e. end of basic process) or END
  //(i.e. end of a general paragraph) is reached. The former happens
  //when declaring basic processes within a single circus latex environment,
  //whereas the latter happens when using multiple circusaction latex environments
  //to declared basic processes. 
  //
  //Whenever both inCircusBasicProcess and inActionDef are enabled, and
  //the next token is a DECORWORD, then, just like in colon declaration for Z,
  //we need to lookahead to see whether the DECORWORD is part of a communication
  //or not. That is, we need to lookahead until the flag is switched off, in which
  //case nothing changes; or we find a PREFIXTHEN token, in which case the DECORWORD
  //is rebranded as CIRCUSNAME and the remainder fileds are parsed appropriately.
  //
  private boolean inActionDef = false;
  
  // Set of names collected from CircusToken and CircusKeyword that we should stop
  // lookahead for communication patterns. That is, all circus tokens different from 
  // PREFIXCOLON and PREFIXTHEN
  private static final Set&lt; String &gt; CIRCUS_TOKENS_STOP_LOOKAHEAD = collectCircusSymbolNames();
  
  // To avoid delayed lookups, collect the symbol table (symbols as keys) for all 
  // symbols to stop the lookahead. We do that by retaining all collected names 
  // and then flipping the resulting map.
  private static final Map&lt; Object, String &gt; CIRCUS_SYMBOL_MAP_STOP_LOOKAHEAD = retainAllCircusNames(CIRCUS_TOKENS_STOP_LOOKAHEAD);
  
  private static Set&lt; String &gt; collectCircusSymbolNames()
  {
    Set&lt; String &gt; result = new HashSet();
    EnumSet CIRCUS_TOKENS = EnumSet.allOf(CircusToken.class);
    EnumSet CIRCUS_KEYWORDS = EnumSet.allOf(CircusKeyword.class);
    CIRCUS_KEYWORDS.remove(CircusKeyword.PREFIXTHEN);
    CIRCUS_KEYWORDS.remove(CircusKeyword.PREFIXCOLON);            
    
    Iterator&lt; CircusToken &gt; it = CIRCUS_TOKENS.iterator();
    while (it.hasNext())
    {
      boolean ok = result.add(it.next().getName());
      assert ok : "invalid CircusToken at smart scanning";
    }
    Iterator&lt; CircusKeyword &gt; it2 = CIRCUS_KEYWORDS.iterator();
    while (it2.hasNext())
    {
      boolean ok = result.add(it2.next().getName());
      assert ok : "invalid CircusKeyword at smart scanning";
    }
    
    assert result.size() == CIRCUS_TOKENS.size() + CIRCUS_KEYWORDS.size();
    
    return result;
  }
  
  private static &lt;K, V&gt; Map&lt;V, K&gt; flipMap(Map&lt;K, V&gt; m)
  {
    Map&lt;V, K&gt; result = new HashMap&lt;V, K&gt;();
    Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = m.entrySet().iterator();
    while (it.hasNext())
    {
      Map.Entry&lt;K, V&gt; entry = it.next();      
      result.put(entry.getValue(), entry.getKey());
    }    
    assert 
      ((m.keySet().containsAll(result.values()) &amp;&amp; m.keySet().size() == result.values().size()) &amp;&amp;
      (result.keySet().containsAll(m.values()) &amp;&amp; result.keySet().size() == m.values().size())) : "map flipping failed";
    return result;
  }
    
  private static Map&lt; Object, String &gt; retainAllCircusNames(Set&lt; String &gt; namesToRetain)
  {
    // get the symbol table as NAME = INT_VALUE
    Map&lt; String, Object &gt; result = DebugUtils.getFieldMap2(Sym.class);
    
    // retain all names from given set
    result.keySet().retainAll(namesToRetain);      
    
    // flip the map as the result.
    return flipMap(result);
  }
</add:circus>  
  
  private TokenStack dumb_;

  <class/>(net.sourceforge.czt.java_cup.runtime.Scanner dumbscanner)
  {
    dumb_ = new TokenStack(dumbscanner);
  }

  public Symbol next_token()
    throws Exception
  {
    Symbol result = dumb_.pop();
    if (result.sym == Sym.DECORWORD &amp;&amp; inBoxName) {
      //don't look ahead if the previous token was a box token
      inBoxName = false;
    }
    else if (result.sym == Sym.DECORWORD &amp;&amp; !inBoxName) 
    {
<add:circus>
      // if within a basic process and within an action definition
      // then lookahead for potential prefix communication.          
      if (inCircusBasicProcess &amp;&amp; inActionDef &amp;&amp; isChannelName())
      {
        System.out.println("\tIn DECORWORD of a basic process after action def");        
        // unfortunately, in the case of processes defined within the same
        // circus environment, there is no effecient way of discerning when
        // the action definition has finished. On the other hand, if using
        // circusaction environments, we can know when they finish by looking
        // for a END symbol.

        //result.sym = Sym.CIRCUSNAME;        
      }
      else
</add:circus>
      //if this is a colon decl, convert the DECORWORD to a DECLWORD
      if (isColonDecl()) 
      {
        result.sym = Sym.DECLWORD;
      }
<add:oz>
      else
      {  
        LinkedList &lt; Symbol &gt; tokens = new LinkedList &lt; Symbol &gt;();
        Symbol currsym = dumb_.pop();
        tokens.addLast(currsym);
        //skip any newlines
        while (currsym.sym == Sym.NL) {
          currsym = dumb_.pop();
          tokens.addLast(currsym);
        }
        //skip any formal parameters
        if (currsym.sym == Sym.LSQUARE) {
          while (currsym.sym != Sym.RSQUARE) {
            currsym = dumb_.pop();
            tokens.addLast(currsym);
          }
          currsym = dumb_.pop();
          tokens.addLast(currsym);
        }
        //if the next token is a DEFFREE or DEFEQUAL, return a DEFNAME
        if (currsym.sym == Sym.DEFFREE || currsym.sym == Sym.DEFEQUAL) {
          result.sym = Sym.DEFNAME;
        }
        //if the next token is a SDEF, return an OPNAME
        else if (currsym.sym == Sym.SDEF) {
          result.sym = Sym.OPNAME;
        }
        pushList(tokens, false);
      }
</add:oz>
    }
    else if (result.sym == Sym.SCH ||
<add:oz>
             result.sym == Sym.CLASS ||
             result.sym == Sym.OPSCH ||
</add:oz>
             result.sym == Sym.GENSCH) 
    {
        inBoxName = true;
    } 
<add:circus>
    // if starting a basic process, mark it true and not def. action yet
    else if (result.sym == Sym.CIRCBEGIN)
    {
       inCircusBasicProcess = true;
       inActionDef = false;
       System.out.println("\tSwitching on basic process flag and off the action def flag");
    }
    // if finishing a basic process, mark it fakse and not def. action yet
    else if (result.sym == Sym.CIRCEND)
    {
       inCircusBasicProcess = false;
       inActionDef = false;
       System.out.println("\tSwitching off basic process and action def flag");
    }
    // if defining an action and within a basic process, mark def. action true
    // CIRCDEF might appear outside basic process - ex. other processes definitions.
    else if (result.sym == Sym.CIRCDEF &amp;&amp; inCircusBasicProcess)
    {       
       inActionDef = true;
       System.out.println("\tSwitching on action def flag");
    }
    // if terminating some definition within a basic process, then 
    // mark def. action false. This only happens when we have circusaction 
    // latex environments, as within a single circus latex environment, paragraphs
    // are terminated/separated by new lines!
    else if (result.sym == Sym.END &amp;&amp; inCircusBasicProcess)
    {
       inActionDef = false;
       System.out.println("\tSwitching off action def flag");
    }
</add:circus>    
    return result;
  }

  private boolean isColonDecl()
    throws Exception
  {
    boolean isColonDecl = false;
    boolean doLookahead = true;
    LinkedList &lt; Symbol &gt; tokens = new LinkedList &lt; Symbol &gt;();
    Symbol currsym;

    do {
      currsym = dumb_.pop();
      tokens.addLast(currsym);
    }
    while (currsym.sym == Sym.NL);
 
    while (currsym.sym == Sym.COMMA &amp;&amp; doLookahead) {
      currsym = dumb_.pop();
      tokens.addLast(currsym);
      doLookahead = false;
      while(currsym.sym == Sym.DECORWORD || currsym.sym == Sym.ARG ||
            currsym.sym == Sym.LISTARG || currsym.sym == Sym.DECLWORD ||
	    currsym.sym == Sym.NL) {
        currsym = dumb_.pop();
        tokens.addLast(currsym);
        doLookahead = true;
      }
    }
    if (currsym.sym == Sym.COLON &amp;&amp; doLookahead) {
      isColonDecl = true;
    }
    pushList(tokens, isColonDecl);
    return isColonDecl;
  }
  
<add:circus>
  private boolean isChannelName() 
    throws Exception 
  {
    boolean result = false;
    boolean doLookahead = true;
    
    LinkedList &lt; Symbol &gt; tokens = new LinkedList &lt; Symbol &gt;();
    Symbol currsym = dumb_.pop();
    tokens.addLast(currsym);
    
    //skip any newlines
    while (currsym.sym == Sym.NL) {
      currsym = dumb_.pop();
      tokens.addLast(currsym);
    }
    
    //skip any actual parameters on generic channels
    if (currsym.sym == Sym.LSQUARE) {
      System.out.println("\tWithin isChannelName for generic channel");
      while (currsym.sym != Sym.RSQUARE) {
        currsym = dumb_.pop();
        tokens.addLast(currsym);
      }
      currsym = dumb_.pop();
      tokens.addLast(currsym);
    }
    /*
    CIRCUS_SYMBOL_MAP_STOP_LOOKAHEAD.keySet().contains(currsym.sym)
    get_sym(currsym)
    CIRCUS_TOKENS_STOP_LOOKAHEAD.contains(get_sym(currsym
    
    while (currsym.sym == Sym.COMMA &amp;&amp; doLookahead) {
      currsym = dumb_.pop();
      tokens.addLast(currsym);
      doLookahead = false;
      while(currsym.sym == Sym.DECORWORD || currsym.sym == Sym.ARG ||
            currsym.sym == Sym.LISTARG || currsym.sym == Sym.DECLWORD ||
	    currsym.sym == Sym.NL) {
        currsym = dumb_.pop();
        tokens.addLast(currsym);
        doLookahead = true;
      }
    }
    */
    /*
    //if the next token is a DEFFREE or DEFEQUAL, return a DEFNAME
    if (currsym.sym == Sym.DEFFREE || currsym.sym == Sym.DEFEQUAL) {
      result.sym = Sym.DEFNAME;
    }
    //if the next token is a SDEF, return an OPNAME
    else if (currsym.sym == Sym.SDEF) {
      result.sym = Sym.OPNAME;
    }
    */
    
    
    
    /*
    // if we did lookahead and found a PREFIXTHEN, mark this as channelname
    if (currsym.sym == Sym.PREFIXTHEN &amp;&amp; doLookahead) {
      result = true;
    }
    */
    
    // push the tokens back, where tokens remain DECORWORDs 
    pushList(tokens, false);
    
    // return the result to the next_token() call
    return result;
  } 
</add:circus>  

  private void pushList(List &lt; Symbol &gt; tokens, boolean isColonDecl)
  {
    for (int i = tokens.size() - 1; i >= 0; i--) {
      Symbol symbol = tokens.get(i);
      if (symbol.sym == Sym.DECORWORD  &amp;&amp; isColonDecl) {
        symbol.sym = Sym.DECLWORD;
      }
      else {
      }
      dumb_.push(symbol);
    }
  }
  
  private Map&lt; Object, String &gt; symbolMap_ = DebugUtils.getFieldMap(Sym.class);  
  
  /**
   * Returns the String representation for the given Symbol sym field.
   * That is, the declared name for that symbol. This declared name can
   * then be used to lookup the Token interface enum implementations for
   * the various extensions. 
   */
  private String get_sym(Symbol symbol)
  { 
    String sym = symbolMap_.get(new Integer(symbol.sym));
    return sym;
  }

  private String get_info(Symbol symbol)
  {
    String result = get_sym(symbol);    
    if (symbol.value != null) {
      result += "(" + symbol.value + ")";
    }
    return result;
  }
}
</scanner>
