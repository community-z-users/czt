<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright (C) 2003, 2004, 2005, 2006, 2007 Petra Malik
     This file is part of the CZT project.

     The CZT project contains free software;
     you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with CZT; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<parser xmlns:add="http://czt.sourceforge.net/templates/additional">
package <package/>;

import net.sourceforge.czt.java_cup.runtime.*;
import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import net.sourceforge.czt.base.ast.Term;
import net.sourceforge.czt.util.CztException;
import net.sourceforge.czt.util.CztLogger;
import net.sourceforge.czt.z.ast.*;
import net.sourceforge.czt.z.util.ZChar;
import net.sourceforge.czt.z.util.ZString;
import net.sourceforge.czt.z.util.ZUtils;
import net.sourceforge.czt.parser.util.*;
import net.sourceforge.czt.print.util.PrintException;
import net.sourceforge.czt.print.z.DefsWord;
import net.sourceforge.czt.print.z.WhereWord;
import net.sourceforge.czt.session.*;
<add:oz>
import net.sourceforge.czt.oz.util.OzString;
</add:oz>
<add:circus>
import net.sourceforge.czt.circus.util.CircusString;
</add:circus>

<add:oldz>
/**
 * Translator into old (Z-EVES) latex markup.
 *
 * <ul>
 *   <li>Arithmos is translated into \num (this is not always the
 *       right thing to do but the best approximation I could think of)</li>
 *   <li>The Z-EVES style of defining Z sections is used</li>
 *   <li>For global schema definitions, the latex command \defs
 *       is used instead of "=="</li>
 * </ul>
 */
</add:oldz>
action code
{:
  private Map sections_ = new HashMap();
  private Map unicode2latexMap_ = null;

  /**
   * An iterator over markup directives to be printed.
   */
  protected Iterator markup_ = null;

  private Map addStandardMapping(Map map)
  {
    map.put(ZString.SPOT, new LatexCommand("@", ZString.SPOT, true, true));
    map.put("+", new LatexCommand("+", "+", true, true));
    map.put(ZString.MINUS, new LatexCommand("-", ZString.MINUS, true, true));
    map.put("*", new LatexCommand("*", "*", true, true));
    map.put("|", new LatexCommand("|", "|", true, true));
    map.put(";", new LatexCommand(";", ";", false, true));
    map.put(",", new LatexCommand(",", ",", false, true));
    map.put(ZString.SE, new LatexCommand("_{", ZString.SE, false, false));
    map.put(ZString.NW, new LatexCommand("}", ZString.NW, false, false));
    map.put(ZString.NE, new LatexCommand("^{", ZString.NE, false, false));
    map.put(ZString.SW, new LatexCommand("}", ZString.SW, false, false));
    map.put(ZString.LL, new LatexCommand("\\_", ZString.LL, false, false));
<add:oldz>
    map.put(ZString.NEG, new LatexCommand("-", ZString.NEG, false, false));
</add:oldz>
<add:circus>
    /*  Add here only additional elements that have not been declared in toolkits
     *  or in other Keyword/Token related files.
     */
</add:circus>
    return map;
  }

  private String begin(String string)
  {
    return "\\begin{" + string + "}";
  }

  private String end(String string)
  {
    return "\n\\end{" + string + "}";
  }

  private LatexCommand concate(LatexCommand c1, LatexCommand c2)
  {
    if (c1 == null || c1.getUnicode().length() &lt;= 0) return c2;
    if (c2 == null || c2.getUnicode().length() &lt;= 0) return c1;
    String latex = c1.getName();
    if (! c1.addRightSpace() &amp;&amp; ! c2.addLeftSpace()) {
      final ZChar[] unicode1 = ZChar.toZChars(c1.getUnicode());
      final ZChar[] unicode2 = ZChar.toZChars(c2.getUnicode());
      final ZChar lastChar = unicode1[unicode1.length - 1];
      final ZChar firstChar = unicode2[0];
      final boolean lastIsAlphaOrStroke =
        ZChar.isAlpha(lastChar) || ZChar.isStroke(lastChar);
      final boolean firstIsAlphaOrStrokeOrWordglue =
        ZChar.isAlpha(firstChar) || ZChar.isStroke(firstChar) ||
        ZChar.isWordGlue(firstChar);
      final boolean case1 =
        lastIsAlphaOrStroke &amp;&amp; ! firstIsAlphaOrStrokeOrWordglue;
      final boolean lastIsAlphaOrStrokeOrWordglue =
        ZChar.isAlpha(lastChar) || ZChar.isStroke(lastChar) ||
        ZChar.isWordGlue(lastChar);
      final boolean firstIsAlphaOrStroke =
        ZChar.isAlpha(firstChar) || ZChar.isStroke(firstChar);
      final boolean case2 =
        ! lastIsAlphaOrStrokeOrWordglue &amp;&amp; firstIsAlphaOrStroke;
      if (case1 || case2) {
        latex += " ";
      }
      else {
        latex += "~";
      }
    } else {
      latex += " ";
    }
    latex += c2.getName();
    String unicode = c1.getUnicode() + " " + c2.getUnicode();
    return
      new LatexCommand(latex, unicode, c1.addLeftSpace(), c2.addRightSpace());
  }

  private LatexCommand toLatex(String s, int line, int column)
    throws PrintException
  {
    assert unicode2latexMap_ != null;
    return uniwordToLatex(s, unicode2latexMap_, line, column);
  }

  /**
   * @czt.todo Write this method properly!
   */
  private String toLatexInSectHead(String s)
  {
    return s.replaceAll("_", "\\\\_");
  }

  private LatexCommand uniwordToLatex(String word, Map latexCommands,
                                      int line, int column)
    throws PrintException
  {
    LatexCommand command = null;
    if (markup_ == null) {
      Object o = latexCommands.get(word);
      if (o instanceof MarkupDirective) {
        MarkupDirective directive = (MarkupDirective) o;
        command = new LatexCommand(directive.getCommand(),
                                   directive.getUnicode(),
                                   directive.addLeftSpace(),
                                   directive.addRightSpace());
      }
      else {
        command = (LatexCommand) o;
      }
      if (command != null) {
        return command;
      }
    }
    StringBuffer latex = new StringBuffer();
    boolean addLeftSpace = false;
    boolean addRightSpace = false;
    ZChar[] zchars = ZChar.toZChars(word);
    int charcount = 0;
    for (int i = 0; i &lt; zchars.length; i++) {
      ZChar zchar = zchars[i];
      Object o = latexCommands.get(zchar.toString());
      if (o instanceof MarkupDirective) {
        MarkupDirective directive = (MarkupDirective) o;
        command = new LatexCommand(directive.getCommand(),
                                   directive.getUnicode(),
                                   directive.addLeftSpace(),
                                   directive.addRightSpace());
      }
      else {
        command = (LatexCommand) o;
      }
      if (command != null) {
        if ( (command.addLeftSpace() &amp;&amp; i &gt; 0) ||
             (command.addRightSpace() &amp;&amp; i + 1 &lt; zchars.length) ) {
          latex.append("{" + command.getName() + "}");
        }
        else {
          if (command.getName().startsWith("\\")) {
            latex.append(command.getName() + " ");
          }
          else {
            latex.append(command.getName());
          }
        }
        addRightSpace = command.addRightSpace();
      }
      else if (zchar.isAsciiChar()) { // ASCII?
        latex.append(zchar.toString());
      }
      else if (ZChar.PRIME.equals(zchar)) {
        latex.append("'");
      }
      else {
        final int hexBase = 16;
        String hex = Integer.toString(zchar.codePoint(), hexBase);
        String message = "Error while transforming " + word +
          ": Unexpected character " + zchar.toString() +
          " (\\u" + hex + ") in line " + line + " column " +
          charcount + column;
        throw new PrintException(message);
      }
      charcount = charcount + zchar.charCount();
    }
    return new LatexCommand(latex.toString(), word,
                            addLeftSpace, addRightSpace);
  }

  /**
   * Create a list containing one element.
   */
  protected List list(Object o)
  {
    List result = new ArrayList();
    result.add(o);
    return result;
  }

  private void addParentMarkups(ZSect zsect, LatexMarkupFunction table)
  {
    for (Parent parent : zsect.getParent()) {
      String parentName = parent.getWord();
      LatexMarkupFunction parentMarkup = null;
      try {
        parentMarkup = (LatexMarkupFunction)
          parser.sectInfo_.get(new Key(parentName, LatexMarkupFunction.class));
      }
      catch (CommandException exception) {
        String message = "Cannot get latex markup for parent section " +
          parentName + " caused by " + exception;
        CztLogger.getLogger(<class/>.class).warning(message);
      }
      if (parentMarkup == null) {
        ZSect parentHeader = (ZSect) sections_.get(parentName);
        if (parentHeader != null) addParentMarkups(parentHeader, table);
      }
      else {
        try {
          table.add(parentMarkup);
        }
        catch (MarkupException e) {
          CztLogger.getLogger(<class/>.class).warning(e.getMessage());
        }
      }
    }
  }

  protected void setupMarkupTable(ZSect zsect)
  {
    final String sectName = zsect.getName();
    LatexMarkupFunction table = null;
    try {
      table = (LatexMarkupFunction)
        parser.sectInfo_.get(new Key(sectName, LatexMarkupFunction.class));
    }
    catch (CommandException exception) {
      String message = "Cannot get latex markup for section " + sectName +
        " caused by " + exception;
      CztLogger.getLogger(<class/>.class).warning(message);
    }
    if (table != null) {
      LatexMarkupPara para =
        table.toAst(new net.sourceforge.czt.z.util.Factory());
      markup_ = para.getDirective().iterator();
    }
    else {
      table = new LatexMarkupFunction(zsect.getName());
      addParentMarkups(zsect, table);
    }
    assert table != null;
    setupMarkupTable(table);
  }

  protected void setupMarkupTable(LatexMarkupFunction table)
  {
    unicode2latexMap_ = new HashMap();
    if (table != null) {
      for (Iterator iter = table.iterator(); iter.hasNext();) {
        MarkupDirective directive = (MarkupDirective) iter.next();
        unicode2latexMap_.put(directive.getUnicode(), directive);
      }
    }
    addStandardMapping(unicode2latexMap_);
<add:oldz>
    LatexCommand arithmos =
       new LatexCommand("\\num", ZString.ARITHMOS, false, false);
    unicode2latexMap_.put(ZString.ARITHMOS, arithmos);
</add:oldz>
  }

:}

parser code {:
  public static final Map symbolMap_ = DebugUtils.getFieldMap(Sym.class);

  private Writer writer_ = new OutputStreamWriter(System.out);
  protected SectionInfo sectInfo_ = new SectionManager();
  protected String sectionName_;

  /**
   * Used to scan the unicode provided within markup directives.
   * Whenever a latex markup directives is to printed, a new
   * markup scanner is created that scans the unicode of that
   * markup.  If it is not &lt;code&gt;null&lt;/code&gt; we are just
   * printing the definition part of a latex markup directive.
   */
  protected ContextFreeScanner markupScanner_ = null;

  public SectionInfo getSectionInfo()
  {
    return sectInfo_;
  }

  public void setSectionInfo(SectionInfo sectInfo)
  {
    sectInfo_ = sectInfo;
  }

  public void setSectionInfo(SectionInfo sectInfo, String sectionName)
  {
    sectInfo_ = sectInfo;
    sectionName_ = sectionName;
  }

  public Writer getWriter()
  {
    return writer_;
  }

  public void setWriter(Writer writer)
  {
    writer_ = writer;
  }

  protected void write(String s)
  {
    try {
      writer_.write(s);
    }
    catch(IOException e) {
      System.err.println("Cannot write");
    }
  }

  private String printType(DirectiveType type)
  {
    if (DirectiveType.NONE.equals(type)) return "";
    return type.toString().toLowerCase();
  }

  /**
   * Returns the next token.
   */
  protected Symbol local_next_token()
    throws Exception
  {
    Symbol result = local_next_token_help();
    if (result.sym == Sym.SECTHEAD) {
      action_obj.setupMarkupTable((ZSect) result.value);
    }
    else if (result.sym == Sym.TOKENSEQ ||
             result.sym == Sym.PARA_START) {
      LatexMarkupFunction table = (LatexMarkupFunction)
        sectInfo_.get(new Key(sectionName_, LatexMarkupFunction.class));
      action_obj.setupMarkupTable(table);
    }
    String logMessage =
        "Next token is (" + symbolMap_.get(result.sym) + ", " + 
            (result.sym != Sym.TEXT ? String.valueOf(result.value) + ", " + 
                (result.value != null ? result.value.getClass().getName() : "null") : "...shhh...") + ").";    
    CztLogger.getLogger(<class/>.class).fine(logMessage);
    return result;
  }

  private Symbol local_next_token_help()
    throws Exception
  {
    if (markupScanner_ != null) {
      // if markupScanner_ is not null, we are just printing the definition
      // part of a latex markup directive.  Therefore, markup_ must be non
      // null (since we can only got the directive from there).
      assert action_obj.markup_ != null;
      Symbol result = markupScanner_.next_token();
      if (result == null || result.sym == Sym.EOF) {
        markupScanner_ = null;
        return new Symbol(Sym.END_MARKUP);
      }
      return result;
    }
    if (action_obj.markup_ != null &amp;&amp; action_obj.markup_.hasNext()) {
      Directive directive = (Directive) action_obj.markup_.next();
      final String unicode = directive.getUnicode();
      final char[] charArray = unicode.toCharArray();
      if (unicode.length() == 1) {
        StringBuffer result = new StringBuffer();
        result.append("\n");
        char c = unicode.charAt(0);
        result.append("%%Z" + printType(directive.getType())+ "char ");
        result.append(directive.getCommand() + " ");
        result.append("U+");
        String hex = Integer.toHexString(c).toUpperCase();
        for (int i = 0; i &lt; 4 - hex.length(); i++) {
          result.append("0");
        }
        result.append(hex);
        result.append("\n");
        return new Symbol(Sym.CHAR_MARKUP, result.toString());
      }
      else if (charArray.length == 2 &amp;&amp;
               Character.isSurrogatePair(charArray[0], charArray[1])) {
        StringBuffer result = new StringBuffer();
        result.append("\n");
        int codePoint = Character.codePointAt(charArray, 0);
        result.append("%%Z" + printType(directive.getType())+ "char ");
        result.append(directive.getCommand() + " ");
        result.append("U-");
        String hex = Integer.toHexString(codePoint).toUpperCase();
        for (int i = 0; i &lt; 8 - hex.length(); i++) {
          result.append("0");
        }
        result.append(hex);
        result.append("\n");
        return new Symbol(Sym.CHAR_MARKUP, result.toString());
      }
      else {
        markupScanner_ = new ContextFreeScanner(new StringReader(unicode));
        markupScanner_.yybegin(ContextFreeScanner.Z);
        DirectiveType type = directive.getType();
        if (DirectiveType.NONE.equals(type)) {
          return new Symbol(Sym.WORD_MARKUP, directive.getCommand());
        }
        else if (DirectiveType.IN.equals(type)) {
          return new Symbol(Sym.INWORD_MARKUP, directive.getCommand());
        }
        else if (DirectiveType.POST.equals(type)) {
          return new Symbol(Sym.POSTWORD_MARKUP, directive.getCommand());
        }
        else if (DirectiveType.PRE.equals(type)) {
          return new Symbol(Sym.PREWORD_MARKUP, directive.getCommand());
        }
        else {
          throw new CztException("Unexpected directive type " + type);
        }
      }
    }
    else {
      action_obj.markup_ = null;
      Symbol result = getScanner().next_token();
      return result;
    }
  }

  public void report_error(String message, Object info) {
    StringBuffer m = new StringBuffer("Error");
    if (info instanceof net.sourceforge.czt.java_cup.runtime.Symbol) {
      net.sourceforge.czt.java_cup.runtime.Symbol s =
        ((net.sourceforge.czt.java_cup.runtime.Symbol) info);
      if (s.left &gt;= 0) {                
        m.append(" in line "+(s.left+1));   
        if (s.right &gt;= 0) m.append(", column "+(s.right + 1));
      }
      String value = String.valueOf(s.value);
      if (s.value instanceof Term &amp;&amp; ((Term)s.value).getAnn(LocAnn.class) != null) {  
        value += " at " + ((LocAnn)(((Term)s.value).getAnn(LocAnn.class))).toString();
      }
      m.append(", Token(" + symbolMap_.get(s.sym) + "," + s.value + ")");
    }
    m.append(": " + message);
    System.err.println(m);
  }

  public void report_fatal_error(String message, Object info)
  {
    report_error(message, info);
    done_parsing();
    throw new UnsupportedOperationException("Parse error: " +
      String.valueOf(message) + " => " + String.valueOf(info));
  }

  public void unrecovered_syntax_error(Symbol token)
  {
    report_fatal_error("Syntax error at token " + symbolMap_.get(token.sym),
                       token);
  }
:};

scan with {: return local_next_token(); :};

/* ------------Declaration of Terminals and Non Terminals Section----------- */
   
/* Terminals */
terminal           LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACE, RBRACE,
                   LBIND, RBIND, LDATA, RDATA, ZED, AX, SCH, GENAX, GENSCH,
                   END, NL,
                   SECTION, PARENTS, // used by the SectHeadScanner
                   WHERE, // the latex \where command
                   INSTROKE, OUTSTROKE, NEXTSTROKE,
 <add:oz>
                   CLASS, GENCLASS, OPSCH, INIT, STATE, SDEF,
 </add:oz>
<add:circus>
                   CIRCUS, CIRCUSACTION, LCIRCCHANSET, RCIRCCHANSET, CIRCLINST, CIRCRINST,
                   LPAR, RPAR, LINTER, RINTER, LCIRCGUARD, RCIRCGUARD,
                   LSCHEXPRACT, RSCHEXPRACT, LCIRCRENAME, RCIRCRENAME, 
                   
                   //CIRCREFINES, CIRCDEF, CIRCCHAN, CIRCCHANFROM, CIRCCHANSET,
                   //CIRCPROC, CIRCDO, CIRCVAR, CIRCVAL, CIRCRES, CIRCVRES, CIRCNAMESET,
                   //CIRCASSERTREF, CIRCBEGIN, CIRCSTATE, CIRCREPINTERLEAVE, CIRCEND,
</add:circus>
<add:zpatt>
                   JOKER, RULE, RULELINE, PROVISO,
</add:zpatt>
<add:circuspatt>
                   CIRCUSJOKER, CIRCUSACTIONLAW, CIRCUSPROCESSLAW,
</add:circuspatt>
                   END_MARKUP,
                   TOKENSEQ, PARA_START, PARA_END;
terminal ZSect     SECTHEAD;
terminal LocInt    NUMERAL, NUMSTROKE;
terminal LocString TEXT;
terminal String    CHAR_MARKUP, WORD_MARKUP, INWORD_MARKUP, PREWORD_MARKUP,
                   POSTWORD_MARKUP;
terminal Decorword DECORWORD;

/* Non terminals */
non terminal              input, narrWordList, sectionList, paragraphList;
non terminal ZSect        sectionHeader;
non terminal String       markup, para, zpara, wordmarkup;
<add:oz>
non terminal LatexCommand innerPara;
</add:oz>
non terminal LatexCommand token, tokenSeq, paren, special, decorword;

   input ::= narrWordList:narr sectionList:s
             {: parser.getWriter().flush(); :}
             |
             TOKENSEQ tokenSeq:s TOKENSEQ
             {: 
                if (s != null) parser.write(s.getName());
                parser.getWriter().flush();
             :}
             |
             PARA_START zpara:p PARA_END
             {:
                parser.getWriter().flush();
             :}
             ;

   narrWordList ::=
             TEXT:t narrWordList
             {: parser.write(t.getString()); :}
             |
             // empty
             ;

   sectionList ::= 
             sectionList sectionHeader:zsect paragraphList
<add:oldz>
             {:
                if (! ZUtils.isAnonymous(zsect)) {
                  parser.write(end("zsection"));
                }
             :}
</add:oldz>
             |
             // empty
             ;

   sectionHeader ::= SECTHEAD:zsect
             {:
                RESULT = zsect;
                final String name = zsect.getName();
                sections_.put(name, zsect);
                if (! ZUtils.isAnonymous(zsect)) {
                  parser.write(begin("zsection"));
                  final String latexName = toLatexInSectHead(zsect.getName());
<add:z>
                  parser.write("\\SECTION " + latexName + " \\parents ");
</add:z>
<add:oldz>
                  parser.write("{" + latexName + "}{");
</add:oldz>
                  for (Iterator iter = zsect.getParent().iterator();
                       iter.hasNext();) {
                    Parent parent = (Parent) iter.next();
                    String parentLatexName =
                      toLatexInSectHead(parent.getWord());
                    parser.write(parentLatexName);
                    if (iter.hasNext()) parser.write(", ");
                  }
<add:oldz>
                  parser.write("}");
</add:oldz>
<add:z>
                  parser.write(end("zsection"));
</add:z>
                }
             :}
             ;

   paragraphList ::= 
             paragraphList para
             |
             // empty
             ;

   para ::=  markup
             |
             TEXT:t
             {: parser.write(t.getString()); :}
             |
             zpara:z
             {: RESULT = z; :}
             ;

   zpara ::= ZED tokenSeq:s END
             {:
                String result = begin("zed");
                if (s != null) { result += s.getName(); }
                result += end("zed");
                parser.write(result);
             :}
             |
             AX tokenSeq:s END
             {:
                String result = begin("axdef");
                if (s != null) result += s.getName();
                result += end("axdef");
                parser.write(result);
             :}
             |
             SCH decorword:w tokenSeq:s END
             {:
                String result = begin("schema") + "{" + w.getName() + "}";
                if (s != null) result += s.getName();
                result += end("schema");
                parser.write(result);
             :}
             |
             GENAX tokenSeq:s END
             {:
                String result = begin("gendef");
                if (s != null) result += s.getName();
                result += end("gendef");
                parser.write(result);
             :}
             |
             GENSCH decorword:w tokenSeq:s END
             {:
                String result = begin("schema") + "{" + w.getName() + "}";
                if (s != null) result += s.getName();
                result += end("schema");
                parser.write(result);
             :}
<add:oz>
             |
             CLASS decorword:w tokenSeq:s END
             {:
                String result = begin("class") + "{" + w.getName() + "}";
                if (s != null) result += s.getName();
                result += end("class");
                parser.write(result);
             :}
             |
             GENCLASS decorword:w tokenSeq:s END
             {:
                String result = begin("class") + "{" + w.getName() + "}";
                if (s != null) result += s.getName();
                result += end("class");
                parser.write(result);
             :}
</add:oz>
<add:zpatt>
             |
             JOKER decorword:w tokenSeq:s END
             {:                
                String result = begin("zedjoker") + "{" + w.getName() + "}";
                if (s != null) result += s.getName();
                result += end("zedjoker");
                parser.write(result);
             :}
             |
             RULE decorword:w tokenSeq:s END
             {:
                String result = begin("rule") + "{" + w.getName() + "}";
                if (s != null) result += s.getName();
                result += end("rule");
                parser.write(result);
             :}
</add:zpatt>
<add:circuspatt>
            |
            CIRCUSJOKER decorword:w tokenSeq:s END
            {:                
               String result = begin("circusjoker") + "{" + w.getName() + "}";
               if (s != null) result += s.getName();
               result += end("circusjoker");
               parser.write(result);
            :}
            |
            CIRCUSACTIONLAW decorword:w tokenSeq:s END
            {:
               String result = begin("circusactionlaw") + "{" + w.getName() + "}";
               if (s != null) result += s.getName();
               result += end("rule");
               parser.write(result);
            :}
            |
            CIRCUSPROCESSLAW decorword:w tokenSeq:s END
            {:
               String result = begin("circusprocesslaw") + "{" + w.getName() + "}";
               if (s != null) result += s.getName();
               result += end("rule");
               parser.write(result);
            :}
</add:circuspatt>
<add:circus>
            // TODO: Add here, like for OZ, the appropriate printing productions
            |
            CIRCUS tokenSeq:s END
            {:
                String result = begin("circus");
                if (s != null) { result += s.getName(); }
                result += end("circus");
                parser.write(result);
            :}
            |
            CIRCUSACTION tokenSeq:s END
            {:
                String result = begin("circusaction");
                if (s != null) result += s.getName();
                result += end("circusaction");
                parser.write(result);
            :}
</add:circus>
             ;

  markup ::=
             CHAR_MARKUP:zchar
             {: parser.write(zchar); :}
             |
             wordmarkup:wm tokenSeq:s END_MARKUP
             {:
                StringBuffer result = new StringBuffer();
                result.append("\n");
                result.append(wm);
                result.append(" ");
                if (s != null) { result.append(s.getName()); }
                result.append("\n");
                parser.write(result.toString());
             :}
             ;

   wordmarkup ::=
             WORD_MARKUP:word
             {:
                RESULT = "%%Zword " + word;
             :}
             |
             INWORD_MARKUP:inword
             {:
                RESULT = "%%Zinword " + inword;
             :}
             |
             PREWORD_MARKUP:preword
             {:
                RESULT = "%%Zpreword " + preword;
             :}
             |
             POSTWORD_MARKUP:postword
             {:
                RESULT = "%%Zpostword " + postword;
             :}
             ;

   tokenSeq ::= tokenSeq:w1 token:w2
             {: RESULT = concate(w1, w2); :}
             |
             tokenSeq:w1 special:w2
             {: RESULT = concate(w1, w2); :}
             |
             {: RESULT = null; :}
<add:oz>
             |
             tokenSeq:w1 innerPara:ip
             {: RESULT = concate(w1, ip); :}
</add:oz>
             ;

   token ::= decorword:s
             {: RESULT = s; :}
             |
             INSTROKE
             {:
                RESULT =
                  new LatexCommand("?", ZString.INSTROKE, false, false);
             :}
             |
             OUTSTROKE
             {:
                RESULT =
                  new LatexCommand("!", ZString.OUTSTROKE, false, false);
             :}
             |
             NEXTSTROKE
             {:
                RESULT =
                  new LatexCommand("'", ZString.PRIME, false, false);
             :}
             |
             NUMSTROKE:i
             {:
                final String numString = i.getValue().toString();
                String latex = "^" + numString;
                String unicode = ZString.SE + numString + ZString.NW;
                RESULT =
                  new LatexCommand(latex, unicode, false, false);
             :}
             |
             NUMERAL:i
             {:
                final String numString = i.getValue().toString();
                RESULT =
                  new LatexCommand(numString, numString, false, false);
             :}
             |
             paren:s
             {: RESULT = s; :}
             |
             WHERE:t
             {:
                RESULT =
                  new LatexCommand("\n\\where\n", ZString.VL, true, true);
             :}
<add:oz>
             |
             SDEF
             {:
                RESULT =
                  new LatexCommand("\\sdef", OzString.SDEF, true, true);
             :}             
</add:oz>
<add:zpatt>
             |
             RULELINE
             {:
                RESULT = new LatexCommand("\n\\derives\n", "\u2500", true, true);
             :}
             |
             PROVISO
             {:
                RESULT = new LatexCommand("\\proviso", "\u25B8", true, true);
             :}
</add:zpatt>
             ;

   decorword ::= DECORWORD:s
             {:
                assert s != null;
                if (s instanceof WhereWord) {
                  RESULT =
                    new LatexCommand("\n\\where\n", ZString.VL, true, true);
                }
<add:oldz>
                else if (s instanceof DefsWord) {
                  RESULT =
                    new LatexCommand("\\defs", ZString.DEFEQUAL, true, true);
                }
</add:oldz>
                else {
                  RESULT = toLatex(s.getName(), sleft, sright);
                }
             :}
             ;

   paren ::= LPAREN
             {:
                RESULT =
                  new LatexCommand("(", ZString.LPAREN, true, true);
             :}
             |
             RPAREN
             {:
                RESULT =
                  new LatexCommand(")", ZString.RPAREN , true, true);
             :}
             |
             LSQUARE
             {:
                RESULT =
                  new LatexCommand("[", ZString.LSQUARE, true, true);
             :}
             |
             RSQUARE
             {:
                RESULT =
                  new LatexCommand("]", ZString.RSQUARE, true, true);
             :}
             |
             LBRACE
             {:
                RESULT =
                  new LatexCommand("\\{",  ZString.LBRACE, true, true);
             :}
             |
             RBRACE
             {:
                RESULT =
                  new LatexCommand("\\}", ZString.RBRACE, true, true);
             :}
             |
             LBIND
             {:
                RESULT =
                  new LatexCommand("\\lblot", ZString.LBIND, true, true);
             :}
             |
             RBIND
             {:
                RESULT =
                  new LatexCommand("\\rblot", ZString.RBIND, true, true);
             :}
             |
             LDATA
             {:
                RESULT =
                  new LatexCommand("\\ldata", ZString.LDATA, true, true);
             :}
             |
             RDATA
             {:
                RESULT =
                  new LatexCommand("\\rdata", ZString.RDATA, true, true);
             :}
<add:circus>
             |
             LCIRCCHANSET
             {:
                RESULT =
                  new LatexCommand("\\lchanset~", CircusString.LCIRCCHANSET, true, true);
             :}
             |
             RCIRCCHANSET
             {:
                RESULT =
                  new LatexCommand("~\\rchanset", CircusString.RCIRCCHANSET, true, true);
             :}
             |
             CIRCLINST
             {:
                RESULT =
                  new LatexCommand("\\circlinst~", CircusString.CIRCLINST, true, true);
             :}
             |
             CIRCRINST
             {:
                RESULT =
                  new LatexCommand("~\\circrinst", CircusString.CIRCRINST, true, true);
             :}
             |
             LCIRCGUARD
             {:
                RESULT =
                  new LatexCommand("\\lcircguard~", CircusString.LCIRCGUARD, true, true);
             :}
             |
             RCIRCGUARD
             {:
                RESULT =
                  new LatexCommand("~\\rcircguard", CircusString.RCIRCGUARD, true, true);
             :}
             |
             LSCHEXPRACT
             {:
                RESULT =
                  new LatexCommand("\\lschexpract~", CircusString.LSCHEXPRACT, true, true);
             :}
             |
             RSCHEXPRACT
             {:
                RESULT =
                  new LatexCommand("~\\rschexpract", CircusString.RSCHEXPRACT, true, true);
             :}
             |
             LCIRCRENAME
             {:
                RESULT =
                  new LatexCommand("\\lcircrename~", CircusString.LCIRCRENAME, true, true);
             :}
             |
             RCIRCRENAME
             {:
                RESULT =
                  new LatexCommand("~\\rcircrename", CircusString.RCIRCRENAME, true, true);
             :}
             |
             LPAR
             {:
                RESULT =
                  new LatexCommand("~\\lpar~", CircusString.LPAR, true, true);
             :}
             |
             RPAR
             {:
                RESULT =
                  new LatexCommand("~\\rpar~", CircusString.RPAR, true, true);
             :}
             |
             LINTER
             {:
                RESULT =
                  new LatexCommand("~\\linter~", CircusString.LINTER, true, true);
             :}
             |
             RINTER
             {:
                RESULT =
                  new LatexCommand("~\\rinter~", CircusString.RINTER, true, true);
             :}                             
</add:circus>
             ;
             
  special ::= NL
             {:
                RESULT =
                  new LatexCommand("\\\\\n", ZString.NL, true, true);
             :}
             ;

<add:oz>
  innerPara ::=
             AX tokenSeq:s END
             {:
                String latex = begin("axdef") + "\n";
                if (s != null) latex += s.getName();
                latex += end("axdef");
                String unicode = ZString.AX;
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = new LatexCommand(latex, unicode, false, false);
             :}
             |
             SCH decorword:w tokenSeq:s END
             {:
                String latex = begin("schema") + "{" + w.getName() + "}\n";
                if (s != null) latex += s.getName();
                latex += end("schema");
                String unicode = ZString.SCH + ZString.SPACE + w.getName();
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = new LatexCommand(latex, unicode, false, false);
             :}
             |
             GENAX tokenSeq:s END
             {:
                String latex = begin("gendef");
                if (s != null) latex += s.getName();
                latex += end("gendef");
                String unicode = ZString.GENAX;
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = new LatexCommand(latex, unicode, false, false);
             :}
             |
             GENSCH decorword:w tokenSeq:s END
             {:
                String latex = begin("schema") + "{" + w.getName() + "}";
                if (s != null) latex += s.getName();
                latex += end("schema");
                String unicode = ZString.SCHCHAR + ZString.GENCHAR + w.getName();
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = new LatexCommand(latex, unicode, false, false);
             :}
             |
             STATE tokenSeq:s END
             {:
                String latex = begin("state");
                if (s != null) latex += s.getName();
                latex += end("state");
                String unicode = ZString.SCH + ZString.ZEDCHAR;
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = new LatexCommand(latex, unicode, false, false);
             :}
             |
             INIT tokenSeq:s END
             {:
                String latex = begin("init");
                if (s != null) latex += s.getName();
                latex += end("init");
                String unicode = ZString.SCH + ZString.SPACE +
                                 OzString.INITWORD + ZString.SPACE;
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = new LatexCommand(latex, unicode, false, false);
             :}
             |
             OPSCH decorword:w tokenSeq:s END
             {:
                String latex = begin("op") + "{" + w.getName() + "}";
                if (s != null) latex += s.getName();
                latex += end("op");
                String unicode =
                  ZString.SCH + "op" + ZString.SPACE + w.getName();
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = new LatexCommand(latex, unicode, false, false);
             :}
             ;
</add:oz>
 
</parser>
