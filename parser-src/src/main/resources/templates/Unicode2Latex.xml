<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright (C) 2003, 2004, 2005, 2006, 2007 Petra Malik
     This file is part of the CZT project.

     The CZT project contains free software;
     you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with CZT; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<parser xmlns:add="http://czt.sourceforge.net/templates/additional">
package <package/>;

import net.sourceforge.czt.java_cup.runtime.*;
import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import net.sourceforge.czt.base.ast.Term;
import net.sourceforge.czt.util.CztException;
import net.sourceforge.czt.util.CztLogger;
import net.sourceforge.czt.z.ast.*;
import net.sourceforge.czt.z.util.ZChar;
import net.sourceforge.czt.z.util.ZString;
import net.sourceforge.czt.z.util.ZUtils;
import net.sourceforge.czt.parser.util.*;
import net.sourceforge.czt.print.util.PrintException;
import net.sourceforge.czt.print.util.PrintPropertiesKeys;
import net.sourceforge.czt.print.z.DefsWord;
import net.sourceforge.czt.print.z.WhereWord;
import net.sourceforge.czt.session.*;
<add:oz>
import net.sourceforge.czt.oz.util.OzString;
</add:oz>
<add:circus>
import net.sourceforge.czt.circus.util.CircusString;
</add:circus>
<add:zeves>
import net.sourceforge.czt.zeves.util.ZEvesString;
</add:zeves>


<add:oldz>
/**
 * Translator into old (Z-EVES) latex markup.
 *
 * &lt;ul&gt;
 *   &lt;li&gt;Arithmos is translated into \num (this is not always the
 *       right thing to do but the best approximation I could think of)&lt;/li&gt;
 *   &lt;li&gt;The Z-EVES style of defining Z sections is used&lt;/li&gt;
 *   &lt;li&gt;For global schema definitions, the latex command \defs
 *       is used instead of "=="&lt;/li&gt;
 * &lt;/ul&gt;
 */
</add:oldz>
action code
{:
  private Map&lt;String,ZSect&gt; sections_ =
    new HashMap&lt;String,ZSect&gt;();
  private Map&lt;String,Object&gt; unicode2latexMap_ = null;

  /**
   * An iterator over markup directives to be printed.
   */
  protected Iterator markup_ = null;

  private Map addStandardMapping(Map&lt;String,Object&gt; map)
  {
    map.put(ZString.SPOT, resultTT("@", ZString.SPOT));
    map.put("+", resultTT("+", "+"));
    map.put(ZString.MINUS, resultTT("-", ZString.MINUS));
    map.put("*", resultTT("*", "*"));
    map.put("|", resultTT("|", "|"));
    map.put(";", resultFT(";", ";"));
    map.put(",", resultFT(",", ","));
    map.put(ZString.SE, resultFF("_{", ZString.SE));
    map.put(ZString.NW, resultFF("}", ZString.NW));
    map.put(ZString.NE, resultFF("^{", ZString.NE));
    map.put(ZString.SW, resultFF("}", ZString.SW));
    map.put(ZString.LL, resultFF("\\_", ZString.LL));
    map.put("parents", resultFT("\\parents", "parents"));
<add:oldz>
    map.put(ZString.NEG, resultFF("-", ZString.NEG));
</add:oldz>
<add:circus>
    /*  Add here only additional elements that have not been declared
     *  in toolkits or in other keyword/token related files.
     */
</add:circus>
    return map;
  }

  private String begin(String string)
  {
    return begin(string, "");
  }

  private String begin(String string, String extra)
  {
    return "\\begin{" + string + "}" + extra ; // + "\n";
  }

  <add:zeves>
  private String begin(String string, LatexCommand ability)
  {
    return begin(string, "", ability);
  }

  private String begin(String string, String extra, LatexCommand ability)
  {
    StringBuilder result = new StringBuilder();
    result.append("\\begin");
    if (ability != null &amp;&amp; !ability.getName().isEmpty())
      result.append(ability.getName());
    result.append("{");
    result.append(string);
    result.append("}");
    result.append(extra);
    //result.append("\n");
    return result.toString();
  }
  </add:zeves>

  private String end(String string)
  {
    return "\n\\end{" + string + "}\n\n";
  }

  private LatexCommand concate(LatexCommand c1, LatexCommand c2)
  {
    if (c1 == null || c1.getUnicode().length() &lt;= 0) return c2;
    if (c2 == null || c2.getUnicode().length() &lt;= 0) return c1;
    String latex = c1.getName();
    if (! c1.addRightSpace() &amp;&amp; ! c2.addLeftSpace()) {
      final ZChar[] unicode1 = ZChar.toZChars(c1.getUnicode());
      final ZChar[] unicode2 = ZChar.toZChars(c2.getUnicode());
      final ZChar lastChar = unicode1[unicode1.length - 1];
      final ZChar firstChar = unicode2[0];
      final boolean lastIsAlphaOrStroke =
        ZChar.isAlpha(lastChar) || ZChar.isStroke(lastChar);
      final boolean firstIsAlphaOrStrokeOrWordglue =
        ZChar.isAlpha(firstChar) || ZChar.isStroke(firstChar) ||
        ZChar.isWordGlue(firstChar);
      final boolean case1 =
        lastIsAlphaOrStroke &amp;&amp; ! firstIsAlphaOrStrokeOrWordglue;
      final boolean lastIsAlphaOrStrokeOrWordglue =
        ZChar.isAlpha(lastChar) || ZChar.isStroke(lastChar) ||
        ZChar.isWordGlue(lastChar);
      final boolean firstIsAlphaOrStroke =
        ZChar.isAlpha(firstChar) || ZChar.isStroke(firstChar);
      final boolean case2 =
        ! lastIsAlphaOrStrokeOrWordglue &amp;&amp; firstIsAlphaOrStroke;
      if (case1 || case2) {
        latex += " ";
      }
      else {
        latex += "~";
      }
    } else {
      latex += " ";
    }
    latex += c2.getName();
    String unicode = c1.getUnicode() + " " + c2.getUnicode();
    return
      new LatexCommand(latex, unicode, c1.addLeftSpace(), c2.addRightSpace());
  }

  private LatexCommand toLatex(String s, int line, int column)
    throws PrintException
  {
    assert unicode2latexMap_ != null;
    return uniwordToLatex(s, unicode2latexMap_, line, column);
  }

  /**
   * @czt.todo Write this method properly!
   */
  private String toLatexInSectHead(String s)
  {
    return s.replaceAll("_", "\\\\_");
  }

  private LatexCommand uniwordToLatex(String word, Map latexCommands,
                                      int line, int column)
    throws PrintException
  {
    LatexCommand command = null;
    if (markup_ == null) {
      Object o = latexCommands.get(word);
      if (o instanceof MarkupDirective) {
        MarkupDirective directive = (MarkupDirective) o;
        <add:zeves>
        // although applies$to is an infix operator, because
        // "to" is a reserved word, and "$" not part an usual
        // name, we must insist on hard spaces around it.
        // that is, for applies$to in Unicode we *MUST* have ~applies\$to~ in LaTeX
        //
        // there is only one other place in the ZEves mathematical toolkit this happens, "the$integer"
        //
        boolean requiresHardSpace = word.equals("applies$to") || word.equals("the$integer");
        </add:zeves>
        command = new LatexCommand(directive.getCommand(),
                                   directive.getUnicode(),
                                   directive.addLeftSpace() <add:zeves>&amp;&amp; !requiresHardSpace</add:zeves>,
                                   directive.addRightSpace()<add:zeves>&amp;&amp; !requiresHardSpace</add:zeves>);
      }
      else {
        command = (LatexCommand) o;
      }
      if (command != null) {
        return command;
      }
    }
    StringBuffer latex = new StringBuffer();
    boolean addLSpace = false;
    boolean addRSpace = false;
    <add:zeves>boolean foundDollarChar = false;</add:zeves>
    ZChar[] zchars = ZChar.toZChars(word);
    int charcount = 0;
    for (int i = 0; i &lt; zchars.length; i++) {
      ZChar zchar = zchars[i];
      Object o = latexCommands.get(zchar.toString());
      if (o instanceof MarkupDirective) {
        MarkupDirective directive = (MarkupDirective) o;
        command = new LatexCommand(directive.getCommand(),
                                   directive.getUnicode(),
                                   directive.addLeftSpace(),
                                   directive.addRightSpace());
      }
      else {
        command = (LatexCommand) o;
      }
      if (command != null) {
        if ( (command.addLeftSpace() &amp;&amp; i &gt; 0) ||
             (command.addRightSpace() &amp;&amp; i + 1 &lt; zchars.length) ) {
          latex.append("{" + command.getName() + "}");
        }
        else {
          if (command.getName().startsWith("\\")) {
            latex.append(command.getName() + " ");
          }
          else {
            latex.append(command.getName());
          }
        }
        addRSpace = command.addRightSpace();
      }
      <add:zeves>
      else if (net.sourceforge.czt.zeves.util.ZEvesChar.isZProofDollar(zchar))
      {
        latex.append("\\");
        latex.append(zchar.toString().trim());
        foundDollarChar = true;
        // TODO: why does this add a space after the dollar sometimes?
        //       it occurs mainly during testing. Running directly doesn't...
      }
      </add:zeves>
      else if (zchar.isAsciiChar()) { // ASCII?
        latex.append(zchar.toString());
      }
      else if (ZChar.PRIME.equals(zchar)) {
        latex.append("'");
      }
      else {
        final int hexBase = 16;
        String hex = Integer.toString(zchar.codePoint(), hexBase);
        String message = "Error while transforming " + word +
          ": Unexpected character " + zchar.toString() +
          " (\\u" + hex + ") in line " + line + " column " +
          charcount + column;
        throw new PrintException(message);
      }
      charcount = charcount + zchar.charCount();
    }
    String latexStr = latex.toString();
    //System.out.println("uniwordToLatex(" + word + ") = " + latexStr + " instead of " + latexStr.replaceAll(" ", "") <add:zeves>+ " foundDollar? = " + foundDollarChar</add:zeves>);
    //<add:zeves>if (foundDollarChar) latexStr = latexStr.replaceAll(" ", ""); </add:zeves>
    return createLatexCommand(latexStr, word, addLSpace, addRSpace);
  }

  // Whilst concate(w1, w2), spaces at edges are considered. For the cases
  // where "keywords" are typeset the same in LaTeX and Unicode, it can be
  // sometimes annoying/desarible to have hard or soft spaces added. That's
  // what "concate(w1,w2)" does. Here, we can influence its behaviour by
  // appending an extra soft space in the case where no such issue arrise?
  private LatexCommand createLatexCommand(String latex, String word, boolean addLeft, boolean addRight)
  {
    boolean isKeyword = false 
                  <add:zeves>||  net.sourceforge.czt.parser.zeves.ZEvesSymMap.ALL_ZEVES_KEYWORDS.contains(word.toUpperCase())</add:zeves>
                  ;
    addLeft = addLeft || isKeyword;
    addRight = addRight || isKeyword;
    return new LatexCommand(latex, word, addLeft, addRight);
  }


  private void addParentMarkups(ZSect zsect, LatexMarkupFunction table)
  {
    for (Parent parent : zsect.getParent()) {
      String parentName = parent.getWord();
      LatexMarkupFunction parentMarkup = null;
      try {
        parentMarkup = 
          parser.sectInfo_.get(new Key&lt;LatexMarkupFunction&gt;(parentName, LatexMarkupFunction.class));
      }
      catch (CommandException exception) {
        String message = "Cannot get latex markup for parent section " +
          parentName + " caused by " + exception;
        CztLogger.getLogger(<class/>.class).warning(message);
      }
      if (parentMarkup == null) {
        ZSect parentHeader = sections_.get(parentName);
        if (parentHeader != null) addParentMarkups(parentHeader, table);
      }
      else {
        try {
          table.add(parentMarkup);
        }
        catch (MarkupException e) {
          CztLogger.getLogger(<class/>.class).warning(e.getMessage());
        }
      }
    }
  }

  protected void setupMarkupTable(ZSect zsect)
  {
    final String sectName = zsect.getName();
    LatexMarkupFunction table = getMarkupTable(sectName);
    if (table == null) {
      table = new LatexMarkupFunction(zsect.getName());
      addParentMarkups(zsect, table);
    }
    assert table != null;
    setupMarkupTable(table);
  }

  /**
   * Returns the LatexMarkupFunction for the given section.
   * Also sets up &lt;code&gt;markup_&lt;/code&gt; if a LatexMarkupFunction
   * has been found.
   */
  protected LatexMarkupFunction getMarkupTable(String sectName)
  {
    LatexMarkupFunction table = null;
    try {
      table = 
        parser.sectInfo_.get(new Key&lt;LatexMarkupFunction&gt;(sectName, LatexMarkupFunction.class));
      if (table != null) {
        LatexMarkupPara para =
          table.toAst(new net.sourceforge.czt.z.util.Factory());
        markup_ = para.getDirective().iterator();
      }
      return table;
    }
    catch (CommandException exception) {
      String message = "Cannot get latex markup for section " + sectName +
        " caused by " + exception;
      CztLogger.getLogger(<class/>.class).warning(message);
    }
    return table;
  }

  protected void setupMarkupTable(LatexMarkupFunction table)
  {
    unicode2latexMap_ = new HashMap&lt;String,Object&gt;();
    if (table != null) {
      for (Iterator iter = table.iterator(); iter.hasNext();) {
        MarkupDirective directive = (MarkupDirective) iter.next();
        final String unicode = directive.getUnicode();
        <add:z>
        // For Std Z printing, we should not consider FUZZ_TOOLKIT symbols!
        if (!directive.getSection().equals(net.sourceforge.czt.z.util.Section.FUZZ_TOOLKIT.getName()))
        </add:z>
           unicode2latexMap_.put(unicode, directive);
      }
    }
    addStandardMapping(unicode2latexMap_);
<add:oldz>
    LatexCommand arithmos = resultFF("\\num", ZString.ARITHMOS);
    unicode2latexMap_.put(ZString.ARITHMOS, arithmos);
</add:oldz>
  }

  protected LatexCommand resultTT(String latex, String unicode)
  {
    return new LatexCommand(latex, unicode, true, true);
  }

  protected LatexCommand resultTF(String latex, String unicode)
  {
    return new LatexCommand(latex, unicode, true, false);
  }

  protected LatexCommand resultFT(String latex, String unicode)
  {
    return new LatexCommand(latex, unicode, false, true);
  }

  protected LatexCommand resultFF(String latex, String unicode)
  {
    return new LatexCommand(latex, unicode, false, false);
  }
:}

parser code {:
  public static final Map&lt;Object, String&gt; symbolMap_ = DebugUtils.getFieldMap(Sym.class);
  public static final Map&lt;String, Object&gt; symbolMap2_= DebugUtils.getFieldMap2(Sym.class);

  private Writer writer_ = new OutputStreamWriter(System.out);
  protected SectionInfo sectInfo_ = new SectionManager();
  protected String sectionName_;
  protected int tabSize_ = PrintPropertiesKeys.PROP_TXT_TAB_SIZE_DEFAULT;

  /**
   * Used to scan the unicode provided within markup directives.
   * Whenever a latex markup directives is to printed, a new
   * markup scanner is created that scans the unicode of that
   * markup.  If it is not &lt;code&gt;null&lt;/code&gt; we are just
   * printing the definition part of a latex markup directive.
   */
  protected ContextFreeScanner markupScanner_ = null;

  public SectionInfo getSectionInfo()
  {
    return sectInfo_;
  }

  public void setSectionInfo(SectionInfo sectInfo)
  {
    sectInfo_ = sectInfo;
  }

  public void setSectionInfo(SectionInfo sectInfo, String sectionName)
  {
    sectInfo_ = sectInfo;
    sectionName_ = sectionName;
    if (sectInfo_ instanceof SectionManager)
    {
      try {
        tabSize_ = ((SectionManager)sectInfo_).getIntegerProperty(PrintPropertiesKeys.PROP_TXT_TAB_SIZE);
      }
      catch (NumberFormatException e)
      {
        tabSize_ = PrintPropertiesKeys.PROP_TXT_TAB_SIZE_DEFAULT;
      }
    }
  }

  public Writer getWriter()
  {
    return writer_;
  }

  public void setWriter(Writer writer)
  {
    writer_ = writer;
  }

  protected void write(String s)
  {
    try {
      writer_.write(s);
    }
    catch(IOException e) {
      System.err.println("Cannot write");
    }
  }

  private String printType(DirectiveType type)
  {
    if (DirectiveType.NONE.equals(type)) return "";
    return type.toString().toLowerCase();
  }

  /**
   * Returns the next token.
   */
  protected Symbol local_next_token()
    throws Exception
  {
    Symbol result = local_next_token_help();
    if (result.sym == Sym.DECORWORD &amp;&amp;
             "section".equals(result.value.toString())) {
      return new Symbol(Sym.SECTION);
    }
    else if (result.sym == Sym.TOKENSEQ ||
             result.sym == Sym.PARA_START) {
      LatexMarkupFunction table = 
        sectInfo_.get(new Key&lt;LatexMarkupFunction&gt;(sectionName_, LatexMarkupFunction.class));
      action_obj.setupMarkupTable(table);
    }
    String logMessage =
      "Next token is (" + symbolMap_.get(result.sym) + ", " + 
      (result.sym != Sym.TEXT ? String.valueOf(result.value) + ", " + 
       (result.value != null ? result.value.getClass().getName() : "null") :
       "...shhh...") + ").";    
    CztLogger.getLogger(<class/>.class).fine(logMessage);
    return result;
  }

  private Symbol local_next_token_help()
    throws Exception
  {
    if (markupScanner_ != null) {
      // if markupScanner_ is not null, we are just printing the definition
      // part of a latex markup directive.  Therefore, markup_ must be non
      // null (since we can only get the directive from there).
      assert action_obj.markup_ != null;
      Symbol result = markupScanner_.next_token();
      if (result == null || result.sym == Sym.EOF) {
        markupScanner_ = null;
        return new Symbol(Sym.END_MARKUP);
      }
      return result;
    }
    if (action_obj.markup_ != null &amp;&amp; action_obj.markup_.hasNext()) {
      Directive directive = (Directive) action_obj.markup_.next();
      final String unicode = directive.getUnicode();
      final char[] charArray = unicode.toCharArray();
      if (unicode.length() == 1) {
        StringBuffer result = new StringBuffer();
        result.append("\n");
        char c = unicode.charAt(0);
        result.append("%%Z" + printType(directive.getType())+ "char ");
        result.append(directive.getCommand() + " ");
        result.append("U+");
        String hex = Integer.toHexString(c).toUpperCase();
        for (int i = 0; i &lt; 4 - hex.length(); i++) {
          result.append("0");
        }
        result.append(hex);
        result.append("\n");
        return new Symbol(Sym.CHAR_MARKUP, result.toString());
      }
      else if (charArray.length == 2 &amp;&amp;
               Character.isSurrogatePair(charArray[0], charArray[1])) {
        StringBuffer result = new StringBuffer();
        result.append("\n");
        int codePoint = Character.codePointAt(charArray, 0);
        result.append("%%Z" + printType(directive.getType())+ "char ");
        result.append(directive.getCommand() + " ");
        result.append("U-");
        String hex = Integer.toHexString(codePoint).toUpperCase();
        for (int i = 0; i &lt; 8 - hex.length(); i++) {
          result.append("0");
        }
        result.append(hex);
        result.append("\n");
        return new Symbol(Sym.CHAR_MARKUP, result.toString());
      }
      else {
        markupScanner_ = new ContextFreeScanner(new StringReader(unicode));
        markupScanner_.yybegin(ContextFreeScanner.Z);
        DirectiveType type = directive.getType();
        if (DirectiveType.NONE.equals(type)) {
          return new Symbol(Sym.WORD_MARKUP, directive.getCommand());
        }
        else if (DirectiveType.IN.equals(type)) {
          return new Symbol(Sym.INWORD_MARKUP, directive.getCommand());
        }
        else if (DirectiveType.POST.equals(type)) {
          return new Symbol(Sym.POSTWORD_MARKUP, directive.getCommand());
        }
        else if (DirectiveType.PRE.equals(type)) {
          return new Symbol(Sym.PREWORD_MARKUP, directive.getCommand());
        }
        else {
          throw new CztException("Unexpected directive type " + type);
        }
      }
    }
    else {
      action_obj.markup_ = null;
      Symbol result = getScanner().next_token();
      return result;
    }
  }

  public void report_error(String message, Object info) {
    StringBuffer m = new StringBuffer("Error");
    if (info instanceof net.sourceforge.czt.java_cup.runtime.Symbol) {
      net.sourceforge.czt.java_cup.runtime.Symbol s =
        ((net.sourceforge.czt.java_cup.runtime.Symbol) info);
      if (s.left &gt;= 0) {                
        m.append(" in line "+(s.left+1));   
        if (s.right &gt;= 0) m.append(", column "+(s.right + 1));
      }
      String value = String.valueOf(s.value);
      if (s.value instanceof Term &amp;&amp;
          ((Term)s.value).getAnn(LocAnn.class) != null) {  
        value += " at " +
          ((LocAnn)(((Term)s.value).getAnn(LocAnn.class))).toString();
      }
      m.append(", Token(" + symbolMap_.get(s.sym) + "," + s.value + ")");
    }
    m.append(": " + message);
    System.err.println(m);
  }

  public void report_fatal_error(String message, Object info)
  {
    report_error(message, info);
    done_parsing();
    throw new PrintException("Parse error: " +
      String.valueOf(message) + " => " + (info instanceof Symbol ? symbolMap_.get(((Symbol)info).sym) : String.valueOf(info)));
  }

  public void unrecovered_syntax_error(Symbol token)
  {
    report_fatal_error("Syntax error at token " + symbolMap_.get(token.sym),
                       token);
  }
:};

scan with {: return local_next_token(); :};

/* ------------Declaration of Terminals and Non Terminals Section----------- */
   
/* Terminals */
terminal           LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACE, RBRACE,
                   LBIND, RBIND, LDATA, RDATA, ZED, AX, SCH, GENAX, GENSCH,
                   END, NL, THEOREM,
                   SECTION, PARENTS, // used by the SectHeadScanner within ContextFreeScanner
                   WHERE, // the latex \where command
                   INSTROKE, OUTSTROKE, NEXTSTROKE,
                   
                   ZSTATE, ZSTINIT, ZSTFIN, ZASTATE, ZASTINIT, ZCSTATE, ZCSTINIT,
                   ZRETRIEVE, ZRETRIEVEIN, ZRETRIEVEOUT, ZFSREFINES, ZBSREFINES,
                   ZASTFIN, ZCSTFIN, ZAINITIN, ZAFINOUT, ZCINITIN, ZCFINOUT,
 <add:oz>
                   CLASS, GENCLASS, OPSCH, INIT, STATE, SDEF,
 </add:oz>
<add:circus>
                   CIRCUS, CIRCUSACTION, LCIRCCHANSET, RCIRCCHANSET,
                   CIRCLINST, CIRCRINST,
                   LPAR, RPAR, LINTER, RINTER, LCIRCGUARD, RCIRCGUARD,
                   LSCHEXPRACT, RSCHEXPRACT, LCIRCRENAME, RCIRCRENAME, 
                   
                   //CIRCREFINES, CIRCDEF, CIRCCHAN, CIRCCHANFROM,
                   //CIRCCHANSET, CIRCPROC, CIRCDO, CIRCVAR, CIRCVAL,
                   //CIRCRES, CIRCVRES, CIRCNAMESET, CIRCASSERTREF,
                   //CIRCBEGIN, CIRCSTATE, CIRCREPINTERLEAVE, CIRCEND,

                   /* Support for Circus Time */
                   LCIRCTIMEOUT, RCIRCTIMEOUT,
</add:circus>
<add:zeves>
                   // Proof environment chars and specific proof words
        ZPROOF, ZPROOFSECTION, ZPROOFCOMMANDSEP, 
        THMREPLACEMENT, QNTINSTANTIATION,
        LLABEL, RLABEL, LZNOTE, RZNOTE, DISABLEDTHMTAG, DISABLEDDEFTAG,
        PROOFWORD, THMNAME, THMRULE, THMGRULE, THMFRULE, THMAXIOM,

        APPLY, BACK, CASES, CONJUNCTIVE, DISJUNCTIVE, EQUALITY,
        INSTANTIATE, INVOKE, NEXT, PRENEX, PROVE, REARRANGE, TRIVIAL, TRY,
        SPLIT, USE, WITH, BY, ENABLED, EXPRESSION, DISABLED, LEMMA,
        NORMALIZATION, PREDICATE, SUBSTITUTE, TO, SORRY, OOPS,

        CHECK, DECLARE, HELP, PARENT, PRINT, QUIT, READ, RESET, RETRY,
        SYNTAX, THEOREMS, UNDO, ZSECTION, ZTAGS,

        ABOUT, DECLARATION, FORMULA, HISTORY, PROOF, SCRIPT, STATUS,
        SUMMARY, THROUGH,
        
</add:zeves>
<add:zpatt>
                   JOKER, RULE, RULELINE, PROVISO,
</add:zpatt>
<add:circuspatt>
                   CIRCUSJOKER, CIRCUSACTIONLAW, CIRCUSPROCESSLAW,
</add:circuspatt>
                   END_MARKUP,
                   TOKENSEQ, PARA_START, PARA_END;
terminal LocInt    NUMERAL, NUMSTROKE;
terminal LocString TEXT;
terminal String    CHAR_MARKUP, WORD_MARKUP, INWORD_MARKUP, PREWORD_MARKUP,
                   POSTWORD_MARKUP, INDENT;
terminal Decorword DECORWORD;

/* Non terminals */
non terminal              input, // narrWordList, // never used!
                          paragraphList;
// non terminal ZSect        sectionHeader;
non terminal String       markup, para, zpara, zedPara, 
                wordmarkup;
<add:oz>
non terminal LatexCommand innerPara;
</add:oz>
non terminal LatexCommand token, tokenSeq,
                          specialSeq, sectHeadSeq,
     <add:zeves>optDefAbility, optThmAbility, labelAbility,
                thmUsage, optThmUsage, proofTokenSeq,
                proofToken, proofSpecial,
     </add:zeves>
                zStInfo, optZStInfo, schGenerics, decorwordList,
                paren, special, indent, decorword;

// These are ordered from loosest first to tightest last.
precedence nonassoc INDENT;

   input ::= paragraphList
             {: parser.getWriter().flush(); :}
             |
             TOKENSEQ tokenSeq:s TOKENSEQ
             {: 
                if (s != null) parser.write(s.getName());
                parser.getWriter().flush();
             :}
             |
             PARA_START zpara PARA_END
             {:
                parser.getWriter().flush();
             :}             
             ;

   /* NEVER USED: remove? 
   narrWordList ::=
             TEXT:t narrWordList
             {: parser.write(t.getString()); :}
             |
             // empty
             ;
   */

   paragraphList ::= 
             paragraphList para
             |
             // empty
             ;

   para ::=  markup
             |
             TEXT:t
             {: parser.write(t.getString()); :}
             |
             zpara:z
             {: RESULT = z; :}
             ;

   zedPara ::=
             SECTION specialSeq DECORWORD:dw sectHeadSeq:s
             {:
                String result = begin("zsection");
                result += "\t \\SECTION " + toLatexInSectHead(dw.getName()) + " ";
                if (s != null) { result += s.getName(); }
                result += end("zsection");
                parser.write(result);
                parser.sectionName_ = dw.getName();
                LatexMarkupFunction table =
                  getMarkupTable(parser.sectionName_);
                setupMarkupTable(table);
             :}
             |
             <add:zeves>
                optDefAbility:ability
              </add:zeves>
              token:t tokenSeq:s
             {:
                String result = begin("zed" <add:zeves>, ability</add:zeves>);
                if (s != null) { result += concate(t,s).getName(); }
                result += end("zed");
                parser.write(result);
             :}
             ;

   sectHeadSeq ::= sectHeadSeq:s DECORWORD:dw
             {:
                if ("parents".equals(dw.getName())) {
                  RESULT = concate(s, resultFF("\\parents", dw.getName()));
                }
                else {
                  String latex = toLatexInSectHead(dw.getName());
                  RESULT = concate(s, resultFF(latex, dw.getName()));
                }
             :}
             |
             sectHeadSeq:s special:w2
             {: RESULT = concate(s, w2); :}
             |
             {: RESULT = null; :}
             ;             

   zpara ::= ZED
              <add:zeves>
                optThmAbility:ability
              </add:zeves>
             THEOREM
             <add:zeves>
                optThmUsage:usage
             </add:zeves>
                decorword:w tokenSeq:s END
             {:
                //System.out.println("DEBUG: Unicode2Latex sees THEOREM " + w.getName());
                String result = begin("theorem", "{" + <add:zeves>usage.getName() + " " + </add:zeves> w.getName() + "}"
                                          <add:zeves>, ability</add:zeves>);
                if (s != null) result += s.getName();
                result += end("theorem");
                parser.write(result);
             :}
             |
             ZED
              <add:zeves>
                optThmAbility:ability
              </add:zeves>
             specialSeq zedPara END
             |
             AX tokenSeq:s END
             {:
                String result = begin("axdef");
                if (s != null) result += s.getName();
                result += end("axdef");
                parser.write(result);
             :}
             |
             SCH
              <add:zeves>
                optDefAbility:ability
              </add:zeves>
             specialSeq decorword:w
             optZStInfo:zsti
             tokenSeq:s END
             {:
                String result = begin("schema", "{" + w.getName() + "}" <add:zeves>, ability</add:zeves>);
                if (zsti != null) 
                  result += "\n" + zsti.getName();
                else
                  result += "\n";
                if (s != null) result += s.getName();
                result += end("schema");
                parser.write(result);
             :}
             |
             GENAX tokenSeq:s END
             {:
                String result = begin("gendef");
                if (s != null) result += s.getName();
                result += end("gendef");
                parser.write(result);
             :}
             |
             GENSCH
              <add:zeves>
                optDefAbility:ability
              </add:zeves>
             specialSeq decorword:w
             schGenerics:gen
             optZStInfo:zsti
             tokenSeq:s END
             {:
                String result = begin("schema", "{" + w.getName() + "}" <add:zeves>, ability</add:zeves>);
                if (gen == null)
                  throw new PrintException("Generic parameters expected for schema " + w.getName());
                else
                  result += gen.getName() + "\n";
                if (zsti != null) result += zsti.getName();
                if (s != null) result += s.getName();
                result += end("schema");
                parser.write(result);
             :}
<add:oz>
             |
             CLASS decorword:w tokenSeq:s END
             {:
                String result = begin("class", "{" + w.getName() + "}");
                if (s != null) result += s.getName();
                result += end("class");
                parser.write(result);
             :}
             |
             GENCLASS decorword:w tokenSeq:s END
             {:
                String result = begin("class", "{" + w.getName() + "}");
                if (s != null) result += s.getName();
                result += end("class");
                parser.write(result);
             :}
</add:oz>
<add:zpatt>
             |
             JOKER decorword:w tokenSeq:s END
             {:                
                String result = begin("zedjoker", "{" + w.getName() + "}");
                if (s != null) result += s.getName();
                result += end("zedjoker");
                parser.write(result);
             :}
             |
             RULE decorword:w tokenSeq:s END
             {:
                String result = begin("rule", "{" + w.getName() + "}");
                if (s != null) result += s.getName();
                result += end("rule");
                parser.write(result);
             :}
</add:zpatt>
<add:circuspatt>
            |
            CIRCUSJOKER decorword:w tokenSeq:s END
            {:                
               String result = begin("circusjoker") + "{" +
                 w.getName() + "}";
               if (s != null) result += s.getName();
               result += end("circusjoker");
               parser.write(result);
            :}
            |
            CIRCUSACTIONLAW decorword:w tokenSeq:s END
            {:
               String result = begin("circusactionlaw", "{" +  w.getName() + "}");
               if (s != null) result += s.getName();
               result += end("rule");
               parser.write(result);
            :}
            |
            CIRCUSPROCESSLAW decorword:w tokenSeq:s END
            {:
               String result = begin("circusprocesslaw", "{" + w.getName() + "}");
               if (s != null) result += s.getName();
               result += end("rule");
               parser.write(result);
            :}
</add:circuspatt>
<add:circus>
            |
            CIRCUS tokenSeq:s END
            {:
                String result = begin("circus");
                if (s != null) { result += s.getName(); }
                result += end("circus");
                parser.write(result);
            :}
            |
            CIRCUSACTION tokenSeq:s END
            {:
                String result = begin("circusaction");
                if (s != null) result += s.getName();
                result += end("circusaction");
                parser.write(result);
            :}
</add:circus>
<add:zeves>
            |
            ZPROOF specialSeq:sq decorword:w proofTokenSeq:s END
            {:
                String result = begin("zproof", "[" + w.getName() + "]");
                if (s != null) { result += "\n" + s.getName(); }
                result += end("zproof");
                parser.write(result);
            :}
            |
            ZPROOFSECTION tokenSeq:s END
            {:
                String result = begin("zproofsection");
                if (s != null) { result += s.getName(); }
                result += end("zproofsection");
                parser.write(result);
            :}
</add:zeves>
             ;

  markup ::=
             CHAR_MARKUP:zchar
             {: parser.write(zchar); :}
             |
             wordmarkup:wm tokenSeq:s END_MARKUP
             {:
                StringBuffer result = new StringBuffer();
                result.append("\n");
                result.append(wm);
                result.append(" ");
                if (s != null) { result.append(s.getName()); }
                result.append("\n");
                parser.write(result.toString());
             :}
             ;

   wordmarkup ::=
             WORD_MARKUP:word
             {:
                RESULT = "%%Zword " + word;
             :}
             |
             INWORD_MARKUP:inword
             {:
                RESULT = "%%Zinword " + inword;
             :}
             |
             PREWORD_MARKUP:preword
             {:
                RESULT = "%%Zpreword " + preword;
             :}
             |
             POSTWORD_MARKUP:postword
             {:
                RESULT = "%%Zpostword " + postword;
             :}
             ;

   tokenSeq ::= tokenSeq:w1 token:w2
             {: RESULT = concate(w1, w2); :}
             |
             tokenSeq:w1 special:w2
             {: RESULT = concate(w1, w2); :}
             |
             {: RESULT = null; :}
<add:oz>
             |
             tokenSeq:w1 innerPara:ip
             {: RESULT = concate(w1, ip); :}
</add:oz>
             ;

   token ::= decorword:s
             {: RESULT = s; :}
             |
             INSTROKE
             {: RESULT = resultFF("?", ZString.INSTROKE); :}
             |
             OUTSTROKE
             {: RESULT = resultFF("!", ZString.OUTSTROKE); :}
             |
             NEXTSTROKE
             {: RESULT = resultFF("'", ZString.PRIME); :}
             |
             NUMSTROKE:i
             {:
                final String numString = i.getValue().toString();
                String latex = "_" + numString;
                String unicode = ZString.SE + numString + ZString.NW;
                RESULT = resultFF(latex, unicode);
             :}
             |
             NUMERAL:i
             {:
                final String numString = i.getValue().toString();
                RESULT = resultFF(numString, numString);
             :}
             |
             paren:s
             {: RESULT = s; :}
             |
             WHERE:t
             {:
                RESULT = resultTT("\n\\where\n", ZString.VL); :}
<add:oz>
             |
             SDEF
             {: RESULT = resultTT("\\sdef", OzString.SDEF); :}             
</add:oz>
<add:zpatt>
             |
             RULELINE
             {: RESULT = resultTT("\n\\derives\n", "\u2500"); :}
             |
             PROVISO
             {: RESULT = resultTT("\\proviso", "\u25B8"); :}
</add:zpatt>
<add:zeves>
             //|
             //ZPROOFCOMMANDSEP
             //{:
             //   RESULT = resultFT(";\n", ZEvesString.ZPROOFCOMMANDSEP);
             //:}
             //|
             //ZPROOFDOLLAR
             //{:
             //   RESULT = resultFF("\\$", ZEvesString.ZPROOFDOLLAR);
             //:}
             //|
             //// only accept prime for now. See if others are needed as we process more examples
             //ZPROOFDOLLARSTROKE:s
             //{:
             //   RESULT = resultFF("\\$" + s.getName().substring(1), ZEvesString.ZPROOFDOLLAR + s.getName().substring(1));
             //:}
             |
             thmUsage:t
             {:
                RESULT = t;
             :}
             |
             labelAbility:l
             {:
                RESULT = l;
             :}
 </add:zeves>
             ;


<add:zeves>
proofTokenSeq ::= proofTokenSeq:w1 proofToken:w2
             {: RESULT = concate(w1, w2); :}
             |
             proofTokenSeq:w1 proofSpecial:w2
             {: RESULT = concate(w1, w2); :}
             |
             {: RESULT = null; :}
             ;

 proofToken ::= decorword:s
             {: RESULT = s; :}
             |
             INSTROKE
             {: RESULT = resultFF("?", ZString.INSTROKE); :}
             |
             OUTSTROKE
             {: RESULT = resultFF("!", ZString.OUTSTROKE); :}
             |
             NEXTSTROKE
             {: RESULT = resultFF("'", ZString.PRIME); :}
             |
             NUMSTROKE:i
             {:
                final String numString = i.getValue().toString();
                String latex = "_" + numString;
                String unicode = ZString.SE + numString + ZString.NW;
                RESULT = resultFF(latex, unicode);
             :}
             |
             NUMERAL:i
             {:
                final String numString = i.getValue().toString();
                RESULT = resultFF(numString, numString);
             :}
             |
             paren:s
             {: RESULT = s; :}
             |
             ZPROOFCOMMANDSEP
             {:
                RESULT = resultFT(";\n", ZEvesString.ZPROOFCOMMANDSEP);
             :}
             ;

proofSpecial ::= NL
             {:
                // within a ZPROOF environment, don't add hard, but soft newlines
                RESULT = resultTT("\n", ZString.NL);
             :}
             |
             INDENT:indent
             {:
                RESULT = resultTT(indent, indent);
             :}
             ;
 </add:zeves>



decorwordList ::=
              decorwordList:dw1 special:dw2
              {:
                RESULT = concate(dw1, dw2);
              :}
              |
              decorwordList:dw decorword:s
              {:
                 RESULT = concate(dw, s);
              :}
              |
              decorword:s
              {:
                 RESULT = s;
              :}
              //|
              //special:s
              //{:
              //   RESULT = s;
              //:}
              ;

schGenerics  ::=
             LSQUARE decorwordList:dwl RSQUARE
             {:
               RESULT = concate(resultTT("[", ZString.LSQUARE),
                          concate(dwl, resultTT("]", ZString.RSQUARE)));
             :}
             ;

// Z state info always appear after a NL; or there will be a NL with no info
optZStInfo   ::=
             NL indent:id zStInfo:zsi
             {:
                RESULT = concate(id, zsi);
             :}
             |
             NL zStInfo:zsi
             {:
                RESULT = zsi;
             :}
             |
             NL indent:id
             {:
                RESULT = id;
             :}
             |
             NL
             {:
                RESULT = null; //resultTT("\\\\\n", ZString.NL);
             :}
             ;

zStInfo   ::=
             ZSTATE
             {:
                RESULT = resultFT("\\zstate", ZString.ZSTATE);
             :}
             |
             ZSTINIT 
             {:
                RESULT = resultFT("\\zstinit", ZString.ZSTINIT);
             :}
             |
             ZASTATE 
             {:
                RESULT = resultFT("\\zastate", ZString.ZASTATE);
             :}
             |
             ZASTINIT 
             {:
                RESULT = resultFT("\\zastinit", ZString.ZASTINIT);
             :}
             |
             ZCSTATE 
             {:
                RESULT = resultFT("\\zcstate", ZString.ZCSTATE);
             :}
             |
             ZCSTINIT 
             {:
                RESULT = resultFT("\\zcstinit", ZString.ZCSTINIT);
             :}
             |
             ZASTFIN
             {:
                RESULT = resultFT("\\zastfin", ZString.ZASTFIN);
             :}
             |
             ZCSTFIN
             {:
                RESULT = resultFT("\\zcstfin", ZString.ZCSTFIN);
             :}
             |
             ZRETRIEVE 
             {:
                RESULT = resultFT("\\zretrieve", ZString.ZRETRIEVE);
             :}
             |
             ZRETRIEVEIN 
             {:
                RESULT = resultFT("\\zretrievein", ZString.ZRETRIEVEIN);
             :}
             |
             ZRETRIEVEOUT 
             {:
                RESULT = resultFT("\\zretrieveout", ZString.ZRETRIEVEOUT);
             :}
             |
             ZAINITIN
             {:
                RESULT = resultFT("\\zainitin", ZString.ZAINITIN);
             :}
             |
             ZAFINOUT
             {:
                RESULT = resultFT("\\zafinout", ZString.ZAFINOUT);
             :}
             |
             ZCINITIN
             {:
                RESULT = resultFT("\\zcinitin", ZString.ZCINITIN);
             :}
             |
             ZCFINOUT
             {:
                RESULT = resultFT("\\zcfinout", ZString.ZCFINOUT);
             :}
             |
             ZFSREFINES decorword:s 
             {:
                String name = s.getName();
                RESULT = resultFT("\\zfsrefines " + name,
                  ZString.ZFSREFINES + ZString.SPACE + name);
             :}
             |
             ZBSREFINES decorword:s  
             {:
                String name = s.getName();
                RESULT = resultFT("\\zbsrefines " + name,
                  ZString.ZBSREFINES + ZString.SPACE + name);
             :}
             //|
             //NL
             //{:
             //   RESULT = resultTT("\\\\\n", ZString.NL);
             //:}
             //|
             //// empty
             //{:
             //   RESULT = null;
             //:}
             ;

<add:zeves>
 // ability as different tokens - this is necessary for Unicode differentiation
 optDefAbility ::=
             DISABLEDDEFTAG
             {:
                RESULT = resultFF("[disabled]", ZEvesString.DISABLEDDEFTAG);
             :}
             |
             // empty
             ;

 optThmAbility ::=
             DISABLEDTHMTAG
             {:
                RESULT = resultFF("[disabled]", ZEvesString.DISABLEDTHMTAG);
             :}
             |
             // empty
             ;

 thmUsage ::=
             /* MUST BE DECORWORD: within tokenSeq we have LLABEL ... ?*/
             THMRULE // or just use DECORWORD?
             {:
                // TT here to avoid "glueing" up with other names
                RESULT = resultTT("rule", ZEvesString.THMRULE);
             :}
             |
             THMFRULE
             {:
                RESULT = resultTT("frule", ZEvesString.THMFRULE);
             :}
             |
             THMGRULE
             {:
                RESULT = resultTT("grule", ZEvesString.THMGRULE);
             :}
             |
             THMAXIOM
             {:
                RESULT = resultTT("axiom", ZEvesString.THMAXIOM);
             :}
             ;

// as keywords
 labelAbility ::=
             DISABLED
             {:
                RESULT = resultTT("disabled", ZEvesString.DISABLED);
             :}
             |
             ENABLED
             {:
                RESULT = resultTT("enabled", ZEvesString.ENABLED);
             :}
             ;


 optThmUsage ::=
             thmUsage:t
             {:
                RESULT = t;
             :}
             |
             // empty
             {:
                RESULT = resultFF("", "");
             :}
             ;

</add:zeves>

   decorword ::= DECORWORD:s
             {:
                assert s != null;
                if (s instanceof WhereWord) {
                  RESULT = resultTT("\n\\where\n", ZString.VL);
                }
<add:oldz>
                else if (s instanceof DefsWord) {
                  RESULT = resultTT("\\defs", ZString.DEFEQUAL);
                }
</add:oldz>
                else {
                  RESULT = toLatex(s.getName(), sleft, sright);
                }
             :}
             ;

   paren ::= LPAREN
             {: RESULT = resultTT("(", ZString.LPAREN); :}
             |
             RPAREN
             {: RESULT = resultTT(")", ZString.RPAREN); :}
             |
             LSQUARE
             {: RESULT = resultTT("[", ZString.LSQUARE); :}
             |
             RSQUARE
             {: RESULT = resultTT("]", ZString.RSQUARE); :}
             |
             LBRACE
             {: RESULT = resultTT("\\{",  ZString.LBRACE); :}
             |
             RBRACE
             {: RESULT = resultTT("\\}", ZString.RBRACE); :}
             |
             LBIND
             {: RESULT = resultTT("\\lblot", ZString.LBIND); :}
             |
             RBIND
             {: RESULT = resultTT("\\rblot", ZString.RBIND); :}
             |
             LDATA
             {: RESULT = resultTT("\\ldata", ZString.LDATA); :}
             |
             RDATA
             {: RESULT = resultTT("\\rdata", ZString.RDATA); :}
<add:circus>
             |
             LCIRCCHANSET
             {:
                RESULT = resultTT("\\lchanset~", CircusString.LCIRCCHANSET);
             :}
             |
             RCIRCCHANSET
             {:
                RESULT = resultTT("~\\rchanset", CircusString.RCIRCCHANSET);
             :}
             |
             CIRCLINST
             {:
                RESULT = resultTT("\\circlinst~", CircusString.CIRCLINST);
             :}
             |
             CIRCRINST
             {:
                RESULT = resultTT("~\\circrinst", CircusString.CIRCRINST);
             :}
             |
             LCIRCGUARD
             {:
                RESULT = resultTT("\\lcircguard~", CircusString.LCIRCGUARD);
             :}
             |
             RCIRCGUARD
             {:
                RESULT = resultTT("~\\rcircguard", CircusString.RCIRCGUARD);
             :}
             |
             LSCHEXPRACT
             {:
                RESULT = resultTT("\\lschexpract~", CircusString.LSCHEXPRACT);
             :}
             |
             RSCHEXPRACT
             {:
                RESULT = resultTT("~\\rschexpract", CircusString.RSCHEXPRACT);
             :}
             |
             LCIRCRENAME
             {:
                RESULT = resultTT("\\lcircrename~", CircusString.LCIRCRENAME);
             :}
             |
             RCIRCRENAME
             {:
                RESULT = resultTT("~\\rcircrename", CircusString.RCIRCRENAME);
             :}
             |
             LPAR
             {:
                RESULT = resultTT("~\\lpar~", CircusString.LPAR);
             :}
             |
             RPAR
             {:
                RESULT = resultTT("~\\rpar~", CircusString.RPAR);
             :}
             |
             LINTER
             {:
                RESULT = resultTT("~\\linter~", CircusString.LINTER);
             :}
             |
             RINTER
             {:
                RESULT = resultTT("~\\rinter~", CircusString.RINTER);
             :}
             /* Support for Circus Time */
             LCIRCTIMEOUT
             {:
                RESULT = resultTT("~\\lcirctimeout~", CircusString.LCIRCTIMEOUT);
             :}
             |
             RCIRCTIMEOUT
             {:
                RESULT = resultTT("~\\rcirctimeout~", CircusString.RCIRCTIMEOUT);
             :}
</add:circus>
<add:zeves>
             |
             LLABEL
             {:
                RESULT = resultFF("\\Label{", ZEvesString.LLABEL);
             :}
             |
             RLABEL
             {:
                RESULT = resultFT("}\n", ZEvesString.RLABEL);
             :}
 </add:zeves>
             ;

  specialSeq ::=
             specialSeq:sq special:s
             {:
                if (sq != null)
                  RESULT = concate(sq, s);
                else
                  RESULT = s;
             :}
             |
             // empty
             {:
                RESULT = null;
             :}
             ;
             
  special ::= NL
             {:
                RESULT = resultTT("\\\\\n", ZString.NL);
             :}
             |
             indent:i
             {:
                RESULT = i;
             :}
              ;

  indent   ::= INDENT:indent
             {:
                // the amount of space given will generate various t1..n
                int i = indent.length();
                int ts = (i / parser.tabSize_);
                int trail = (i % parser.tabSize_);
                if (trail >= (parser.tabSize_ / 2)) ts++;
                if (ts > 9) ts = 9; else if (ts &lt; 1) ts = 1;
                String latex = indent + "\\t" + ts + "\t";
                RESULT = resultTT(latex, indent);
             :} 
             ;

<add:oz>
  innerPara ::=
             AX tokenSeq:s END
             {:
                String latex = begin("axdef") + "\n";
                if (s != null) latex += s.getName();
                latex += end("axdef");
                String unicode = ZString.AX;
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = resultFF(latex, unicode);
             :}
             |
             SCH decorword:w tokenSeq:s END
             {:
                String latex = begin("schema") + "{" + w.getName() + "}\n";
                if (s != null) latex += s.getName();
                latex += end("schema");
                String unicode = ZString.SCH + ZString.SPACE + w.getName();
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = resultFF(latex, unicode);
             :}
             |
             GENAX tokenSeq:s END
             {:
                String latex = begin("gendef");
                if (s != null) latex += s.getName();
                latex += end("gendef");
                String unicode = ZString.GENAX;
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = new LatexCommand(latex, unicode, false, false);
             :}
             |
             GENSCH decorword:w tokenSeq:s END
             {:
                String latex = begin("schema") + "{" + w.getName() + "}";
                if (s != null) latex += s.getName();
                latex += end("schema");
                String unicode =
                  ZString.SCHCHAR + ZString.GENCHAR + w.getName();
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = resultFF(latex, unicode);
             :}
             |
             STATE tokenSeq:s END
             {:
                String latex = begin("state");
                if (s != null) latex += s.getName();
                latex += end("state");
                String unicode = ZString.SCH + ZString.ZEDCHAR;
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = resultFF(latex, unicode);
             :}
             |
             INIT tokenSeq:s END
             {:
                String latex = begin("init");
                if (s != null) latex += s.getName();
                latex += end("init");
                String unicode = ZString.SCH + ZString.SPACE +
                                 OzString.INITWORD + ZString.SPACE;
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = resultFF(latex, unicode);
             :}
             |
             OPSCH decorword:w tokenSeq:s END
             {:
                String latex = begin("op") + "{" + w.getName() + "}";
                if (s != null) latex += s.getName();
                latex += end("op");
                String unicode =
                  ZString.SCH + "op" + ZString.SPACE + w.getName();
                if (s != null) unicode += s.getUnicode();
                unicode += ZString.END;
                RESULT = resultFF(latex, unicode);
             :}
             ;
</add:oz>
 
</parser>
