
/******************************************************************************
DO NOT EDIT THIS FILE!  THIS FILE WAS GENERATED BY GNAST
FROM THE TEMPLATE FILE CoreFactory.vm.
ANY MODIFICATIONS TO THIS FILE WILL BE LOST UPON REGENERATION.

-------------------------------------------------------------------------------

Copyright 2003, 2004, 2005 Mark Utting
This file is part of the czt project.

The czt project contains free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

The czt project is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with czt; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
******************************************************************************/

package net.sourceforge.czt.zpatt.util;

import net.sourceforge.czt.zpatt.ast.*;
import net.sourceforge.czt.z.ast.*;

/**
 * <p>An object factory for the AST.
 *
 * <p>This object factory allows the programmer
 * to programatically construct new instances of concrete Z terms.
 * </p>
 *
 * @author Gnast version 0.1
 */
public class Factory
  extends net.sourceforge.czt.z.util.Factory
{
  private net.sourceforge.czt.zpatt.ast.ZpattFactory factory_ =
    new net.sourceforge.czt.zpatt.impl.ZpattFactoryImpl();

  /**
   * Creates a new convenience factory that uses the standard factory
   * implementation for creating AST terms.
   */
  public Factory()
  {
    super();
  }

  /**
   * Creates a new convenience factory that uses the given base factory
   * for creating AST terms.
   */
  public Factory(net.sourceforge.czt.zpatt.ast.ZpattFactory factory)
  {
    super(factory);
    factory_ = factory;
  }

  /**
   * Creates an instance of {@link JokerName}.
   *
   * @return the new instance of JokerName.
   */
  public JokerName createJokerName()
  {
    return factory_.createJokerName();
  }

  /**
   * Creates an instance of {@link JokerName} with the given children.
   *
   * @return the new instance of JokerName.
   */
  public JokerName createJokerName(String word, java.util.List stroke, String id, String name)
  {
    return factory_.createJokerName(word, stroke, id, name);
  }

  /**
   * Creates an instance of {@link PredSequent}.
   *
   * @return the new instance of PredSequent.
   */
  public PredSequent createPredSequent()
  {
    return factory_.createPredSequent();
  }

  /**
   * Creates an instance of {@link PredSequent} with the given children.
   *
   * @return the new instance of PredSequent.
   */
  public PredSequent createPredSequent(SequentContext sequentContext, net.sourceforge.czt.z.ast.Pred pred, Deduction deduction)
  {
    return factory_.createPredSequent(sequentContext, pred, deduction);
  }

  /**
   * Creates an instance of {@link JokerExpr}.
   *
   * @return the new instance of JokerExpr.
   */
  public JokerExpr createJokerExpr()
  {
    return factory_.createJokerExpr();
  }

  /**
   * Creates an instance of {@link JokerExpr} with the given children.
   *
   * @return the new instance of JokerExpr.
   */
  public JokerExpr createJokerExpr(String name)
  {
    return factory_.createJokerExpr(name);
  }

  /**
   * Creates an instance of {@link JokerExprListBinding}.
   *
   * @return the new instance of JokerExprListBinding.
   */
  public JokerExprListBinding createJokerExprListBinding()
  {
    return factory_.createJokerExprListBinding();
  }

  /**
   * Creates an instance of {@link JokerExprListBinding} with the given children.
   *
   * @return the new instance of JokerExprListBinding.
   */
  public JokerExprListBinding createJokerExprListBinding(JokerExprList jokerExprList, java.util.List expr)
  {
    return factory_.createJokerExprListBinding(jokerExprList, expr);
  }

  /**
   * Creates an instance of {@link JokerExprBinding}.
   *
   * @return the new instance of JokerExprBinding.
   */
  public JokerExprBinding createJokerExprBinding()
  {
    return factory_.createJokerExprBinding();
  }

  /**
   * Creates an instance of {@link JokerExprBinding} with the given children.
   *
   * @return the new instance of JokerExprBinding.
   */
  public JokerExprBinding createJokerExprBinding(JokerExpr jokerExpr, net.sourceforge.czt.z.ast.Expr expr)
  {
    return factory_.createJokerExprBinding(jokerExpr, expr);
  }

  /**
   * Creates an instance of {@link LookupConstDeclProviso}.
   *
   * @return the new instance of LookupConstDeclProviso.
   */
  public LookupConstDeclProviso createLookupConstDeclProviso()
  {
    return factory_.createLookupConstDeclProviso();
  }

  /**
   * Creates an instance of {@link LookupConstDeclProviso} with the given children.
   *
   * @return the new instance of LookupConstDeclProviso.
   */
  public LookupConstDeclProviso createLookupConstDeclProviso(SequentContext sequentContext, net.sourceforge.czt.z.ast.Expr leftExpr, net.sourceforge.czt.z.ast.Expr rightExpr)
  {
    return factory_.createLookupConstDeclProviso(sequentContext, leftExpr, rightExpr);
  }

  /**
   * Creates an instance of {@link JokerExprList}.
   *
   * @return the new instance of JokerExprList.
   */
  public JokerExprList createJokerExprList()
  {
    return factory_.createJokerExprList();
  }

  /**
   * Creates an instance of {@link JokerExprList} with the given children.
   *
   * @return the new instance of JokerExprList.
   */
  public JokerExprList createJokerExprList(String name)
  {
    return factory_.createJokerExprList(name);
  }

  /**
   * Creates an instance of {@link LookupPredProviso}.
   *
   * @return the new instance of LookupPredProviso.
   */
  public LookupPredProviso createLookupPredProviso()
  {
    return factory_.createLookupPredProviso();
  }

  /**
   * Creates an instance of {@link LookupPredProviso} with the given children.
   *
   * @return the new instance of LookupPredProviso.
   */
  public LookupPredProviso createLookupPredProviso(SequentContext sequentContext, net.sourceforge.czt.z.ast.Pred pred)
  {
    return factory_.createLookupPredProviso(sequentContext, pred);
  }

  /**
   * Creates an instance of {@link CalculateProviso}.
   *
   * @return the new instance of CalculateProviso.
   */
  public CalculateProviso createCalculateProviso()
  {
    return factory_.createCalculateProviso();
  }

  /**
   * Creates an instance of {@link CalculateProviso} with the given children.
   *
   * @return the new instance of CalculateProviso.
   */
  public CalculateProviso createCalculateProviso(SequentContext sequentContext, net.sourceforge.czt.z.ast.Expr leftExpr, net.sourceforge.czt.z.ast.Expr rightExpr)
  {
    return factory_.createCalculateProviso(sequentContext, leftExpr, rightExpr);
  }

  /**
   * Creates an instance of {@link SequentContext}.
   *
   * @return the new instance of SequentContext.
   */
  public SequentContext createSequentContext()
  {
    return factory_.createSequentContext();
  }

  /**
   * Creates an instance of {@link JokerNameBinding}.
   *
   * @return the new instance of JokerNameBinding.
   */
  public JokerNameBinding createJokerNameBinding()
  {
    return factory_.createJokerNameBinding();
  }

  /**
   * Creates an instance of {@link JokerNameBinding} with the given children.
   *
   * @return the new instance of JokerNameBinding.
   */
  public JokerNameBinding createJokerNameBinding(JokerName jokerName, net.sourceforge.czt.z.ast.DeclName declName)
  {
    return factory_.createJokerNameBinding(jokerName, declName);
  }

  /**
   * Creates an instance of {@link Deduction}.
   *
   * @return the new instance of Deduction.
   */
  public Deduction createDeduction()
  {
    return factory_.createDeduction();
  }

  /**
   * Creates an instance of {@link Deduction} with the given children.
   *
   * @return the new instance of Deduction.
   */
  public Deduction createDeduction(java.util.List binding, java.util.List sequent, String name)
  {
    return factory_.createDeduction(binding, sequent, name);
  }

  /**
   * Creates an instance of {@link Rule}.
   *
   * @return the new instance of Rule.
   */
  public Rule createRule()
  {
    return factory_.createRule();
  }

  /**
   * Creates an instance of {@link Rule} with the given children.
   *
   * @return the new instance of Rule.
   */
  public Rule createRule(java.util.List sequent, String name)
  {
    return factory_.createRule(sequent, name);
  }

  /**
   * Creates an instance of {@link CheckProviso}.
   *
   * @return the new instance of CheckProviso.
   */
  public CheckProviso createCheckProviso()
  {
    return factory_.createCheckProviso();
  }

  /**
   * Creates an instance of {@link CheckProviso} with the given children.
   *
   * @return the new instance of CheckProviso.
   */
  public CheckProviso createCheckProviso(SequentContext sequentContext, net.sourceforge.czt.z.ast.Pred pred)
  {
    return factory_.createCheckProviso(sequentContext, pred);
  }

  /**
   * Creates an instance of {@link JokerDeclList}.
   *
   * @return the new instance of JokerDeclList.
   */
  public JokerDeclList createJokerDeclList()
  {
    return factory_.createJokerDeclList();
  }

  /**
   * Creates an instance of {@link JokerDeclList} with the given children.
   *
   * @return the new instance of JokerDeclList.
   */
  public JokerDeclList createJokerDeclList(String name)
  {
    return factory_.createJokerDeclList(name);
  }

  /**
   * Creates an instance of {@link Binding}.
   *
   * @return the new instance of Binding.
   */
  public Binding createBinding()
  {
    return factory_.createBinding();
  }

  /**
   * Creates an instance of {@link TypeProviso}.
   *
   * @return the new instance of TypeProviso.
   */
  public TypeProviso createTypeProviso()
  {
    return factory_.createTypeProviso();
  }

  /**
   * Creates an instance of {@link TypeProviso} with the given children.
   *
   * @return the new instance of TypeProviso.
   */
  public TypeProviso createTypeProviso(SequentContext sequentContext, net.sourceforge.czt.z.ast.Expr expr, net.sourceforge.czt.z.ast.Type type)
  {
    return factory_.createTypeProviso(sequentContext, expr, type);
  }

  /**
   * Creates an instance of {@link JokerDeclListBinding}.
   *
   * @return the new instance of JokerDeclListBinding.
   */
  public JokerDeclListBinding createJokerDeclListBinding()
  {
    return factory_.createJokerDeclListBinding();
  }

  /**
   * Creates an instance of {@link JokerDeclListBinding} with the given children.
   *
   * @return the new instance of JokerDeclListBinding.
   */
  public JokerDeclListBinding createJokerDeclListBinding(JokerDeclList jokerDeclList, java.util.List decl)
  {
    return factory_.createJokerDeclListBinding(jokerDeclList, decl);
  }

  /**
   * Creates an instance of {@link Jokers}.
   *
   * @return the new instance of Jokers.
   */
  public Jokers createJokers()
  {
    return factory_.createJokers();
  }

  /**
   * Creates an instance of {@link Jokers} with the given children.
   *
   * @return the new instance of Jokers.
   */
  public Jokers createJokers(java.util.List name, String kind)
  {
    return factory_.createJokers(name, kind);
  }

  /**
   * Creates an instance of {@link JokerPred}.
   *
   * @return the new instance of JokerPred.
   */
  public JokerPred createJokerPred()
  {
    return factory_.createJokerPred();
  }

  /**
   * Creates an instance of {@link JokerPred} with the given children.
   *
   * @return the new instance of JokerPred.
   */
  public JokerPred createJokerPred(String name)
  {
    return factory_.createJokerPred(name);
  }

  /**
   * Creates an instance of {@link JokerPredBinding}.
   *
   * @return the new instance of JokerPredBinding.
   */
  public JokerPredBinding createJokerPredBinding()
  {
    return factory_.createJokerPredBinding();
  }

  /**
   * Creates an instance of {@link JokerPredBinding} with the given children.
   *
   * @return the new instance of JokerPredBinding.
   */
  public JokerPredBinding createJokerPredBinding(JokerPred jokerPred, net.sourceforge.czt.z.ast.Pred pred)
  {
    return factory_.createJokerPredBinding(jokerPred, pred);
  }


  /**
   * Creates a list of size one with the given object as element.
   * This is a convenience method.
   */
  public java.util.List list(Object o)
  {
    java.util.List result = new java.util.ArrayList();
    result.add(o);
    return result;
  }

  /**
   * Creates a list with the two objects as elements.
   * This is a convenience method.
   */
  public java.util.List list(Object first, Object second)
  {
    java.util.List result = new java.util.ArrayList();
    result.add(first);
    result.add(second);
    return result;
  }

  /**
   * Creates an application (Expr followed by Expr in the syntax),
   * that is an ApplExpr with mixfix set to <code>false</code>.
   * This is a convenience method.
   */
  public ApplExpr createApplication(RefName refName, Expr expr)
  {
    return createApplExpr(createRefExpr(refName), expr, Boolean.FALSE);
  }

  /**
   * Creates a DeclName with the given word and strokes and
   * id set to <code>null</code>.
   * This is a convenience method.
   */
  public DeclName createDeclName(String word, java.util.List strokes)
  {
    return createDeclName(word, strokes, null);
  }

  /**
   * Creates a DeclName from a decorword, that is a string that
   * may contain strokes at the end.
   * The strokes are extracted from the end and the resulting
   * name is returned.
   * This is a convenience method.
   */
  public DeclName createDeclName(String decorword)
  {
    java.util.List strokes = new java.util.ArrayList();
    final String word = getWordAndStrokes(decorword, strokes);
    return createDeclName(word, strokes, null);
  }

  protected String getWordAndStrokes(String decorword, java.util.List strokes)
  {
    net.sourceforge.czt.z.util.ZChar[] zchars =
      net.sourceforge.czt.z.util.ZChar.toZChars(decorword);
    int i;
    for (i = zchars.length - 1; i >= 0; i--) {
      net.sourceforge.czt.z.util.ZChar zchar = zchars[i];
      if (net.sourceforge.czt.z.util.ZChar.INSTROKE.equals(zchar)) {
        strokes.add(0, createInStroke());
      }
      else if (net.sourceforge.czt.z.util.ZChar.OUTSTROKE.equals(zchar)) {
        strokes.add(0, createOutStroke());
      }
      else if (net.sourceforge.czt.z.util.ZChar.PRIME.equals(zchar)) {
        strokes.add(0, createNextStroke());
      }
      else if (i >= 2 &&
          net.sourceforge.czt.z.util.ZChar.NW.equals(zchar) &&
          net.sourceforge.czt.z.util.ZChar.isDigit(zchars[i - 1]) &&
          net.sourceforge.czt.z.util.ZChar.SE.equals(zchars[i - 2])) {
        NumStroke numStroke =
          createNumStroke(new Integer(zchars[i - 1].toString()));
        strokes.add(numStroke);
        i = i - 2;
      }
      else {
        break;
      }
    }
    StringBuffer result = new StringBuffer();
    for (int j = 0; j <= i; j++) {
      result.append(zchars[j].toString());
    }
    return result.toString();
  }

  /**
   * Creates a member predicate that represents equality
   * between the two given expressions.
   * This is a convenience method.
   */
  public MemPred createEquality(Expr left, Expr right)
  {
    return createMemPred(left, createSetExpr(list(right)), Boolean.TRUE);
  }

  /**
   * Creates a function operator application, that is an ApplExpr
   * with mixfix set to <code>true</code>.
   * This is a convenience method.
   */
  public ApplExpr createFunOpAppl(RefName refName, Expr expr)
  {
    return createApplExpr(createRefExpr(refName), expr, Boolean.TRUE);
  }

  /**
   * Creates a generic instantiation expression, that is a RefExpr
   * with mixfix set to <code>false</code>.
   * This is a convenience method.
   */
  public RefExpr createGenInst(RefName refName, java.util.List exprs)
  {
    return createRefExpr(refName, exprs, Boolean.FALSE);
  }

  /**
   * Creates a generic operator application, that is a RefExpr
   * with mixfix set to <code>true</code>.
   * This is a convenience method.
   */
  public RefExpr createGenOpApp(RefName refName, java.util.List exprs)
  {
    return createRefExpr(refName, exprs, Boolean.TRUE);
  }

  /**
   * Creates a horizontal definition, that is an axiomatic definition
   * containing a constant declaration of the name to the given
   * expression and with Box set to OmitBox.
   * This is a convenience method.
   *
   * @param declName name of the schema.
   * @param expr an expression.
   */
  public AxPara createHorizontalDef(DeclName declName, Expr expr)
  {
    return createHorizontalDef(declName, null, expr);
  }

  /**
   * Creates a generic horizontal definition, that is an axiomatic definition
   * containing a constant declaration of the name to the given
   * expression and with Box set to OmitBox.
   * This is a convenience method.
   *
   * @param declName name of the schema.
   * @param formals a list of DeclName, the formal parameters.
   * @param expr an expression.
   */
  public AxPara createHorizontalDef(DeclName declName,
                                    java.util.List formals,
                                    Expr expr)
  {
    ConstDecl constDecl = createConstDecl(declName, expr);
    SchText schText = createSchText(list(constDecl), null);
    return createAxPara(formals, schText, Box.OmitBox);
  }

  /**
   * Creates a member predicate for a given referencing name and
   * an expression, that is a MemPred with mixfix set to <code>false</code>.
   * This is a convenience method.
   */ 
  public MemPred createMemPred(RefName refName, Expr expr)
  {
    return createMemPred(createRefExpr(refName), expr, Boolean.FALSE);
  }

  /**
   * Creates a number expression with the given value.
   * This is a convenience method.
   */
  public NumExpr createNumExpr(int value)
  {
    return createNumExpr(java.math.BigInteger.valueOf(value));
  }

  /**
   * Creates a binary product expression.
   * This is a convenience method.
   */
  public ProdExpr createProdExpr(Expr left, Expr right)
  {
    return createProdExpr(list(left, right));
  }

  /**
   * Creates a reference (expression) to the given name.
   * The mixfix child of the returned reference expression
   * is <code>false</code> and the list of expressions is empty.
   * This is a convenience method.
   */
  public RefExpr createRefExpr(RefName refName)
  {
    return createRefExpr(refName, null, Boolean.FALSE);
  }

  /**
   * Creates a RefName with the given word and strokes and
   * id set to <code>null</code>.
   * This is a convenience method.
   */
  public RefName createRefName(String word, java.util.List strokes)
  {
    return createRefName(word, strokes, null);
  }

  /**
   * Creates a RefName from a decorword, that is a string that
   * may contain strokes at the end.
   * The strokes are extracted from the end and the resulting
   * name is returned.
   * This is a convenience method.
   */
  public RefName createRefName(String decorword)
  {
    java.util.List strokes = new java.util.ArrayList();
    final String word = getWordAndStrokes(decorword, strokes);
    return createRefName(word, strokes, null);
  }

  /**
   * Creates a referencing name that refers to the given
   * declaring name.
   * This is a convenience method.
   */
  public RefName createRefName(DeclName declName)
  {
    return createRefName(declName.getWord(), declName.getStroke(), declName);
  }

  /**
   * Creates a relation operator application, that is a MemPred
   * with mixfix set to <code>true</code>.
   * This is a convenience method.
   */
  public MemPred createRelOpAppl(Expr expr, RefName refName)
  {
    return createMemPred(expr, createRefExpr(refName), Boolean.TRUE);
  }

  /**
   * Creates a schema definition, that is an axiomatic definition
   * containing a constant declaration of the name to the given
   * schema text and with Box set to SchBox.
   * This is a convenience method.
   *
   * @param declName name of the schema.
   * @param schemaText the schema text.
   */
  public AxPara createSchema(DeclName declName, SchText schemaText)
  {
    return createSchema(declName, null, schemaText);
  }

  /**
   * Creates a generic schema definition, that is an axiomatic definition
   * containing a constant declaration of the name to the given
   * schema text and with Box set to SchBox.
   * This is a convenience method.
   *
   * @param formals a list of DeclName, the formal parameters.
   * @param declName name of the schema.
   * @param schemaText the schema text.
   */
  public AxPara createSchema(DeclName declName,
                             java.util.List formals,
                             SchText schemaText)
  {
    ConstDecl constDecl = createConstDecl(declName, createSchExpr(schemaText));
    SchText schText = createSchText(list(constDecl), null);
    return createAxPara(formals, schText, Box.SchBox);
  }

  /**
   * <p>Creates a sequence, that is a set of pairs of position
   * (starting from 1) and corresponding component expression.
   * This applies rule 12.2.12 of the Z standard to a list of
   * expressions.</p>
   *
   * <p>More formally, a list
   * <code>e_1, ..., e_n</code> of expressions is transformed into
   * the set <code>\{ (1, e_1), ... , (n, e_n) \}</code>.
   * </p>
   *
   * <p>This is a convenience method.</p>
   *
   * @param exprList a list of expressions (Expr).
   */
  public SetExpr createSequence(java.util.List exprList)
  {
    java.util.List tupleList = new java.util.ArrayList(exprList.size());
    int count = 1;
    for (java.util.Iterator i = exprList.iterator(); i.hasNext(); count++) {
      tupleList.add(createTupleExpr(createNumExpr(count), (Expr) i.next()));
    }
    return createSetExpr(tupleList);
  }

  /**
   * Creates a pair, that is a tuple expression with two elements.
   * This is a convenience method.
   */
  public TupleExpr createTupleExpr(Expr left, Expr right)
  {
    return createTupleExpr(list(left, right));
  }
}
