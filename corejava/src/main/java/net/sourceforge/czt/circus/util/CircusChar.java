
/*
  Copyright 2005 Leonardo Freitas
  This file is part of the czt project.

  The czt project contains free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  The czt project is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with czt; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package net.sourceforge.czt.circus.util;

import net.sourceforge.czt.z.util.*;

/**
 * An interface for commonly used Circus characters.
 *
 * @author generated by Gnast XSL script circuschar2class.xsl
 */
public class CircusChar extends ZChar
{
  public CircusChar(char[] chars)
  {
    super(chars);
  }



  /**
   * left channel set bracket.
   */
  public static CircusChar LCIRCCHANSET = new CircusChar(Character.toChars(0x2983));

  /**
   * right channel set bracket.
   */
  public static CircusChar RCIRCCHANSET = new CircusChar(Character.toChars(0x2984));

  /**
   * left indexed process instantiation angle bracket.
   */
  public static CircusChar CIRCLINST = new CircusChar(Character.toChars(0x230A));

  /**
   * right indexed process instantiation angle bracket.
   */
  public static CircusChar CIRCRINST = new CircusChar(Character.toChars(0x230B));

  /**
   * left guarded action bracket.
   */
  public static CircusChar LCIRCGUARD = new CircusChar(Character.toChars(0x3014));

  /**
   * right guarded action bracket.
   */
  public static CircusChar RCIRCGUARD = new CircusChar(Character.toChars(0x3015));

  /**
   * left schema expression action bracket.
   */
  public static CircusChar LSCHEXPRACT = new CircusChar(Character.toChars(0x2768));

  /**
   * right schema expression action bracket.
   */
  public static CircusChar RSCHEXPRACT = new CircusChar(Character.toChars(0x2769));

  /**
   * left process renaming bracket.
   */
  public static CircusChar LCIRCRENAME = new CircusChar(Character.toChars(0x3016));

  /**
   * right process renaming bracket.
   */
  public static CircusChar RCIRCRENAME = new CircusChar(Character.toChars(0x3017));

  /**
   * left parallel bracket.
   */
  public static CircusChar LPAR = new CircusChar(Character.toChars(0x27E6));

  /**
   * right parallel bracket.
   */
  public static CircusChar RPAR = new CircusChar(Character.toChars(0x27E7));

  /**
   * left interleave bracket.
   */
  public static CircusChar LINTER = new CircusChar(Character.toChars(0x27E6));

  /**
   * right interleave bracket.
   */
  public static CircusChar RINTER = new CircusChar(Character.toChars(0x27E7));

  /**
   * box drawings thick down and right. Like SCHCHAR.
   */
  public static CircusChar CIRCUSPROCESSCHAR = new CircusChar(Character.toChars(0x250F));

  /**
   * prefix input field colon.
   */
  public static CircusChar PREFIXCOLON = new CircusChar(Character.toChars(0x2236));

  /**
   * Spivey's like definition symbol (or just \defs?).
   */
  public static CircusChar CIRCDEF = new CircusChar(Character.toChars(0x2259));

  /**
   * Process indexing spot or 2A00.
   */
  public static CircusChar CIRCINDEX = new CircusChar(Character.toChars(0x2299));

  /**
   * recursive (least fixed-point) operator.
   */
  public static CircusChar CIRCMU = new CircusChar(Character.toChars(0x00B5));

  /**
   * then for if guarded command.
   */
  public static CircusChar CIRCTHEN = new CircusChar(Character.toChars(0x27FC));

  /**
   * else for if guarded command.
   */
  public static CircusChar CIRCELSE = new CircusChar(Character.toChars(0x25AF));

  /**
   * prefixing.
   */
  public static CircusChar PREFIXTHEN = new CircusChar(Character.toChars(0x27F6));

  /**
   * sequential composition.
   */
  public static CircusChar CIRCSEQ = new CircusChar(Character.toChars(0x037E));

  /**
   * Process interleave.
   */
  public static CircusChar INTERLEAVE = new CircusChar(Character.toChars(0x2980));

  /**
   * Replicated interleave.
   */
  public static CircusChar REPINTERLEAVE = new CircusChar(Character.toChars(0x2AFC));

  /**
   * Replicated Parallelism or 01C1.
   */
  public static CircusChar REPPARALLEL = new CircusChar(Character.toChars(0x2225));

  /**
   * Hiding operator.
   */
  public static CircusChar CIRCHIDING = new CircusChar(Character.toChars(0x2AF5));

  /**
   * External choice.
   */
  public static CircusChar EXTCHOICE = new CircusChar(Character.toChars(0x25FB));

  /**
   * Replicated external choice.
   */
  public static CircusChar REPEXTCHOICE = new CircusChar(Character.toChars(0x25A1));

  /**
   * Internal choice.
   */
  public static CircusChar INTCHOICE = new CircusChar(Character.toChars(0x2293));

  /**
   * Replicated internal choice (TODO:Change Unicode char).
   */
  public static CircusChar REPINTCHOICE = new CircusChar(Character.toChars(0x2294));

  /**
   * mathematical double-struck capital B.
   */
  public static CircusChar BOOLEAN = new CircusChar(Character.toChars(0x1D539));

  /**
   * generalised disjointness.
   */
  public static CircusChar GENDJ = new CircusChar(Character.toChars(0x2A46));

  /**
   * regions of a set of sets.
   */
  public static CircusChar REGIONS = new CircusChar(Character.toChars(0x2A02));

  /**
   * distributed set difference.
   */
  public static CircusChar DSETMINUS = new CircusChar(Character.toChars(0x21F2));

  /**
   * distributed set intersection.
   */
  public static CircusChar DCAP = new CircusChar(Character.toChars(0x25C7));
}
