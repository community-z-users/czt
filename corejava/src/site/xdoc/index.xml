<?xml version="1.0" encoding="UTF-8"?>
<document> 
  <properties> 
    <title>Welcome to Corejava</title> 
  </properties> 
  <body> 
    <p>
      Corejava is part of the
      <a href="http://czt.sourceforge.net/">CZT</a>
      project that aims at providing a framework
      for building formal methods tools, especially for the Z specification
      language.  This subproject provides AST (Annotated Syntax Tree)
      classes for Z written in Java.
    </p>
    <p>
      If you are a Z user and you are looking for existing Z tools,
      you might be more interested in other, more user oriented
      subprojects of CZT (which often use the classes provided here).
      If you are a developer of Z tools, this might be exactly what
      you are looking for.
    </p>
    <p>Features are:</p>
    <ul>
      <li>AST interfaces and classes for standard Z, Object Z,
        and Circus</li>
      <li>Support for the visitor design pattern that allows tools
        to traverse the AST</li>
      <li>XML reader and writer</li>
    </ul>

    <section name="Visitor Support in Corejava">
      <p>
        Corejava provides a variant of the
        <a href="http://www.ccs.neu.edu/research/demeter/adaptive-patterns/visitor-usage/papers/plop96/variations-visitor-nordberg.ps">default visitor</a>
        introduced by Martin E. Nordberg III.
        The default visitor adds another level
        of inheritance to the visitor pattern.
        It provides the possibility to implement default behaviour
        by taking advantage of the inheritance
        relationship of the classes to be visited.
      </p>

      <p>
        Nordberg achieves this by deriving the default visitor from the
        standard visitor, adding visit methods for each abstract AST class,
        and implementing the visit methods in such a way that the visit method
        for a class Foo calls the visit method for class Bar
        where Bar is the base class of Foo.
      </p>

      <p>
        The CZT AST classes already support visit methods for abstact classes.
        Each AST class Foo, concrete as well as abstract,
        has a corresponding FooVisitor interface defining the visitFoo method.
        A visitor may or may not implement this particular interface.
        If an instance of class Foo accepts a visitor, it checks whether the
        visiting visitor implements FooVisitor.  If this is the case,
        this method is called.  However, if the accepted visitor does
        not implement FooVisitor, it is checked whether it implements
        BarVisitor where Bar is the base class of Foo, etc.
        This way, the AST classes itself take care of calling the closest (with
        respect to inheritence hierachy) visit method implemented by the
        visitor.
      </p>

      <p>
        This makes it very easy to implement a visitor that visits each
        element of an AST without being forced to implement all visit methods
        for concrete classes:
      </p>
      <source>
public SimpleVisitor implements TermVisitor
{
  public Object visitTerm(Term term)
  {
    Object[] args = term.getChildren();
    for (int i = 0; i &lt; args.length; i++) {
      if (args[i] instanceof Term) {
        ((Term) args[i]).accept(this);
      }
      else if (args[i] instanceof List) {
        // handle lists ...
      }
    }
    return null;
  }
}
</source>
    </section>
  </body>
</document>
