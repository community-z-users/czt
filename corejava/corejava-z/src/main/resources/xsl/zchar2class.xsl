<?xml version="1.0" encoding="utf-8"?>
<xsl:transform xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="1.0">

  <xsl:output method="text"/>
  <xsl:strip-space elements="*"/>

  <xsl:template match="/">
    <xsl:text>
/*
  Copyright 2003, 2004, 2005 Mark Utting
  This file is part of the czt project.

  The czt project contains free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  The czt project is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with czt; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package net.sourceforge.czt.z.util;

/**
 * Commonly used Z characters and helper methods for Z characters.
 *
 * @author generated by Gnast XSL script zchar2class.xsl
 */
public class ZChar
{
  private static final int ASCII = 256;
  private final int codePoint_;

  public ZChar(char c)
  {
    if (Character.isHighSurrogate(c)) {
      throw new IllegalArgumentException();
    }
    codePoint_ = c;
  }

  public ZChar(int codePoint)
  {
    if (! Character.isValidCodePoint(codePoint)) {
      throw new IllegalArgumentException();
    }
    codePoint_ = codePoint;
  }

  protected ZChar(char high, char low)
  {
    if (! Character.isSurrogatePair(high, low)) {
      throw new IllegalArgumentException();
    }
    char[] chars = new char[2];
    chars[0] = high;
    chars[1] = low;
    codePoint_ = Character.codePointAt(chars, 0);
  }

  public ZChar(char[] chars)
  {
    codePoint_ = Character.codePointAt(chars, 0);
  }

  public int codePoint()
  {
    return codePoint_;
  }

  public int charCount()
  {
    return Character.charCount(codePoint_);
  }

  public boolean equals(Object obj)
  {
    if (obj != null) {
      if (this.getClass().equals(obj.getClass())) {
        ZChar zchar = (ZChar) obj;
        return codePoint_ == zchar.codePoint_;
      }
    }
    return false;
  }
  
  public int hashCode()
  {
	int hashCode = super.hashCode();
    hashCode += codePoint_;
    return hashCode;
  }

  public String toString()
  {
    return String.valueOf(Character.toChars(codePoint_));
  }

  public static ZChar[] toZChars(String string)
  {
    final int numZChars = string.codePointCount(0, string.length());
    ZChar[] result = new ZChar[numZChars];
    int index = 0;
    for (int i = 0; i &lt; numZChars; i++) {
      // This should work but it doesn't (perhaps a bug in Java 1.5?)
      //      final int index = string.offsetByCodePoints(0, i);
      final int codePoint = string.codePointAt(index);
      result[i] = new ZChar(codePoint);
      index = index + result[i].charCount();
    }
    return result;
  }

  public boolean isAsciiChar()
  {
    return codePoint_ &lt; ASCII;
  }

  public static boolean isAlpha(ZChar zchar)
  {
    return isLetter(zchar) || isDigit(zchar);
  }

  public static boolean isDigit(ZChar zchar)
  {
    return Character.isDigit(zchar.codePoint());
  }

  public static boolean isLetter(ZChar zchar)
  {
    return Character.isLetter(zchar.codePoint());
  }

  public static boolean isStroke(ZChar zchar)
  {
    return zchar.equals(INSTROKE) || zchar.equals(OUTSTROKE) ||
      zchar.equals(PRIME);
  }

  public static boolean isWordGlue(ZChar zchar)
  {
    boolean isSE = zchar.equals(SE);
    boolean isSW = zchar.equals(SW);
    boolean isNE = zchar.equals(NE);
    boolean isNW = zchar.equals(NW);
    boolean isLL = zchar.equals(LL);
    return isSE || isSW || isNE || isNW || isLL;
  }

</xsl:text>
<xsl:apply-templates select="*"/>
<xsl:text>
}
</xsl:text>
  </xsl:template>

  <xsl:template match="*[@regexp]"/>

  <xsl:template match="char">
    <xsl:text>

  /**
   * </xsl:text><xsl:value-of select="@description"/><xsl:text>.
   */
  public static final ZChar </xsl:text>
    <xsl:value-of select="@id"/>
    <xsl:text> = new ZChar(0x</xsl:text>
    <xsl:value-of select="@hex"/>
    <xsl:text>);</xsl:text>
  </xsl:template>

</xsl:transform>
