#*
Copyright 2003, 2005, 2006, 2007 Petra Malik
This file is part of the czt project.

The czt project contains free software; you can redistribute it and/or modify
it under the terms of txhe GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

The czt project is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with czt; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-----------------------------------------------------------------------------
Variables and methods used:
  class:     An implementation of GnastClass;
             represents the class to be generated.
             (assumes that an interface is generated as well).
  author:    The author of the generated class.
  copyright: Name of a file containing copyright information to be included
             in the generated file.
  getObject("factory"):
             The name of the AST object factory.  This is used
             in javadoc in order to link from the constructor to the
             object factory.
             
  addAstFinaliser: if ==true, adds a finaliser to the instance counting process
*#
#parse("variables.vm")
/******************************************************************************
DO NOT EDIT THIS FILE!  THIS FILE WAS GENERATED BY GNAST
FROM THE TEMPLATE FILE AstClass.vm.
ANY MODIFICATIONS TO THIS FILE WILL BE LOST UPON REGENERATION.

-------------------------------------------------------------------------------

#if($copyright)#include($copyright)#end
******************************************************************************/

package ${class.ImplPackage};

#foreach($p in $projects)
import ${p.AstPackage}.*;
import ${p.ImplPackage}.*;
#end

// --------------------------------------
// ALL PROPERTIES
// class = ${class}
// class.getClass       = ${class.getClass()}
// class.getPackage     = ${class.getPackage()}
// class.getImplPackage = ${class.getImplPackage()}
// class.getVisitorPack = ${class.getVisitorPackage()}
// class.getAllProps    = ${class.getAllProperties()}
// --------------------------------------
// forall(prop in class getAllProperties) {
// #foreach($prop in ${class.getAllProperties()})
//		prop 									  = ${prop}
//		#if(${prop.isList()})
//		prop.getListType.getFullName 			  = ${prop.getListType().getFullName()}
//		prop.getListType.getPackage  			  = ${prop.getListType().getPackage()}
//
//		prop.getListType.getProject  			  = ${prop.getListType().getProject().getClass()}
//		prop.getListType.getProject.getAstPackage = ${prop.getListType().getProject().getAstPackage()}
//		prop.getListType.getProject.getImplPackage= ${prop.getListType().getProject().getImplPackage()}
//		#else
//		prop.getType.getFullName 			  = ${prop.getType().getFullName()}
//		prop.getType.getPackage  			  = ${prop.getType().getPackage()}
//
//		prop.getType.getProject  			  = ${prop.getType().getProject().getClass()}
//		prop.getType.getProject.getAstPackage = ${prop.getType().getProject().getAstPackage()}
//		prop.getType.getProject.getImplPackage= ${prop.getType().getProject().getImplPackage()}
//		#end
// --------------------------------------
// #end
// class.getProps       =${class.getProperties()}
// --------------------------------------
// forall(prop in class getProperties) {
// #foreach($prop in ${class.getProperties()})
//		prop 		       = ${prop}
//		prop.getClass      = ${prop.getClass()}
//		prop.getVarName    = ${prop.VarName}
//		prop.getMemVarName = ${prop.MemVarName}
//		prop.getGetterName = ${prop.GetterName}
//		prop.SetterName    = ${prop.SetterName}
//		prop.getType	   = ${prop.getType().getClass()}

//		prop.Type.FullName       			  = ${prop.Type.FullName}
//		prop.getType.getFullName 			  = ${prop.getType().getFullName()}
//		prop.getType.getPackage  			  = ${prop.getType().getPackage()}

//		prop.getType.getProject  			  = ${prop.getType().getProject().getClass()}
//		prop.getType.getProject.getAstPackage = ${prop.getType().getProject().getAstPackage()}
//		prop.getType.getProject.getImplPackage= ${prop.getType().getProject().getImplPackage()}
// --------------------------------------
// #end

/**
 * An implementation of the interface
 * {@link ${class.getPackage()}.${class.Name}}.
 *
#if($author) * @author ${author}
#end
 */
#if(${class.isList()})
#set($type = ${class.getAllProperties().get(0).getListType()})
#set($typePack = ${class.getAllProperties().get(0).getListType().getPackage()})
// ${type} + ${typePack}

public class ${class.ImplName}
  extends java.util.AbstractList<${type}>
  implements ${class.getPackage()}.${class.Name}
{
  private net.sourceforge.czt.base.impl.BaseFactory factory_;

  /**
   * The list containing the data.
   */
  /*@ non_null @*/
  private java.util.List<${type}> list_;

  /**
   * A list of annotations.
   */
  private java.util.List<Object> anns_;
  
  #if(! ${class.Abstract})
  /**
   * static instance count for ${class.ImplName}
   */
  private static long instanceCount_ = 0;

  /**
   * public attribute determining whether to log to the 
   * standard output information about who is creating 
   * this instance of ${class.ImplName} (e.g., ic >= sl)
   */
  protected static long startLoggingFrom_ = Long.MAX_VALUE;

  public static final long instanceCount()
  {
    return instanceCount_;
  }
   
  #if($addAstFinaliser)
  private static long instancesFinalised_ = 0;

  /**
   * if GnAST properties contain addAstFiniliser, we add it here 
   * note this will decrease AST performance as finalisers aggregate
   * quite some memory footprint!!!!
   */ 
  @Override
  @SuppressWarnings("FinalizeDeclaration")
  protected void finalize() throws Throwable
  {
    instancesFinalised_++;
    super.finalize();
  }
  // cannot be final because JokerCommunicationImpl extends CommunicationImpl
  public /*final*/ static long instancesFinalised() { return instancesFinalised_;}
  public /*final*/ static boolean countingFinaliser() { return true; }
  #else
  // cannot be final because JokerCommunicationImpl extends CommunicationImpl
  public /*final*/ static boolean countingFinaliser() { return false; }
  public /*final*/ static long instancesFinalised() 
  { 
    throw new UnsupportedOperationException("GnAST AST finalisers have not been set"); 
  }
  #end
  #end

  /**
   * The default constructor.
   *
   * Do not use it explicitly, unless you are extending this class.
   * If you want to create an instance of this class, please use the
   * {@link ${project.getObject("factory")} object factory}.
   */
  protected ${class.ImplName}()
  {
    this(null);
  }

  protected ${class.ImplName}(net.sourceforge.czt.base.impl.BaseFactory factory)
  {
    super();
    factory_ = factory;
    anns_ = null;
    list_ = null;
    #if(! ${class.Abstract})
    instanceCount_++;
  #end
  }
  
  protected java.util.List<${type}> getList()
  {
    if (list_ == null) list_ = new java.util.ArrayList<${type}>(net.sourceforge.czt.base.util.PerformanceSettings.INITIAL_ARRAY_CAPACITY);
    return list_;
  }

  @Override
  public String toString()
  {
    try {
      if (factory_ != null) {
        final String result = factory_.toString(this);
        if (result != null) return result;
      }
    }
    catch (Exception e) {
      e.printStackTrace();
    }
    return super.toString();
  }

  /**
   * Returns a list of annotiations.
   */
  @Override
  public java.util.List<Object> getAnns()
  {
    // synchronise the creation bit to avoid races - rare cases? TODO-CHECK
    //synchronized(this)
    //{
      if (anns_ == null) anns_ = new java.util.ArrayList<Object>(net.sourceforge.czt.base.util.PerformanceSettings.INITIAL_ARRAY_CAPACITY);
    //}
    assert anns_ != null;
    return anns_;
  }

  @Override
  public int annsSize()
  {
    return anns_ == null ? 0 : anns_.size();
  }

  @Override
  public boolean hasAnn()
  {
    return annsSize() > 0;
  }

  public ${class.getPackage()}.${class.Name} ${class.getAllProperties().get(0).GetterName}()
  {
    return this;
  }

  @Override
  @SuppressWarnings("unchecked")
  public <T> T getAnn(Class<T> aClass)
  {
    if (hasAnn()) {
      for (Object annotation : getAnns()) {
        if (aClass.isInstance(annotation)) {
          return (T)annotation;
        }
      }
    }
    return null;
  }
  
  @Override
  public <T> boolean hasAnn(Class<T> aClass)
  {
    return getAnn(aClass) != null;
  }

  @Override
  public <T> void removeAnn(Class<T> aClass)
  {
    if (hasAnn()) {
      java.util.List<Object> anns = getAnns();
      java.util.Iterator<Object> iter = anns.iterator();
      
      while (iter.hasNext()) {
        Object ann = iter.next();
        if (aClass.isInstance(ann)) {
          iter.remove();
        }
      }
      iter = null;
    }
  }

  @Override
  public <T> boolean removeAnn(T annotation)
  {
    boolean result = false;
    if (hasAnn()) {
      java.util.List<Object> anns = getAnns();
      java.util.Iterator<Object> iter = anns.iterator();
      
      while (iter.hasNext() && !result) {
        Object ann = iter.next();
        result = ann.equals(annotation);
      }
      
      if (result) {
        iter.remove();
      }
      iter = null;
    }
    return result;
  }

  /**
   * Inserts the specified element at the specified position in this list.
   * Shifts the element currently at that position (if any) and any
   * subsequent elements to the right (adds one to their indices).
   *
   * @param index the index at which the specified element is to be inserted.
   * @param element the element to be inserted.
   * @throws IndexOutOfBoundsException if the index is out of range
   *         <code>(index < 0 || index > size())</code>.
   */
  @Override
  public void add(int index, ${type} element)
  {
    getList().add(index, element);
  }

  /**
   * Returns the element at the specified position in this list.
   *
   * @param index the index of the elment to be returned.
   * @return the element at the specified position in this list.
   * @throws IndexOutOfBoundsException if the index is out of range
   *         <code>(index < 0 || index >= size())</code>.
   */
  @Override
  public ${type} get(int index)
  {
    return getList().get(index);
  }

  /**
   * Removes the element at the specified position in this list.
   * Shifts any subsequent elements to the left
   * (subtracts one from their indices).
   * Returns the element that was removed from the list.
   *
   * @param index the index of the element to be removed.
   * @return the element previously at the specified position.
   * @throws IndexOutOfBoundsException if the index is out of range
   *         <code>(index < 0 || index >= size())</code>.
   */
  @Override
  public ${type} remove(int index)
  {
    return getList().remove(index);
  }

  /**
   * Replaces the elment at the specifed position
   * in this list with the specified element.
   *
   * @param index the position of the element to replace.
   * @param element the new element to be stored at the specified position.
   * @return the element previously at the specified position.
   * @throws ArrayIndexOutOfBoundsException if <code>index</code>
   *         is out of range <code>(index < 0 || index >= size())</code>.
   */
  @Override
  public ${type} set(int index, ${type} element)
  {
    return getList().set(index, element);
  }

  /**
   * Returns the number of components in this list.
   */
  @Override
  public int size()
  {
    return getList().size();
  }

  @Override
  public <R> R accept(${baseVisitor}<R> v)
  {
    if (v instanceof ${class.VisitorPackage}.${class.Name}Visitor) {
      ${class.VisitorPackage}.${class.Name}Visitor<R> visitor = 
      		(${class.VisitorPackage}.${class.Name}Visitor<R>) v;
      return visitor.visit${class.Name}(this);
    }
    if (v instanceof net.sourceforge.czt.base.visitor.TermVisitor) {
      net.sourceforge.czt.base.visitor.TermVisitor<R> visitor = (net.sourceforge.czt.base.visitor.TermVisitor<R>) v;
      return visitor.visitTerm(this);
    }
    return null;
  }

  @Override
  public Object[] getChildren()
  {
    return getList().isEmpty() ? new Object[0] : getList().toArray();
  }

  @Override
  public ${class.ImplName} create(Object[] args)
  {
    ${class.ImplName} result = new ${class.ImplName}(factory_);
    for (int i = 0; i < args.length; i++) {
      result.add((${type}) args[i]);
    }
    return result;
  }
}
#else
public#abstract($class) class ${class.ImplName}
#if($class.Extends)extends 
	#if(${class.ImplExtends.endsWith("Term")}) 
  		net.sourceforge.czt.base.impl.${class.ImplExtends}
	#else
		${class.getImplPackage()}.${class.ImplExtends}
	#end
#end
  implements ${class.getPackage()}.${class.Name}
{

#if(! ${class.Abstract})
  /**
   * static instance count for ${class.ImplName}
   */
   private static long instanceCount_ = 0;
   
  /**
   * public attribute determining whether to log to the 
   * standard output information about who is creating 
   * this instance of ${class.ImplName} (e.g., ic >= sl)
   */
  protected static long startLoggingFrom_ = Long.MAX_VALUE;
   
  #if($addAstFinaliser)
  private static long instancesFinalised_ = 0;

  /** 
   * if GnAST properties contain addAstFiniliser, we add it here 
   * note this will decrease AST performance as finalisers aggregate
   * quite some memory footprint!!!!
   */ 
  @Override
  @SuppressWarnings("FinalizeDeclaration")
  protected void finalize() throws Throwable
  {
    instancesFinalised_++;
    super.finalize();
  }
  // cannot be final because JokerCommunicationImpl extends CommunicationImpl
  public /*final*/ static long instancesFinalised() { return instancesFinalised_;}
  public /*final*/ static boolean countingFinaliser() { return true; }
  #else
  // cannot be final because JokerCommunicationImpl extends CommunicationImpl
  public /*final*/ static boolean countingFinaliser() { return false; }
  public /*final*/ static long instancesFinalised() 
  { 
    throw new UnsupportedOperationException("GnAST AST finalisers have not been set"); 
  }
  #end
#end

  /**
   * The default constructor.
   *
   * Do not use it explicitly, unless you are extending this class.
   * If you want to create an instance of this class, please use the
   * {@link ${project.getObject("factory")} object factory}.
   */
  protected ${class.ImplName}()
  {
    this(null);
  }

  protected ${class.ImplName}(net.sourceforge.czt.base.impl.BaseFactory factory)
  {
    super(factory);
#if(! ${class.Abstract})
    instanceCount_++;
#end
  }
  
  /**
   * Compares the specified object with this ${class.ImplName}
   * for equality.  Returns true if and only if the specified object is
   * also a(n) ${class.ImplName} and all the getter methods except getAnns
   * return equal objects.
   */
  @Override
  public boolean equals(Object obj)
  {
    if (obj != null) {
      if (this.getClass().equals(obj.getClass()) && super.equals(obj)) {
      	// if foreach on meta-model (.vm) file is empty, this won't be used.
      	//@SuppressWarnings("unused")
        //${class.ImplName} object = ((${class.ImplName}) obj);
#foreach($prop in ${class.Properties})
        if (${prop.MemVarName} != null) {
          if (!${prop.MemVarName}.equals(((${class.ImplName}) obj).${prop.MemVarName})) {
            return false;
          }
        }
        else {
          if (((${class.ImplName}) obj).${prop.MemVarName} != null) {
            return false;
          }
        }
#end
        return true;
      }
    }
    return false;
  }

  /**
   * Returns the hash code value for this ${class.ImplName}.
   */
  @Override
  public int hashCode()
  {
    //final int constant = 31;

    int hashCode = super.hashCode();
    hashCode += "${class.ImplName}".hashCode();
#foreach($prop in ${class.Properties})
    if (${prop.MemVarName} != null) {
      hashCode += 31 * ${prop.MemVarName}.hashCode();
    }
#end
    return hashCode;
  }

  /**
   * Accepts a visitor.
   */
  @Override
  public <R> R accept(${baseVisitor}<R> v)
  {
    if (v instanceof ${class.VisitorPackage}.${class.Name}Visitor) {
      ${class.VisitorPackage}.${class.Name}Visitor<R> visitor = 
      	  (${class.VisitorPackage}.${class.Name}Visitor<R>) v;
      return visitor.visit${class.Name}(this);
    }
    return super.accept(v);
  }

#if(! ${class.Abstract})
#set($methodName = 'create')
  /**
   * Returns a new object of this class.
   */
  public ${class.ImplName} ${methodName}(Object[] args)
  {
    ${class.ImplName} zedObject = null;
    try {
#foreach($prop in ${class.AllProperties})
#set($counter = $velocityCount - 1)
	  #if(${prop.Type.FullName.endsWith(">")})
		  @SuppressWarnings("unchecked")
	  #end
	  #if(${prop.isList()})
	  java.util.List<${prop.ListType.FullName}>
	  	${prop.VarName} = (java.util.List<${prop.ListType.FullName}>) args[$counter];
	  #else
	  ${prop.Type.FullName} ${prop.VarName} = (${prop.Type.FullName}) args[$counter];
	  #end
#end
      zedObject = new ${class.ImplName}(getFactory());
#foreach($prop in $class.AllProperties)
#if(${prop.isList()})
      if (${prop.VarName} != null) {
        zedObject.${prop.GetterName}().addAll(${prop.VarName});
      }
#else
      zedObject.${prop.SetterName}(${prop.VarName});
#end
#end## foreach prop
    }
    catch (IndexOutOfBoundsException e) {
      throw new IllegalArgumentException(e);
    }
    catch (ClassCastException e) {
      throw new IllegalArgumentException(e);
    }
    return zedObject;
  }

#set($methodName = 'getChildren')
  public Object[] ${methodName}()
  {
    Object[] erg = { #getterList(${class.AllProperties}) };
    return erg;
  }
  
  /** Only concrete classes get the instance count method visible */
  // JokerCommunication in circuspatt extends CommunicationImpl which is not abstract? weird...
  public static /*final*/ long instanceCount()
  {
    return instanceCount_;
  }
#end##end if not abstract
#foreach($prop in ${class.Properties})

#if(${prop.isList()})

  private net.sourceforge.czt.base.ast.ListTerm<${prop.ListType.FullName}> ${prop.MemVarName} =
    new net.sourceforge.czt.base.impl.ListTermImpl<${prop.ListType.FullName}>();

  public net.sourceforge.czt.base.ast.ListTerm<${prop.ListType.FullName}> ${prop.GetterName}()
  {
    return ${prop.MemVarName};
  }
#else
  private ${prop.Type.FullName} ${prop.MemVarName};

  public ${prop.Type.FullName} ${prop.GetterName}()
  {
    return ${prop.MemVarName};
  }

  public void ${prop.SetterName}(${prop.Type.FullName} ${prop.VarName})
  {
    ##// ${class.ImplName}
    ##// ${prop.MemVarName}
    ##// ${prop.SetterName}
    ##// $znameImpl
    #if(${class.ImplName} == $znameImpl && (${prop.SetterName} == $znameImplSetWord || ${prop.SetterName} == $znameImplSetId))
      ${prop.SetterName}Internal(${prop.VarName});
    #else
      ${prop.MemVarName} = ${prop.VarName};
  #end
  }
#if(${prop.Type.Name} == 'ExprList' || ${prop.Type.Name} == 'RenameList' || ${prop.Type.Name} == 'NameList' || ${prop.Type.Name} == 'DeclList')
#if(${prop.GetterName} == "get${prop.Type.Name}")
  /**
   * This is a convenience method.
   * It returns a Z${prop.Type.Name} if #${prop.GetterName}
   * returns an instance of Z${prop.Type.Name}
   * and throws an UnsupportedAstClassException otherwise.
   */
  public ${prop.Type.Package}.Z${prop.Type.Name} getZ${prop.Type.Name}()
  {
    ${prop.Type.Package}.${prop.Type.Name} object = ${prop.GetterName}();
    if (object instanceof ${prop.Type.Package}.Z${prop.Type.Name}) {
      return (${prop.Type.Package}.Z${prop.Type.Name}) object;
    }
    final String message = "Expected the Z implementation of ${prop.Type.Package}.${prop.Type.Name}" +
      " but found " + String.valueOf(object);
    throw new net.sourceforge.czt.base.util.UnsupportedAstClassException(message);
  }
#end
#end
#end
#end
#if(${class.AdditionalImplCodeFilename})
#include(${class.AdditionalImplCodeFilename})
#end
}
#end
