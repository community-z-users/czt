
/*
  Copyright 2003, 2004, 2005 Mark Utting
  This file is part of the czt project.

  The czt project contains free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  The czt project is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with czt; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package net.sourceforge.czt.z.util;

/**
 * Commonly used Z characters and helper methods for Z characters.
 *
 * @author generated by Gnast XSL script zchar2class.xsl
 */
public class ZChar
{
  private final int ASCII = 256;
  private int codePoint_;

  public ZChar(char c)
  {
    if (Character.isHighSurrogate(c)) {
      throw new IllegalArgumentException();
    }
    codePoint_ = c;
  }

  public ZChar(int codePoint)
  {
    if (! Character.isValidCodePoint(codePoint)) {
      throw new IllegalArgumentException();
    }
    codePoint_ = codePoint;
  }

  private ZChar(char high, char low)
  {
    if (! Character.isSurrogatePair(high, low)) {
      throw new IllegalArgumentException();
    }
    char[] chars = new char[2];
    chars[0] = high;
    chars[1] = low;
    codePoint_ = Character.codePointAt(chars, 0);
  }

  public ZChar(char[] chars)
  {
    codePoint_ = Character.codePointAt(chars, 0);
  }

  public int codePoint()
  {
    return codePoint_;
  }

  public int charCount()
  {
    return Character.charCount(codePoint_);
  }

  public boolean equals(Object obj)
  {
    if (obj != null) {
      if (this.getClass().equals(obj.getClass())) {
        ZChar zchar = (ZChar) obj;
        return codePoint_ == zchar.codePoint_;
      }
    }
    return false;
  }

  public String toString()
  {
    return String.valueOf(Character.toChars(codePoint_));
  }

  public static ZChar[] toZChars(String string)
  {
    final int numZChars = string.codePointCount(0, string.length());
    ZChar[] result = new ZChar[numZChars];
    int index = 0;
    for (int i = 0; i < numZChars; i++) {
      // This should work but it doesn't (perhaps a bug in Java 1.5?)
      //      final int index = string.offsetByCodePoints(0, i);
      final int codePoint = string.codePointAt(index);
      result[i] = new ZChar(codePoint);
      index = index + result[i].charCount();
    }
    return result;
  }

  public boolean isAsciiChar()
  {
    return codePoint_ < ASCII;
  }

  public static boolean isAlpha(ZChar zchar)
  {
    return isLetter(zchar) || isDigit(zchar);
  }

  public static boolean isDigit(ZChar zchar)
  {
    return Character.isDigit(zchar.codePoint());
  }

  public static boolean isLetter(ZChar zchar)
  {
    return Character.isLetter(zchar.codePoint());
  }

  public static boolean isStroke(ZChar zchar)
  {
    return zchar.equals(INSTROKE) || zchar.equals(OUTSTROKE) ||
      zchar.equals(PRIME);
  }

  public static boolean isWordGlue(ZChar zchar)
  {
    boolean isSE = zchar.equals(SE);
    boolean isSW = zchar.equals(SW);
    boolean isNE = zchar.equals(NE);
    boolean isNW = zchar.equals(NW);
    boolean isLL = zchar.equals(LL);
    return isSE || isSW || isNE || isNW || isLL;
  }



  /**
   * Greek capital letter delta.
   */
  public static ZChar DELTA = new ZChar(0x0394);

  /**
   * Greek capital letter xi.
   */
  public static ZChar XI = new ZChar(0x039E);

  /**
   * Greek small letter theta.
   */
  public static ZChar THETA = new ZChar(0x03B8);

  /**
   * Greek small letter lambda.
   */
  public static ZChar LAMBDA = new ZChar(0x03BB);

  /**
   * Greek small letter mu.
   */
  public static ZChar MU = new ZChar(0x03BC);

  /**
   * double-struck capital A (currently just a strange A).
   */
  public static ZChar ARITHMOS = new ZChar(0x1D538);

  /**
   * double-struck capital N.
   */
  public static ZChar NAT = new ZChar(0x2115);

  /**
   * double-struck capital P.
   */
  public static ZChar POWER = new ZChar(0x2119);

  /**
   * prime.
   */
  public static ZChar PRIME = new ZChar(0x2032);

  /**
   * exclamation mark.
   */
  public static ZChar OUTSTROKE = new ZChar(0x0021);

  /**
   * question mark.
   */
  public static ZChar INSTROKE = new ZChar(0x003F);

  /**
   * north east arrow.
   */
  public static ZChar NE = new ZChar(0x2197);

  /**
   * south west arrow.
   */
  public static ZChar SW = new ZChar(0x2199);

  /**
   * south east arrow.
   */
  public static ZChar SE = new ZChar(0x2198);

  /**
   * north west arrow.
   */
  public static ZChar NW = new ZChar(0x2196);

  /**
   * low line.
   */
  public static ZChar LL = new ZChar(0x005F);

  /**
   * left parenthesis.
   */
  public static ZChar LPAREN = new ZChar(0x0028);

  /**
   * right parenthesis.
   */
  public static ZChar RPAREN = new ZChar(0x0029);

  /**
   * left square bracket.
   */
  public static ZChar LSQUARE = new ZChar(0x005B);

  /**
   * right square bracket.
   */
  public static ZChar RSQUARE = new ZChar(0x005D);

  /**
   * left curly bracket.
   */
  public static ZChar LBRACE = new ZChar(0x007B);

  /**
   * right curly bracket.
   */
  public static ZChar RBRACE = new ZChar(0x007D);

  /**
   * left binding bracket.
   */
  public static ZChar LBIND = new ZChar(0x2989);

  /**
   * right binding bracket.
   */
  public static ZChar RBIND = new ZChar(0x298A);

  /**
   * mathmatical left double angle bracket.
   */
  public static ZChar LDATA = new ZChar(0x27EA);

  /**
   * mathmatical right double angle bracket.
   */
  public static ZChar RDATA = new ZChar(0x27EB);

  /**
   * box drawings light horizontal.
   */
  public static ZChar ZEDCHAR = new ZChar(0x2500);

  /**
   * box drawings light down.
   */
  public static ZChar AXCHAR = new ZChar(0x2577);

  /**
   * box drawings light down and right.
   */
  public static ZChar SCHCHAR = new ZChar(0x250C);

  /**
   * box drawings double horizontal.
   */
  public static ZChar GENCHAR = new ZChar(0x2550);

  /**
   * paragraph separator.
   */
  public static ZChar ENDCHAR = new ZChar(0x2029);

  /**
   * line seperator.
   */
  public static ZChar NLCHAR = new ZChar(0x2028);

  /**
   * space.
   */
  public static ZChar SPACE = new ZChar(0x0020);

  /**
   * vertical line.
   */
  public static ZChar VL = new ZChar(0x007C);

  /**
   * ampersand.
   */
  public static ZChar AMP = new ZChar(0x0026);

  /**
   * right tack.
   */
  public static ZChar VDASH = new ZChar(0x22A2);

  /**
   * logical and.
   */
  public static ZChar AND = new ZChar(0x2227);

  /**
   * logical or.
   */
  public static ZChar OR = new ZChar(0x2228);

  /**
   * rightwards double arrow.
   */
  public static ZChar IMP = new ZChar(0x21D2);

  /**
   * left right double arrow.
   */
  public static ZChar IFF = new ZChar(0x21D4);

  /**
   * not sign.
   */
  public static ZChar NOT = new ZChar(0x00AC);

  /**
   * for all.
   */
  public static ZChar ALL = new ZChar(0x2200);

  /**
   * there exists.
   */
  public static ZChar EXI = new ZChar(0x2203);

  /**
   * cartesian product.
   */
  public static ZChar CROSS = new ZChar(0x00D7);

  /**
   * solidus.
   */
  public static ZChar SOLIDUS = new ZChar(0x002F);

  /**
   * equals sign.
   */
  public static ZChar EQUALS = new ZChar(0x003D);

  /**
   * element of.
   */
  public static ZChar MEM = new ZChar(0x2208);

  /**
   * colon.
   */
  public static ZChar COLON = new ZChar(0x003A);

  /**
   * semicolon.
   */
  public static ZChar SEMICOLON = new ZChar(0x003B);

  /**
   * comma.
   */
  public static ZChar COMMA = new ZChar(0x002C);

  /**
   * full stop.
   */
  public static ZChar DOT = new ZChar(0x002E);

  /**
   * Z notation spot.
   */
  public static ZChar SPOT = new ZChar(0x2981);

  /**
   * big reverse solidus.
   */
  public static ZChar ZHIDE = new ZChar(0x29F9);

  /**
   * schema projection.
   */
  public static ZChar ZPROJ = new ZChar(0x2A21);

  /**
   * schema composition.
   */
  public static ZChar ZCOMP = new ZChar(0x2A1F);

  /**
   * schema piping.
   */
  public static ZChar ZPIPE = new ZChar(0x2A20);

  /**
   * plus sign.
   */
  public static ZChar PLUS = new ZChar(0x002B);

  /**
   * Z notation type colon.
   */
  public static ZChar TYPECOLON = new ZChar(0x2982);

  /**
   * left right arrow.
   */
  public static ZChar REL = new ZChar(0x2194);

  /**
   * rightwards arrow.
   */
  public static ZChar FUN = new ZChar(0x2192);

  /**
   * not equal to.
   */
  public static ZChar NEQ = new ZChar(0x2260);

  /**
   * not an element of.
   */
  public static ZChar NOTMEM = new ZChar(0x2209);

  /**
   * empty set.
   */
  public static ZChar EMPTYSET = new ZChar(0x2205);

  /**
   * subset of or equal to.
   */
  public static ZChar SUBSETEQ = new ZChar(0x2286);

  /**
   * subset of.
   */
  public static ZChar SUBSET = new ZChar(0x2282);

  /**
   * union.
   */
  public static ZChar CUP = new ZChar(0x222A);

  /**
   * intersection.
   */
  public static ZChar CAP = new ZChar(0x2229);

  /**
   * reverse solidus.
   */
  public static ZChar SETMINUS = new ZChar(0x005C);

  /**
   * circled minus.
   */
  public static ZChar SYMDIFF = new ZChar(0x2296);

  /**
   * n-ary union.
   */
  public static ZChar BIGCUP = new ZChar(0x22C3);

  /**
   * n-ary intersection.
   */
  public static ZChar BIGCAP = new ZChar(0x22C2);

  /**
   * mathmematical double-struck capital F (currently just a strange F).
   */
  public static ZChar FINSET = new ZChar(0x1D53D);

  /**
   * rightwards arrow from bar.
   */
  public static ZChar MAPSTO = new ZChar(0x21A6);

  /**
   * relational composition.
   */
  public static ZChar COMP = new ZChar(0x2A3E);

  /**
   * ring operator.
   */
  public static ZChar CIRC = new ZChar(0x2218);

  /**
   * white left-pointing triangle.
   */
  public static ZChar DRES = new ZChar(0x25C1);

  /**
   * white right-pointing triangle.
   */
  public static ZChar RRES = new ZChar(0x25B7);

  /**
   * domain antirestriction.
   */
  public static ZChar NDRES = new ZChar(0x2A64);

  /**
   * range antirestriction.
   */
  public static ZChar NRRES = new ZChar(0x2A65);

  /**
   * tilde operator.
   */
  public static ZChar TILDE = new ZChar(0x223C);

  /**
   * left image bracket.
   */
  public static ZChar LIMG = new ZChar(0x2987);

  /**
   * right image bracket.
   */
  public static ZChar RIMG = new ZChar(0x2988);

  /**
   * circled plus.
   */
  public static ZChar OPLUS = new ZChar(0x2295);

  /**
   * rightwards arrow with vertical stroke.
   */
  public static ZChar PFUN = new ZChar(0x21F8);

  /**
   * rightwards arrow with tail with vertical stroke.
   */
  public static ZChar PINJ = new ZChar(0x2914);

  /**
   * rightwards arrow with tail.
   */
  public static ZChar INJ = new ZChar(0x21A3);

  /**
   * rightwards two-headed arrow with vertical stroke.
   */
  public static ZChar PSURJ = new ZChar(0x2900);

  /**
   * rightwards two-headed arrow.
   */
  public static ZChar SURJ = new ZChar(0x21A0);

  /**
   * rightwards two-headed arrow with tail.
   */
  public static ZChar BIJ = new ZChar(0x2916);

  /**
   * rightwards arrow with double vertical stroke.
   */
  public static ZChar FFUN = new ZChar(0x21FB);

  /**
   * rightwards arrow with tail with double vertical stroke.
   */
  public static ZChar FINJ = new ZChar(0x2915);

  /**
   * double-struck capital Z.
   */
  public static ZChar NUM = new ZChar(0x2124);

  /**
   * hyphen-minus.
   */
  public static ZChar NEG = new ZChar(0x002D);

  /**
   * minus sign.
   */
  public static ZChar MINUS = new ZChar(0x2212);

  /**
   * less-than or equal to.
   */
  public static ZChar LEQ = new ZChar(0x2264);

  /**
   * less-than sign.
   */
  public static ZChar LESS = new ZChar(0x003C);

  /**
   * greater-than or equal to.
   */
  public static ZChar GEQ = new ZChar(0x2265);

  /**
   * greater-than sign.
   */
  public static ZChar GREATER = new ZChar(0x003E);

  /**
   * asterisk (multiplication sign).
   */
  public static ZChar MULT = new ZChar(0x002A);

  /**
   * number sign.
   */
  public static ZChar NUMBER = new ZChar(0x0023);

  /**
   * mathmatical left angle bracket.
   */
  public static ZChar LANGLE = new ZChar(0x27E8);

  /**
   * mathmatical right angle bracket.
   */
  public static ZChar RANGLE = new ZChar(0x27E9);

  /**
   * character tie.
   */
  public static ZChar CAT = new ZChar(0x2040);

  /**
   * upwards harpoon with barb leftwards.
   */
  public static ZChar EXTRACT = new ZChar(0x21BF);

  /**
   * upwards harpoon with barb rightwards.
   */
  public static ZChar FILTER = new ZChar(0x21BE);
}
