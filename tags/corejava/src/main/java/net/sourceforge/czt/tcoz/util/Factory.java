
/******************************************************************************
DO NOT EDIT THIS FILE!  THIS FILE WAS GENERATED BY GNAST
FROM THE TEMPLATE FILE CoreFactory.vm.
ANY MODIFICATIONS TO THIS FILE WILL BE LOST UPON REGENERATION.

-------------------------------------------------------------------------------

Copyright 2003, 2004, 2005 Mark Utting
This file is part of the czt project.

The czt project contains free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

The czt project is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with czt; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
******************************************************************************/

package net.sourceforge.czt.tcoz.util;

import net.sourceforge.czt.tcoz.ast.*;
import net.sourceforge.czt.z.ast.*;
import net.sourceforge.czt.oz.ast.*;

/**
 * <p>An object factory for the AST.
 *
 * <p>This object factory allows the programmer
 * to programatically construct new instances of concrete Z terms.
 * </p>
 *
 * @author Gnast version 0.1
 */
public class Factory
  extends net.sourceforge.czt.oz.util.Factory
{
  private net.sourceforge.czt.tcoz.ast.TcozFactory factory_ =
    new net.sourceforge.czt.tcoz.impl.TcozFactoryImpl();

  /**
   * Creates a new convenience factory that uses the standard factory
   * implementation for creating AST terms.
   */
  public Factory()
  {
    super();
  }

  /**
   * Creates a new convenience factory that uses the given base factory
   * for creating AST terms.
   */
  public Factory(net.sourceforge.czt.tcoz.ast.TcozFactory factory)
  {
    super(factory);
    factory_ = factory;
  }

  /**
   * Creates an instance of {@link WaitUntilProExpr}.
   *
   * @return the new instance of WaitUntilProExpr.
   */
  public WaitUntilProExpr createWaitUntilProExpr()
  {
    return factory_.createWaitUntilProExpr();
  }

  /**
   * Creates an instance of {@link WaitUntilProExpr} with the given children.
   *
   * @return the new instance of WaitUntilProExpr.
   */
  public WaitUntilProExpr createWaitUntilProExpr( net.sourceforge.czt.oz.ast.OpExpr  opExpr, net.sourceforge.czt.z.ast.Expr  waitUntil)
  {
    return factory_.createWaitUntilProExpr(opExpr, waitUntil);
  }

  /**
   * Creates an instance of {@link DistInChoiceProExpr}.
   *
   * @return the new instance of DistInChoiceProExpr.
   */
  public DistInChoiceProExpr createDistInChoiceProExpr()
  {
    return factory_.createDistInChoiceProExpr();
  }

  /**
   * Creates an instance of {@link DistInChoiceProExpr} with the given children.
   *
   * @return the new instance of DistInChoiceProExpr.
   */
  public DistInChoiceProExpr createDistInChoiceProExpr( net.sourceforge.czt.z.ast.SchText  schText, OpExpr  opExpr)
  {
    return factory_.createDistInChoiceProExpr(schText, opExpr);
  }

  /**
   * Creates an instance of {@link ChannelType}.
   *
   * @return the new instance of ChannelType.
   */
  public ChannelType createChannelType()
  {
    return factory_.createChannelType();
  }

  /**
   * Creates an instance of {@link ChannelType} with the given children.
   *
   * @return the new instance of ChannelType.
   */
  public ChannelType createChannelType( net.sourceforge.czt.z.ast.Type2  type)
  {
    return factory_.createChannelType(type);
  }

  /**
   * Creates an instance of {@link DivergeProExpr}.
   *
   * @return the new instance of DivergeProExpr.
   */
  public DivergeProExpr createDivergeProExpr()
  {
    return factory_.createDivergeProExpr();
  }

  /**
   * Creates an instance of {@link SynPllProExpr}.
   *
   * @return the new instance of SynPllProExpr.
   */
  public SynPllProExpr createSynPllProExpr()
  {
    return factory_.createSynPllProExpr();
  }

  /**
   * Creates an instance of {@link SynPllProExpr} with the given children.
   *
   * @return the new instance of SynPllProExpr.
   */
  public SynPllProExpr createSynPllProExpr( OpExpr  leftOpExpr, OpExpr  rightOpExpr, EventSet  events)
  {
    return factory_.createSynPllProExpr(leftOpExpr, rightOpExpr, events);
  }

  /**
   * Creates an instance of {@link AtProExpr}.
   *
   * @return the new instance of AtProExpr.
   */
  public AtProExpr createAtProExpr()
  {
    return factory_.createAtProExpr();
  }

  /**
   * Creates an instance of {@link AtProExpr} with the given children.
   *
   * @return the new instance of AtProExpr.
   */
  public AtProExpr createAtProExpr( Event  event, net.sourceforge.czt.z.ast.Expr  expr, net.sourceforge.czt.oz.ast.OpExpr  opExpr)
  {
    return factory_.createAtProExpr(event, expr, opExpr);
  }

  /**
   * Creates an instance of {@link Connection}.
   *
   * @return the new instance of Connection.
   */
  public Connection createConnection()
  {
    return factory_.createConnection();
  }

  /**
   * Creates an instance of {@link Connection} with the given children.
   *
   * @return the new instance of Connection.
   */
  public Connection createConnection(java.util.List<? extends net.sourceforge.czt.z.ast.RefName>
 leftProcess,java.util.List<? extends net.sourceforge.czt.z.ast.RefName>
 rightProcess,java.util.List<? extends net.sourceforge.czt.z.ast.RefName>
 channels)
  {
    return factory_.createConnection(leftProcess, rightProcess, channels);
  }

  /**
   * Creates an instance of {@link InterruptTimeOpExpr}.
   *
   * @return the new instance of InterruptTimeOpExpr.
   */
  public InterruptTimeOpExpr createInterruptTimeOpExpr()
  {
    return factory_.createInterruptTimeOpExpr();
  }

  /**
   * Creates an instance of {@link InterruptTimeOpExpr} with the given children.
   *
   * @return the new instance of InterruptTimeOpExpr.
   */
  public InterruptTimeOpExpr createInterruptTimeOpExpr( net.sourceforge.czt.oz.ast.OpExpr  normalOp, net.sourceforge.czt.z.ast.Expr  intOrTimeout, net.sourceforge.czt.oz.ast.OpExpr  handlerOp)
  {
    return factory_.createInterruptTimeOpExpr(normalOp, intOrTimeout, handlerOp);
  }

  /**
   * Creates an instance of {@link InChoiceProExpr}.
   *
   * @return the new instance of InChoiceProExpr.
   */
  public InChoiceProExpr createInChoiceProExpr()
  {
    return factory_.createInChoiceProExpr();
  }

  /**
   * Creates an instance of {@link InChoiceProExpr} with the given children.
   *
   * @return the new instance of InChoiceProExpr.
   */
  public InChoiceProExpr createInChoiceProExpr( OpExpr  leftOpExpr, OpExpr  rightOpExpr)
  {
    return factory_.createInChoiceProExpr(leftOpExpr, rightOpExpr);
  }

  /**
   * Creates an instance of {@link EventSet}.
   *
   * @return the new instance of EventSet.
   */
  public EventSet createEventSet()
  {
    return factory_.createEventSet();
  }

  /**
   * Creates an instance of {@link EventSet} with the given children.
   *
   * @return the new instance of EventSet.
   */
  public EventSet createEventSet(java.util.List<? extends net.sourceforge.czt.z.ast.Expr>
 event)
  {
    return factory_.createEventSet(event);
  }

  /**
   * Creates an instance of {@link Event}.
   *
   * @return the new instance of Event.
   */
  public Event createEvent()
  {
    return factory_.createEvent();
  }

  /**
   * Creates an instance of {@link Event} with the given children.
   *
   * @return the new instance of Event.
   */
  public Event createEvent( net.sourceforge.czt.z.ast.RefName  channelName, net.sourceforge.czt.z.ast.Expr  expr)
  {
    return factory_.createEvent(channelName, expr);
  }

  /**
   * Creates an instance of {@link TimeoutEndProExpr}.
   *
   * @return the new instance of TimeoutEndProExpr.
   */
  public TimeoutEndProExpr createTimeoutEndProExpr()
  {
    return factory_.createTimeoutEndProExpr();
  }

  /**
   * Creates an instance of {@link TimeoutEndProExpr} with the given children.
   *
   * @return the new instance of TimeoutEndProExpr.
   */
  public TimeoutEndProExpr createTimeoutEndProExpr( net.sourceforge.czt.oz.ast.OpExpr  normalOp, net.sourceforge.czt.z.ast.Expr  intOrTimeout, net.sourceforge.czt.oz.ast.OpExpr  handlerOp)
  {
    return factory_.createTimeoutEndProExpr(normalOp, intOrTimeout, handlerOp);
  }

  /**
   * Creates an instance of {@link SensorExpr}.
   *
   * @return the new instance of SensorExpr.
   */
  public SensorExpr createSensorExpr()
  {
    return factory_.createSensorExpr();
  }

  /**
   * Creates an instance of {@link SensorExpr} with the given children.
   *
   * @return the new instance of SensorExpr.
   */
  public SensorExpr createSensorExpr( Expr  expr)
  {
    return factory_.createSensorExpr(expr);
  }

  /**
   * Creates an instance of {@link TopologyProExpr}.
   *
   * @return the new instance of TopologyProExpr.
   */
  public TopologyProExpr createTopologyProExpr()
  {
    return factory_.createTopologyProExpr();
  }

  /**
   * Creates an instance of {@link TopologyProExpr} with the given children.
   *
   * @return the new instance of TopologyProExpr.
   */
  public TopologyProExpr createTopologyProExpr(java.util.List<? extends Connection>
 connection)
  {
    return factory_.createTopologyProExpr(connection);
  }

  /**
   * Creates an instance of {@link TimeoutStartProExpr}.
   *
   * @return the new instance of TimeoutStartProExpr.
   */
  public TimeoutStartProExpr createTimeoutStartProExpr()
  {
    return factory_.createTimeoutStartProExpr();
  }

  /**
   * Creates an instance of {@link TimeoutStartProExpr} with the given children.
   *
   * @return the new instance of TimeoutStartProExpr.
   */
  public TimeoutStartProExpr createTimeoutStartProExpr( net.sourceforge.czt.oz.ast.OpExpr  normalOp, net.sourceforge.czt.z.ast.Expr  intOrTimeout, net.sourceforge.czt.oz.ast.OpExpr  handlerOp)
  {
    return factory_.createTimeoutStartProExpr(normalOp, intOrTimeout, handlerOp);
  }

  /**
   * Creates an instance of {@link RecProExpr}.
   *
   * @return the new instance of RecProExpr.
   */
  public RecProExpr createRecProExpr()
  {
    return factory_.createRecProExpr();
  }

  /**
   * Creates an instance of {@link RecProExpr} with the given children.
   *
   * @return the new instance of RecProExpr.
   */
  public RecProExpr createRecProExpr( net.sourceforge.czt.z.ast.RefName  opName, net.sourceforge.czt.oz.ast.OpExpr  opExpr)
  {
    return factory_.createRecProExpr(opName, opExpr);
  }

  /**
   * Creates an instance of {@link ActuatorExpr}.
   *
   * @return the new instance of ActuatorExpr.
   */
  public ActuatorExpr createActuatorExpr()
  {
    return factory_.createActuatorExpr();
  }

  /**
   * Creates an instance of {@link ActuatorExpr} with the given children.
   *
   * @return the new instance of ActuatorExpr.
   */
  public ActuatorExpr createActuatorExpr( Expr  expr)
  {
    return factory_.createActuatorExpr(expr);
  }

  /**
   * Creates an instance of {@link DeadlineProExpr}.
   *
   * @return the new instance of DeadlineProExpr.
   */
  public DeadlineProExpr createDeadlineProExpr()
  {
    return factory_.createDeadlineProExpr();
  }

  /**
   * Creates an instance of {@link DeadlineProExpr} with the given children.
   *
   * @return the new instance of DeadlineProExpr.
   */
  public DeadlineProExpr createDeadlineProExpr( net.sourceforge.czt.oz.ast.OpExpr  opExpr, net.sourceforge.czt.z.ast.Expr  deadline)
  {
    return factory_.createDeadlineProExpr(opExpr, deadline);
  }

  /**
   * Creates an instance of {@link DistInterleaveProExpr}.
   *
   * @return the new instance of DistInterleaveProExpr.
   */
  public DistInterleaveProExpr createDistInterleaveProExpr()
  {
    return factory_.createDistInterleaveProExpr();
  }

  /**
   * Creates an instance of {@link DistInterleaveProExpr} with the given children.
   *
   * @return the new instance of DistInterleaveProExpr.
   */
  public DistInterleaveProExpr createDistInterleaveProExpr( net.sourceforge.czt.z.ast.SchText  schText, OpExpr  opExpr)
  {
    return factory_.createDistInterleaveProExpr(schText, opExpr);
  }

  /**
   * Creates an instance of {@link WaitProExpr}.
   *
   * @return the new instance of WaitProExpr.
   */
  public WaitProExpr createWaitProExpr()
  {
    return factory_.createWaitProExpr();
  }

  /**
   * Creates an instance of {@link WaitProExpr} with the given children.
   *
   * @return the new instance of WaitProExpr.
   */
  public WaitProExpr createWaitProExpr( net.sourceforge.czt.z.ast.Expr  expr)
  {
    return factory_.createWaitProExpr(expr);
  }

  /**
   * Creates an instance of {@link InterruptProExpr}.
   *
   * @return the new instance of InterruptProExpr.
   */
  public InterruptProExpr createInterruptProExpr()
  {
    return factory_.createInterruptProExpr();
  }

  /**
   * Creates an instance of {@link InterruptProExpr} with the given children.
   *
   * @return the new instance of InterruptProExpr.
   */
  public InterruptProExpr createInterruptProExpr( net.sourceforge.czt.oz.ast.OpExpr  normalOp, net.sourceforge.czt.z.ast.Expr  intOrTimeout, net.sourceforge.czt.oz.ast.OpExpr  handlerOp)
  {
    return factory_.createInterruptProExpr(normalOp, intOrTimeout, handlerOp);
  }

  /**
   * Creates an instance of {@link InterleaveProExpr}.
   *
   * @return the new instance of InterleaveProExpr.
   */
  public InterleaveProExpr createInterleaveProExpr()
  {
    return factory_.createInterleaveProExpr();
  }

  /**
   * Creates an instance of {@link InterleaveProExpr} with the given children.
   *
   * @return the new instance of InterleaveProExpr.
   */
  public InterleaveProExpr createInterleaveProExpr( OpExpr  leftOpExpr, OpExpr  rightOpExpr)
  {
    return factory_.createInterleaveProExpr(leftOpExpr, rightOpExpr);
  }

  /**
   * Creates an instance of {@link StopProExpr}.
   *
   * @return the new instance of StopProExpr.
   */
  public StopProExpr createStopProExpr()
  {
    return factory_.createStopProExpr();
  }

  /**
   * Creates an instance of {@link ChannelExpr}.
   *
   * @return the new instance of ChannelExpr.
   */
  public ChannelExpr createChannelExpr()
  {
    return factory_.createChannelExpr();
  }

  /**
   * Creates an instance of {@link SkipProExpr}.
   *
   * @return the new instance of SkipProExpr.
   */
  public SkipProExpr createSkipProExpr()
  {
    return factory_.createSkipProExpr();
  }

  /**
   * Creates an empty list of the given element type.
   * This is a convenience method.
   */
  public <E> java.util.List<E> list()
  {
    java.util.List<E> result = new java.util.ArrayList<E>();
    return result;
  }
  

  /**
   * Creates a list with the given elements.
   * This is a convenience method.
   */
  public <E> java.util.List<E> list(E... elems)
  {
    java.util.List<E> result = new java.util.ArrayList<E>();
    result.addAll(java.util.Arrays.asList(elems));
    return result;
  }

  /**
   * Creates an application (Expr followed by Expr in the syntax),
   * that is an ApplExpr with mixfix set to <code>false</code>.
   * This is a convenience method.
   */
  public ApplExpr createApplication(RefName refName, Expr expr)
  {
    return createApplExpr(createRefExpr(refName), expr, Boolean.FALSE);
  }

  /**
   * Creates a ZDeclName with the given word and strokes and
   * id set to <code>null</code>.
   * This is a convenience method.
   */
  public ZDeclName createZDeclName(String word,
                                   StrokeList strokes)
  {
    return createZDeclName(word, strokes, null);
  }

  /**
   * Creates a ZDeclName from a decorword, that is a string that
   * may contain strokes at the end.
   * The strokes are extracted from the end and the resulting
   * name is returned.
   * This is a convenience method.
   */
  public ZDeclName createZDeclName(String decorword)
  {
    ZStrokeList strokes = createZStrokeList();
    final String word = getWordAndStrokes(decorword, strokes);
    return createZDeclName(word, strokes, null);
  }

  public String getWordAndStrokes(String decorword,
                                  ZStrokeList strokes)
  {
    net.sourceforge.czt.z.util.ZChar[] zchars =
      net.sourceforge.czt.z.util.ZChar.toZChars(decorword);
    int i;
    for (i = zchars.length - 1; i >= 0; i--) {
      net.sourceforge.czt.z.util.ZChar zchar = zchars[i];
      if (net.sourceforge.czt.z.util.ZChar.INSTROKE.equals(zchar)) {
        strokes.add(0, createInStroke());
      }
      else if (net.sourceforge.czt.z.util.ZChar.OUTSTROKE.equals(zchar)) {
        strokes.add(0, createOutStroke());
      }
      else if (net.sourceforge.czt.z.util.ZChar.PRIME.equals(zchar)) {
        strokes.add(0, createNextStroke());
      }
      else if (i >= 2 &&
          net.sourceforge.czt.z.util.ZChar.NW.equals(zchar) &&
          net.sourceforge.czt.z.util.ZChar.isDigit(zchars[i - 1]) &&
          net.sourceforge.czt.z.util.ZChar.SE.equals(zchars[i - 2])) {
        net.sourceforge.czt.base.ast.Digit digit =
          net.sourceforge.czt.base.util.CztDatatypeConverter.parseDigit(zchars[i - 1].toString());
        strokes.add(0, createNumStroke(digit));
        i = i - 2;
      }
      else {
        break;
      }
    }
    StringBuffer result = new StringBuffer();
    for (int j = 0; j <= i; j++) {
      result.append(zchars[j].toString());
    }
    return result.toString();
  }

  /**
   * Creates a member predicate that represents equality
   * between the two given expressions.
   * This is a convenience method.
   */
  public MemPred createEquality(Expr left, Expr right)
  {
    ZExprList zExprList = createZExprList();
    zExprList.add(right);
    return createMemPred(left, createSetExpr(zExprList), Boolean.TRUE);
  }

  /**
   * Creates a function operator application, that is an ApplExpr
   * with mixfix set to <code>true</code>.
   * This is a convenience method.
   */
  public ApplExpr createFunOpAppl(RefName refName, Expr expr)
  {
    return createApplExpr(createRefExpr(refName), expr, Boolean.TRUE);
  }

  /**
   * Creates a generic instantiation expression, that is a RefExpr
   * with mixfix set to <code>false</code>.
   * This is a convenience method.
   */
  public RefExpr createGenInst(RefName refName,
                               java.util.List<? extends Expr> exprs)
  {
    ZExprList zExprList = createZExprList(exprs);
    return createRefExpr(refName, zExprList, Boolean.FALSE);
  }

  /**
   * Creates a generic operator application, that is a RefExpr
   * with mixfix set to <code>true</code>.
   * This is a convenience method.
   */
  public RefExpr createGenOpApp(RefName refName,
                                java.util.List<? extends Expr> exprs)
  {
    ZExprList zExprList = createZExprList(exprs);
    return createRefExpr(refName, zExprList, Boolean.TRUE);
  }

  /**
   * Creates a horizontal definition, that is an axiomatic definition
   * containing a constant declaration of the name to the given
   * expression and with Box set to OmitBox.
   * This is a convenience method.
   *
   * @param declName name of the schema.
   * @param expr an expression.
   */
  public AxPara createHorizontalDef(DeclName declName, Expr expr)
  {
    return createHorizontalDef(declName, null, expr);
  }

  /**
   * Creates a generic horizontal definition, that is an axiomatic definition
   * containing a constant declaration of the name to the given
   * expression and with Box set to OmitBox.
   * This is a convenience method.
   *
   * @param declName name of the schema.
   * @param formals a list of DeclName, the formal parameters.
   * @param expr an expression.
   */
  public AxPara createHorizontalDef(DeclName declName,
                                    java.util.List<? extends DeclName> formals,
                                    Expr expr)
  {
    ZDeclNameList zdnl = createZDeclNameList();
    if (formals != null) {
      zdnl.addAll(formals);
    }
    Decl decl = createConstDecl(declName, expr);
    SchText schText = createZSchText(createZDeclList(list(decl)), null);
    return createAxPara(zdnl, schText, Box.OmitBox);
  }

  /**
   * Creates a member predicate for a given referencing name and
   * an expression, that is a MemPred with mixfix set to <code>false</code>.
   * This is a convenience method.
   */
  public MemPred createMemPred(RefName refName, Expr expr)
  {
    return createMemPred(createRefExpr(refName), expr, Boolean.FALSE);
  }

  /**
   * Creates a number expression with the given value.
   * This is a convenience method.
   */
  public NumExpr createNumExpr(int value)
  {
    return factory_.createNumExpr(createZNumeral(value));
  }

  /**
   * Creates a number expression with the given value.
   * This is a convenience method.
   */
  public NumExpr createNumExpr(java.math.BigInteger bigInt)
  {
    return createNumExpr(bigInt.intValue());
  }

  public ZNumeral createZNumeral(int value)
  {
    return factory_.createZNumeral(java.math.BigInteger.valueOf(value));
  }

  /**
   * Creates a binary product expression.
   * This is a convenience method.
   */
  public ProdExpr createProdExpr(Expr left, Expr right)
  {
    return createProdExpr(createZExprList(list(left, right)));
  }

  public RefExpr createRefExpr(RefName refName,
                               ZExprList zExprList,
                               Boolean mixfix)
  {
    return factory_.createRefExpr(refName, zExprList, mixfix, false);
  }

  /**
   * Creates a reference (expression) to the given name.
   * The mixfix child of the returned reference expression
   * is <code>false</code> and the list of expressions is empty.
   * This is a convenience method.
   */
  public RefExpr createRefExpr(RefName refName)
  {
    return createRefExpr(refName, createZExprList(), Boolean.FALSE);
  }

  /**
   * Creates a ZRefName with the given word and strokes and
   * decl set to <code>null</code>.
   * This is a convenience method.
   */
  public ZRefName createZRefName(String word,
                                 StrokeList strokes)
  {
    return createZRefName(word, strokes, null);
  }

  /**
   * Creates a ZRefName from a decorword, that is a string that
   * may contain strokes at the end.
   * The strokes are extracted from the end and the resulting
   * name is returned.
   * This is a convenience method.
   */
  public ZRefName createZRefName(String decorword)
  {
    ZStrokeList strokes = createZStrokeList();
    final String word = getWordAndStrokes(decorword, strokes);
    return createZRefName(word, strokes, null);
  }

  /**
   * Creates a referencing name that refers to the given
   * declaring name.
   * This is a convenience method.
   */
  public ZRefName createZRefName(ZDeclName declName)
  {
    return createZRefName(declName.getWord(),
			  declName.getStrokeList(),
			  declName);
  }

  /**
   * Creates a relation operator application, that is a MemPred
   * with mixfix set to <code>true</code>.
   * This is a convenience method.
   */
  public MemPred createRelOpAppl(Expr expr, RefName refName)
  {
    return createMemPred(expr, createRefExpr(refName), Boolean.TRUE);
  }

  /**
   * Creates a schema definition, that is an axiomatic definition
   * containing a constant declaration of the name to the given
   * schema text and with Box set to SchBox.
   * This is a convenience method.
   *
   * @param declName name of the schema.
   * @param schemaText the schema text.
   */
  public AxPara createSchema(DeclName declName, SchText schemaText)
  {
    return createSchema(declName, null, schemaText);
  }

  /**
   * Creates a generic schema definition, that is an axiomatic definition
   * containing a constant declaration of the name to the given
   * schema text and with Box set to SchBox.
   * This is a convenience method.
   *
   * @param formals a list of DeclName, the formal parameters.
   * @param declName name of the schema.
   * @param schemaText the schema text.
   */
  public AxPara createSchema(DeclName declName,
                             java.util.List<? extends DeclName> formals,
                             SchText schemaText)
  {
    ZDeclNameList zdnl = createZDeclNameList();
    if (formals != null) {
      zdnl.addAll(formals);
    }
    Decl decl = createConstDecl(declName, createSchExpr(schemaText));
    SchText schText = createZSchText(createZDeclList(list(decl)), null);
    return createAxPara(zdnl, schText, Box.SchBox);
  }

  /**
   * <p>Creates a sequence, that is a set of pairs of position
   * (starting from 1) and corresponding component expression.
   * This applies rule 12.2.12 of the Z standard to a list of
   * expressions.</p>
   *
   * <p>More formally, a list
   * <code>e_1, ..., e_n</code> of expressions is transformed into
   * the set <code>\{ (1, e_1), ... , (n, e_n) \}</code>.
   * </p>
   *
   * <p>This is a convenience method.</p>
   *
   * @param exprList a list of expressions (Expr).
   */
  public SetExpr createSequence(java.util.List<? extends Expr> exprList)
  {
    ZExprList zExprList = createZExprList();
    int count = 1;
    for (java.util.Iterator<? extends Expr> i = exprList.iterator();
         i.hasNext(); count++) {
      zExprList.add(createTupleExpr(createNumExpr(count), i.next()));
    }
    return createSetExpr(zExprList);
  }

  /**
   * Creates a pair, that is a tuple expression with two elements.
   * This is a convenience method.
   */
  public TupleExpr createTupleExpr(Expr left, Expr right)
  {
    return createTupleExpr(createZExprList(list(left, right)));
  }

  public java.math.BigInteger toBig(Integer i)
  {
    if (i != null) {
      return java.math.BigInteger.valueOf(i.intValue());
    }
    return null;
  }

  public NumStroke createNumStroke(int value)
  {
    net.sourceforge.czt.base.ast.Digit digit =
      net.sourceforge.czt.base.ast.Digit.fromValue(value);
    return createNumStroke(digit);
  }

  public LocAnn createLocAnn(String source, Integer line, Integer col)
  {
    return createLocAnn(source, line, col, null, null);
  }

  public LocAnn createLocAnn(String source,
                             Integer line, Integer col,
                             Integer start, Integer length)
  {
    return createLocAnn(source,
                        toBig(line), toBig(col),
                        toBig(start), toBig(length));
  }
}
