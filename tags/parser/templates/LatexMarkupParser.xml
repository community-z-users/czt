<?xml version="1.0" encoding="utf-8"?>
<scanner xmlns:add="http://czt.sourceforge.net/templates/additional">
/*
  Copyright (C) 2004, 2005, 2006 Petra Malik
  This file is part of the CZT project: http://czt.sourceforge.net

  The CZT project contains free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License as published
  by the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  The CZT project is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License along
  with CZT; if not, write to the Free Software Foundation, Inc.,
  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package <package/>;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import net.sourceforge.czt.parser.util.*;
import net.sourceforge.czt.parser.z.ZParseError;
import net.sourceforge.czt.parser.z.ZParseMessage;
import net.sourceforge.czt.session.*;
import net.sourceforge.czt.util.CztLogger;
import net.sourceforge.czt.z.ast.Directive;
import net.sourceforge.czt.z.ast.DirectiveType;
import net.sourceforge.czt.z.util.Factory;
import net.sourceforge.czt.z.util.ZChar;

/**
 * A latex markup parser that looks like a scanner.
 * Instances of this class are usually used after the Latex2Unicode
 * converter.  It preprocesses the output of the converter and updates
 * the markup function appropriately.  It is possible to use the same
 * markup function in the converter if each markup command is used
 * AFTER it is defined in a markup directive.
 */
public class <class/>
  implements Lexer
{
  private static Factory factory_ = new Factory();

  /**
   * The latex to unicode scanner that provides the input.
   */
  private LatexLexer lexer_;

  /**
   * Section information.
   */
  private SectionInfo sectInfo_;

  /**
   * The markup function for the current section.
   */
  private LatexMarkupFunction markupFunction_ = null;

  /**
   * All markup functions created so far.
   */
  private Map markupFunctions_ = new HashMap();

  /**
   * Are we just parsing a section header?
   */
  private boolean sectHead_ = false;

  /**
   * The current section name.
   */
  private String sectName_ = null;

  /**
   * The parents of the current section.
   */
  private String parents_ = null;

  /**
   * The token returned by the last call to method next_token.
   */
  private LocToken symbol_ = null;

  /**
   * Creates a new latex markup parser that uses the scanner provided.
   * The section information should be able to provide information of type
   * &lt;code&gt; 
   * net.sourceforge.czt.parser.util. LatexMarkupFunction.class&lt;/code&gt;.
   */
  public <class/>(LatexLexer lexer, SectionInfo sectInfo)
  {
    lexer_ = lexer;
    sectInfo_ = sectInfo;
  }

  public Source getSource()
  {
    return lexer_.getSource();
  }

  /**
   * Adds the markup function of the given specification
   * to the current markup function.
   *
   * @param parent the name of the parent specification.
   */
  private void addMarkupFunction(String parent)
  {
    if (markupFunction_ == null) {
      markupFunction_ = new LatexMarkupFunction(sectName_);
      markupFunctions_.put(sectName_, markupFunction_);
      lexer_.setMarkupFunction(markupFunction_);
    }
    LatexMarkupFunction markupFunction =
      (LatexMarkupFunction) markupFunctions_.get(parent);
    if (markupFunction == null) {
      try {
        markupFunction = (LatexMarkupFunction)
          sectInfo_.get(new Key(parent, LatexMarkupFunction.class));
      }
      catch (CommandException exception) {
        String message = "Cannot get LatexMarkupFunction for " + parent
          + "; try to continue anyway";
        CztLogger.getLogger(LatexMarkupFunctionVisitor.class).warning(message);
      }
    }
    if (markupFunction != null) {
      try {
        markupFunction_.add(markupFunction);
      }
      catch (MarkupException e) {
        throw new RuntimeException(e);
      }
    }
  }

  private boolean is(LocToken token, LatexSym sym)
  {
    return token.getName().equals(sym.toString());
  }

  public LocToken next()
    throws IOException
  {
    final LocToken token = lexer_.next();
    if (token == null) {
      updateLatexMarkupFunction();
      return token;
    }
    final boolean isStartOfAnonymousSpec = sectName_ == null &amp;&amp;
        (is(token, LatexSym.CHAR_MARKUP) ||
         is(token, LatexSym.WORD_MARKUP) ||
         is(token, LatexSym.INWORD_MARKUP) ||
         is(token, LatexSym.PREWORD_MARKUP) ||
         is(token, LatexSym.POSTWORD_MARKUP) ||
         is(token, LatexSym.UNICODE));
    if (isStartOfAnonymousSpec) {
      // we are parsing an anonymous specification
      sectName_ = "Specification";
      parents_ = "standard_toolkit<add:oz>, oz_toolkit</add:oz><add:circus>, circus_toolkit</add:circus>";
      addMarkupFunction("prelude");
<add:oz>
      addMarkupFunction("oz_toolkit");
</add:oz>
<add:circus>
      addMarkupFunction("circus_toolkit");
</add:circus>
      addMarkupFunction("standard_toolkit");
    }
    if (sectHead_) { // we are just parsing a section header
      if (is(token, LatexSym.END)) { // end of section header
        sectName_ = sectName_.trim();
        markupFunction_ = new LatexMarkupFunction(sectName_);
        markupFunctions_.put(sectName_, markupFunction_);
        lexer_.setMarkupFunction(markupFunction_);
        if (! sectName_.equals("prelude")) {
          addMarkupFunction("prelude");
        }
<add:oz>
        if (! sectName_.equals("prelude") &amp;&amp;
            ! sectName_.equals("oz_toolkit")) {
          addMarkupFunction("oz_toolkit");
        }
</add:oz>
<add:circus>
        /* Educated guess that it is needed based on Oz code */
        if (! sectName_.equals("prelude") &amp;&amp;
            ! sectName_.equals("circus_toolkit")) {
          addMarkupFunction("circus_toolkit");
        }
</add:circus>
        if (parents_ != null) {
          String[] parents = parents_.split(",");
          for (int i = 0; i &lt; parents.length; i++) {
            String parent = parents[i].trim();
            if (parent != null &amp;&amp; ! parent.equals("")) {
              addMarkupFunction(parent);
            }
          }
        }
        sectHead_ = false;
      }
      else if (is(token, LatexSym.SECTION)) { // section token
        // start parsing section name
        sectName_ = "";
      }
      else if (is(token, LatexSym.PARENTS)) { // parents token
        // start parsing parents
        parents_ = "";
      }
      else {
        if (parents_ != null) {
          parents_ += token.spelling();
        }
        else if (sectName_ != null) {
          sectName_ += token.spelling();
        }
        else {
          System.err.println("Unexpected token '" + token.spelling() +
                             "' within a section header.");
        }
      }
    }
    else if (is(token, LatexSym.SECT)) { // begin of a section header
      updateLatexMarkupFunction();
      sectHead_ = true;
      parents_ = null;
      sectName_ = null;
    }
    else if (is(token, LatexSym.CHAR_MARKUP)) {
      Directive directive = parseCharMarkupDirective(token.spelling(),
                                                     token.getLocation());
      if (directive != null) {
        try {
          markupFunction_.add(directive);
        }
        catch (MarkupException e) {
          throw new RuntimeException(e);
        }
      }
      return next();
    }
    else if (is(token, LatexSym.WORD_MARKUP)) {
      parseWordMarkup(DirectiveType.NONE, token.getLocation());
    }
    else if (is(token, LatexSym.INWORD_MARKUP)) {
      parseWordMarkup(DirectiveType.IN, token.getLocation());
    }
    else if (is(token, LatexSym.PREWORD_MARKUP)) {
      parseWordMarkup(DirectiveType.PRE, token.getLocation());
    }
    else if (is(token, LatexSym.POSTWORD_MARKUP)) {
      parseWordMarkup(DirectiveType.POST, token.getLocation());
    }
    check(symbol_, token);
    if (token.spelling() != null) {
      symbol_ = token;
    }
    return token;
  }

  private void updateLatexMarkupFunction()
  {
    if (markupFunction_ != null) {
      final Key key =
        new Key(markupFunction_.getSection(), LatexMarkupFunction.class);
      sectInfo_.put(key, markupFunction_, null);
    }
  }

  private void check(LocToken t1, LocToken t2)
  {
    if (t1 != null &amp;&amp; t2 != null) {
      if (is(t1, LatexSym.UNICODE) &amp;&amp; is(t2, LatexSym.UNICODE)) {
        String s1 = t1.spelling();
        String s2 = t2.spelling();
        if (s1 != null &amp;&amp; s1.length() > 0 &amp;&amp;
            s2 != null &amp;&amp; s2.length() > 0) {
          final ZChar[] zchars1 = ZChar.toZChars(s1);
          final ZChar[] zchars2 = ZChar.toZChars(s2);
          ZChar c1 = zchars1[zchars1.length - 1];
          ZChar c2 = zchars2[0];
          final boolean c1IsLetterOrDigit =
            ZChar.isDigit(c1) || ZChar.isLetter(c1);
          final boolean c2IsLetterOrDigit =
            ZChar.isDigit(c2) || ZChar.isLetter(c2);
          final boolean c1IsDeltaOrXi =
            ZChar.DELTA.equals(c1) || ZChar.XI.equals(c1);
          final boolean cond =
            c1IsLetterOrDigit &amp;&amp; c2IsLetterOrDigit &amp;&amp; 
              ! c1IsDeltaOrXi;
          if (cond) {
            ZParseError.report(sectInfo_,
                               getSource(),
                               ErrorType.WARNING,
                               ZParseMessage.MSG_POSSIBLE_MISSING_SPACE,
                               new Object[0],
                               t2.getLocation());
          }
        }
      }
    }
  }

  private void parseWordMarkup(DirectiveType type, LocInfo location)
    throws IOException
  {
    String name = parseName();
    String latex = parseUnicode();
    Directive directive = factory_.createDirective(name, latex, type);
    directive.getAnns().add(factory_.createLocAnn(location.getSource(),
                                                  location.getLine(),
                                                  null));
    try {
      markupFunction_.add(directive);
    }
    catch (MarkupException e) {
      throw new RuntimeException(e);
    }
  }

  private String parseName()
    throws IOException
  {
    LocToken token = lexer_.next();
    if (is(token, LatexSym.NAME)) {
      return token.spelling();
    }
    System.err.println("Error while parsing markup directive.");
    return null;
  }

  private String parseUnicode()
    throws IOException
  {
    String result = "";
    LocToken token = lexer_.next();
    while (token != null &amp;&amp;
           ! is(token, LatexSym.END_MARKUP)) {
      result += token.spelling();
      token = lexer_.next();
    }
    return result;
  }

  public static Directive parseCharMarkupDirective(String directive,
                                                   LocInfo loc)
  {
    String[] splitted = directive.split("[ \t]+");
    final int expectedLength = 3;
    if (splitted.length == expectedLength) {
      DirectiveType type = DirectiveType.NONE;
      String name = splitted[1];
      if ("%%Zprechar".equals(splitted[0])) {
        type = DirectiveType.PRE;
      }
      else if ("%%Zpostchar".equals(splitted[0])) {
        type = DirectiveType.POST;
      }
      else if ("%%Zinchar".equals(splitted[0])) {
        type = DirectiveType.IN;
      }

      if (splitted[2].startsWith("U+")) {
        final int beginString = 2;
        final int endString = 6;
        String hexValue = splitted[2].substring(beginString, endString);
        final int hexBase = 16;
        int decimal = Integer.parseInt(hexValue, hexBase);
        char[] chars = Character.toChars(decimal);
        String unicode = new String(chars);
        Directive d = factory_.createDirective(name, unicode, type);
        d.getAnns().add(factory_.createLocAnn(loc.getSource(),
                                              loc.getLine(),
                                              null));
        return d;
      }
      else if (splitted[2].startsWith("U-")) {
        final int beginString = 2;
        final int endString = 10;
        String hexValue = splitted[2].substring(beginString, endString);
        final int hexBase = 16;
        int decimal = Integer.parseInt(hexValue, hexBase);
        char[] chars = Character.toChars(decimal);
        String unicode = new String(chars);
        Directive d = factory_.createDirective(name, unicode, type);
        d.getAnns().add(factory_.createLocAnn(loc.getSource(),
                                              loc.getLine(),
                                              null));
        return d;
      }
      System.err.println("WARNING: Cannot parse " + directive);
      return null;
    }
    System.err.println("WARNING: Cannot parse " + directive);
    return null;
  }

  public interface LatexLexer
    extends Lexer
  {
    void setMarkupFunction(LatexMarkupFunction markupFunction);
  }
}
</scanner>
