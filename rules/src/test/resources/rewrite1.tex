\begin{zsection}
\SECTION rewrite1 \parents unfold, simplification\_rules
\end{zsection}

\begin{theorem}{theorem1}
  \vdash? true \iff true
\end{theorem}




\begin{schema}{Simple}
  x: \nat
\end{schema}

\begin{theorem}{theorem2}
  \vdash? Simple =
    [x : \arithmos | x \in \nat]
\end{theorem}

\begin{theorem}{theorem3}
  \vdash? \Delta Simple =
    [x : \arithmos; x' : \arithmos | x \in \nat \land x' \in \nat]
\end{theorem}

\begin{theorem}{theorem4}
  \vdash? \Xi Simple =
    [x : \arithmos; x' : \arithmos | x \in \nat \land x' \in \nat \land
       \lblot x == x \rblot  = \lblot x == x' \rblot ]
\end{theorem}

\begin{theorem}{theorem5}
  \vdash? Simple~' =
    [x' : \arithmos | x' \in \nat]
\end{theorem}

\begin{theorem}{theoremNegation}
  \vdash? (\lnot Simple) = [x:\arithmos | \lnot (x \in \nat)]
\end{theorem}

\begin{theorem}{theoremConjunction}
  \vdash? (Simple \land Simple~') = [x : \arithmos; x' : \arithmos | x \in \nat \land x' \in \nat]
\end{theorem}

\begin{theorem}{theoremDisjunction}
  \vdash? (Simple \lor Simple~') = [x : \arithmos; x' : \arithmos | x \in \nat \lor x' \in \nat]
\end{theorem}

\begin{theorem}{theoremImplication}
  \vdash? (Simple \implies Simple~') = [x : \arithmos; x' : \arithmos | x \in \nat \implies x' \in \nat]
\end{theorem}

\begin{theorem}{theoremEquivalence}
  \vdash? (Simple \iff Simple~') = [x : \arithmos; x' : \arithmos | x \in \nat \iff x' \in \nat]
\end{theorem}

\begin{theorem}{Theta}
  \vdash? (\mu Simple @ \theta Simple) =
          (\mu x : \arithmos | x \in \nat @ \lblot x == x \rblot )
\end{theorem}

\begin{theorem}{ThetaPrime}
  \vdash? (\mu Simple~' @ \theta Simple~') =
          (\mu x' : \arithmos | x' \in \nat @ \lblot x == x' \rblot )
\end{theorem}

\begin{theorem}{SimpleProjection}
  \vdash? Simple \project Simple =
         [ x : \arithmos | (\exists | true @ x \in \nat) ]
\end{theorem}

\begin{theorem}{SimpleProjection2}
  \vdash? Simple \project [| true] =
         [ | (\exists  x : \arithmos | true @ x \in \nat) ]
\end{theorem}

\begin{schema}{SimpleConstDecl}
  y == 3
\end{schema}

\begin{theorem}{theoremSimpleConstDecl}
  \vdash? SimpleConstDecl =
    [ y : \arithmos | y = 3 ]
\end{theorem}

\begin{theorem}{theorem10}
  \vdash? (\exists Simple @ SimpleConstDecl) =
    [ y : \arithmos | 
      (\exists x : \arithmos @ x \in \nat \land y = 3) ]
\end{theorem}


\begin{schema}{SimpleGen}[T]
  x: T
\end{schema}

\begin{theorem}{theorem2Gen}
  \vdash? SimpleGen[\nat] =
    [ x : \arithmos | x \in \nat ]
\end{theorem}




Unfolding birthdaybook:

\begin{zed}[NAME, DATE]\end{zed}

\begin{schema}{BirthdayBook}
    known: \power NAME \\
    birthday: NAME \pfun DATE
\where
    known=\dom birthday
\end{schema}

\begin{theorem}{BirthdayBookUnfolded}
  \vdash? BirthdayBook =
    [ known : \power NAME ; birthday : \power ( NAME \cross DATE )
    | birthday \in NAME \pfun DATE \land known = \dom birthday ]
\end{theorem}
