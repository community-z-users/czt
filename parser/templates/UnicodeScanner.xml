<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright 2003 Mark Utting
     This file is part of the czt project.
     
     The czt project contains free software;
     you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     
     The czt project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     
     You should have received a copy of the GNU General Public License
     along with czt; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
     -->

<scanner xmlns:add="http://czt.sourceforge.net/templates/additional">
/**
 * This is a scanner for lexing
<add:z> * Z specifications</add:z>
<add:oz> * Object Z specifications</add:oz>
<add:tcoz> * TCOZ specifications</add:tcoz>
 * in unicode format as described in the Z standard.
 * Numbers in brackets contained in comments refer to
 * the corresponding sections in this document.
 *
 * @author Petra Malik
 */

/* --------------------------Usercode Section------------------------ */
package <package/>;

import java.io.*;
import java_cup.runtime.*;
      
import net.sourceforge.czt.parser.util.CztReader;
import net.sourceforge.czt.parser.util.DebugUtils;
import net.sourceforge.czt.parser.util.ScanException;

%%
/* -----------------Options and Declarations Section----------------- */
%class <class/>
%public
%unicode
%line
%column
%char
%cupsym Sym
%cup
   
%{
  <add:oz>
  /**
   * Records whether the number of paragraph "begins", so we know
   * when to return to the initial state.
   */
  private int begins_ = 0;
  </add:oz>

  /**
   * Lexes a given file.
   */
  public static void main(String argv[]) {    
    try {
      InputStream stream = new FileInputStream(argv[0]);
      InputStreamReader reader = new InputStreamReader(stream, "UTF-8");

      <class/> scanner = new <class/>(reader);
      DebugUtils.scan(scanner, Sym.class);
    }
    catch (Exception e) {
      e.printStackTrace();
    }
  }

  /**
   * Creates a new java_cup.runtime.Symbol with line and column
   * information about the current token.
   * The token will have no value.
   */
  private Symbol symbol(int type)
  {
    return new Symbol(type, getLine(), getColumn());
  }

  /**
   * Creates a new java_cup.runtime.Symbol with line and column
   * information about the current token.
   *
   * @param value the value of the Symbol to be returned.
   * @return a new Symbol with column and line information
   *         and the given value.
   */
  private Symbol symbol(int type, Object value)
  {
    return new Symbol(type, getLine(), getColumn(), value);
  }

  private int getLine()
  {
    if (yy_reader instanceof CztReader) {
      CztReader reader = (CztReader) yy_reader;
      return reader.getLine(yychar);
    }
    return yyline;
  }

  private int getColumn()
  {
    if (yy_reader instanceof CztReader) {
      CztReader reader = (CztReader) yy_reader;
      return reader.getColumn(yychar);
    }
    return yycolumn;
  }

%}
   
/***********************************************************************
  Z characters (6.2)
 ***********************************************************************/

/* TODO: Distinguish between DIGIT and DECIMAL */
DIGIT = {DECIMAL}
DECIMAL = [:digit:]

/* TODO: What about OTHERLETTER? */
LETTER = [:letter:]

SPECIAL =   {STROKECHAR}
          | {WORDGLUE}
          | {BRACKET}
          | {BOXCHAR}
          | {NLCHAR}
          | {SPACE}
          | {CONTROL}

/* NOT_SYMBOL ist only needed to define SYMBOL */
NOT_SYMBOL = {DIGIT} | {LETTER} | {SPECIAL} | "\t"

/* SYMBOL are all the characters that are not NOT_SYMBOL */
SYMBOL = !(![^] | {NOT_SYMBOL})

/* SPECIAL
   ======= */

/* Stroke */
STROKECHAR = {INSTROKE} | {OUTSTROKE} | {NEXTSTROKE}
INSTROKE = "\u003F"   /* question mark */
OUTSTROKE = "\u0021"  /* exclamation mark */
NEXTSTROKE = "\u2032" /* prime */

/* Word glue (6.4.4.2) */
WORDGLUE = {NE} | {SE} | {SW} | {NW} | {LL}
NE = "\u2197" /* north east arrow */
SW = "\u2199" /* south west arrow */
SE = "\u2198" /* south east arrow */
NW = "\u2196" /* north west arrow */
LL = "\u005F" /* low line */

/* Bracket characters (6.4.4.3) */
BRACKET = {LPAREN} | {RPAREN} | {LSQUARE} | {RSQUARE} | {LBRACE} | {RBRACE} | {LBIND} | {RBIND} | {LDATA} | {RDATA}
LPAREN = "\u0028"  /* left parenthesis */
RPAREN = "\u0029"  /* right parenthesis */
LSQUARE = "\u005B" /* left square bracket */
RSQUARE = "\u005D" /* right square bracket */
LBRACE = "\u007B"  /* left curly bracket */
RBRACE = "\u007D"  /* right curly bracket */
LBIND = "\u2989"   /* Z notation left binding bracket */
RBIND = "\u298A"   /* Z notation right binding bracket */
LDATA = "\u27EA"   /* mathmatical left double angle bracket */
RDATA = "\u27EB"   /* mathmatical right double angle bracket */

/* Box characters (6.4.4.3) */
BOXCHAR = {ZEDCHAR} | {AXCHAR} | {SCHCHAR} | {GENCHAR} | {ENDCHAR}
ZEDCHAR = "\u2500" /* box drawings light horizontal */
AXCHAR = "\u2577"  /* box drawings light down */
SCHCHAR = "\u250C" /* box drawings light down and right */
GENCHAR = "\u2550" /* box drawings double horizontal */
ENDCHAR = "\u2029" /* paragraph separator */
<add:oz>
STATECHAR = "\u2500" /* horizontal line */
</add:oz>

/* Other SPECIAL characters (6.4.4.5) */
NLCHAR = "\u2028" | {CR} {LF} | {CR} | {LF}  /* line separator TODO add BEF*/
SPACE =   "\u0020" /* space */

CONTROL = {TAB}
LF = "\n"
CR = "\r"
TAB = "\t"

NOT_BOXCHAR = !(![^] | {BOXCHAR})
TEXT = {NOT_BOXCHAR}*

/***********************************************************************
  Lexis (7)
 ***********************************************************************/

DECORWORD = {WORD} {STROKE}*
WORD =   {WORDPART}+
       | {LETTER} {ALPHASTR} {WORDPART}*
       | {SYMBOL}+ {WORDPART}*
WORDPART = {WORDGLUE} ( {ALPHASTR} | {SYMBOL}* )
ALPHASTR = ({LETTER} | {DIGIT})*
NUMERAL = {DIGIT}+
STROKE = {STROKECHAR} | {SE} {DIGIT} {NW}
ZED = {ZEDCHAR}
AX = {AXCHAR}
SCH = {SCHCHAR}
GENAX = {AXCHAR} {GENCHAR}
GENSCH = {SCHCHAR} {GENCHAR}
END = {ENDCHAR}
NL = {NLCHAR}

%state Z

%%
/* ------------------------Lexical Rules Section---------------------- */

&lt;YYINITIAL&gt; {
  {ZED}         {  <add:oz>begins_++;</add:oz>
                   yybegin(Z); return symbol(Sym.ZED); }
  {AX}          {  <add:oz>begins_++;</add:oz>
                   yybegin(Z); return symbol(Sym.AX); }
  {GENAX}       {  <add:oz>begins_++;</add:oz>
                   yybegin(Z); return symbol(Sym.GENAX); }
  {SCH}         {  <add:oz>begins_++;</add:oz>
                   yybegin(Z); return symbol(Sym.SCH); }
  {GENSCH}      {  <add:oz>begins_++;</add:oz>
                   yybegin(Z); return symbol(Sym.GENSCH); }

  <add:oz>
  /* Object-Z class paragraph */
  {SCHCHAR} ({SPACE} | {CONTROL}) "class"
                {  begins_++;
                   yybegin(Z); return symbol(Sym.CLASS); }
  </add:oz>

  {TEXT}        {  return symbol(Sym.TEXT, yytext()); }
}

&lt;Z&gt; {
  /* Keywords (7.4.2 and 7.4.3) */
  "else"        { return symbol(Sym.ELSE); }
  "false"       { return symbol(Sym.FALSE); }
  "function"    { return symbol(Sym.FUNCTION); }
  "generic"     { return symbol(Sym.GENERIC); }
  "if"          { return symbol(Sym.IF); }
  "leftassoc"   { return symbol(Sym.LEFTASSOC); }
  "let"         { return symbol(Sym.LET); }
  "\u2119"      { return symbol(Sym.POWER); }
  "parents"     { return symbol(Sym.PARENTS); }
  "pre"         { return symbol(Sym.ZPRE); }
  "relation"    { return symbol(Sym.RELATION); }
  "rightassoc"  { return symbol(Sym.RIGHTASSOC); }
  "section"     { return symbol(Sym.SECTION); }
  "then"        { return symbol(Sym.THEN); }
  "true"        { return symbol(Sym.TRUE); }
  ":"           { return symbol(Sym.COLON); }
  "=="          { return symbol(Sym.DEFEQUAL); }
  ","           { return symbol(Sym.COMMA); }
  "::="         { return symbol(Sym.DEFFREE); }
  "|"           { return symbol(Sym.BAR); }
<add:print>
  {NL} {SPACE}* "|" {SPACE}* {NL}
                { return symbol(Sym.WHERE); }
</add:print>
  "&amp;"       { return symbol(Sym.ANDALSO); }
  "\u2055"      { return symbol(Sym.ZHIDE); }
  "/"           { return symbol(Sym.SLASH); }
  "."           { return symbol(Sym.DOT); }
  ";"           { return symbol(Sym.SEMICOLON); }
  "\u005F"      { return symbol(Sym.ARG); }
  ",,"          { return symbol(Sym.LISTARG); }
  "="           { return symbol(Sym.EQUALS); }
  "\u22A2?"     { return symbol(Sym.CONJECTURE); }
  "\u2200"      { return symbol(Sym.ALL); }
  "\u2981"      { return symbol(Sym.SPOT); }
  "\u2203"      { return symbol(Sym.EXI); }
  "\u2203\u21981\u2196" { return symbol(Sym.EXIONE); }
  "\u21D4"      { return symbol(Sym.IFF); }
  "\u21D2"      { return symbol(Sym.IMP); }
  "\u2228"      { return symbol(Sym.OR); }
  "\u2227"      { return symbol(Sym.AND); }
  "\u00AC"      { return symbol(Sym.NOT); }
  "\u2208"      { return symbol(Sym.MEM); }
  "\u2A21"      { return symbol(Sym.ZPROJ); }
  "\u00D7"      { return symbol(Sym.CROSS); }
  "\u03BB"      { return symbol(Sym.LAMBDA); }
  "\u03BC"      { return symbol(Sym.MU); }
  "\u03B8"      { return symbol(Sym.THETA); }
  "\u2A1F"      { return symbol(Sym.ZCOMP); }
  "\u2A20"      { return symbol(Sym.ZPIPE); }

  /* Boxes */
  {END}         {  <add:oz>
                   if (--begins_ == 0) {
                   </add:oz>
                     yybegin(YYINITIAL);
                   <add:oz>
                   }
                   </add:oz>
                   return symbol(Sym.END); }
  {NL}          {  return symbol(Sym.NL); }

  /* strip spaces (context-sensitive lexis; 7.4.1)
     \t is added so that unicode files containing tabs
     can be read properly */
  {SPACE} | {CONTROL} { }


  <add:oz>
  /* Object-Z keywords */
  "\u2AFE"      { return symbol(Sym.GCH); }
  "\u2225"      { return symbol(Sym.PARALLEL); }
  "\u2225" {SE} {OUTSTROKE} {NW}
                { return symbol(Sym.ASSOCPARALLEL); }
  "\u2AFF"      { return symbol(Sym.DGCH); }
  "\u22C0"      { return symbol(Sym.DCNJ); }
  "Init"        { return symbol(Sym.INITWORD); }
  "inherits"    { return symbol(Sym.INHERITS); }


  /* Object-Z box characters */
  {SCHCHAR} {STATECHAR}+
                { begins_++; return symbol(Sym.STATE); }
  {SCHCHAR} ({SPACE} | {CONTROL}) "Init"
                { begins_++; return symbol(Sym.INIT); }

  //these are added becaus they can be nested inside Object-Z class boxes
  {ZED}         { begins_++; return symbol(Sym.ZED); }
  {AX}          { begins_++; return symbol(Sym.AX); }
  {GENAX}       { begins_++; return symbol(Sym.GENAX); }
  {SCH}         { begins_++; return symbol(Sym.SCH); }
  </add:oz>

  /* Brackets */
  {LPAREN}      {  return symbol(Sym.LPAREN); }
  {RPAREN}      {  return symbol(Sym.RPAREN); }
  {LSQUARE}     {  return symbol(Sym.LSQUARE); }
  {RSQUARE}     {  return symbol(Sym.RSQUARE); }
  {LBRACE}      {  return symbol(Sym.LBRACE); }
  {RBRACE}      {  return symbol(Sym.RBRACE); }
  {LBIND}       {  return symbol(Sym.LBIND); }
  {RBIND}       {  return symbol(Sym.RBIND); }
  {LDATA}       {  return symbol(Sym.LDATA); }
  {RDATA}       {  return symbol(Sym.RDATA); }
  {INSTROKE}    {  return symbol(Sym.INSTROKE); }
  {OUTSTROKE}   {  return symbol(Sym.OUTSTROKE); }
  {NEXTSTROKE}  {  return symbol(Sym.NEXTSTROKE); }
  {SE} {DIGIT} {NW}
                {  Integer digit = new Integer(yytext().substring(1,2));
                   return symbol(Sym.NUMSTROKE, digit);
                }
  {NUMERAL}     {  return symbol(Sym.NUMERAL, new Integer(yytext())); }
  {DECORWORD}   {  return symbol(Sym.DECORWORD, yytext()); }

  /* error fallback */
  .             {
                   String message = "Unexpected character &gt;" + yytext() + "&gt;";
                   throw new ScanException(message, getLine(), getColumn());
                }
}
</scanner>
