<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright 2003, 2004 Petra Malik
     This file is part of the CZT project.

     The CZT project contains free software;
     you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with CZT; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<parser xmlns:add="http://czt.sourceforge.net/templates/additional">
package <package/>;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

import net.sourceforge.czt.util.ParseException;
import net.sourceforge.czt.z.util.ZChar;
import net.sourceforge.czt.z.util.ZString;
import net.sourceforge.czt.parser.util.LatexCommand;
import net.sourceforge.czt.parser.util.LatexMarkupUtils;
import net.sourceforge.czt.parser.z.LatexMarkup;

action code
{:
  private Map map_ = createMap();

  private Map createMap()
  {
    Map map = new HashMap();
    Set set = LatexMarkup.getUnicodeMappingEntries();
    for (Iterator iter = set.iterator(); iter.hasNext();) {
      Map.Entry entry = (Map.Entry) iter.next();
      String latex = (String) entry.getKey();
      String unicode = (String) entry.getValue();
      LatexMarkup.Type type = LatexMarkup.getType(latex);
      boolean leftSpace = type.equals(LatexMarkup.Type.IN) ||
                          type.equals(LatexMarkup.Type.POST);
      boolean rightSpace = type.equals(LatexMarkup.Type.IN) ||
                           type.equals(LatexMarkup.Type.PRE);
      LatexCommand command =
        new LatexCommand(latex, unicode, leftSpace, rightSpace);
      map.put(unicode, command);
    }
    map.put(ZString.SPOT, new LatexCommand("@", ZString.SPOT, true, true));
    map.put("+", new LatexCommand("+", "+", true, true));
    map.put("-", new LatexCommand("-", "-", true, true));
    map.put("*", new LatexCommand("*", "*", true, true));
    map.put("|", new LatexCommand("|", "|", true, true));
    map.put(";", new LatexCommand(";", ";", false, true));
    map.put(",", new LatexCommand(",", ",", false, true));
    map.put(ZString.SE, new LatexCommand("_{", ZString.SE, false, false));
    map.put(ZString.NW, new LatexCommand("}", ZString.NW, false, false));
    map.put(ZString.NE, new LatexCommand("^{", ZString.NE, false, false));
    map.put(ZString.SW, new LatexCommand("}", ZString.SW, false, false));
    map.put(ZString.LL, new LatexCommand("\\_", ZString.LL, false, false));
    return map;
  }

  private String begin(String string)
  {
    return "\\begin{" + string + "}";
  }

  private String end(String string)
  {
    return "\n\\end{" + string + "}";
  }

  private LatexCommand concate(LatexCommand c1, LatexCommand c2)
  {
    if (c1 == null) return c2;
    if (c2 == null) return c1;
    String latex = c1.getName();
    if (! c1.addRightSpace() &amp;&amp; ! c2.addLeftSpace()) {
      char lastChar = c1.getUnicode().charAt(c1.getUnicode().length() - 1);
      char firstChar = c2.getUnicode().charAt(0);
      boolean lastIsLetterOrStroke = isLetter(lastChar) || isStroke(lastChar);
      boolean firstIsLetterOrStrokeOrWordglue =
        isLetter(firstChar) || isStroke(firstChar) || isWordGlue(firstChar);
      boolean case1 =
        lastIsLetterOrStroke &amp;&amp; ! firstIsLetterOrStrokeOrWordglue;
      boolean lastIsLetterOrStrokeOrWordglue =
        isLetter(lastChar) || isStroke(lastChar) || isWordGlue(lastChar);
      boolean firstIsLetterOrStroke =
        isLetter(firstChar) || isStroke(firstChar);
      boolean case2 =
        ! lastIsLetterOrStrokeOrWordglue &amp;&amp; firstIsLetterOrStroke;
      if (case1 || case2) {
        latex += " ";
      }
      else {
        latex += "~";
      }
    } else {
      latex += " ";
    }
    latex += c2.getName();
    String unicode = c1.getUnicode() + " " + c2.getUnicode();
    return
      new LatexCommand(latex, unicode, c1.addLeftSpace(), c2.addRightSpace());
  }

  private boolean isLetter(char character)
  {
    return Character.isLetter(character);
  }

  private boolean isStroke(char character)
  {
    boolean isPrime = character == ZChar.PRIME;
    boolean isOutStroke = character == ZChar.OUTSTROKE;
    boolean isInStroke = character == ZChar.INSTROKE;
    if (isPrime || isOutStroke || isInStroke) {
      return true;
    }
    return false;
  }

  private boolean isWordGlue(char character)
  {
    boolean isSE = character == ZChar.SE;
    boolean isSW = character == ZChar.SW;
    boolean isNE = character == ZChar.NE;
    boolean isNW = character == ZChar.NW;
    boolean isLL = character == ZChar.LL;
    if (isSE || isSW || isNE || isNW || isLL) {
      return true;
    }
    return false; 
  }

  private LatexCommand toLatex(String s, int line, int column)
    throws ParseException
  {
    try {
      return LatexMarkupUtils.uniwordToLatex(s, map_);
    }
    catch(ParseException e) {
      e.setLine(line);
      e.setColumn(column + e.getColumn());
      throw e;
    }
  }
:}

parser code {:
  private Writer writer_ = new OutputStreamWriter(System.out);

  public Writer getWriter()
  {
    return writer_;
  }

  public void setWriter(Writer writer)
  {
    writer_ = writer;
  }

  protected void write(String s)
  {
    try {
      writer_.write(s);
    }
    catch(IOException e) {
      System.err.println("Cannot write");
    }
  }

  public void report_error(String message, Object info) {
    StringBuffer m = new StringBuffer("Error");
    if (info instanceof java_cup.runtime.Symbol) {
      java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
      if (s.left &gt;= 0) {                
        m.append(" in line "+(s.left+1));   
        if (s.right &gt;= 0) m.append(", column "+(s.right+1));
      }
      m.append(" (" + s.sym + "," + s.value + ")");
    }
    m.append(": " + message);
    System.err.println(m);
  }


  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new UnsupportedOperationException("Parse error.");
  }
:};


/* ------------Declaration of Terminals and Non Terminals Section----------- */
   
/* Terminals */
terminal           LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACE, RBRACE,
                   LBIND, RBIND, LDATA, RDATA, ZED, AX, SCH, GENAX, GENSCH,
                   END, NL, ELSE, FALSE, FUNCTION, GENERIC, IF,
                   LEFTASSOC, LET, POWER, PARENTS, ZPRE, RELATION,
                   RIGHTASSOC, SECTION, THEN, TRUE, COLON, DEFFREE,
                   BAR, WHERE, ANDALSO, ZHIDE, SLASH, DOT, SEMICOLON, ARG,
                   LISTARG, EQUALS, CONJECTURE, ALL, SPOT, EXI, EXIONE,
                   IFF, IMP, OR, AND, NOT, MEM, ZPROJ, CROSS, LAMBDA,
                   MU, THETA, ZCOMP, COMMA, DEFEQUAL, ZPIPE, INSTROKE,
                   OUTSTROKE, NEXTSTROKE;
terminal Integer   NUMERAL, NUMSTROKE;
terminal String    DECORWORD, TEXT;
   
/* Non terminals */
non terminal String     s, input, sect, para;
non terminal LatexCommand token, tokenSeq, other, paren, special, decorword;


   s ::=     input
             {: parser.getWriter().flush(); :}
             ;

   input ::= input sect
             |
             sect
             |
             input para
             |
             para
             |
             input TEXT:t
             {: parser.write(t); :}
             |
             TEXT:t
             {: parser.write(t); :}
             ;

   sect ::=  ZED SECTION tokenSeq END
             ;

   para ::=  ZED tokenSeq:s END
             {:
                String result = begin("zed");
                if (s != null) { result += s.getName(); }
                result += end("zed");
                parser.write(result);
             :}
             |
             AX tokenSeq:s END
             {:
                String result = begin("axdef");
                if (s != null) result += s.getName();
                result += end("axdef");
                parser.write(result);
             :}
             |
             SCH decorword:w tokenSeq:s END
             {:
                String result = begin("schema") + "{" + w.getName() + "}";
                if (s != null) result += s.getName();
                result += end("schema");
                parser.write(result);
             :}
             |
             GENAX tokenSeq:s END
             {:
                String result = begin("gendef");
                if (s != null) result += s.getName();
                result += end("gendef");
                parser.write(result);
             :}
             |
             GENSCH tokenSeq:s END
             {:
                String result = begin("schema");
                if (s != null) result += s.getName();
                result += end("schema");
                parser.write(result);
             :}
             ;

   tokenSeq ::= tokenSeq:w1 token:w2
             {: RESULT = concate(w1, w2); :}
             |
             tokenSeq:w1 special:w2
             {: RESULT = concate(w1, w2); :}
             |
             {: RESULT = null; :}
             ;

   token ::= decorword:s
             {: RESULT = s; :}
             |
             INSTROKE
             {: RESULT =
                  new LatexCommand("?", ZString.INSTROKE, false, false); :}
             |
             OUTSTROKE
             {: RESULT =
                  new LatexCommand("!", ZString.OUTSTROKE, false, false); :}
             |
             NEXTSTROKE
             {: RESULT =
                  new LatexCommand("'", ZString.PRIME, false, false); :}
             |
             NUMSTROKE:i
             {:
                String latex = "^" + i.toString();
                String unicode = ZString.SE + i.toString() + ZString.NW;
                RESULT =
                  new LatexCommand(latex, unicode, false, false); :}
             |
             NUMERAL:i
             {:
                RESULT =
                  new LatexCommand(i.toString(), i.toString(), false, false);
             :}
             |
             paren:s
             {: RESULT = s; :}
             |
             other:s
             {: RESULT = s; :}
             ;

   decorword ::= DECORWORD:s
             {:
                RESULT = toLatex(s, sleft, sright);
                /*
                String string = (String) map_.get(s);
                if (string != null) {
                  LatexMarkup.Type type = LatexMarkup.getType(string);
                  RESULT = new Word(string, type);
                }
                else RESULT = new Word(s, true, true);
                */
             :}
             ;

   paren ::= LPAREN
             {: RESULT = new LatexCommand("(", ZString.LPAREN, true, true); :}
             |
             RPAREN
             {: RESULT = new LatexCommand(")", ZString.RPAREN , true, true); :}
             |
             LSQUARE
             {: RESULT = new LatexCommand("[", ZString.LSQUARE, true, true); :}
             |
             RSQUARE
             {: RESULT = new LatexCommand("]", ZString.RSQUARE, true, true); :}
             |
             LBRACE
             {: RESULT = new LatexCommand("\\{",  ZString.LBRACE, true, true); :}
             |
             RBRACE
             {: RESULT = new LatexCommand("\\}", ZString.RBRACE, true, true); :}
             |
             LBIND
             {: RESULT =
                  new LatexCommand("\\lblot", ZString.LBIND, true, true); :}
             |
             RBIND
             {: RESULT =
                  new LatexCommand("\\rblot", ZString.RBIND, true, true); :}
             |
             LDATA
             {: RESULT =
                  new LatexCommand("\\ldata", ZString.LDATA, true, true); :}
             |
             RDATA
             {: RESULT =
                  new LatexCommand("\\rdata", ZString.RDATA, true, true); :}
             ;

  special ::= NL
             {: RESULT = new LatexCommand("\\\\\n", ZString.NL, true, true); :}
             ;

  other ::=  BAR:t
             {: RESULT = toLatex("|", tleft, tright); :}
             |
             WHERE:t
             {: RESULT =
                  new LatexCommand("\n\\where\n", ZString.VL, true, true); :}
             |
             ELSE:t
             {: RESULT = toLatex("else", tleft, tright); :}
             |
             FALSE:t
             {: RESULT = toLatex("false", tleft, tright); :}
             |
             FUNCTION:t
             {: RESULT = toLatex("function", tleft, tright); :}
             |
             GENERIC:t
             {: RESULT = toLatex("generic", tleft, tright); :}
             |
             IF:t
             {: RESULT = toLatex("if", tleft, tright); :}
             |
             LEFTASSOC:t
             {: RESULT = toLatex("leftassoc", tleft, tright); :}
             |
             LET:t
             {: RESULT = toLatex("let", tleft, tright); :}
             |
             POWER:t
             {: RESULT = toLatex(ZString.POWER, tleft, tright); :}
             |
             PARENTS:t
             {: RESULT = toLatex("parents", tleft, tright); :}
             |
             ZPRE:t
             {: RESULT = toLatex("pre", tleft, tright); :}
             |
             RELATION:t
             {: RESULT = toLatex("relation", tleft, tright); :}
             |
             RIGHTASSOC:t
             {: RESULT = toLatex("rightassoc", tleft, tright); :}
             |
             THEN:t
             {: RESULT = toLatex("then", tleft, tright); :}
             |
             TRUE:t
             {: RESULT = toLatex("true", tleft, tright); :}
             |
             COLON
             {: RESULT = new LatexCommand(":", ":" , false, false); :}
             |
             DEFFREE:t
             {: RESULT = toLatex("::=", tleft, tright); :}
             |
             ANDALSO:t
             {: RESULT = toLatex("&amp;", tleft, tright); :}
             |
             ZHIDE:t
             {: RESULT = toLatex(ZString.ZHIDE, tleft, tright); :}
             |
             SLASH:t
             {: RESULT = toLatex(ZString.AMP, tleft, tright); :}
             |
             DOT:t
             {: RESULT = toLatex(ZString.DOT, tleft, tright); :}
             |
             SEMICOLON:t
             {: RESULT = toLatex(ZString.SEMICOLON, tleft, tright); :}
             |
             ARG:t
             {: RESULT = toLatex("_", tleft, tright); :}
             |
             LISTARG:t
             {: RESULT = toLatex(",,", tleft, tright); :}
             |
             EQUALS:t
             {: RESULT = toLatex("=", tleft, tright); :}
             |
             CONJECTURE:t
             {: RESULT = toLatex(ZString.CONJECTURE, tleft, tright); :}
             |
             ALL:t
             {: RESULT = toLatex(ZString.ALL, tleft, tright); :}
             |
             SPOT:t
             {: RESULT = toLatex(ZString.SPOT, tleft, tright); :}
             |
             EXI:t
             {: RESULT = toLatex(ZString.EXI, tleft, tright); :}
             |
             EXIONE:t
             {: RESULT = toLatex(ZString.EXI + ZString.SUB1, tleft, tright); :}
             |
             IFF:t
             {: RESULT = toLatex(ZString.IFF, tleft, tright); :}
             |
             IMP:t
             {: RESULT = toLatex(ZString.IMP, tleft, tright); :}
             |
             OR:t
             {: RESULT = toLatex(ZString.OR, tleft, tright); :}
             |
             AND:t
             {: RESULT = toLatex(ZString.AND, tleft, tright); :}
             |
             NOT:t
             {: RESULT = toLatex(ZString.NOT, tleft, tright); :}
             |
             MEM:t
             {: RESULT = toLatex(ZString.MEM, tleft, tright); :}
             |
             ZPROJ:t
             {: RESULT = toLatex(ZString.ZPROJ, tleft, tright); :}
             |
             CROSS:t
             {: RESULT = toLatex(ZString.CROSS, tleft, tright); :}
             |
             LAMBDA:t
             {: RESULT = toLatex(ZString.LAMBDA, tleft, tright); :}
             |
             MU:t
             {: RESULT = toLatex(ZString.MU, tleft, tright); :}
             |
             THETA:t
             {: RESULT = toLatex(ZString.THETA, tleft, tright); :}
             |
             ZCOMP:t
             {: RESULT = toLatex(ZString.ZCOMP, tleft, tright); :}
             |
             COMMA:t
             {: RESULT = toLatex(ZString.COMMA, tleft, tright); :}
             |
             DEFEQUAL:t
             {: RESULT = toLatex("==", tleft, tright); :}
             |
             ZPIPE:t
             {: RESULT = toLatex(ZString.ZPIPE, tleft, tright); :}
             ;
</parser>
