<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright (C) 2003, 2004 Petra Malik
     This file is part of the CZT project.

     The CZT project contains free software;
     you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with CZT; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<parser xmlns:add="http://czt.sourceforge.net/templates/additional">
package <package/>;

import java_cup.runtime.*;
import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import net.sourceforge.czt.util.CztException;
import net.sourceforge.czt.util.CztLogger;
import net.sourceforge.czt.util.ParseException;
import net.sourceforge.czt.z.ast.*;
import net.sourceforge.czt.z.util.ZChar;
import net.sourceforge.czt.z.util.ZString;
import net.sourceforge.czt.parser.util.*;
import net.sourceforge.czt.parser.z.LatexMarkup;
import net.sourceforge.czt.session.SectionInfo;
import net.sourceforge.czt.session.SectionManager;

action code
{:
  private Map unicode2latexMap_ = null;
  protected Iterator markup_ = null;

  private Map addStandardMapping(Map map)
  {
    map.put(ZString.SPOT, new LatexCommand("@", ZString.SPOT, true, true));
    map.put("+", new LatexCommand("+", "+", true, true));
    map.put(ZString.MINUS, new LatexCommand("-", ZString.MINUS, true, true));
    map.put("*", new LatexCommand("*", "*", true, true));
    map.put("|", new LatexCommand("|", "|", true, true));
    map.put(";", new LatexCommand(";", ";", false, true));
    map.put(",", new LatexCommand(",", ",", false, true));
    map.put(ZString.SE, new LatexCommand("_{", ZString.SE, false, false));
    map.put(ZString.NW, new LatexCommand("}", ZString.NW, false, false));
    map.put(ZString.NE, new LatexCommand("^{", ZString.NE, false, false));
    map.put(ZString.SW, new LatexCommand("}", ZString.SW, false, false));
    map.put(ZString.LL, new LatexCommand("\\_", ZString.LL, false, false));
    return map;
  }

  private String begin(String string)
  {
    return "\\begin{" + string + "}";
  }

  private String end(String string)
  {
    return "\n\\end{" + string + "}";
  }

  private LatexCommand concate(LatexCommand c1, LatexCommand c2)
  {
    if (c1 == null) return c2;
    if (c2 == null) return c1;
    String latex = c1.getName();
    if (! c1.addRightSpace() &amp;&amp; ! c2.addLeftSpace()) {
      char lastChar = c1.getUnicode().charAt(c1.getUnicode().length() - 1);
      char firstChar = c2.getUnicode().charAt(0);
      boolean lastIsAlphaOrStroke = isAlpha(lastChar) || isStroke(lastChar);
      boolean firstIsAlphaOrStrokeOrWordglue =
        isAlpha(firstChar) || isStroke(firstChar) || isWordGlue(firstChar);
      boolean case1 =
        lastIsAlphaOrStroke &amp;&amp; ! firstIsAlphaOrStrokeOrWordglue;
      boolean lastIsAlphaOrStrokeOrWordglue =
        isAlpha(lastChar) || isStroke(lastChar) || isWordGlue(lastChar);
      boolean firstIsAlphaOrStroke =
        isAlpha(firstChar) || isStroke(firstChar);
      boolean case2 =
        ! lastIsAlphaOrStrokeOrWordglue &amp;&amp; firstIsAlphaOrStroke;
      if (case1 || case2) {
        latex += " ";
      }
      else {
        latex += "~";
      }
    } else {
      latex += " ";
    }
    latex += c2.getName();
    String unicode = c1.getUnicode() + " " + c2.getUnicode();
    return
      new LatexCommand(latex, unicode, c1.addLeftSpace(), c2.addRightSpace());
  }

  private boolean isAlpha(char character)
  {
    return isLetter(character) || isDigit(character);
  }

  private boolean isLetter(char character)
  {
    return Character.isLetter(character);
  }

  private boolean isDigit(char character)
  {
    return Character.isDigit(character);
  }

  private boolean isStroke(char character)
  {
    boolean isPrime = character == ZChar.PRIME;
    boolean isOutStroke = character == ZChar.OUTSTROKE;
    boolean isInStroke = character == ZChar.INSTROKE;
    if (isPrime || isOutStroke || isInStroke) {
      return true;
    }
    return false;
  }

  private boolean isWordGlue(char character)
  {
    boolean isSE = character == ZChar.SE;
    boolean isSW = character == ZChar.SW;
    boolean isNE = character == ZChar.NE;
    boolean isNW = character == ZChar.NW;
    boolean isLL = character == ZChar.LL;
    if (isSE || isSW || isNE || isNW || isLL) {
      return true;
    }
    return false; 
  }

  private LatexCommand toLatex(String s, int line, int column)
    throws ParseException
  {
    try {
      assert unicode2latexMap_ != null;
      return uniwordToLatex(s, unicode2latexMap_);
    }
    catch(ParseException e) {
      e.setLine(line);
      e.setColumn(column + e.getColumn());
      throw e;
    }
  }

  /**
   * @czt.todo Write this method properly!
   */
  private String toLatexInSectHead(String s)
  {
    return s.replaceAll("_", "\\\\_");
  }

  private LatexCommand uniwordToLatex(String word, Map latexCommands)
    throws ParseException
  {
    LatexCommand command = null;
    if (markup_ == null) {
      Object o = latexCommands.get(word);
      if (o instanceof LatexMarkupFunction.MarkupDirective) {
        LatexMarkupFunction.MarkupDirective directive =
          (LatexMarkupFunction.MarkupDirective) o;
        command = new LatexCommand(directive.getCommand(),
                                   directive.getUnicode(),
                                   directive.addLeftSpace(),
                                   directive.addRightSpace());
      }
      else {
        command = (LatexCommand) o;
      }
      if (command != null) {
        return command;
      }
    }
    String latex = "";
    boolean addLeftSpace = false;
    boolean addRightSpace = false;
    for (int i = 0; i &lt; word.length(); i++) {
      char character = word.charAt(i);
      Object o = latexCommands.get(String.valueOf(character));
      if (o instanceof LatexMarkupFunction.MarkupDirective) {
        LatexMarkupFunction.MarkupDirective directive =
          (LatexMarkupFunction.MarkupDirective) o;
        command = new LatexCommand(directive.getCommand(),
                                   directive.getUnicode(),
                                   directive.addLeftSpace(),
                                   directive.addRightSpace());
      }
      else {
        command = (LatexCommand) o;
      }
      final int ascii = 256;
      if (command != null) {
        if ( (command.addLeftSpace() &amp;&amp; i &gt; 0) ||
             (command.addRightSpace() &amp;&amp; i + 1 &lt; word.length()) ) {
          latex += "{" + command.getName() + "}";
        }
        else {
          latex += command.getName() + " ";
        }
        addRightSpace = command.addRightSpace();
      }
      else if (character &lt; ascii) { // ASCII?
        latex += character;
      }
      else if (ZChar.PRIME == character) {
        latex += "'";
      }
      else {
        final int hexBase = 16;
        String hex = Integer.toString((int) character, hexBase);
        String message = "Error while transforming " + word +
          ": Unexpected character " + character + " (\\u" + hex + ")";
        throw new ParseException(message, 0, i);
      }
    }
    return new LatexCommand(latex, word, addLeftSpace, addRightSpace);
  }

  /**
   * Create a list containing one element.
   */
  protected List list(Object o)
  {
    List result = new ArrayList();
    result.add(o);
    return result;
  }

  private void setupMarkupTable(ZSect zsect)
  {
    final String sectName = zsect.getName();
    LatexMarkupFunction table = (LatexMarkupFunction)
      parser.sectInfo_.getInfo(sectName, LatexMarkupFunction.class);
    if (table != null) {
      LatexMarkupPara para =
        table.toAst(new net.sourceforge.czt.z.impl.ZFactoryImpl());
      markup_ = para.getDirective().iterator();
    }
    else {
      table = new LatexMarkupFunction(zsect.getName());
      for (Iterator iter = zsect.getParent().iterator(); iter.hasNext();) {
        Parent parent = (Parent) iter.next();
        String parentName = parent.getWord();
        LatexMarkupFunction parentMarkup = (LatexMarkupFunction)
          parser.sectInfo_.getInfo(parentName, LatexMarkupFunction.class);
        if (parentMarkup != null) {
          try {
            table.add(parentMarkup);
          }
          catch (MarkupException e) {
            CztLogger.getLogger(<class/>.class).warning(e.getMessage());
          }
        }
      }
    }
    assert table != null;
    unicode2latexMap_ = new HashMap();
    for (Iterator iter = table.iterator(); iter.hasNext();) {
      LatexMarkupFunction.MarkupDirective directive =
        (LatexMarkupFunction.MarkupDirective) iter.next();
      unicode2latexMap_.put(directive.getUnicode(), directive);
    }
    addStandardMapping(unicode2latexMap_);
  }
:}

parser code {:
  private Writer writer_ = new OutputStreamWriter(System.out);
  protected SectionInfo sectInfo_ = new SectionManager();
  protected ContextFreeScanner markupScanner_ = null;
  protected Scanner scanner_ = null;

  public Unicode2Latex(SectionInfo sectInfo)
  {
    sectInfo_ = sectInfo;
  }

  public Writer getWriter()
  {
    return writer_;
  }

  public void setWriter(Writer writer)
  {
    writer_ = writer;
  }

  protected void write(String s)
  {
    try {
      writer_.write(s);
    }
    catch(IOException e) {
      System.err.println("Cannot write");
    }
  }

  private String printType(DirectiveType type)
  {
    if (DirectiveType.NONE.equals(type)) return "";
    return type.toString().toLowerCase();
  }

  /**
   * Returns the next token.
   */
  protected Symbol local_next_token()
    throws Exception
  {
    if (markupScanner_ != null) {
      assert action_obj.markup_ != null;
      Symbol result = markupScanner_.next_token();
      if (result == null || result.sym == Sym.EOF) {
        markupScanner_ = null;
        return new Symbol(Sym.END_MARKUP);
      }
      return result;
    }
    if (action_obj.markup_ != null &amp;&amp; action_obj.markup_.hasNext()) {
      Directive directive = (Directive) action_obj.markup_.next();
      final String unicode = directive.getUnicode();
      if (unicode.length() == 1) {
        StringBuffer result = new StringBuffer();
        result.append("\n");
        char c = unicode.charAt(0);
        result.append("%%Z" + printType(directive.getType())+ "char ");
        result.append(directive.getCommand() + " ");
        result.append("U+");
        String hex = Integer.toHexString(c).toUpperCase();
        for (int i = 0; i &lt; 4 - hex.length(); i++) {
          result.append("0");
        }
        result.append(hex);
        result.append("\n");
        return new Symbol(Sym.CHAR_MARKUP, result.toString());
      }
      else {
        markupScanner_ = new ContextFreeScanner(new StringReader(unicode));
        markupScanner_.yybegin(ContextFreeScanner.Z);
        DirectiveType type = directive.getType();
        if (DirectiveType.NONE.equals(type)) {
          return new Symbol(Sym.WORD_MARKUP, directive.getCommand());
        }
        else if (DirectiveType.IN.equals(type)) {
          return new Symbol(Sym.INWORD_MARKUP, directive.getCommand());
        }
        else if (DirectiveType.POST.equals(type)) {
          return new Symbol(Sym.POSTWORD_MARKUP, directive.getCommand());
        }
        else if (DirectiveType.PRE.equals(type)) {
          return new Symbol(Sym.PREWORD_MARKUP, directive.getCommand());
        }
        else {
          throw new CztException("Unexpected directive type " + type);
        }
      }
    }
    else {
      action_obj.markup_ = null;
      if (scanner_ == null) {
        scanner_ = new SectHeadScanner(getScanner(), this);
      }
      Symbol result = scanner_.next_token();
      return result;
    }
  }

  public void report_error(String message, Object info) {
    StringBuffer m = new StringBuffer("Error");
    if (info instanceof java_cup.runtime.Symbol) {
      java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
      if (s.left &gt;= 0) {                
        m.append(" in line "+(s.left+1));   
        if (s.right &gt;= 0) m.append(", column "+(s.right+1));
      }
      m.append(" (" + s.sym + "," + s.value + ")");
    }
    m.append(": " + message);
    System.err.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new UnsupportedOperationException("Parse error.");
  }
:};

scan with {: return local_next_token(); :};

/* ------------Declaration of Terminals and Non Terminals Section----------- */
   
/* Terminals */
terminal           LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACE, RBRACE,
                   LBIND, RBIND, LDATA, RDATA, ZED, AX, SCH, GENAX, GENSCH,
                   END, NL, SECTION, PARENTS, WHERE,
                   INSTROKE, OUTSTROKE, NEXTSTROKE,
                   END_MARKUP;
terminal ZSect     SECTHEAD;
terminal Integer   NUMERAL, NUMSTROKE;
terminal String    DECORWORD, TEXT,
                   CHAR_MARKUP, WORD_MARKUP, INWORD_MARKUP, PREWORD_MARKUP,
                   POSTWORD_MARKUP;
   
/* Non terminals */
non terminal              input, narrWordList, sectionHeader,
                          sectionList, paragraphList;
non terminal String       markup, para, wordmarkup;
non terminal LatexCommand token, tokenSeq, paren, special, decorword;

   input ::= narrWordList:narr sectionList:s
             {: parser.getWriter().flush(); :}
             ;

   narrWordList ::=
             TEXT:t narrWordList
             {: parser.write(t); :}
             |
             // empty
             ;

   sectionList ::= 
             sectionList sectionHeader paragraphList
             |
             // empty
             ;

   sectionHeader ::= SECTHEAD:zsect
             {:
                parser.write(begin("zsection"));
                final String latexName = toLatexInSectHead(zsect.getName());
                parser.write("\\SECTION " + latexName + " \\parents ");
                for (Iterator iter = zsect.getParent().iterator();
                     iter.hasNext();) {
                  Parent parent = (Parent) iter.next();
                  String parentLatexName = toLatexInSectHead(parent.getWord());
                  parser.write(parentLatexName);
                  if (iter.hasNext()) parser.write(", ");
                }
                parser.write(end("zsection"));
                setupMarkupTable(zsect);
             :}
             ;

   paragraphList ::= 
             paragraphList para
             |
             // empty
             ;

   para ::=  markup
             |
             TEXT:t
             {: parser.write(t); :}
             |
             ZED tokenSeq:s END
             {:
                String result = begin("zed");
                if (s != null) { result += s.getName(); }
                result += end("zed");
                parser.write(result);
             :}
             |
             AX tokenSeq:s END
             {:
                String result = begin("axdef");
                if (s != null) result += s.getName();
                result += end("axdef");
                parser.write(result);
             :}
             |
             SCH decorword:w tokenSeq:s END
             {:
                String result = begin("schema") + "{" + w.getName() + "}";
                if (s != null) result += s.getName();
                result += end("schema");
                parser.write(result);
             :}
             |
             GENAX tokenSeq:s END
             {:
                String result = begin("gendef");
                if (s != null) result += s.getName();
                result += end("gendef");
                parser.write(result);
             :}
             |
             GENSCH tokenSeq:s END
             {:
                String result = begin("schema");
                if (s != null) result += s.getName();
                result += end("schema");
                parser.write(result);
             :}
             ;

  markup ::=
             CHAR_MARKUP:zchar
             {: parser.write(zchar); :}
             |
             wordmarkup:wm tokenSeq:s END_MARKUP
             {:
                StringBuffer result = new StringBuffer();
                result.append("\n");
                result.append(wm);
                result.append(" ");
                if (s != null) { result.append(s.getName()); }
                result.append("\n");
                parser.write(result.toString());
             :}
             ;

   wordmarkup ::=
             WORD_MARKUP:word
             {:
                RESULT = "%%Zword " + word;
             :}
             |
             INWORD_MARKUP:inword
             {:
                RESULT = "%%Zinword " + inword;
             :}
             |
             PREWORD_MARKUP:preword
             {:
                RESULT = "%%Zpreword " + preword;
             :}
             |
             POSTWORD_MARKUP:postword
             {:
                RESULT = "%%Zpostword " + postword;
             :}
             ;

   tokenSeq ::= tokenSeq:w1 token:w2
             {: RESULT = concate(w1, w2); :}
             |
             tokenSeq:w1 special:w2
             {: RESULT = concate(w1, w2); :}
             |
             {: RESULT = null; :}
             ;

   token ::= decorword:s
             {: RESULT = s; :}
             |
             INSTROKE
             {:
                RESULT =
                  new LatexCommand("?", ZString.INSTROKE, false, false);
             :}
             |
             OUTSTROKE
             {:
                RESULT =
                  new LatexCommand("!", ZString.OUTSTROKE, false, false);
             :}
             |
             NEXTSTROKE
             {:
                RESULT =
                  new LatexCommand("'", ZString.PRIME, false, false);
             :}
             |
             NUMSTROKE:i
             {:
                String latex = "^" + i.toString();
                String unicode = ZString.SE + i.toString() + ZString.NW;
                RESULT =
                  new LatexCommand(latex, unicode, false, false); :}
             |
             NUMERAL:i
             {:
                RESULT =
                  new LatexCommand(i.toString(), i.toString(), false, false);
             :}
             |
             paren:s
             {: RESULT = s; :}
             |
             WHERE:t
             {:
                RESULT =
                  new LatexCommand("\n\\where\n", ZString.VL, true, true);
             :}
             ;

   decorword ::= DECORWORD:s
             {:
                assert s != null;
                RESULT = toLatex(s, sleft, sright);
             :}
             ;

   paren ::= LPAREN
             {:
                RESULT =
                  new LatexCommand("(", ZString.LPAREN, true, true);
             :}
             |
             RPAREN
             {:
                RESULT =
                  new LatexCommand(")", ZString.RPAREN , true, true);
             :}
             |
             LSQUARE
             {:
                RESULT =
                  new LatexCommand("[", ZString.LSQUARE, true, true);
             :}
             |
             RSQUARE
             {:
                RESULT =
                  new LatexCommand("]", ZString.RSQUARE, true, true);
             :}
             |
             LBRACE
             {:
                RESULT =
                  new LatexCommand("\\{",  ZString.LBRACE, true, true);
             :}
             |
             RBRACE
             {:
                RESULT =
                  new LatexCommand("\\}", ZString.RBRACE, true, true);
             :}
             |
             LBIND
             {:
                RESULT =
                  new LatexCommand("\\lblot", ZString.LBIND, true, true);
             :}
             |
             RBIND
             {:
                RESULT =
                  new LatexCommand("\\rblot", ZString.RBIND, true, true);
             :}
             |
             LDATA
             {:
                RESULT =
                  new LatexCommand("\\ldata", ZString.LDATA, true, true);
             :}
             |
             RDATA
             {:
                RESULT =
                  new LatexCommand("\\rdata", ZString.RDATA, true, true);
             :}
             ;

  special ::= NL
             {:
                RESULT =
                  new LatexCommand("\\\\\n", ZString.NL, true, true);
             :}
             ;
</parser>
