<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright (C) 2003, 2004 Petra Malik
     This file is part of the CZT project.

     The CZT project contains free software;
     you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with CZT; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<parser xmlns:add="http://czt.sourceforge.net/templates/additional">
package <package/>;

import java_cup.runtime.*;
import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import net.sourceforge.czt.util.CztException;
import net.sourceforge.czt.util.CztLogger;
import net.sourceforge.czt.util.ParseException;
import net.sourceforge.czt.z.ast.*;
import net.sourceforge.czt.z.util.ZChar;
import net.sourceforge.czt.z.util.ZString;
import net.sourceforge.czt.parser.util.*;
import net.sourceforge.czt.session.SectionInfo;
import net.sourceforge.czt.session.SectionManager;

action code
{:
  private Map sections_ = new HashMap();
  protected Map unicode2latexMap_ = null;

  /**
   * An iterator over markup directives to be printed.
   */
  protected Iterator markup_ = null;

  private Map addStandardMapping(Map map)
  {
    map.put(ZString.SPOT, new LatexCommand("@", ZString.SPOT, true, true));
    map.put("+", new LatexCommand("+", "+", true, true));
    map.put(ZString.MINUS, new LatexCommand("-", ZString.MINUS, true, true));
    map.put("*", new LatexCommand("*", "*", true, true));
    map.put("|", new LatexCommand("|", "|", true, true));
    map.put(";", new LatexCommand(";", ";", false, true));
    map.put(",", new LatexCommand(",", ",", false, true));
    map.put(ZString.SE, new LatexCommand("_{", ZString.SE, false, false));
    map.put(ZString.NW, new LatexCommand("}", ZString.NW, false, false));
    map.put(ZString.NE, new LatexCommand("^{", ZString.NE, false, false));
    map.put(ZString.SW, new LatexCommand("}", ZString.SW, false, false));
    map.put(ZString.LL, new LatexCommand("\\_", ZString.LL, false, false));
    return map;
  }

  private String begin(String string)
  {
    return "\\begin{" + string + "}";
  }

  private String end(String string)
  {
    return "\n\\end{" + string + "}";
  }

  private LatexCommand concate(LatexCommand c1, LatexCommand c2)
  {
    if (c1 == null || c1.getUnicode().length() &lt;= 0) return c2;
    if (c2 == null || c2.getUnicode().length() &lt;= 0) return c1;
    String latex = c1.getName();
    if (! c1.addRightSpace() &amp;&amp; ! c2.addLeftSpace()) {
      final ZChar[] unicode1 = ZChar.toZChars(c1.getUnicode());
      final ZChar[] unicode2 = ZChar.toZChars(c2.getUnicode());
      final ZChar lastChar = unicode1[unicode1.length - 1];
      final ZChar firstChar = unicode2[0];
      final boolean lastIsAlphaOrStroke =
        ZChar.isAlpha(lastChar) || ZChar.isStroke(lastChar);
      final boolean firstIsAlphaOrStrokeOrWordglue =
        ZChar.isAlpha(firstChar) || ZChar.isStroke(firstChar) ||
        ZChar.isWordGlue(firstChar);
      final boolean case1 =
        lastIsAlphaOrStroke &amp;&amp; ! firstIsAlphaOrStrokeOrWordglue;
      final boolean lastIsAlphaOrStrokeOrWordglue =
        ZChar.isAlpha(lastChar) || ZChar.isStroke(lastChar) ||
        ZChar.isWordGlue(lastChar);
      final boolean firstIsAlphaOrStroke =
        ZChar.isAlpha(firstChar) || ZChar.isStroke(firstChar);
      final boolean case2 =
        ! lastIsAlphaOrStrokeOrWordglue &amp;&amp; firstIsAlphaOrStroke;
      if (case1 || case2) {
        latex += " ";
      }
      else {
        latex += "~";
      }
    } else {
      latex += " ";
    }
    latex += c2.getName();
    String unicode = c1.getUnicode() + " " + c2.getUnicode();
    return
      new LatexCommand(latex, unicode, c1.addLeftSpace(), c2.addRightSpace());
  }

  private LatexCommand toLatex(String s, int line, int column)
    throws ParseException
  {
    try {
      assert unicode2latexMap_ != null;
      return uniwordToLatex(s, unicode2latexMap_);
    }
    catch(ParseException e) {
      e.setLine(line);
      e.setColumn(column + e.getColumn());
      throw e;
    }
  }

  /**
   * @czt.todo Write this method properly!
   */
  private String toLatexInSectHead(String s)
  {
    return s.replaceAll("_", "\\\\_");
  }

  private LatexCommand uniwordToLatex(String word, Map latexCommands)
    throws ParseException
  {
    LatexCommand command = null;
    if (markup_ == null) {
      Object o = latexCommands.get(word);
      if (o instanceof LatexMarkupFunction.MarkupDirective) {
        LatexMarkupFunction.MarkupDirective directive =
          (LatexMarkupFunction.MarkupDirective) o;
        command = new LatexCommand(directive.getCommand(),
                                   directive.getUnicode(),
                                   directive.addLeftSpace(),
                                   directive.addRightSpace());
      }
      else {
        command = (LatexCommand) o;
      }
      if (command != null) {
        return command;
      }
    }
    String latex = "";
    boolean addLeftSpace = false;
    boolean addRightSpace = false;
    ZChar[] zchars = ZChar.toZChars(word);
    int charcount = 0;
    for (int i = 0; i &lt; zchars.length; i++) {
      ZChar zchar = zchars[i];
      Object o = latexCommands.get(zchar.toString());
      if (o instanceof LatexMarkupFunction.MarkupDirective) {
        LatexMarkupFunction.MarkupDirective directive =
          (LatexMarkupFunction.MarkupDirective) o;
        command = new LatexCommand(directive.getCommand(),
                                   directive.getUnicode(),
                                   directive.addLeftSpace(),
                                   directive.addRightSpace());
      }
      else {
        command = (LatexCommand) o;
      }
      if (command != null) {
        if ( (command.addLeftSpace() &amp;&amp; i &gt; 0) ||
             (command.addRightSpace() &amp;&amp; i + 1 &lt; zchars.length) ) {
          latex += "{" + command.getName() + "}";
        }
        else {
          latex += command.getName() + " ";
        }
        addRightSpace = command.addRightSpace();
      }
      else if (zchar.isAsciiChar()) { // ASCII?
        latex += zchar.toString();
      }
      else if (ZChar.PRIME.equals(zchar)) {
        latex += "'";
      }
      else {
        final int hexBase = 16;
        String hex = Integer.toString(zchar.codePoint(), hexBase);
        String message = "Error while transforming " + word +
          ": Unexpected character " + zchar.toString() +
          " (\\u" + hex + ")";
        throw new ParseException(message, 0, charcount);
      }
      charcount = charcount + zchar.charCount();
    }
    return new LatexCommand(latex, word, addLeftSpace, addRightSpace);
  }

  /**
   * Create a list containing one element.
   */
  protected List list(Object o)
  {
    List result = new ArrayList();
    result.add(o);
    return result;
  }

  private void addParentMarkups(ZSect zsect, LatexMarkupFunction table)
  {
    for (Iterator iter = zsect.getParent().iterator(); iter.hasNext();) {
      Parent parent = (Parent) iter.next();
      String parentName = parent.getWord();
      LatexMarkupFunction parentMarkup = (LatexMarkupFunction)
        parser.sectInfo_.getInfo(parentName, LatexMarkupFunction.class);
      if (parentMarkup == null) {
        ZSect parentHeader = (ZSect) sections_.get(parentName);
        if (parentHeader != null) addParentMarkups(parentHeader, table);
      }
      else {
        try {
          table.add(parentMarkup);
        }
        catch (MarkupException e) {
          CztLogger.getLogger(<class/>.class).warning(e.getMessage());
        }
      }
    }
  }

  protected void setupMarkupTable(ZSect zsect)
  {
    final String sectName = zsect.getName();
    LatexMarkupFunction table = (LatexMarkupFunction)
      parser.sectInfo_.getInfo(sectName, LatexMarkupFunction.class);
    if (table != null) {
      LatexMarkupPara para =
        table.toAst(new net.sourceforge.czt.z.impl.ZFactoryImpl());
      markup_ = para.getDirective().iterator();
    }
    else {
      table = new LatexMarkupFunction(zsect.getName());
      addParentMarkups(zsect, table);
    }
    assert table != null;
    unicode2latexMap_ = toUnicode2LatexMap(table);
    addStandardMapping(unicode2latexMap_);
  }

  protected Map toUnicode2LatexMap(LatexMarkupFunction table)
  {
    Map result = new HashMap();
    if (table != null) {
      for (Iterator iter = table.iterator(); iter.hasNext();) {
        LatexMarkupFunction.MarkupDirective directive =
          (LatexMarkupFunction.MarkupDirective) iter.next();
        result.put(directive.getUnicode(), directive);
      }
    }
    return result;
  }

:}

parser code {:
  private Writer writer_ = new OutputStreamWriter(System.out);
  protected SectionInfo sectInfo_ = new SectionManager();
  protected String sectionName_ = null;
  /**
   * Used to scan the unicode provided within markup directives.
   * Whenever a latex markup directives is to printed, a new
   * markup scanner is created that scans the unicode of that
   * markup.  If it is not <code>null</code> we are just
   * printing the definition part of a latex markup directive.
   */
  protected ContextFreeScanner markupScanner_ = null;

  public SectionInfo getSectionInfo()
  {
    return sectInfo_;
  }

  public void setSectionInfo(SectionInfo sectInfo)
  {
    sectInfo_ = sectInfo;
  }

  public void setSectionInfo(SectionInfo sectInfo, String sectionName)
  {
    sectInfo_ = sectInfo;
    sectionName_ = sectionName;
  }

  public Writer getWriter()
  {
    return writer_;
  }

  public void setWriter(Writer writer)
  {
    writer_ = writer;
  }

  protected void write(String s)
  {
    try {
      writer_.write(s);
    }
    catch(IOException e) {
      System.err.println("Cannot write");
    }
  }

  private String printType(DirectiveType type)
  {
    if (DirectiveType.NONE.equals(type)) return "";
    return type.toString().toLowerCase();
  }

  /**
   * Returns the next token.
   */
  protected Symbol local_next_token()
    throws Exception
  {
    Symbol result = local_next_token_help();
    if (result.sym == Sym.SECTHEAD) {
      action_obj.setupMarkupTable((ZSect) result.value);
    }
    else if (result.sym == Sym.TOKENSEQ) {
      LatexMarkupFunction table = (LatexMarkupFunction)
        sectInfo_.getInfo(sectionName_, LatexMarkupFunction.class);
      action_obj.unicode2latexMap_ = action_obj.toUnicode2LatexMap(table);
    }
    return result;
  }

  private Symbol local_next_token_help()
    throws Exception
  {
    if (markupScanner_ != null) {
      // if markupScanner_ is not null, we are just printing the definition
      // part of a latex markup directive.  Therefore, markup_ must be non
      // null (since we can only got the directive from there).
      assert action_obj.markup_ != null;
      Symbol result = markupScanner_.next_token();
      if (result == null || result.sym == Sym.EOF) {
        markupScanner_ = null;
        return new Symbol(Sym.END_MARKUP);
      }
      return result;
    }
    if (action_obj.markup_ != null &amp;&amp; action_obj.markup_.hasNext()) {
      Directive directive = (Directive) action_obj.markup_.next();
      final String unicode = directive.getUnicode();
      final char[] charArray = unicode.toCharArray();
      if (unicode.length() == 1) {
        StringBuffer result = new StringBuffer();
        result.append("\n");
        char c = unicode.charAt(0);
        result.append("%%Z" + printType(directive.getType())+ "char ");
        result.append(directive.getCommand() + " ");
        result.append("U+");
        String hex = Integer.toHexString(c).toUpperCase();
        for (int i = 0; i &lt; 4 - hex.length(); i++) {
          result.append("0");
        }
        result.append(hex);
        result.append("\n");
        return new Symbol(Sym.CHAR_MARKUP, result.toString());
      }
      else if (charArray.length == 2 &amp;&amp;
               Character.isSurrogatePair(charArray[0], charArray[1])) {
        StringBuffer result = new StringBuffer();
        result.append("\n");
        int codePoint = Character.codePointAt(charArray, 0);
        result.append("%%Z" + printType(directive.getType())+ "char ");
        result.append(directive.getCommand() + " ");
        result.append("U-");
        String hex = Integer.toHexString(codePoint).toUpperCase();
        for (int i = 0; i &lt; 8 - hex.length(); i++) {
          result.append("0");
        }
        result.append(hex);
        result.append("\n");
        return new Symbol(Sym.CHAR_MARKUP, result.toString());
      }
      else {
        markupScanner_ = new ContextFreeScanner(new StringReader(unicode));
        markupScanner_.yybegin(ContextFreeScanner.Z);
        DirectiveType type = directive.getType();
        if (DirectiveType.NONE.equals(type)) {
          return new Symbol(Sym.WORD_MARKUP, directive.getCommand());
        }
        else if (DirectiveType.IN.equals(type)) {
          return new Symbol(Sym.INWORD_MARKUP, directive.getCommand());
        }
        else if (DirectiveType.POST.equals(type)) {
          return new Symbol(Sym.POSTWORD_MARKUP, directive.getCommand());
        }
        else if (DirectiveType.PRE.equals(type)) {
          return new Symbol(Sym.PREWORD_MARKUP, directive.getCommand());
        }
        else {
          throw new CztException("Unexpected directive type " + type);
        }
      }
    }
    else {
      action_obj.markup_ = null;
      Symbol result = getScanner().next_token();
      return result;
    }
  }

  public void report_error(String message, Object info) {
    StringBuffer m = new StringBuffer("Error");
    if (info instanceof java_cup.runtime.Symbol) {
      java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
      if (s.left &gt;= 0) {                
        m.append(" in line "+(s.left+1));   
        if (s.right &gt;= 0) m.append(", column "+(s.right+1));
      }
      m.append(" (" + s.sym + "," + s.value + ")");
    }
    m.append(": " + message);
    System.err.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new UnsupportedOperationException("Parse error.");
  }
:};

scan with {: return local_next_token(); :};

/* ------------Declaration of Terminals and Non Terminals Section----------- */
   
/* Terminals */
terminal           LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACE, RBRACE,
                   LBIND, RBIND, LDATA, RDATA, ZED, AX, SCH, GENAX, GENSCH,
                   END, NL, SECTION, PARENTS, WHERE,
                   INSTROKE, OUTSTROKE, NEXTSTROKE,
                   END_MARKUP, TOKENSEQ;
terminal ZSect     SECTHEAD;
terminal Integer   NUMERAL, NUMSTROKE;
terminal String    DECORWORD, TEXT,
                   CHAR_MARKUP, WORD_MARKUP, INWORD_MARKUP, PREWORD_MARKUP,
                   POSTWORD_MARKUP;

/* Non terminals */
non terminal              input, narrWordList, sectionHeader,
                          sectionList, paragraphList;
non terminal String       markup, para, wordmarkup;
non terminal LatexCommand token, tokenSeq, paren, special, decorword;

   input ::= narrWordList:narr sectionList:s
             {: parser.getWriter().flush(); :}
             |
             TOKENSEQ tokenSeq:s TOKENSEQ
             {:
                if (s != null) parser.write(s.getName());
                parser.getWriter().flush();
             :}
             ;

   narrWordList ::=
             TEXT:t narrWordList
             {: parser.write(t); :}
             |
             // empty
             ;

   sectionList ::= 
             sectionList sectionHeader paragraphList
             |
             // empty
             ;

   sectionHeader ::= SECTHEAD:zsect
             {:
                sections_.put(zsect.getName(), zsect);
                parser.write(begin("zsection"));
                final String latexName = toLatexInSectHead(zsect.getName());
                parser.write("\\SECTION " + latexName + " \\parents ");
                for (Iterator iter = zsect.getParent().iterator();
                     iter.hasNext();) {
                  Parent parent = (Parent) iter.next();
                  String parentLatexName = toLatexInSectHead(parent.getWord());
                  parser.write(parentLatexName);
                  if (iter.hasNext()) parser.write(", ");
                }
                parser.write(end("zsection"));
             :}
             ;

   paragraphList ::= 
             paragraphList para
             |
             // empty
             ;

   para ::=  markup
             |
             TEXT:t
             {: parser.write(t); :}
             |
             ZED tokenSeq:s END
             {:
                String result = begin("zed");
                if (s != null) { result += s.getName(); }
                result += end("zed");
                parser.write(result);
             :}
             |
             AX tokenSeq:s END
             {:
                String result = begin("axdef");
                if (s != null) result += s.getName();
                result += end("axdef");
                parser.write(result);
             :}
             |
             SCH decorword:w tokenSeq:s END
             {:
                String result = begin("schema") + "{" + w.getName() + "}";
                if (s != null) result += s.getName();
                result += end("schema");
                parser.write(result);
             :}
             |
             GENAX tokenSeq:s END
             {:
                String result = begin("gendef");
                if (s != null) result += s.getName();
                result += end("gendef");
                parser.write(result);
             :}
             |
             GENSCH tokenSeq:s END
             {:
                String result = begin("schema");
                if (s != null) result += s.getName();
                result += end("schema");
                parser.write(result);
             :}
             ;

  markup ::=
             CHAR_MARKUP:zchar
             {: parser.write(zchar); :}
             |
             wordmarkup:wm tokenSeq:s END_MARKUP
             {:
                StringBuffer result = new StringBuffer();
                result.append("\n");
                result.append(wm);
                result.append(" ");
                if (s != null) { result.append(s.getName()); }
                result.append("\n");
                parser.write(result.toString());
             :}
             ;

   wordmarkup ::=
             WORD_MARKUP:word
             {:
                RESULT = "%%Zword " + word;
             :}
             |
             INWORD_MARKUP:inword
             {:
                RESULT = "%%Zinword " + inword;
             :}
             |
             PREWORD_MARKUP:preword
             {:
                RESULT = "%%Zpreword " + preword;
             :}
             |
             POSTWORD_MARKUP:postword
             {:
                RESULT = "%%Zpostword " + postword;
             :}
             ;

   tokenSeq ::= tokenSeq:w1 token:w2
             {: RESULT = concate(w1, w2); :}
             |
             tokenSeq:w1 special:w2
             {: RESULT = concate(w1, w2); :}
             |
             {: RESULT = null; :}
             ;

   token ::= decorword:s
             {: RESULT = s; :}
             |
             INSTROKE
             {:
                RESULT =
                  new LatexCommand("?", ZString.INSTROKE, false, false);
             :}
             |
             OUTSTROKE
             {:
                RESULT =
                  new LatexCommand("!", ZString.OUTSTROKE, false, false);
             :}
             |
             NEXTSTROKE
             {:
                RESULT =
                  new LatexCommand("'", ZString.PRIME, false, false);
             :}
             |
             NUMSTROKE:i
             {:
                String latex = "^" + i.toString();
                String unicode = ZString.SE + i.toString() + ZString.NW;
                RESULT =
                  new LatexCommand(latex, unicode, false, false); :}
             |
             NUMERAL:i
             {:
                RESULT =
                  new LatexCommand(i.toString(), i.toString(), false, false);
             :}
             |
             paren:s
             {: RESULT = s; :}
             |
             WHERE:t
             {:
                RESULT =
                  new LatexCommand("\n\\where\n", ZString.VL, true, true);
             :}
             ;

   decorword ::= DECORWORD:s
             {:
                assert s != null;
                RESULT = toLatex(s, sleft, sright);
             :}
             ;

   paren ::= LPAREN
             {:
                RESULT =
                  new LatexCommand("(", ZString.LPAREN, true, true);
             :}
             |
             RPAREN
             {:
                RESULT =
                  new LatexCommand(")", ZString.RPAREN , true, true);
             :}
             |
             LSQUARE
             {:
                RESULT =
                  new LatexCommand("[", ZString.LSQUARE, true, true);
             :}
             |
             RSQUARE
             {:
                RESULT =
                  new LatexCommand("]", ZString.RSQUARE, true, true);
             :}
             |
             LBRACE
             {:
                RESULT =
                  new LatexCommand("\\{",  ZString.LBRACE, true, true);
             :}
             |
             RBRACE
             {:
                RESULT =
                  new LatexCommand("\\}", ZString.RBRACE, true, true);
             :}
             |
             LBIND
             {:
                RESULT =
                  new LatexCommand("\\lblot", ZString.LBIND, true, true);
             :}
             |
             RBIND
             {:
                RESULT =
                  new LatexCommand("\\rblot", ZString.RBIND, true, true);
             :}
             |
             LDATA
             {:
                RESULT =
                  new LatexCommand("\\ldata", ZString.LDATA, true, true);
             :}
             |
             RDATA
             {:
                RESULT =
                  new LatexCommand("\\rdata", ZString.RDATA, true, true);
             :}
             ;

  special ::= NL
             {:
                RESULT =
                  new LatexCommand("\\\\\n", ZString.NL, true, true);
             :}
             ;
</parser>
