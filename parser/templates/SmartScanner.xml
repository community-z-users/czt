<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright 2003 Mark Utting.  marku@cs.waikato.ac.nz
     This file is part of the CZT project: http://czt.sourceforge.net

     The CZT project contains free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License as published
     by the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License along
     with CZT; if not, write to the Free Software Foundation, Inc.,
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<scanner xmlns:add="http://czt.sourceforge.net/templates/additional">

package <package/>;

import java.io.IOException;
import java.util.*;
import java_cup.runtime.Symbol;

import net.sourceforge.czt.parser.util.*;

/** Looks ahead in the token stream to resolve some Z ambiguities.
 *
 *  This class 'buffers' the token stream, so that it can look
 *  ahead in the token stream if necessary, to help resolve some
 *  ambiguities in the Z grammar.
 *
 *  As described in the ISO Z standard (Section 8.4, p37), the Z
 *  grammar has several ambiguities.  For example, in {x,y,z...}, if the
 *  x,y,z is followed by ':', then it is part of a declaration (a set
 *  comprehension) and declares new variables x,y,z, otherwise it
 *  is a set extension, and x,y,z must already have been declared.
 *  To resolve this, whenever we come to a DECORWORD,
 *  this class looks ahead over (COMMA,DECORWORD) pairs to see if they
 *  are followed by a COLON (:) token.  If they are,
 *  it returns those names as DECLNAME tokens rather than DECORWORD tokens.
 */
class <class/> implements java_cup.runtime.Scanner
{
  private boolean debug_ = false;

  //indicates whether the previous token is a named box token
  //i.e. SCH, GENSCH, CLASS, OPSCH
  private boolean inBoxName = false;

  private TokenStack dumb_;

  <class/>(java_cup.runtime.Scanner dumbscanner)
  {
    dumb_ = new TokenStack(dumbscanner);
  }

  public Symbol next_token()
    throws Exception
  {
    Symbol result = dumb_.pop();
    if (result.sym == Sym.DECORWORD &amp;&amp; inBoxName) {
      //don't look ahead if the previous token was a box token
      inBoxName = false;
    }
    else if (result.sym == Sym.LSQUARE) {
      LinkedList &lt; Symbol &gt; tokens = new LinkedList &lt; Symbol &gt;();
      Symbol currsym = dumb_.pop();
      tokens.addLast(currsym);
      int level = 0;
      while (currsym.sym != Sym.RSQUARE || level > 0) {
        if (currsym.sym == Sym.LSQUARE) level++;
        if (currsym.sym == Sym.RSQUARE) level--;
        if ((currsym.sym == Sym.COLON ||
             currsym.sym == Sym.SEMICOLON ||
             currsym.sym == Sym.BAR ||
             currsym.sym == Sym.DEFEQUAL) &amp;&amp; level == 0)  {
          result.sym = Sym.LSCH;
          break;
        }
        currsym = dumb_.pop();
        tokens.addLast(currsym);
      }
      for (int i = tokens.size() - 1; i >= 0; i--) {
        dumb_.push(tokens.get(i));
      }
    }
    else if (result.sym == Sym.DECORWORD &amp;&amp; !inBoxName) {
      debug("starting lookahead from " + (String) result.value);

      //now we look ahead for: (COMMA WORD)* COLON
      boolean matching = true;   // we are still looking ahead
      LinkedList &lt; Symbol &gt; tokens = new LinkedList &lt; Symbol &gt;();
      Symbol currsym = dumb_.pop();

      debug("pushing: " + get_info(currsym));
      tokens.addLast(currsym);

      while (currsym.sym == Sym.COMMA &amp;&amp; matching) {
        currsym = dumb_.pop();
        debug("pushing: " + get_info(currsym));
        tokens.addLast(currsym);
        if (currsym.sym == Sym.DECORWORD) {
          currsym = dumb_.pop();
          debug("pushing: " + currsym.value);
          tokens.addLast(currsym);
        }
        else {
          matching = false;
        }
      }

      if (currsym.sym == Sym.COLON &amp;&amp; matching) {
        //change result and all WORDs in tokens to DECLWORD.
        debug("converting result: " + result.value + " to DECLWORD");
        result.sym = Sym.DECLWORD;
      }

      for (int i = tokens.size() - 1; i >= 0; i--) {
        dumb_.push(tokens.get(i));
      }
    }
    else if (result.sym == Sym.SCH ||
<add:oz>
             result.sym == Sym.CLASS ||
             result.sym == Sym.OPSCH ||
</add:oz>
             result.sym == Sym.GENSCH) {
        inBoxName = true;
    }
    debug("returning: " + get_info(result));
    return result;
  }

  private void debug(String msg)
  {
    if (debug_) {
      System.err.println(msg);
    }
  }

  private Object get_info(Symbol symbol)
  {
    String result = null;
    Map symbolMap = DebugUtils.getFieldMap(Sym.class);
    Object sym = symbolMap.get(new Integer(symbol.sym));
    if (symbol.value != null) {
      result = sym.toString() + "(" + symbol.value + ")";
    }
    else {
      result = sym.toString();
    }
    return result;
  }
}
</scanner>
