<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright 2003 Tim Miller
     This file is part of the CZT project.

     The CZT project contains free software;
     you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with CZT; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<optable xmlns:add="http://czt.sourceforge.net/templates/additional">
package <package/>;

import java.util.*;

import net.sourceforge.czt.base.ast.*;
import net.sourceforge.czt.z.ast.*;
import net.sourceforge.czt.util.CztException;
import net.sourceforge.czt.parser.util.DebugUtils;
import net.sourceforge.czt.parser.util.Strokes;
import net.sourceforge.czt.z.util.ZString;

/**
 * An operator table records each operator and its integer value.
 */
public class <class/>
{
  /** no precedence given */
  public static final int NO_PREC = -1;

  /** The different types of templates. */
  public static final int PREFIX = 1;
  public static final int POSTFIX = PREFIX + 1;
  public static final int INFIX = POSTFIX + 1;
  public static final int NOFIX = INFIX + 1;

  /** The name of the prelude section. */
  public static final String PRELUDE = "prelude";

  /** Maps symbol numbers into names, for debugging only. */
  public static Map/*&lt;Integer,String&gt;*/ symMap_
    = DebugUtils.getFieldMap(Sym.class);

  /**
   * A mapping from section names to a set of its (immediate) parents.
   */
  protected Map/*&lt;String,Set&lt;String&gt;&gt;*/ mParents_ = new HashMap();

  /**
   * The current section's ancestors.
   * This contains its parents, the parents of its parents, etc.
   */
  protected Set/*&lt;String&gt;*/ mCurrentParents_ = new HashSet();

  /** The name of the current section. */
  protected String mSection_ = null;

  /** The operators. */
  protected Set/*&lt;OperatorInfo&gt;*/ mOperators_ = new HashSet();

  /** The operator names - allows hash lookup of names. */
  // UNUSED? protected Set mOperatorNames_ = new HashSet();

  /**
   * Indicates whether to perform a requested lookup.
   * There are two cases in which a lookup is not performed:
   *   1) When parsing an operator template, so that an operator
   *      can be re-used (see section 8.3)
   *   2) When parsing a section header, so that section names can
   *      can be operator names (see section 8.4)
   */
  protected boolean mLookup_ = true;

  /**
   * Construct a new operator table.
   */
  public <class/>()
  {
  }

  /**
   * Add an operatior with a specified prefix. Other information is
   * retrieved from the OptempPara
   * @param fix the "fix" e.g. OperatorTable.PREFIX
   * @param otp the operator template paragraph containing the info
   */
  public void add(int fix, OptempPara otp)
  {
    //TODO: throw an exception if an operator is defined twice with
    //difference precedences or associativities, or if two operators
    //with the same precedence and associativity are declared in the
    //same scope
    switch (fix)
    {
        case PREFIX:
          addPrefix(otp);
          break;
        case POSTFIX:
          addPostfix(otp);
          break;
        case INFIX:
          addInfix(otp);
          break;
        case NOFIX:
          addNofix(otp);
          break;
        default:
          //do nothing
    }
  }

  /**
   * Set the current section.
   * @param section the section
   */
  public void setSection(String section)
  {
    endSection();
    mSection_ = section;
    mParents_.put(section, new HashSet());
  }

  /**
   * @return the current section
   */
  public String getSection()
  {
    return mSection_;
  }

  /**
   * Returns true if and only if the specified section has been parsed.
   *
   * @param section the section
   * @return true if and only if the specified section has been parsed
   */
  public boolean isParsed(String section)
  {
    return mParents_.get(section) != null;
  }

  /**
   * Add a parent to the current section.
   * @param parent the name of a section to be added as a parent.
   */
  public void addParent(String parent)
  {
    mCurrentParents_.add(parent);
    mCurrentParents_.addAll(getTransitiveParents(parent));

    Set parents = (Set) mParents_.get(mSection_);
    if (parents == null) {
      parents = new HashSet();
      mParents_.put(mSection_, parents);
    }
    parents.add(parent);
  }

  /**
   * End the current section.
   */
  public void endSection()
  {
    mCurrentParents_ = new HashSet();
    mSection_ = null;
  }

  /**
   * Determines whether to perform a lookup.
   */
  public void setLookup(boolean lookup)
  {
    mLookup_ = lookup;
  }

  /**
   * Lookup the int token value of a symbol, e.g. Sym.PRE.
   * Assumes that symbols are never given the value -1.
   *
   * @param symbol the string value of the symbol
   * @return the int token value of symbol
   */
  public int lookup(String symbol)
  {
    int result = -1;
    if (!mLookup_) {
      return result;
    }
    String section = null;
    OperatorInfo op = getOperatorInfo(symbol);
    if (op != null) {
      result = op.getType();
      section = op.getSection();
    }
    return isInScope(section) ? result : -1;
  }
  
  /**
   * Returns whether an operator defined in the given
   * section is in the scope of the current section or not.
   *
   * @return <code>true</code> iff the current section is anonymous
   *         (i.e. all operators are available)
   *         or the given section is the current section
   *         or one of its ancestors.
   *         Note that the prelude is always an ancestor.
   */
  private boolean isInScope(String section)
  {
    final boolean anonymous = mSection_ == null;
    if (! anonymous) {
      final boolean sectIsPrelude = PRELUDE.equals(section);
      final boolean sectIsCurrentSect = mSection_.equals(section);
      final boolean sectIsParent = mCurrentParents_.contains(section);
      return sectIsPrelude || sectIsCurrentSect || sectIsParent;
    }
    return true;
  }

  /**
   * Returns the operator info for a given symbol, e.g. Sym.PRE.
   *
   * @param symbol the string value of the symbol.
   */
  private OperatorInfo getOperatorInfo(String symbol)
  {
    OperatorInfo result = null;
    DeclName dn = Strokes.getWordAndStroke(symbol);
    String word = dn.getWord();
    for (Iterator iter = mOperators_.iterator(); iter.hasNext(); ) {
      OperatorInfo op = (OperatorInfo) iter.next();
      if (op.getName().equals(word)) {
	result = op;
        break;
      }
    }
    return result;
  }

  /**
   * Lookup the precedence of an operator.
   *
   * @param symbol the string value of the symbol
   * @return the precedence of symbol, NO_PREC if it is not an operator
   */
  public int getPrec(String symbol)
  {
    int result = NO_PREC;
    String section = null;
    OperatorInfo op = getOperatorInfo(symbol);
    if (op != null) {
      result = op.getPrec();
      section = op.getSection();
    }
    return isInScope(section) ? result : NO_PREC;
  }

  /**
   * Lookup the category of an operator.
   *
   * @param symbol the string value of the symbol
   * @return the category of symbol, null if it is not an operator
   */
  public Cat getCat(String symbol)
  {
    Cat result = null;
    String section = null;
    OperatorInfo op = getOperatorInfo(symbol);
    if (op != null) {
      result = op.getCat();
      section = op.getSection();
    }
    return isInScope(section) ? result : null;
  }

  /**
   * Lookup the associativity of an operator.
   *
   * @param symbol the string value of the symbol
   * @return the associativity of symbol, null if it is not an operator
   */
  public Assoc getAssoc(String symbol)
  {
    Assoc result = null;
    String section = null;
    OperatorInfo op = getOperatorInfo(symbol);
    if (op != null) {
      result = op.getAssoc();
      section = op.getSection();
    }
    return isInScope(section) ? result : null;
  }

  /**
   * Gets the transitive parents of a section.
   */
  private Set getTransitiveParents(String section) {
    Set result = new HashSet();

    //get the set of direct parents
    Set parents = (Set) mParents_.get(section);

    if (parents != null) {
      result.addAll(parents);

      //for each direct parent, get the transitive parents
      for (Iterator iter = parents.iterator(); iter.hasNext(); ) {
        String parent = (String) iter.next();
        Set transitiveParents = getTransitiveParents(parent);
        result.addAll(transitiveParents);
      }
    }
    return result;
  }

  /**
   * Dump the entire contents of the table (for debugging purposes).
   */
  public void dump()
  {
    for (Iterator iter = mOperators_.iterator(); iter.hasNext(); ) {
      OperatorInfo op = (OperatorInfo) iter.next();
      System.err.println(op.getName() + ": " + getType(op.getType()));
    }
  }

  /**
   * Returns the type as a string (for debugging purposes).
   */
  public static String getType(int type)
  {
    return (String) symMap_.get(new Integer(type));
  }

  private void addPrefix(OptempPara otp)
  {
    List words = otp.getOper();

    final int start = 1;
    final int finish = words.size() - 4;

    if (words.size() &lt; 2) {
      lessThan2Exception();
    }
    else if (words.size() == 2) {
      //"PRE _ | PREP _"
      addPreOrPrep(otp);
    }
    else {
      //"L  { _ (ES | SS) } _ (ERE | SRE) _ | "
      //"LP { _ (ES | SS) } _ (EREP | SREP) _"
      addLOrLp(otp);
      addEsOrSsList(otp, start, finish);
      addEreOrSreOrErepOrSRep(otp);
    }
  }

  private void addPostfix(OptempPara otp)
  {
    List words = otp.getOper();
    final int start = 2;
    final int finish = words.size() - 3;

    if (words.size() &lt; 2) {
      lessThan2Exception();
    }
    else if (words.size() == 2) {
      //"_ POST | _ POSTP"
      addPostOrPostp(otp);
    }
    else {
      //"_ EL { _ (ES | SS) } _ (ER | SR) |"
      //"_ ELP { _ (ES | SS) } _ (ERP | SRP)"

      addElOrElp(otp);
      addEsOrSsList(otp, start, finish);
      addErOrSrOrErpOrSrp(otp);
    }
  }

  private void addInfix(OptempPara otp)
  {
    List words = otp.getOper();
    final int start = 2;
    final int finish = words.size() - 4;

    if (words.size() &lt; 2) {
      lessThan2Exception();
    }
    else if (words.size() == 3) {
      addIOrIp(otp);
    }
    else {
      addElOrElp(otp);
      addEsOrSsList(otp, start, finish);
      addEreOrSreOrErepOrSRep(otp);
    }
  }

  private void addNofix(OptempPara otp)
  {
    List words = otp.getOper();
    final int start = 1;
    final int finish = words.size() - 2;

    addLOrLp(otp);
    addEsOrSsList(otp, start, finish);
    addErOrSrOrErpOrSrp(otp);
  }

  private void addPreOrPrep(OptempPara otp)
  {
    List words = otp.getOper();
    final int namePosition = 0;

    final int type = otp.getCat().equals(Cat.Relation) ?
      Sym.PREP :
      Sym.PRE;

    addOp(words, namePosition, type, otp.getCat(), otp.getPrec(), otp.getAssoc());
  }

  private void addLOrLp(OptempPara otp)
  {
    List words = otp.getOper();
    final int namePosition = 0;

    int type = otp.getCat().equals(Cat.Relation) ?
      Sym.LP :
      Sym.L;

    addOp(words, namePosition, type, otp.getCat(), otp.getPrec(), otp.getAssoc());
  }

  private void addPostOrPostp(OptempPara otp)
  {
    List words = otp.getOper();
    final int namePosition = 1;

    final int type = otp.getCat().equals(Cat.Relation) ?
      Sym.POSTP :
      Sym.POST;

    addOp(words, namePosition, type, otp.getCat(), otp.getPrec(), otp.getAssoc());
  }

  private void addElOrElp(OptempPara otp)
  {
    List words = otp.getOper();
    final int namePosition = 1;

    final int type = otp.getCat().equals(Cat.Relation) ?
      Sym.ELP :
      Sym.EL;

    addOp(words, namePosition, type, otp.getCat(), otp.getPrec(), otp.getAssoc());
  }

  private void addEsOrSsList(OptempPara otp, int start, int finish)
  {
    List words = otp.getOper();

    for (int i = start; i &lt; finish; i += 2) {
      int type =
        isSeq(words, i) ?
        Sym.SS :
        Sym.ES;

      int namePosition = i + 1;
      addOp(words, namePosition, type, otp.getCat(), otp.getPrec(), otp.getAssoc());
    }
  }

  private void addErOrSrOrErpOrSrp(OptempPara otp)
  {
    List words = otp.getOper();
    int type = -1;
    final int opPosition = words.size() - 2;
    final int namePosition = words.size() - 1;

    if (otp.getCat().equals(Cat.Relation)) {
      type = isSeq(words, opPosition) ?
        Sym.SRP :
        Sym.ERP;
    }
    else {
      type = isSeq(words, opPosition) ?
        Sym.SR :
        Sym.ER;
    }

    addOp(words, namePosition, type, otp.getCat(), otp.getPrec(), otp.getAssoc());
  }

  private void addEreOrSreOrErepOrSRep(OptempPara otp)
  {
    List words = otp.getOper();
    int type = -1;
    final int opPosition = words.size() - 3;
    final int namePosition = words.size() - 2;

    if (otp.getCat().equals(Cat.Relation)) {
      type = isSeq(words, opPosition) ?
        Sym.SREP :
        Sym.EREP;
    }
    else {
      type = isSeq(words, opPosition) ?
        Sym.SRE :
        Sym.ERE;
    }

    addOp(words, namePosition, type, otp.getCat(), otp.getPrec(), otp.getAssoc());
  }

  private void addIOrIp(OptempPara otp)
  {
    List words = otp.getOper();
    final int namePosition = 1;

    final int type = otp.getCat().equals(Cat.Relation) ?
      Sym.IP :
      Sym.I;

    addOp(words, namePosition, type, otp.getCat(), otp.getPrec(), otp.getAssoc());
  }

  private void addOp(String name, int type, Cat cat, Integer prec, Assoc assoc)
  {
    OperatorInfo op =
      new OperatorInfo(name, mSection_, type, cat, prec, assoc);
    mOperators_.add(op);
  }

  private void addOp(List words, int namePosition, int type, 
		     Cat cat, Integer prec, Assoc assoc)
  {
    String name = getName(words.get(namePosition));
    addOp(name, type, cat, prec, assoc);
  }

  /**
   * Converts a DeclName to its string representation.
   */
  private String getName(Object o)
  {
    String result = null;

    if (o instanceof Operator) {
      Operator op = (Operator) o;
      result = op.getWord();
    }
    else {
      throw new CztException("Attempt to add non-operator " + 
			     "into operator table");
    }
    return result;
  }

  private boolean isSeq(List words, int i)
  {
    return (((Operand) words.get(i)).getList()).booleanValue();
  }

  private void lessThan2Exception()
  {
    throw new CztException("Error: operator template with less " +
			   "than 2 arguments");
  }

  /**
   * An operator token.
   * For example, the operator  _ \limg _ \rimg  contains two
   * operator tokens, \limg and \rimg (actually their Unicode equivalents),
   * of type EL and ER, respectively.
   * Each of these becomes one OperatorInfo object.
   */
  private class OperatorInfo
  {
    /** The "name" of the token. */
    protected String mName_;

    /** The section in which the operator is declared. */
    protected String mSection_;

    /** The type of the token (e.g. Sym.IP). */
    protected int mType_;

    /** The category of the token. */
    protected Cat mCat_;

    /** The precedence of the token. */
    protected int mPrec_;

    /** The associativity of the token. */
    protected Assoc mAssoc_;

    /**
     * Construct a new operator from the given info.
     */
    public OperatorInfo(String name, String section, int type, 
			Cat cat, Integer prec, Assoc assoc)
    {
      mName_ = name;
      mSection_ = section;
      mType_ = type;
      mCat_ = cat;
      if (prec != null) {
        mPrec_ = prec.intValue();
      }
      else {
        mPrec_ = -1;
      }
      mAssoc_ = assoc;
    }

    /**
     * Return the name of this operator.
     */
    public String getName()
    {
      return mName_;
    }

    /**
     * Return the section in which this operator was declared.
     */
    public String getSection()
    {
      return mSection_;
    }

    /**
     * Return the type of this operator.
     */
    public int getType()
    {
      return mType_;
    }

    /**
     * Return the category of this operator.
     */
    public Cat getCat()
    {
      return mCat_;
    }

    /**
     * Return the precedence of this operator.
     */
    public int getPrec()
    {
      return mPrec_;
    }

    /**
     * Return the associativity of this operator.
     */
    public Assoc getAssoc()
    {
      return mAssoc_;
    }
  }
}
</optable>
