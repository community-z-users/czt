<?xml version="1.0" encoding="utf-8"?>
<scanner xmlns:add="http://czt.sourceforge.net/templates/additional">
/*
  Copyright (C) 2004, 2005, 2006 Petra Malik
  This file is part of the CZT project: http://czt.sourceforge.net

  The CZT project contains free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License as published
  by the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  The CZT project is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License along
  with CZT; if not, write to the Free Software Foundation, Inc.,
  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package <package/>;

import java.io.*;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import net.sourceforge.czt.parser.util.*;
import net.sourceforge.czt.session.*;

/**
 * &lt;p&gt;
 *   The high-level latex to unicode converter for <add:oz>Object </add:oz>Z <add:circus> and Circus</add:circus>.
 * &lt;/p&gt;
 * &lt;p&gt;
 *   This class is responsible for translating
 *   <add:oz>Object </add:oz>Z <add:circus> and Circus </add:circus>
 *   specifications written in the latex mark-up language into unicode.
 *   It provides tokens whos values
 *   are unicode strings and which contain line and column number
 *   information of the original latex file or stream.  This makes it
 *   possible to use this class as a standalone translater and, via
 *   {@link net.sourceforge.czt.parser.util.CztReader},
 *   as the input to the unicode scanner and therefore
 *   for the <add:oz>Object </add:oz>Z parser.
 * &lt;/p&gt;
 */
public class <class/>
  implements Lexer
{
  private LatexMarkupParser lexer_;
  private SectionInfo sectInfo_;
  private Latex2Unicode l2u_;

  /**
   * Ignores the markup information contained in source and treats the
   * content of source as LaTeX.
   */
  public <class/>(Source source, SectionInfo sectInfo, Properties properties)
    throws IOException
  {
    l2u_ = new Latex2Unicode(source, properties);
    lexer_ = new LatexMarkupParser(l2u_, sectInfo);
    lexer_.setSource(source.toString());
  }

  public LocToken next()
    throws IOException
  {
    return lexer_.next();
  }

  public static void convert(Source source,
                             Writer writer,
                             Properties properties)
    throws Exception
  {
    <class/> lexer = new <class/>(source, new SectionManager(), properties);
    LocToken s = null;
    while ( (s = lexer.next()) != null) {
      if (s.spelling() != null) writer.write(s.spelling());
    }
  }

  public static void main(String[] args)
  {
    String usage = "Usage: java <package/>.<class/>"
      + " [-in &lt;inputfile&gt;] [-out &lt;outputfile&gt;]"
      + " [-encoding &lt;encoding&gt;]";
    try {
      Source source = new StdInSource();
      Writer writer = new PrintWriter(System.out);
      String outfile = null;
      String encoding = "UTF-8";
      for (int i = 0; i &lt; args.length; i++) {
        if ("-in".equals(args[i])) {
          if (i &lt; args.length) {
            source = new FileSource(args[++i]);
          } else {
            System.err.println(usage);
            return;
          }
        }
        else if ("-encoding".equals(args[i])) {
          if (i &lt; args.length) {
            encoding = args[++i];
          } else {
            System.err.println(usage);
            return;
          }
        }
        else if ("-out".equals(args[i])) {
          if (i &lt; args.length) {
            outfile = args[++i];
          }
          else {
            System.err.println(usage);
            return;
          }
        }
        else {
          System.err.println(usage);
          return;
        }
      }
      if (outfile != null) {
        FileOutputStream stream = new FileOutputStream(outfile);
        writer = new OutputStreamWriter(stream, encoding);
      }
      convert(source, writer, new Properties());
      writer.close();
    }
    catch (Exception e) {
      e.printStackTrace();
    }
  }
}
</scanner>
