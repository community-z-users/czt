<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright (C) 2004, 2005 Petra Malik, Tim Miller
     This file is part of the czt project.
     
     The czt project contains free software;
     you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     
     The czt project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     
     You should have received a copy of the GNU General Public License
     along with czt; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
     -->

<scanner xmlns:add="http://czt.sourceforge.net/templates/additional">
package <package/>;

import java.io.IOException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.Stack;

import net.sourceforge.czt.java_cup.runtime.*;

import net.sourceforge.czt.parser.util.DebugUtils;
import net.sourceforge.czt.parser.util.Decorword;
import net.sourceforge.czt.parser.util.ParsePropertiesKeys;
import net.sourceforge.czt.util.CztException;
import net.sourceforge.czt.util.CztLogger;

import net.sourceforge.czt.z.ast.*;
import net.sourceforge.czt.z.util.ZString;
<add:zpatt>
import net.sourceforge.czt.zpatt.util.ZPattString;
</add:zpatt>
<add:oz>
import net.sourceforge.czt.oz.util.OzString;
</add:oz>

<add:tcoz>
import net.sourceforge.czt.tcoz.util.TcozString;
</add:tcoz>

<add:circus>
import net.sourceforge.czt.circus.util.CircusString;
</add:circus>

/**
 * &lt;p&gt;This is a keyword lexer (part of context-sensitive lexis) for
<add:z> * Z</add:z>
<add:oz> * Object Z</add:oz>
<add:circus> * Circus </add:circus><add:tcoz> and TCOZ</add:tcoz>
 * specifications in unicode format.&lt;/p&gt;
 *
 * &lt;p&gt;According to the ISO Standard for Z, the lexis for Z specifications
 * consists of two phases: the context-free lexis and the context-sensitive
 * lexis.  This class is an implementation of sections 7.4.2 and 7.4.3
 * of the ISO Z standard, which describes the context-sensitive lexis.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;This class transforms a stream of tokens into another stream of
 * tokens.  The input is usually provided by the {@link ContextFreeScanner}.
 * Each DECORWORD token whos spelling is exactly that of a keyword is mapped
 * to the corresponding keyword token.  All other tokens are left unchanged.
 * &lt;/p&gt;
 */
public class KeywordScanner
  implements Scanner
{
  private SeparateDelimiter scanner_;
  private Map &lt;String, Integer&gt; keywords_ = new HashMap&lt;String, Integer&gt;();
  private Stack&lt;Symbol&gt; tokens_ = new Stack&lt;Symbol&gt;();
  
  private static final Map symbolMap_ = DebugUtils.getFieldMap(Sym.class);

public static long time = 0;

  public KeywordScanner(ContextFreeScanner scanner, Properties properties)
  {
    createKeywordMap();
    scanner_ = new SeparateDelimiter(scanner, properties);
  }

  private void createKeywordMap()
  {
    // Z Standard 7.4.3 (Symbolic Keywords)
    addKeywordMapping(ZString.COLON, Sym.COLON);
    addKeywordMapping(ZString.DEFEQUAL, Sym.DEFEQUAL);
    addKeywordMapping(ZString.COMMA, Sym.COMMA);
    addKeywordMapping(ZString.DEFFREE, Sym.DEFFREE);
    addKeywordMapping(ZString.BAR, Sym.BAR);
    addKeywordMapping(ZString.ANDALSO, Sym.ANDALSO);
    addKeywordMapping(ZString.ZHIDE, Sym.ZHIDE);
    addKeywordMapping(ZString.SLASH, Sym.SLASH);
    addKeywordMapping(ZString.DOT, Sym.DOT);
    addKeywordMapping(ZString.SEMICOLON, Sym.SEMICOLON);
    addKeywordMapping(ZString.ARG, Sym.ARG);
    addKeywordMapping(ZString.LISTARG, Sym.LISTARG);
    addKeywordMapping(ZString.EQUALS, Sym.EQUALS);
    addKeywordMapping(ZString.CONJECTURE, Sym.CONJECTURE);
    addKeywordMapping(ZString.ALL, Sym.ALL);
    addKeywordMapping(ZString.SPOT, Sym.SPOT);
    addKeywordMapping(ZString.EXI, Sym.EXI);
    addKeywordMapping(ZString.EXIONE, Sym.EXIONE);
    addKeywordMapping(ZString.IFF, Sym.IFF);
    addKeywordMapping(ZString.IMP, Sym.IMP);
    addKeywordMapping(ZString.OR, Sym.OR);
    addKeywordMapping(ZString.AND, Sym.AND);
    addKeywordMapping(ZString.NOT, Sym.NOT);
    addKeywordMapping(ZString.MEM, Sym.MEM);
    addKeywordMapping(ZString.ZPROJ, Sym.ZPROJ);
    addKeywordMapping(ZString.CROSS, Sym.CROSS);
    addKeywordMapping(ZString.LAMBDA, Sym.LAMBDA);
    addKeywordMapping(ZString.MU, Sym.MU);
    addKeywordMapping(ZString.THETA, Sym.THETA);
    addKeywordMapping(ZString.ZCOMP, Sym.ZCOMP);
    addKeywordMapping(ZString.ZPIPE, Sym.ZPIPE);

    // Z Standard 7.4.2 (Alphabetic Keywords)
    addKeywordMapping(ZString.ELSE, Sym.ELSE);
    addKeywordMapping(ZString.FALSE, Sym.FALSE);
    addKeywordMapping(ZString.FUNCTION, Sym.FUNCTION);
    addKeywordMapping(ZString.GENERIC, Sym.GENERIC);
    addKeywordMapping(ZString.IF, Sym.IF);
    addKeywordMapping(ZString.LEFTASSOC, Sym.LEFTASSOC);
    addKeywordMapping(ZString.LET, Sym.LET);
    addKeywordMapping(ZString.PARENTS, Sym.PARENTS);
    addKeywordMapping(ZString.POWER, Sym.POWER);
    addKeywordMapping(ZString.PRE, Sym.ZPRE);
    addKeywordMapping(ZString.RELATION, Sym.RELATION);
    addKeywordMapping(ZString.RIGHTASSOC, Sym.RIGHTASSOC);
    addKeywordMapping(ZString.SECTION, Sym.SECTION);
    addKeywordMapping(ZString.THEN, Sym.THEN);
    addKeywordMapping(ZString.TRUE, Sym.TRUE);

<add:zpatt>
    addKeywordMapping(ZString.VDASH, Sym.VDASH);
    addKeywordMapping(ZPattString.PROVISO, Sym.PROVISO);
</add:zpatt>
<add:oz>
    addKeywordMapping(ZString.DELTA, Sym.DELTA);
    addKeywordMapping(OzString.GCH, Sym.GCH);
    addKeywordMapping(OzString.PARALLEL, Sym.PARALLEL);
    addKeywordMapping(OzString.ASSOPARALLEL, Sym.ASSOPARALLEL);
    addKeywordMapping(OzString.DGCH, Sym.DGCH);
    addKeywordMapping(OzString.DCNJ, Sym.DCNJ);
    addKeywordMapping(OzString.CLASSUNION, Sym.CLASSUNION);
    addKeywordMapping(OzString.SDEF, Sym.SDEF);
    addKeywordMapping(OzString.POLY, Sym.POLY);
    addKeywordMapping(OzString.CONTAINMENT, Sym.CONTAINMENT);
    addKeywordMapping(OzString.INITWORD, Sym.INITWORD);
</add:oz>
<add:tcoz>
    addKeywordMapping(TcozString.ATTIME, Sym.ATTIME);
    addKeywordMapping(TcozString.NEXTPRO, Sym.NEXTPRO);
    addKeywordMapping(TcozString.INTCHOICE, Sym.INTCHOICE);
    addKeywordMapping(TcozString.DIC, Sym.DIC);
    addKeywordMapping(TcozString.INTERLEAVE, Sym.INTERLEAVE);
    addKeywordMapping(TcozString.DIL, Sym.DIL);
    addKeywordMapping("waituntil", Sym.WAITUNTIL);
    addKeywordMapping("deadline", Sym.DEADLINE);
    addKeywordMapping("wait", Sym.WAIT);
    addKeywordMapping(TcozString.INTERRUPT, Sym.INTERRUPT);
    addKeywordMapping(TcozString.TIMEOUT, Sym.TIMEOUT);
    addKeywordMapping(TcozString.TIMEEND, Sym.TIMEEND);
    addKeywordMapping(TcozString.DPARA, Sym.DPARA);
    addKeywordMapping(TcozString.NETTOPLEFT, Sym.NETTOPLEFT);
    addKeywordMapping(TcozString.NETTOPRIGHT, Sym.NETTOPRIGHT);
    addKeywordMapping("chan", Sym.CHAN);
    addKeywordMapping("sensor", Sym.SENSOR);
    addKeywordMapping("actuator", Sym.ACTUATOR);
</add:tcoz>  
<add:circus>
    /* Circus symbolic keychars*/
    addKeywordMapping(CircusString.PREFIXCOLON, Sym.PREFIXCOLON);
    addKeywordMapping(CircusString.CIRCDEF, Sym.CIRCDEF);  
    addKeywordMapping(CircusString.CIRCINDEX, Sym.CIRCINDEX);
    addKeywordMapping(CircusString.CIRCMU, Sym.CIRCMU);
    addKeywordMapping(CircusString.CIRCTHEN, Sym.CIRCTHEN);
    addKeywordMapping(CircusString.CIRCELSE, Sym.CIRCELSE);
    addKeywordMapping(CircusString.PREFIXTHEN, Sym.PREFIXTHEN);
    /**
     * Note: We are reusing ANDALSO instead. See Parser.xml terminal section for an explanation.
     * addKeywordMapping(CircusString.CIRCGUARD, Sym.CIRCGUARD); 
     */
    addKeywordMapping(CircusString.CIRCSEQ, Sym.CIRCSEQ);
    /**
     * Note: We are reusing ZCOMP instead. See Parser.xml terminal section for an explanation.
     * addKeywordMapping(CircusString.REPSEQ, Sym.REPSEQ);
     */    
    addKeywordMapping(CircusString.INTERLEAVE, Sym.INTERLEAVE);
    addKeywordMapping(CircusString.REPINTERLEAVE, Sym.REPINTERLEAVE);   
    addKeywordMapping(CircusString.REPPARALLEL, Sym.REPPARALLEL);   
    addKeywordMapping(CircusString.CIRCHIDING, Sym.CIRCHIDING);
    addKeywordMapping(CircusString.EXTCHOICE, Sym.EXTCHOICE);
    addKeywordMapping(CircusString.REPEXTCHOICE, Sym.REPEXTCHOICE);   
    addKeywordMapping(CircusString.INTCHOICE, Sym.INTCHOICE);
    addKeywordMapping(CircusString.REPINTCHOICE, Sym.REPINTCHOICE);   
    //addKeywordMapping(CircusString.CIRCPARBAR, Sym.CIRCPARBAR);   
    
    /* Circus language keywords*/
    /**
     * Note: We are reusing ZString.IF instead. See Parser.xml terminal section for an explanation.
     * addKeywordMapping(CircusString.CIRCIF, Sym.CIRCIF);
     */    
    addKeywordMapping(CircusString.CIRCFI, Sym.CIRCFI);
    addKeywordMapping(CircusString.CIRCDO, Sym.CIRCDO);
    addKeywordMapping(CircusString.CIRCOD, Sym.CIRCOD);
    addKeywordMapping(CircusString.CIRCVAR, Sym.CIRCVAR);
    addKeywordMapping(CircusString.CIRCVAL, Sym.CIRCVAL);
    addKeywordMapping(CircusString.CIRCRES, Sym.CIRCRES);
    addKeywordMapping(CircusString.CIRCVRES, Sym.CIRCVRES);    
    addKeywordMapping(CircusString.CIRCSKIP, Sym.CIRCSKIP);
    addKeywordMapping(CircusString.CIRCSTOP, Sym.CIRCSTOP);
    addKeywordMapping(CircusString.CIRCCHAOS, Sym.CIRCCHAOS);
    
    /**
     * Note: Removed from Keyword scanner and added directly into the low-level
     *       Latex2Unicode scanner instead? TODO:TESTING. I think it needs to 
     *       be kept here anyway.
     */     
      addKeywordMapping(CircusString.CIRCCHAN, Sym.CIRCCHAN);
      addKeywordMapping(CircusString.CIRCCHANFROM, Sym.CIRCCHANFROM);
      addKeywordMapping(CircusString.CIRCCHANSET, Sym.CIRCCHANSET);
      addKeywordMapping(CircusString.CIRCNAMESET, Sym.CIRCNAMESET);
      addKeywordMapping(CircusString.CIRCPROC, Sym.CIRCPROC);
      addKeywordMapping(CircusString.CIRCBEGIN, Sym.CIRCBEGIN);
      addKeywordMapping(CircusString.CIRCEND, Sym.CIRCEND);
      addKeywordMapping(CircusString.CIRCSTATE, Sym.CIRCSTATE);
     /**/
</add:circus>    
  }
  
  /**
   * &lt;p&gt;
   * Maps the given keyword string with a specific &lt;code&gt;Symbol&lt;/code&gt;
   * by including it into the &lt;code&gt;keyword_&lt;/code&gt; map. 
   * &lt;/p&gt;
   * &lt;p&gt;
   * If a previous mapping to same keyword already exists, a warning message is given.
   * It is useful while debugging the parsers/scanners to ensure that the Unicode
   * symbols used are indeed unique.
   * &lt;/p&gt;
   */
  private void addKeywordMapping(String keyword, int symbol) {
    Integer old = keywords_.put(keyword, new Integer(symbol));        
    if (old != null) {
      String logMessage = "Invalid keyword mapping [" + keyword + " -> " + 
        symbolMap_.get(symbol) + ")]. The keyword " + keyword + 
        " has already been mapped to token " + symbolMap_.get(old) + ".";
      CztLogger.getLogger(KeywordScanner.class).severe(logMessage);
    }
  }

  private Symbol toToken(Stroke stroke, int left, int right)
  {
    if (stroke instanceof InStroke) {
      return new Symbol(Sym.INSTROKE, left, right);
    }
    else if (stroke instanceof OutStroke) {
      return new Symbol(Sym.OUTSTROKE, left, right);
    }
    else if (stroke instanceof NextStroke) {
      return new Symbol(Sym.NEXTSTROKE, left, right);
    }
    else if (stroke instanceof NumStroke) {
      NumStroke numStroke = (NumStroke) stroke;
      return new Symbol(Sym.NUMSTROKE, left, right, numStroke.getDigit());
    }
    else {
      throw new CztException("Unexpected stroke");
    }
  }

  public Symbol next_token()
    throws IOException
  {
    if (! tokens_.empty()) return tokens_.pop();
    Symbol symbol = scanner_.next_token();
    String logMessage =
      "Received token (" + symbol.sym + ", " + symbol.value + ")";
    CztLogger.getLogger(KeywordScanner.class).finer(logMessage);
    if (symbol.sym == Sym.DECORWORD) {
      Decorword decorword = (Decorword) symbol.value;
      if ("".equals(decorword.getWord())) {
        Stroke[] strokes = decorword.getStrokes();
        assert strokes.length > 0;
        for (int i = strokes.length - 1; i > 0; i--) {
          tokens_.push(toToken(strokes[i], symbol.left, symbol.right));
        }
        return toToken(strokes[0], symbol.left, symbol.right);
      }
      String value = decorword.getName();
      Integer token = (Integer) keywords_.get(value);
      if (token != null) {
        logMessage =
          "Returning " + token.intValue() + " instead.";
        CztLogger.getLogger(KeywordScanner.class).finer(logMessage);
        return new Symbol(token.intValue(), symbol.left, symbol.right);
      }
    }
    return symbol;
  }
}

class SeparateDelimiter
  implements Scanner, ParsePropertiesKeys
{
  private Properties properties_;
  private ContextFreeScanner scanner_;
  private Stack&lt;Symbol&gt; tokens_ = new Stack&lt;Symbol&gt;();

  public SeparateDelimiter(ContextFreeScanner scanner, Properties properties)
  {
    scanner_ = scanner;
    properties_ = properties;
  }

  private boolean getBooleanProperty(String propertyKey)
  {
    if (properties_ == null) {
      return false;
    }
    return "true".equals(properties_.getProperty(propertyKey));
  }

  private boolean needsSeparation(char c)
  {
    return c == ',' || c == ';' || c == '.';
  }

  // TODO compute line and column number correctly (not possible?)
  public Symbol next_token()
    throws IOException
  {
    if (! tokens_.empty()) return tokens_.pop();
    Symbol symbol = scanner_.next_token();
    int left = symbol.left;
    int right = symbol.right;
    if (symbol.sym == Sym.DECORWORD &amp;&amp;
        getBooleanProperty(PROP_EXTRACT_COMMA_OR_SEMI_FROM_DECORWORDS)) {
      String value = ((Decorword) symbol.value).getName();
      char[] charArray = value.toCharArray();
      int length = charArray.length;
      int suffix = length - 1;
      while(needsSeparation(charArray[suffix])) {
        if (suffix &lt;= 0) {
          return symbol;
        }
        suffix--;
      }
      assert suffix >= 0;
      if (suffix &lt; length - 1) {
        String string = new String(charArray, suffix + 1, length - suffix - 1);
        Decorword dw = new Decorword(string);
        tokens_.push(new Symbol(Sym.DECORWORD, left, right, dw));
      }
      int prefix = 0;
      while(needsSeparation(charArray[prefix])) {
        prefix++;
      }
      assert prefix &lt;= suffix;
      String string = new String(charArray, prefix, suffix - prefix + 1);
      Symbol newSymbol =
        new Symbol(Sym.DECORWORD, left, right, new Decorword(string));
      if (prefix == 0) {
        return newSymbol;
      }
      tokens_.push(newSymbol);
      string = new String(charArray, 0, prefix);
      return new Symbol(Sym.DECORWORD, left, right, new Decorword(string));
    }
    return symbol;
  }
}
</scanner>
