<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright (C) 2003, 2004, 2005 Tim Miller
     Copyright (C) 2004, 2005 Petra Malik
     This file is part of the CZT project.

     The CZT project contains free software;
     you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with CZT; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<parser xmlns:add="http://czt.sourceforge.net/templates/additional">
package <package/>;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.io.*;

import net.sourceforge.czt.java_cup.runtime.*;

import net.sourceforge.czt.base.ast.*;
<add:zpatt>
import net.sourceforge.czt.zpatt.util.Factory;
import net.sourceforge.czt.zpatt.ast.*;
</add:zpatt>
<add:circus>
import net.sourceforge.czt.circus.util.Factory;
import net.sourceforge.czt.circus.ast.*;
</add:circus>
<add:oz>
import net.sourceforge.czt.oz.util.OzString;
import net.sourceforge.czt.oz.ast.*;
</add:oz>
<add:ozz>
import net.sourceforge.czt.oz.util.Factory;
</add:ozz>
<add:tcoz>
import net.sourceforge.czt.tcoz.util.TcozString;
import net.sourceforge.czt.tcoz.ast.*;
import net.sourceforge.czt.tcoz.util.Factory;
</add:tcoz>

import net.sourceforge.czt.parser.util.*;
import net.sourceforge.czt.session.*;
import net.sourceforge.czt.util.CztException;
import net.sourceforge.czt.util.CztLogger;
import net.sourceforge.czt.z.ast.*;
import net.sourceforge.czt.z.util.*;
<add:z>
import net.sourceforge.czt.z.util.Factory;
</add:z>
import net.sourceforge.czt.z.util.OperatorName;
import net.sourceforge.czt.z.util.ZString;
import net.sourceforge.czt.session.SectionInfo;

action code
{:
    /** The ZML Version supported by this parser. */
    public final static String ZML_VERSION = Version.ZML_VERSION;

    /**
     * The name given to an anonymous specification when rule 12.2.2.1
     * (defined in the ISO Standard for Z) is applied.
     */
    public final static String ANONYMOUS_SPEC_NAME = "Specification";

    /** The name of the prelude. */
    public final static String PRELUDE = "prelude";

    /** The name of the mathematical toolkit. */
    public final static String TOOLKIT = "standard_toolkit";

    /** The name of the Object-Z toolkit. */
    public final static String OZ_TOOLKIT = "oz_toolkit";

    /** The symbols used to replace arguments for names in ApplExpr etc. */
    public final static String ARG_TOK = ZString.ARG_TOK;
    public final static String LISTARG_TOK = ZString.LISTARG_TOK;
    public final static String SPACE = ZString.SPACE;

    /** The factory for creating AST objects. */
    protected Factory factory_ = new Factory();

    /** The table of operators. */
    protected OpTable opTable_;

<add:zpatt>
    /** The table of joker names. */
    protected JokerTable jokerTable_;
</add:zpatt>

    /** The name of file currently being parsed. */
    protected String file_ = null;

    /**
     * The symbol returned by the last call to local_next_token().
     */
    protected Symbol previous_;

    /** The type of the previous chain relation e.g. MEM, EQUALS, IP */
    protected int previousChain_ = -1;

    /** Section information. */
    protected SectionInfo sectInfo_;

    /** The operator scanner. */
    protected OperatorScanner opScanner_;
    protected NewlineScanner nlScanner_;
<add:zpatt>
    protected JokerScanner jokerScanner_;
</add:zpatt>

    /**
     * Create an empty list.
     */
    protected &lt;E&gt; List&lt;E&gt; list()
    {
      return new ArrayList&lt;E&gt;();
    }

    /**
     * Create a list containing one element.
     */
    protected &lt;E&gt; List&lt;E&gt; list(E elem)
    {
      List&lt;E&gt; result = list();
      result.add(elem);
      return result;
    }

    /**
     * Creates a list containing two elements.
     */
    protected &lt;E&gt; List&lt;E&gt; list(E elem1, E elem2)
    {
      List&lt;E&gt; result = list();
      result.add(elem1);
      result.add(elem2);
      return result;
    }

    /**
     * Creates a list from another list
     */
    protected &lt;E&gt; List&lt;E&gt; list(List&lt;E&gt; list)
    {
      List&lt;E&gt; result = list();
      result.addAll(list);
      return result;
    }

    /**
     * Creates a pair from two elements. 
     */
    protected &lt;X,Y&gt; Pair&lt;X,Y&gt; pair(X x, Y y)
    {
      return new Pair(x, y);
    }

<add:oz>
    /**
     * Create a pair of PrimaryDecl and SecondaryDecl from 2 DeclLists
     */
    protected Pair&lt;PrimaryDecl,SecondaryDecl&gt; 
      statePair(DeclList pDeclList, DeclList sDeclList)
    {
      if (pDeclList == null) {
        pDeclList = factory_.createZDeclList();
      }
      if (sDeclList == null) {
        sDeclList = factory_.createZDeclList();
      }
      PrimaryDecl primaryDecl = factory_.createPrimaryDecl(pDeclList);
      SecondaryDecl secondaryDecl = factory_.createSecondaryDecl(sDeclList);
      return pair(primaryDecl, secondaryDecl);
    }

    protected OpText createOpText(DeltaList del, DeclList dec, Pred p)
    {
      if (dec == null) dec = factory_.createZDeclList();
      return factory_.createOpText(del, factory_.createZSchText(dec, p));
    }
</add:oz>

    private void checkName(Decorword decorword, int line, int column)
    {
      ZChar unmatched = decorword.check();
      if (unmatched != null) {
        final LocInfo locInfo = getLocation(line, column);
        final Object[] params = { unmatched };
        parser.report_error(ParseMessage.MSG_UNMATCHED_WORDGLUE,
                            params, locInfo);
      }
    }

    private Spec createSpec(List&lt;? extends Sect&gt; sectList)
    {
      Spec result = factory_.createSpec();
      result.setVersion(ZML_VERSION);
      result.getSect().addAll(sectList);
      return result;
    }

    private ZSchText createZSchText(List&lt;? extends Decl&gt; decl,
                                    Pred pred)
    {
      return factory_.createZSchText(factory_.createZDeclList(decl), pred);
    }

    private Operator createOperator(Decorword decorword, int line, int column)
      throws ParseException
    {
      return createOperator(decorword.getName(), line, column);
    }

    private Operator createOperator(String name, int line, int column)
      throws ParseException
    {
      final ZDeclName dn = factory_.createZDeclName(name);
      if (dn.getStroke().size() != 0) {
        final LocInfo locInfo = getLocation(line, column);
        final Object[] params = { name };
  	parser.report_error(ParseMessage.MSG_STROKE_IN_OPNAME,
                            params, locInfo);
      }
      Operator result = factory_.createOperator(dn.getWord());
      return result;
    }

    private void misusedOpName(String name, int line, int column)
    {
      final LocInfo locInfo = getLocation(line, column);
      final Object [] params = {name};
      parser.report_error(ParseMessage.MSG_OPNAME_AS_DECLWORD,
                          params, locInfo);
    }

    private LocInfo getLocation(int line, int column)
    {
      return new LocInfo(file_, line, column);
    }

    private LocInfo getLocation(TermA termA)
    {
      return parser.getLocation(termA);
    }

    /**
     * Converts a list of String objects to a DeclName object.
     */
    protected ZDeclName strListToZDeclName(List&lt;String&gt; list,
                                           int line,
                                           int column)
      throws ParseException
    {
      try {
        OperatorName opName = new OperatorName(list);
        return factory_.createZDeclName(opName.getWord(), opName.getStroke());
      }
      catch (OperatorName.OperatorNameException e) {
        parser.report_error(ParseMessage.MSG_OPNAME_ERROR,
                            new Object[0],
                            getLocation(line, column));
        return null;
      }
    }

    /**
     * Converts a list of String objects to a RefName object.
     */
    protected RefName strListToRefName(List&lt;String&gt; list,
                                       int line,
                                       int column)
      throws ParseException
    {
      try {
        OperatorName opName = new OperatorName(list);
        RefName result =
          factory_.createZRefName(opName.getWord(), opName.getStroke());
        addLocAnn(result, line, column);
        return result;
      }
      catch (OperatorName.OperatorNameException e) {
        final String message = "Syntax error: " + e.getMessage();
        parser.report_error(ParseMessage.MSG_OPNAME_ERROR,
                            new Object[0],
                            getLocation(line, column));
        return null;
      }
    }

    /**
     * Converts a TermA to a Pred.
     */
    protected Pred pred(TermA t)
      throws ParseException
    {
      Pred result = null;

      if (t instanceof Pred) {
        result = (Pred) t;
      }
<add:oz>
      else if (t instanceof PredExpr) {
        result = ((PredExpr) t).getPred();
      }
</add:oz>
      else if (t instanceof Expr) {
        result = factory_.createExprPred((Expr) t);
        LocAnn locAnn = (LocAnn) t.getAnn(LocAnn.class);
        if (locAnn != null) result.getAnns().add(locAnn);
      }
      else {
        //I don't think that this is possible...?
        parser.report_error(ParseMessage.MSG_PRED_EXPECTED,
                            new Object[0], getLocation(t));
      }
      return result;
    }

    /**
     * Converts an TermA to an Expr.
     */
    protected Expr expr(TermA t)
      throws ParseException
    {
      Expr result = null;

      if (t instanceof Expr) {
        result = (Expr) t;
      }
      else if (t instanceof ExprPred) {
        result = ((ExprPred) t).getExpr();
      }
      else if (t instanceof Pred) {
<add:oz>
        result = factory_.createPredExpr((Pred) t);
        LocAnn locAnn = (LocAnn) t.getAnn(LocAnn.class);
        if (locAnn != null) result.getAnns().add(locAnn);
</add:oz>
<add:z>
        parser.report_error(ParseMessage.MSG_EXPR_EXPECTED_FOUND_PRED,
                            new Object [0], getLocation(t));
</add:z>
      }
      else {
        parser.report_error(ParseMessage.MSG_EXPR_EXPECTED, 
                            new Object [0], getLocation(t));
      }
      return result;
    }

    /**
     * Converts a TermA to a RefName.
     */
    protected RefName refname(TermA t)
      throws ParseException
    {
      RefName result = null;

      if (t instanceof RefName) {
        result = (RefName) t; 
      }
      else if (t instanceof RefExpr) {
        RefExpr re = (RefExpr) t;

        if (re.getZExprList().size() > 0) {
          parser.report_error(ParseMessage.MSG_REFNAME_NO_PARAMS_EXPECTED,
                              new Object [0], getLocation(re));
        }
        result = re.getRefName();
      }
      else {
        parser.report_error(ParseMessage.MSG_REFNAME_EXPECTED,
                            new Object [0], getLocation(t));
      }

      return result;
    }

    /**
     * Creates a member predicate from a string list and an expression list.
     */
    protected MemPred localCreateMemPred(List&lt;String&gt; name,
                                         ZExprList exprs,
                                         int line,
                                         int column)
      throws ParseException
    {
      Expr e = createTupleExpr(exprs, line, column);
      RefName rn = strListToRefName(name, line, column);
      MemPred result = factory_.createRelOpAppl(e, rn);
      addLocAnn(result.getRightExpr(), line, column);
      return result;
    }

    /**
     * Creates an application expression or reference expression
     * (depending on the type of operator: function or generic)
     * from a string list and an expression list.
     * The line,column pair are the position of the start of
     * the whole mixfix expression.
     */
    protected Expr localCreateMixfixExpr(List&lt;String&gt; name,
                                         ZExprList exprs,
                                         int line,
                                         int column)
      throws ParseException
    {
      final RefName rn = strListToRefName(name, line, column);
      Expr result = null;

      //get the first operator in the name list, i.e. the first
      //item that is not an ARG_TOK or LISTARG_TOK.
      String firstOperator = null;
      for (Iterator&lt;String&gt; iter = name.iterator(); iter.hasNext(); ) {
        String next = iter.next();
        if (! next.equals(ARG_TOK) &amp;&amp; ! next.equals(LISTARG_TOK)) {
          firstOperator = next;
          break;
        }
      }

      if (opTable_.lookup(name) != null &amp;&amp;
          Cat.Function.equals(opTable_.lookup(name).getCat())) {
        Expr e = createTupleExpr(exprs, line, column);
        result = factory_.createFunOpAppl(rn, e);
        addLocAnn(((ApplExpr) result).getLeftExpr(), line, column);
      }
      else {
        result = factory_.createRefExpr(rn, exprs, Boolean.TRUE);
        // Done by callers: addLocAnn(result, line, column);
      }

      return result;
    }

    /**
     * If the list contains just one expression, location annotation
     * is added and the expression is returned.  If there is more than
     * one expression in the list, a tuple expression is created,
     * location annotation is added, and the tuple expression is
     * returned.
     */
    private Expr createTupleExpr(ZExprList exprs,
                                 int line,
                                 int column)
    {
      Expr result = exprs.size() == 1 ?
        exprs.get(0) : factory_.createTupleExpr(exprs);
      LocAnn locAnn = (LocAnn) result.getAnn(LocAnn.class);
      if (locAnn == null) addLocAnn(result, line, column);
      return result;
    }

    /**
     * Returns the right hand side of the previous infix relation.
     */
    protected Expr getPreviousRhsExpr(Pred pred)
    {
      Expr result = null;

      MemPred memPred = null;
      if (pred instanceof MemPred) {
        memPred = (MemPred) pred;
      }
      else {   //AndPred
        memPred = (MemPred) ((AndPred) pred).getRightPred();
      }

      if (previousChain_ == Sym.MEM) {
        result = memPred.getRightExpr();
      }
      else if (previousChain_ == Sym.EQUALS) {
        SetExpr se = (SetExpr) memPred.getRightExpr();
        result = se.getZExprList().get(0);
      }
      //previousChain_ == Sym.IP
      else {
        TupleExpr te = (TupleExpr) memPred.getLeftExpr();
        result = te.getZExprList().get(1);
      }

      return result;
    }

    /**
     * Convert a chain relation into a series of and predicates
     * (transformation rule 12.2.10.3).
     */
    protected Pred transformChainRel(Pred chain, int sym, Expr rhs,
                                     int line, int column)
    {
      Pred result = null;

      Expr lExpr = getPreviousRhsExpr(chain);
      Expr rExpr = rhs;

      Boolean mixfix = Boolean.FALSE;
      if (sym == Sym.EQUALS) {
        ZExprList expList = factory_.createZExprList();
        expList.add(rhs);
        rExpr = factory_.createSetExpr(expList);
        addLocAnn(rExpr, line, column);
        mixfix = Boolean.TRUE;
      }

      MemPred mp = factory_.createMemPred(lExpr, rExpr, mixfix);
      addLocAnn(mp, line, column);
      result = factory_.createAndPred(chain, mp, And.Chain);

      previousChain_ = -1;
      return result;
    }

    protected Pred transformChainRelInfix(Pred chain, Expr rhs, String ip,
                                          int line, int column)
      throws ParseException
    {
      Pred result = null;

      List&lt;String&gt; opName = list(ARG_TOK);
      opName.add(ip);
      opName.add(ARG_TOK);

      Expr lExpr = getPreviousRhsExpr(chain);
      Expr rExpr = rhs;
      ZExprList exprs = factory_.createZExprList();
      exprs.add(lExpr);
      exprs.add(rExpr);
      MemPred mp = localCreateMemPred(opName, exprs, line, column);
      addLocAnn(mp, line, column);
      result = factory_.createAndPred(chain, mp, And.Chain);

      previousChain_ = -1;
      return result;
    }

    /**
     * Creates a list of strings for a list returned by expSep.
     * This list will represent the name of the operator to which
     * the expressions were applied.
     */
    protected void addExpSepName(List&lt;String&gt; opName, List es)
    {
      for (int i = 0; i &lt; es.size(); i += 2) {

        List list = (List) es.get(i);
        if (list.size() == 1) {
          opName.add(ARG_TOK);
        }
        else {
          opName.add(LISTARG_TOK);
        }
        opName.add((String) es.get(i + 1));
      }
    }

    /**
     * Returns the list of expressions returned by expSep.
     */
    protected void addExpSepExp(List expList, List es)
    {
      for (int i = 0; i &lt; es.size(); i += 2) {
        expList.addAll((List) es.get(i));
      }
    }

    private OpTable getOperatorTable(String section, int line, int column)
      throws ParseException
    {
      try {
        return (OpTable) sectInfo_.get(new Key(section, OpTable.class));
      }
      catch (CommandException e) {
        Object [] args = { "Operator table",
                           section };
        parser.report_error(ParseMessage.MSG_OF_PARENT_NOT_FOUND,
                            args, new LocInfo(file_, line, column));
        return null;
      }
    }

    private void resetOpTable(String section, List parents,
                              int line, int column)
      throws ParseException
    {
      List parentOpTables = list();
      if (PRELUDE.equals(section)) {
        assert parents.size() == 0;
      }
      else {
        for (Iterator iter = parents.iterator(); iter.hasNext();) {
          final String parent = ((Parent) iter.next()).getWord();
          OpTable parentOp = getOperatorTable(parent, line, column);
          if (parentOp != null) {
            parentOpTables.add(parentOp);
          }
        }
      }
      try {
        opTable_ = new OpTable(section, parentOpTables);
      }
      catch (OpTable.OperatorException e) {
        parser.report_error(ParseMessage.MSG_CANNOT_MERGE_OPTABLES,
                            new Object[0],
                            getLocation(line, column));
     }
     opScanner_.setOperatorTable(opTable_);
    }

<add:zpatt>
    private JokerTable getJokerTable(String section, int line, int column)
       throws CommandException
    {
      try {
        return (JokerTable) sectInfo_.get(new Key(section, JokerTable.class));
      }
      catch (CommandException e) {
        Object [] args = { "Joker table",
                           section };
        parser.report_error(ParseMessage.MSG_OF_PARENT_NOT_FOUND,
                            args, new LocInfo(file_, line, column));
        return null;
      }
    }

    private void resetJokerTable(String section, List parents,
                                 int line, int column)
      throws CommandException
    {
      List parentJokerTables = list();
      if (PRELUDE.equals(section)) {
        assert parents.size() == 0;
      }
      else {
        for (Iterator iter = parents.iterator(); iter.hasNext();) {
          final String parent = ((Parent) iter.next()).getWord();
          JokerTable parentJoker = getJokerTable(parent, line, column);
          if (parentJoker != null) {
            parentJokerTables.add(parentJoker);
          }
        }
      }
      try {
        jokerTable_ = new JokerTable(section, parentJokerTables);
      }
      catch (JokerTable.JokerException e) {
        parser.report_error(ZpattParseMessage.MSG_CANNOT_MERGE_JOKERTABLES,
                            new Object[0],
                            getLocation(line, column));
     }
     jokerScanner_.setJokerTable(jokerTable_);
    }
</add:zpatt>

    private ZSect createZSect(String name, List parents)
    {
      ZSect result = factory_.createZSect(name, parents, null);
      return result;
    }

    private ZSect updateZSect(ZSect zSect, OpTable opTable
      <add:zpatt>, JokerTable jokerTable </add:zpatt>)
    {
      final boolean parseError = ! parser.errorList_.isEmpty();
      final String sectName = zSect.getName();
      final PrecedenceHandlingVisitor visitor =
        new PrecedenceHandlingVisitor(opTable);
      final ZSect sect = (ZSect) zSect.accept(visitor);
      LatexMarkupFunction latexMarkupFunction = null;
      try {
        latexMarkupFunction = (LatexMarkupFunction)
          sectInfo_.get(new Key(sectName, LatexMarkupFunction.class));
      }
      catch (CommandException exception) {
        String message =
          "Cannot find LatexMarkupFunction for " + sectName;
        CztLogger.getLogger(<class/>.class).warning(message);
      }
      if (latexMarkupFunction != null) {
        final LatexMarkupPara markupPara = latexMarkupFunction.toAst(factory_);
        sect.getPara().add(0, markupPara);
      }
      if (parseError) return sect;

      Set dependencies = new HashSet();
      for (Iterator iter = sect.getParent().iterator(); iter.hasNext(); ) {
        Parent parent = (Parent) iter.next();
        dependencies.add(new Key(parent.getWord(), OpTable.class));
      }
      sectInfo_.put(new Key(sectName, ZSect.class), sect, dependencies);
      sectInfo_.put(new Key(sectName, OpTable.class), opTable, dependencies);
<add:zpatt>
      sectInfo_.put(new Key(sectName, JokerTable.class), jokerTable, dependencies);
</add:zpatt>
      return sect;
    }

    private void addLocAnn(TermA termA, int line, int column)
    {
      LocAnn locAnn =
        factory_.createLocAnn(file_, line + 1, column + 1);
      LocAnn existingAnn = (LocAnn) termA.getAnn(LocAnn.class);
      if (existingAnn != null) {
        assert locAnn.equals(existingAnn);
        return;
      }
      termA.getAnns().add(locAnn);
    }
:}

parser code
{:
    private final static String RESOURCE_NAME =
      "net.sourceforge.czt.parser.util.ParseResources";

    private static final Map symbolMap_ = DebugUtils.getFieldMap(Sym.class);

    public Symbol parse() throws java.lang.Exception
    {
      Symbol symbol = super.parse();
      if (! errorList_.isEmpty()) throw new ParseException(errorList_);
      return symbol;
    }

    /** The file being parsed. */
    protected String file_;

    /** Section information. */
    protected SectionInfo sectInfo_;

    /**
     * The list of parse errors.
     * Not empty if and only if an error has occured during parsing.
     */
    protected List errorList_ = new ArrayList();

    private OperatorScanner opScanner_;
    private NewlineScanner nlScanner_;
<add:zpatt>
    private JokerScanner jokerScanner_;
</add:zpatt>

    /**
     * Creates a new parser with the given scanner and section information.
     * The section information should be able to provide information of
     * type <code>net.sourceforge.czt.parser.util.OpTable.class</code>.
     */
    public <class/>(Scanner scanner,
                    SectionInfo sectInfo)
    {
      this(scanner, null, sectInfo);
    }

    /**
     * Creates a new parser with the given scanner, source information,
     * and section information.
     * The source information is only used for printing error messages.
     * The section information should be able to provide information of
     * type <code>net.sourceforge.czt.parser.util.OpTable.class</code>.
     */
    public <class/>(Scanner scanner,
                    String source,
                    SectionInfo sectInfo)
    {
      super(scanner);
      file_ = source;
      sectInfo_ = sectInfo;
      opScanner_ = new OperatorScanner(getScanner());
<add:zpatt>
      jokerScanner_ = new JokerScanner(getScanner());
      opScanner_ = new OperatorScanner(jokerScanner_);
</add:zpatt>
      nlScanner_ = new NewlineScanner(opScanner_);
      CztLogger.getLogger(<class/>.class).finer("New parser created.");
    }

    /**
     * Returns the next token.
     */
    protected Symbol local_next_token() throws Exception
    {
      Symbol result = nlScanner_.next_token();
      assert result != action_obj.previous_;
      action_obj.previous_ = result;
      String logMessage =
        "Next token in " + file_ +
        " is (" + symbolMap_.get(result.sym) + ", " + result.value + ").";
      CztLogger.getLogger(<class/>.class).finer(logMessage);
      return result;
    }

    /**
     * @throws ClassCastException if the object is not a ParseError
     */
    public void report_error(String message, Object object)
    {
      ParseError error = (ParseError) object;
      errorList_.add(error);
    }

    public void report_error(ParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new ZParseError(msg, params, locInfo));
    }

 <add:zpatt>
    public void report_error(ZpattParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new ZpattParseError(msg, params, locInfo));
    }

</add:zpatt>
    /**
     * @throws ClassCastException if the object is not a ParseError
     */
    public void report_fatal_error(String message, Object param)
      throws ParseException
    {
      report_error(message, param);
      done_parsing();
    }

    public void syntax_error(Symbol token)
    {
      report_error("Syntax error", createSyntaxError(token));
    }

    public void unrecovered_syntax_error(Symbol token)
      throws ParseException
    {
      report_fatal_error("Syntax error", createSyntaxError(token));
    }

    protected ParseError createSyntaxError(Symbol token)
    {
      return new ZParseError(ParseMessage.MSG_SYNTAX_ERROR,
                             new Object[] { toObject(token) },
                             getLocation(token));
    }

    protected Object toObject(Symbol symbol)
    {
      if (symbol.value != null) {
        return symbol.value;
      }
      return symbolMap_.get(symbol.sym);
    }

    protected LocInfo getLocation(Symbol token)
    {
      return new LocInfo(file_, token.left, token.right);
    }

    protected LocInfo getLocation(Object info)
    {
      int line = -1;
      int column = -1;
      if (info instanceof Symbol) {
        return getLocation((Symbol) info);
      }
      else if (info instanceof LocAnn) {
        LocAnn locAnn = (LocAnn) info;
        line = locAnn.getLine();
        column = locAnn.getCol();
      }
      else if (info instanceof TermA) {
        TermA termA = (TermA) info;
        LocAnn locAnn = (LocAnn) termA.getAnn(LocAnn.class);
        return getLocation(locAnn);
      }
      return new LocInfo(file_, line, column);
    }
:}

init with
{:
    //share the operator table between the action code and the parser code
    action_obj.file_ = file_;
    action_obj.sectInfo_ = sectInfo_;
    action_obj.opScanner_ = opScanner_;
    action_obj.nlScanner_ = nlScanner_;
<add:zpatt>
    action_obj.jokerScanner_ = jokerScanner_;
</add:zpatt>
:}

scan with {: return local_next_token(); :};

terminal
        THETA, MU, LAMBDA,
        NEXTSTROKE, OUTSTROKE, INSTROKE,
        LPAREN, RPAREN, LSQUARE, RSQUARE, LBIND, RBIND,
        LDATA, RDATA, LBRACE, RBRACE,
        BAR, ANDALSO, CONJECTURE, AND, OR, IMP, IFF, NOT, 
        ALL, EXI, CROSS, POWER,
        SLASH, EQUALS, MEM, COLON, SEMICOLON, COMMA, DOT, SPOT, ZHIDE, 
        ZPROJ, ZCOMP, ZPIPE, NL,
        SECTION, PARENTS, TRUE, FALSE, LET, IF, THEN, ELSE, ZPRE,
        RELATION, FUNCTION, GENERIC, LEFTASSOC, RIGHTASSOC, LISTARG, ARG,
        DEFFREE, DEFEQUAL, EXIONE,
        END, AX, SCH, GENSCH, GENAX, ZED,
<add:zpatt>
        JOKER, RULE, RULELINE, VDASH, PROVISO,
</add:zpatt>
<add:circus>
        // What do I need to do in order to make the END suitable for \\end{circus}?
        CIRCUS, CIRCCHAN,
</add:circus>
<add:oz>
        DELTA, CLASS, GENCLASS, STATE, INIT, OPSCH, SDEF,
        INITWORD, POLY, CONTAINMENT,
        DCNJ, DGCH, DSQC, PARALLEL, ASSOPARALLEL, GCH, CLASSUNION,
</add:oz>
<add:tcoz>
        ATTIME, NEXTPRO, INTCHOICE, DIC, INTERLEAVE,
        DIL, WAITUNTIL, DEADLINE, WAIT, INTERRUPT, TIMEOUT, TIMEEND, 
        DPARA, NETTOPLEFT, NETTOPRIGHT, CHAN, SENSOR, ACTUATOR, 
</add:tcoz>
        //identifiers starting with a '_' are used only to force precedence
        _APPLICATION, _RENAME;

terminal String
<add:zpatt>
        JOKERNAME, JOKERNAMELIST, JOKEREXPR, JOKERPRED,
        JOKERDECLLIST, JOKERTYPE,
</add:zpatt>
        TEXT, PREP, PRE, POSTP, POST, IP, I, LP, L, ELP, EL, ERP, ER,
        SRP, SR, EREP, ERE, SREP, SRE, ES, SS;

terminal Integer NUMERAL, NUMSTROKE;

terminal Decorword
<add:oz>
        DEFNAME, OPNAME,
</add:oz>
        DECORWORD, DECLWORD;

non terminal Spec
    input,
    specification;

non terminal Sect
    narrSect;

non terminal ZSect
    section,
    emptySectionHeader,
    empty,
    sectionHeader;

non terminal List&lt;Sect&gt;
    sectionList;

non terminal List&lt;Parent&gt;
    parentList,
    parents;

non terminal List&lt;Para&gt;
    paragraphList,
    unboxedParagraphList,
    unboxedParagraphItemList;

non terminal Para 
    boxedParagraph,
    unboxedParagraphItem,
    narrParagraph;

non terminal AxPara
    axiomaticDefinition,
    genericAxDefinition,
    abbreviationDefinition,
    schema;

non terminal ConstDecl
    letDefinition;

non terminal List&lt;Freetype&gt; freeTypeList;
non terminal Freetype freeTypeDefinition;

non terminal List&lt;String&gt;
    narrWordList;

non terminal OptempPara operatorTemplate;
non terminal List /*StringAndOperand?*/ 
    template,
    prefixTemplate,
    postfixTemplate,
    infixTemplate,
    nofixTemplate,
    optWordOperandList;

non terminal Operand 
    varg,
    templateTag;
non terminal Assoc assoc;
non terminal OptempPara catTemplate;

non terminal SchText 
    schemaTextNoExpression,
    schemaText;

non terminal ZDeclList letDefinitionList;

non terminal List&lt;Branch&gt; branchList;
non terminal Branch branch;

non terminal List&lt;DeclName&gt;
    nameList,
    declWordList;

non terminal DeclName
    name,
    declName,
    formalParameterName;

non terminal List&lt;RefName&gt; refNameList;
non terminal ZRefName refName;

non terminal ZRenameList renameList;
non terminal NewOldPair rename;
    
non terminal ZDeclList
    zDeclList;

non terminal DeclList
    optDeclPart,
    declPart;

non terminal VarDecl
    varDecl;
non terminal ConstDecl
    constDecl;
non terminal Decl
    basicDeclaration,
    declaration;

non terminal GivenPara basicTypeDefinition;
non terminal List&lt;DeclName&gt;
    formalParameters,
    optFormalParameters;

non terminal Stroke stroke;

non terminal And
    sep;   

non terminal TermA
    term,
    septerm,
    func_appl,
    inner_term;

non terminal Pred
    predicate,
    relation,
    infixRel,
    infixChainRel;

non terminal MemPred
    prefixRel,
    postfixRel,
    nofixRel;

non terminal Expr
    expression;

non terminal ZDeclList
    constDeclList,
    optConstDeclList;

non terminal ZExprList
    prodExpressionList,
    optExpressionList,
    expressionList;

non terminal List&lt;String&gt;
    opName,
    prefixName,
    postfixName,
    infixName,
    nofixName;

non terminal Pair&lt;DeclName,List&lt;DeclName&gt;&gt;
    genName,
    prefixGenName,
    postfixGenName,
    infixGenName,
    nofixGenName;

non terminal List&lt;String&gt;
    optVargEsSsList;

non terminal Pair /* List DeclName, List DeclName */
    optNameEsSsList;

non terminal Expr
    application,
    prefixApp,
    postfixApp,
    infixApp,
    nofixApp;

non terminal List&lt;Object&gt;
    expSep;

non terminal List&lt;String&gt;
    argErepOrSrep,
    argEreOrSre,
    argErOrSr,
    argEsOrSs,
    argErpOrSrp;

non terminal String
    misusedOpName,
    ereOrSre,
    erOrSr,
    esOrSs;

non terminal And
    optNL;

<add:zpatt>
/// Z pattern constructs ///////////////////////////////////////////////
non terminal Jokers jokerPara;
non terminal Rule rulePara;

non terminal List&lt;String&gt; jokerList;

non terminal List&lt;Sequent&gt;
    sequentLHS,
    antecedents;

non terminal Sequent antecedent;

non terminal PredSequent conclusion;

non terminal Sequent
    sequent,
    proviso,
    lookupProviso,
    provisoSequent,
    predSequent;

non terminal TermA jokerRef;

non terminal Expr baseType;

non terminal DeclList
    signature;

non terminal ZDeclList
    varDeclList;

non terminal DeclList
    jokerDeclList,
    varJokerDeclList;
</add:zpatt>

<add:circus>
non terminal List&lt;Para&gt;
    circusParaItemList;

/// Circus constructs ///////////////////////////////////////////////
non terminal Para
    circusParaItem;
    
non terminal ChannelPara 
    channelPara;
    
//non terminal List /* VarDecl*/        
//    varDeclList;
</add:circus>

<add:oz>
/// Object-Z constructs ///////////////////////////////////////////////
non terminal Expr
    inheritedClass;

non terminal ClassPara
    class;

non terminal Pair&lt;DeclName,List&lt;DeclName&gt;&gt;
    classHeader;

non terminal State
    state;

non terminal Pair&lt;PrimaryDecl,SecondaryDecl&gt;
    stateDeclNoExpression,
    stateDecl;

non terminal ZDeclList
    primaryDeclPart,
    optPrimaryDeclPart;

non terminal DeclList
    secondaryDeclPart;

non terminal InitialState
    initialState;

non terminal TermA
    innerPara;

non terminal List /* TODO: use generics here! TermA */
    innerParaList;

non terminal DeltaList
    deltaList;

non terminal VisibilityList
    visibilityList;
                        
non terminal Expr
    opPromotionLhs;

non terminal OpExpr
    opExpr,
    opExpr1;

non terminal ExprList
    inheritedList;

non terminal List&lt;Expr&gt;
    inheritedClassList;

non terminal OpText
    opText;

non terminal Operation
    operation;

non terminal List&lt;Operation&gt;
    operationList;

</add:oz>
<add:tcoz>
non terminal VarDecl channelDeclaration;

non terminal Expr channel;

non terminal List&lt;Event&gt; eventSet;
 
non terminal Event
    event,
    inOutEvent;
 
non terminal List&lt;Connection&gt; topology;
       
non terminal Connection connection;

/* non terminal ChannelType chantype;*/
</add:tcoz>

// These are ordered from loosest first to tightest last.
precedence right        BAR;
precedence left         TEXT;
precedence left         <add:tcoz>LPAREN,</add:tcoz> RPAREN;
precedence left         NL, SEMICOLON;
precedence nonassoc     DEFEQUAL;
precedence left         ALL, EXI, EXIONE, SPOT;
<add:oz>
precedence left         ASSOPARALLEL;
<add:tcoz>
precedence left         NEXTPRO, ATTIME;
precedence left         NETTOPLEFT, NETTOPRIGHT;
</add:tcoz>
precedence left         PARALLEL<add:tcoz>, INTERLEAVE, INTERRUPT,
TIMEOUT, TIMEEND</add:tcoz>;
precedence left         GCH <add:tcoz>, INTCHOICE </add:tcoz>;
</add:oz>
precedence left         IFF;
precedence right        IMP;
precedence left         OR;
precedence left         AND;
precedence right        NOT;
precedence left         MEM, EQUALS, PREP, LP, IP, EREP, SREP,
                        POSTP, ELP, ERP, SRP;
precedence right        LAMBDA;
precedence right        MU;
precedence right        LET;
<add:oz>
precedence left         CLASSUNION;
</add:oz>
precedence right        ELSE;
precedence left         ZCOMP;
precedence left         ZPIPE;
precedence left         ZHIDE;
precedence left         ZPROJ;
precedence right        ZPRE;
precedence left         EL, ERE, SRE, I, CROSS;
precedence right        POWER, PRE, L;
<add:oz>
precedence right        POLY;
</add:oz>
precedence left         POST, ER, SR;
<add:oz>
precedence left         CONTAINMENT;
</add:oz>
<add:tcoz>
precedence left         CHAN, SENSOR, ACTUATOR;
</add:tcoz>
precedence left         _APPLICATION;
precedence left         INSTROKE, OUTSTROKE, NEXTSTROKE, NUMSTROKE;
precedence left         _RENAME;
<add:zpatt>
precedence left         RULELINE;
</add:zpatt>
precedence left         DOT;
precedence right        THETA;
precedence left         LSQUARE, RSQUARE;
precedence left         DECORWORD <add:oz>, INITWORD</add:oz>;


/// specifications /////////////////////////////////////////////////////////

input ::=
        narrSect:narr specification:s
        {:
           if (narr != null) {
             s.getSect().add(0, narr);
           }
           RESULT = s;
        :}
        ;

narrSect ::=
        //empty
        {:
           RESULT = null;
        :}
	|
	narrWordList:nwl
	{:
           RESULT = factory_.createNarrSect(nwl);
           addLocAnn(RESULT, nwlleft, nwlright);
        :}
        ;

specification ::=
        // anonymous specification
        emptySectionHeader:header paragraphList:pl
        {:
           header.getPara().addAll(pl);
           ZSect zSect = updateZSect(header, opTable_
             <add:zpatt>, jokerTable_ </add:zpatt>);
           RESULT = createSpec(list(zSect));
        :}
        |
        // sectioned specification
        sectionList:sl
        {:
           RESULT = createSpec(sl);
        :}
        ;

emptySectionHeader ::=
        empty:e
        {:
           // Apply Syntactic Transformation Rule 12.2.1.1
           final String name = ANONYMOUS_SPEC_NAME;
           final Parent p = factory_.createParent(TOOLKIT);
<add:oz>
           final Parent poz = factory_.createParent(OZ_TOOLKIT);
</add:oz>
           final List&lt;Parent&gt; parents = list(p<add:oz>, poz</add:oz>);
           resetOpTable(name, parents, eleft, eright);
<add:zpatt>
           resetJokerTable(name, parents, eleft, eright);
</add:zpatt>
           RESULT = createZSect(name, parents);
        :}
        ;

empty ::=
        //empty
        {:
        :}
        ;

sectionList ::= 
        section:s sectionList:sl
        {: 
           sl.add(0,s);
           RESULT = sl;
        :}
        |
        section:s
        {: RESULT = list((Sect) s); :}
        ;

section ::=
        sectionHeader:header paragraphList:pl
        {:
           header.getPara().addAll(pl);
           RESULT = updateZSect(header, opTable_
             <add:zpatt>, jokerTable_ </add:zpatt>);
        :}
        ;

sectionHeader ::=
        //ZED token at the start of sections is ignored by
        //the smart scanner to avoid a few problems
        SECTION:s DECORWORD:dw parents:p END
        {:
           String name = dw.getName();
           checkName(dw, dwleft, dwright);

           if (! name.equals(PRELUDE) &amp;&amp; p.isEmpty()) {
             Parent parent = factory_.createParent(PRELUDE);
             p.add(parent);
           }
<add:oz>
           final Parent ozParent = factory_.createParent(OZ_TOOLKIT);
           if ((! name.equals(OZ_TOOLKIT)) &amp;&amp;
               (! p.contains(ozParent)) &amp;&amp;
               (! name.equals(PRELUDE))) {
             p.add(ozParent);
           }
</add:oz>
           resetOpTable(name, p, pleft, pright);
<add:zpatt>
           resetJokerTable(name, p, pleft, pright);
</add:zpatt>
           RESULT = createZSect(name, p);
           addLocAnn(RESULT, sleft, sright);
        :}
        ;

parents ::=
        //empty
        {: RESULT = list(); :}
        |
        PARENTS
        {: RESULT = list(); :}
        |
        PARENTS parentList:pl
        {: RESULT = pl; :}
        ;

parentList ::=
        DECORWORD:dw COMMA parentList:pl
        {:
           checkName(dw, dwleft, dwright);
           Parent p = factory_.createParent(dw.getName());
           addLocAnn(p, dwleft, dwright);
           pl.add(0, p);
           RESULT = pl;
        :}
        |
        DECORWORD:dw
        {:
           checkName(dw, dwleft, dwright);
           Parent p = factory_.createParent(dw.getName());
           addLocAnn(p, dwleft, dwright);
           RESULT = list(p);
        :}
        ;


//paragraphs are divided into boxed and unboxed paragraphs. 
//Unboxed paragraphs must have a newline after their definition, 
//unless they are the final paragraph within ZED ... END tokens
paragraphList ::= 
        boxedParagraph:p paragraphList:pl
        {:
           if (p != null) pl.add(0, p);
           RESULT = pl;
        :}
        |
        unboxedParagraphList:upl paragraphList:pl
        {:
           pl.addAll(0, upl);
           RESULT = pl;
        :}
        |
        narrParagraph:np paragraphList:pl
        {:
           pl.add(0, np);
           RESULT = pl;
        :}
        |
        //empty
        {: RESULT = list(); :} %prec NL 
        ;


// 6.2 Global Paragraphs //////////////////////////////////////////////////////

boxedParagraph ::=
        axiomaticDefinition:ad
        {: RESULT = ad; :}
        |
        schema:s
        {: RESULT = s; :}
        |
        genericAxDefinition:gd
        {: RESULT = gd; :}
<add:zpatt>
        |
        jokerPara:jp
        {: RESULT = jp; :}
        |
        rulePara:rp
        {: RESULT = rp; :}
</add:zpatt>
<add:oz>
        |
        class:c
        {: RESULT = c; :}
</add:oz>
        |
        error END
        ;

narrParagraph ::=
        narrWordList:nwl
        {:
           RESULT = factory_.createNarrPara(nwl);
           addLocAnn(RESULT, nwlleft, nwlright);
        :}
        ;

unboxedParagraphList ::=
        ZED unboxedParagraphItemList:uil END
        {: RESULT = uil; :}
<add:circus>
        |
        CIRCUS circusParaItemList:cil END
        {: RESULT = cil; :}
</add:circus>        
        |        
        ZED error END
        {: RESULT = list(); :}
        ;

unboxedParagraphItemList ::=
        unboxedParagraphItem:ui NL unboxedParagraphItemList:uil
        {:
           if (ui != null) uil.add(0, ui);
           RESULT = uil;
        :}
        |
        unboxedParagraphItem:ui
        {:
           RESULT = list(ui);
        :}
        ;

<add:circus>        
circusParaItemList ::=
        circusParaItemList:cil NL circusParaItem:ci
        {:
           if (ci != null) cil.add(ci);
           RESULT = cil;
        :}
        |
        circusParaItem:ci
        {:
           RESULT = list(ci);
        :}
        ;
</add:circus>
        
unboxedParagraphItem ::=
        basicTypeDefinition:btd
        {: RESULT = btd; :}
        |
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        |
        freeTypeList:ftl
        {:
           RESULT = factory_.createFreePara(ftl);
           addLocAnn(RESULT, ftlleft, ftlright);
        :}
        |
        optFormalParameters:ofp CONJECTURE predicate:p
        {:
           RESULT = factory_.createConjPara(ofp, p);
           addLocAnn(RESULT, ofpleft, ofpright);
        :}
        |
        operatorTemplate:ot
        {:
           try {
             opTable_.add(ot);
           }
           catch (OpTable.OperatorException e) {
             final Symbol token = new Symbol(Sym.ZED, otleft, otright);
             parser.report_error(ParseMessage.MSG_CANNOT_ADD_OP,
                                 new Object[0],
                                 getLocation(otleft, otright));
           }
           RESULT = ot;
        :}
        ;

<add:circus>
circusParaItem ::=
        channelPara:cp
        {: RESULT = cp; :}
        ;
</add:circus>
        
basicTypeDefinition ::= 
        LSQUARE:lsq nameList:nl RSQUARE
        {:
           RESULT = factory_.createGivenPara(nl);
           addLocAnn(RESULT, lsqleft, lsqright);
        :}
        ;

schema ::=
        SCH:sch name:n schemaText:st END
        {:
           RESULT = factory_.createSchema(n, null, st);
           addLocAnn(RESULT, schleft, schright);
        :}
        |
        GENSCH:gensch name:n optNL formalParameters:fp schemaText:st END
        {:
           RESULT = factory_.createSchema(n, fp, st);
           addLocAnn(RESULT, genschleft, genschright);
        :}
        ;       

genericAxDefinition ::= 
        GENAX:genax formalParameters:fp schemaText:st END
        {:
           RESULT = factory_.createAxPara(fp, st, Box.AxBox);
           addLocAnn(RESULT, genaxleft, genaxright);
        :}
        ;

optFormalParameters ::=
        formalParameters:fp
        {: RESULT = fp; :}
        |
        //empty
        {: RESULT = list(); :}
        ;

formalParameters ::= 
        LSQUARE nameList:nl RSQUARE optNL
        {: RESULT = nl; :}
        ;

axiomaticDefinition ::= 
        AX:ax schemaText:st END
        {:
           RESULT = factory_.createAxPara(null, st, Box.AxBox);
           addLocAnn(RESULT, axleft, axright);
        :}
        ;

//according to the Z ISO standard, an abbreviation definition is to be
//treated as an axiomatic definition, with ConstDecl(dn,e)
abbreviationDefinition ::=
        declName:dn DEFEQUAL:equal expression:e
        {:
           ConstDecl cd = factory_.createConstDecl(dn, e);
           addLocAnn(cd, equalleft, equalright);
           ZDeclList decls = factory_.createZDeclList();
           decls.add(cd);
           ZSchText st = factory_.createZSchText(decls, null);
           addLocAnn(st, dnleft, dnright);
           RESULT = factory_.createAxPara(null, st, Box.OmitBox);
           addLocAnn(RESULT, dnleft, dnright);
        :}
        |
        //TODO: check this. Should be name:n, but the toolkit won't parse
        //"\langle \listarg \rangle [X] == .... without this
        declName:dn formalParameters:fp DEFEQUAL:equal expression:e
        {:
           ConstDecl cd = factory_.createConstDecl(dn, e);
           addLocAnn(cd, equalleft, equalright);
           ZDeclList decls = factory_.createZDeclList();
           decls.add(cd);
           ZSchText st = factory_.createZSchText(decls, null);
           addLocAnn(st, dnleft, dnright);
           RESULT = factory_.createAxPara(fp, st, Box.OmitBox);
           addLocAnn(RESULT, dnleft, dnright);
        :}
        |
        genName:gn DEFEQUAL:equal expression:e
        {:
           DeclName dn = gn.getFirst();
           List&lt;DeclName&gt; fp = gn.getSecond();
           ConstDecl cd = factory_.createConstDecl(dn, e);
           addLocAnn(cd, equalleft, equalright);
           ZDeclList decls = factory_.createZDeclList();
           decls.add(cd);
           ZSchText st = factory_.createZSchText(decls, null);
           RESULT = factory_.createAxPara(fp, st, Box.OmitBox);
           addLocAnn(RESULT, gnleft, gnright);
        :}
        ;


freeTypeList ::=
        freeTypeDefinition:ftd ANDALSO freeTypeList:ftl
        {: 
           ftl.add(0, ftd);
           RESULT = ftl;
        :}
        |
        freeTypeDefinition:ftd
        {: RESULT = list(ftd); :}
        ;

freeTypeDefinition ::=
        name:n DEFFREE:deffree branchList:bl
        {:
           RESULT = factory_.createFreetype(n, bl);
           addLocAnn(RESULT, deffreeleft, deffreeright);
        :}
        ;

branchList ::=
        branch:b BAR branchList:bl
        {:
           bl.add(0, b);
           RESULT = bl;
        :}
        |
        branch:b 
        {: RESULT = list(b); :}
        ;

branch ::=
        declName:dn
        {:
           RESULT = factory_.createBranch(dn, null);
           addLocAnn(RESULT, dnleft, dnright);
        :}
        |
        declName:dn LDATA expression:e RDATA
        {:
           RESULT = factory_.createBranch(dn, e);
           addLocAnn(RESULT, dnleft, dnright);
        :}
        ;

narrWordList ::=
        TEXT:t narrWordList:nwl 
        {:
           nwl.add(0, t);
           RESULT = nwl;
        :}
        |
        TEXT:t
        {: RESULT = list(t); :}
        ;

// operator templates  /////////////////////////////////////////////////////

operatorTemplate ::=
        RELATION:rel template:t
        {:
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(t);
           RESULT.setCat(Cat.Relation);
           addLocAnn(RESULT, relleft, relright);
        :}
        |
        FUNCTION:fun catTemplate:ct
        {:
           ct.setCat(Cat.Function);
           addLocAnn(ct, funleft, funright);
           RESULT = ct;
        :}
        |
        GENERIC:g catTemplate:ct
        {:
           ct.setCat(Cat.Generic);
           addLocAnn(ct, gleft, gright);
           RESULT = ct;
        :}
        ;

template ::=
        prefixTemplate:pt
        {: RESULT = pt; :}
        |
        postfixTemplate:pt
        {: RESULT = pt; :}
        |
        infixTemplate:it
        {: RESULT = it; :}
        |
        nofixTemplate:nt
        {: RESULT = nt; :}
        ;


catTemplate ::=
        prefixTemplate:pt
        {: 
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(pt);
        :}
        |
        postfixTemplate:pt
        {: 
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(pt);
        :}
        |
        NUMERAL:pr assoc:a infixTemplate:it
        {:
           RESULT = factory_.createOptempPara();
           RESULT.setPrec(pr);
           RESULT.getOper().addAll(it);
           RESULT.setAssoc(a);
        :}
        |
        nofixTemplate:nt
        {:
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(nt);
        :}
        ;


assoc ::=
        LEFTASSOC
        {: RESULT = Assoc.Left; :}
        |
        RIGHTASSOC
        {: RESULT = Assoc.Right; :}
        ;


prefixTemplate ::=
        LPAREN DECORWORD:n optWordOperandList:ol varg:v RPAREN
        {:
           ol.add(0, createOperator(n, nleft, nright));
           ol.add(v);
           RESULT = ol; 
        :}
	|
	LPAREN POWER:p varg:v RPAREN
	{:
           RESULT = list(createOperator(ZString.POWER, pleft, pright), v);
	:}
        ;


postfixTemplate ::=
        LPAREN varg:v DECORWORD:n optWordOperandList:ol RPAREN
        {:
           ol.add(0, createOperator(n, nleft, nright));
           ol.add(0, v);
           RESULT = ol; 
        :}
        ;


infixTemplate ::=
        LPAREN varg:v1 DECORWORD:n optWordOperandList:ol varg:v2 RPAREN
        {:
           ol.add(0, createOperator(n, nleft, nright));
           ol.add(0, v1);
           ol.add(v2);
           RESULT = ol; 
        :}
        ;


nofixTemplate ::=
        LPAREN DECORWORD:n optWordOperandList:ol RPAREN:rp
        {:
           if (ol.size() &lt; 1) {
             parser.report_error(ParseMessage.MSG_UNEXPECTED_TOKEN,
                                 new Object[] {"RPAREN"},
                                 getLocation(rpleft, rpright));
           }
           ol.add(0, createOperator(n, nleft, nright));
           RESULT = ol;
        :}
        ;


optWordOperandList ::=
        //empty
        {: RESULT = list(); :}
        |
        optWordOperandList:wl templateTag:t DECORWORD:n
        {:
           wl.add(t);
           wl.add(createOperator(n, nleft, nright));
           RESULT = wl;
        :}
        ;

templateTag ::=
        varg:v
        {: RESULT = v; :}
        |
        LISTARG:listarg
        {: RESULT = factory_.createOperand(Boolean.TRUE); :}
        ;

varg ::=
        ARG:arg
        {: RESULT = factory_.createOperand(Boolean.FALSE); :}
        ;

<add:circus>   
/// Channel Paragraph ////////////////////////////////

channelPara ::= 
        CIRCCHAN:chan declPart:dp
        {:  
           //RESULT = factory_.createChannelPara(null, dp);  TODO:
           RESULT = factory_.createChannelPara();
           addLocAnn(RESULT, chanleft, chanright);
        :}                
        ;
</add:circus>     
                
/// schema text ///////////////////////////////////////////

schemaText ::= 
        optDeclPart:odp BAR predicate:p
        {: RESULT = factory_.createZSchText(odp, p); :}
        |
        optDeclPart:odp
        {: RESULT = factory_.createZSchText(odp, null); :}
        ;

optDeclPart ::=
        //empty
        {: RESULT = factory_.createZDeclList(); :}
        |
        declPart:dp
        {: RESULT = dp; :}
        ;

declPart ::=
        zDeclList:zdl
        {: RESULT = zdl; :}
<add:zpatt>
        | jokerDeclList:jdl
        {: RESULT = jdl; :}
        ;

jokerDeclList ::=
        zDeclList:zdl sep:s JOKERDECLLIST:j
        {: RESULT = factory_.createHeadDeclList(zdl,
             factory_.createJokerDeclList(j)); :}
        |
        JOKERDECLLIST:j
        {:
           RESULT = factory_.createJokerDeclList(j);
        :}
</add:zpatt>
        ;

zDeclList ::=
        declaration:d
        {: RESULT = factory_.createZDeclList(list(d)); :}
        |
        zDeclList:zdl sep:s declaration:d
        {:
           zdl.add(d);
           RESULT = zdl;
        :}
        ;

declaration ::=
        basicDeclaration:bd
        {: RESULT = bd; :}
        |
        expression:e
        {: RESULT = factory_.createInclDecl(e); :}
        ;

schemaTextNoExpression ::=
        optDeclPart:dp BAR predicate:p
        {: RESULT =
             factory_.createZSchText(dp, p); :}
        |
	zDeclList:zdl sep declaration:d
	{:
           zdl.add(d);
           RESULT = factory_.createZSchText(zdl, null);
	:}
	|
	basicDeclaration:bd
	{: 
           ZDeclList zdl = factory_.createZDeclList(list(bd));
           RESULT = factory_.createZSchText(zdl, null);
        :}
        ;

basicDeclaration ::=
        varDecl:vd
        {: RESULT = vd; :}
        |
        constDecl:cd
        {: RESULT = cd; :}
<add:circus>
        |
        declWordList:dwl
        {: RESULT = factory_.createVarDecl(dwl, null); :}
</add:circus>
        ;

varDecl ::= 
        declWordList:dwl COLON:colon expression:e
        {:
           RESULT = factory_.createVarDecl(dwl, e);
           addLocAnn(RESULT, colonleft, colonright);
        :}
<add:zpatt>
        |
        JOKERNAME:jn COLON expression:e
        {:
           DeclName dn = factory_.createJokerDeclName(jn);
           RESULT = factory_.createVarDecl(list(dn), e);
           addLocAnn(RESULT, jnleft, jnright);
        :}
</add:zpatt>
        ;

constDecl ::= 
        declName:dn DEFEQUAL:defequal expression:e
        {:
           RESULT = factory_.createConstDecl(dn, e);
           addLocAnn(RESULT, defequalleft, defequalright);
        :}
<add:zpatt>
        |
        JOKERNAME:jn DEFEQUAL:defequal expression:e
        {:
           DeclName dn = factory_.createJokerDeclName(jn);
           RESULT = factory_.createConstDecl(dn, e);
           addLocAnn(RESULT, defequalleft, defequalright);
        :}
</add:zpatt>
        ;  

sep ::=
        SEMICOLON
        {: RESULT = And.Semi; :}
        |
        NL
        {: RESULT = And.NL; :}
        ;

/// word, declName, and refName lists ////////////////////////////////////

nameList ::=
        DECORWORD:dw COMMA nameList:nl
        {: 
           checkName(dw, dwleft, dwright);
           DeclName dn = factory_.createZDeclName(dw.getName());
           addLocAnn(dn, dwleft, dwright);
           nl.add(0, dn);
           RESULT = nl;
        :}
        |
        DECORWORD:dw
        {: 
           checkName(dw, dwleft, dwright);
           DeclName dn = factory_.createZDeclName(dw.getName());
           addLocAnn(dn, dwleft, dwright);
           RESULT = list(dn);
        :}
        ;

name ::=
        DECORWORD:dw
        {:
           checkName(dw, dwleft, dwright);
           RESULT = factory_.createZDeclName(dw.getName());
           addLocAnn(RESULT, dwleft, dwright);
        :}
<add:oz>
        |
        DEFNAME:dfn
        {:
           checkName(dfn, dfnleft, dfnright);
           RESULT = factory_.createZDeclName(dfn.getName());
           addLocAnn(RESULT, dfnleft, dfnright);
        :}
</add:oz>
        ;

declWordList ::=
        DECLWORD:dw COMMA declWordList:dwl
        {: 
           checkName(dw, dwleft, dwright);
           DeclName dn = factory_.createZDeclName(dw.getName());
           addLocAnn(dn, dwleft, dwright);
           dwl.add(0, dn); 
           RESULT = dwl;
        :}
        |
        opName:on COMMA declWordList:dwl
        {: 
           dwl.add(0, strListToZDeclName(on, onleft, onright)); 
           RESULT = dwl;
        :} 
        |
        misusedOpName:mon COMMA declWordList:dwl
        {:
           misusedOpName(mon, monleft, monright);
        :}        
        |
        opName:on
        {:
           DeclName dn = strListToZDeclName(on, onleft, onright);
           addLocAnn(dn, onleft, onright);
           RESULT = list(dn);
        :}
        |
        DECLWORD:dw
        {:
           checkName(dw, dwleft, dwright);
           DeclName dn = factory_.createZDeclName(dw.getName());
           addLocAnn(dn, dwleft, dwright);
           RESULT = list(dn); 
        :}
        |      
        misusedOpName:mon
        {:
           misusedOpName(mon, monleft, monright);
        :}
        ;

misusedOpName ::=
        PREP:p
        {: RESULT = p; :}
        |
        PRE:p
        {: RESULT = p; :}
        |
        POSTP:p
        {: RESULT = p; :}
        |
        POST:p
        {: RESULT = p; :}
        |
        IP:ip
        {: RESULT = ip; :}
        |
        I:i
        {: RESULT = i; :}
        |
        LP:lp
        {: RESULT = lp; :}
        |
        L:l
        {: RESULT = l; :}
        |
        ELP:elp
        {: RESULT = elp; :}
        |
        EL:el
        {: RESULT = el; :}
        |
        ERP:erp
        {: RESULT = erp; :}
        |
        ER:er
        {: RESULT = er; :}
        |
        SRP:srp
        {: RESULT = srp; :}
        |
        SR:sr
        {: RESULT = sr; :}
        |
        EREP:erep
        {: RESULT = erep; :}
        |
        ERE:ere
        {: RESULT = ere; :}
        |
        SREP:srep
        {: RESULT = srep; :}
        |
        SRE:sre
        {: RESULT = sre; :}
        |
        ES:es
        {: RESULT = es; :}
        |
        SS:ss
        {: RESULT = ss; :}
        ;

declName ::=
        DECORWORD:dw
        {:
           checkName(dw, dwleft, dwright);
           RESULT = factory_.createZDeclName(dw.getName());
           addLocAnn(RESULT, dwleft, dwright);
        :}
        |
<add:oz>
        DEFNAME:dfn
        {:
           checkName(dfn, dfnleft, dfnright);
           RESULT = factory_.createZDeclName(dfn.getName());
           addLocAnn(RESULT, dfnleft, dfnright);
        :}
        |
</add:oz>
        opName:on
        {:
           RESULT = strListToZDeclName(on, onleft, onright);
           addLocAnn(RESULT, onleft, onright);
        :}
        ;

refNameList ::=
        DECORWORD:dw COMMA refNameList:rnl
        {:
           checkName(dw, dwleft, dwright);
           RefName rn = factory_.createZRefName(dw.getName());
           addLocAnn(rn, dwleft, dwright);
           rnl.add(0, rn);
           RESULT = rnl;
        :}        
        <add:oz>
        |
        INITWORD:iw COMMA refNameList:rnl
        {:
           RefName rn = factory_.createZRefName(OzString.INITWORD);
           addLocAnn(rn, iwleft, iwright);
           rnl.add(0, rn);
           RESULT = rnl;
        :}
        </add:oz>
        |
        DECORWORD:dw
        {:
           checkName(dw, dwleft, dwright);
           RefName rn = factory_.createZRefName(dw.getName());
           addLocAnn(rn, dwleft, dwright);
           RESULT = list(rn);
        :}
        <add:oz>
        |
        INITWORD:iw
        {:
           RefName rn = factory_.createZRefName(OzString.INITWORD);
           addLocAnn(rn, iwleft, iwright);
           RESULT = list(rn);
        :}
        </add:oz>
        ;

refName ::=
        DECORWORD:dw
        {:
           checkName(dw, dwleft, dwright);
           RESULT = factory_.createZRefName(dw.getName());
           addLocAnn(RESULT, dwleft, dwright);
        :}        
        <add:oz>
        |
        INITWORD:iw
        {:
           RESULT = factory_.createZRefName(OzString.INITWORD);
           addLocAnn(RESULT, iwleft, iwright);
        :}
        </add:oz>
        |
        LPAREN opName:on RPAREN
        {:
           ZDeclName declName = strListToZDeclName(on, onleft, onright);
           RESULT = factory_.createZRefName(declName.getWord(),
                                            declName.getStroke(),
                                            null);
           RESULT.getAnns().add(factory_.createParenAnn());
           addLocAnn(RESULT, onleft, onright);
        :}
        ;


opName ::=
        prefixName:pn
        {: RESULT = pn; :}
        |
        postfixName:pn
        {: RESULT = pn; :}
        |
        infixName:in
        {: RESULT = in; :}
        |
        nofixName:nn
        {: RESULT = nn; :}
        ;

prefixName ::=
        PRE:p varg
        {: RESULT = list(p, ARG_TOK); :}
        |
        PREP:p varg
        {: RESULT = list(p, ARG_TOK); :}
        |
        L:l optVargEsSsList:ouesl argEreOrSre:aeos varg
        {: 
           RESULT = list(l);
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        :}
        |
        LP:lp optVargEsSsList:ouesl argErepOrSrep:aeos varg
        {: 
           RESULT = list(lp);
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        :}
        ;

postfixName ::=
        varg POST:p
        {: RESULT = list(ARG_TOK, p); :}
        |
        varg POSTP:p
        {: RESULT = list(ARG_TOK, p); :}
        |
        varg EL:el optVargEsSsList:ouesl argErOrSr:aeos
        {:
           RESULT = list(ARG_TOK);
           RESULT.add(el);
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        :}
        |
        varg ELP:elp optVargEsSsList:ouesl argErpOrSrp:aeos
        {:
           RESULT = list(ARG_TOK);
           RESULT.add(elp);
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        :}
        ;


infixName ::=
        varg I:i varg
        {:
           RESULT = list(ARG_TOK);
           RESULT.add(i);
           RESULT.add(ARG_TOK);
        :}
        |
        varg IP:ip varg
        {:
           RESULT = list(ARG_TOK);
           RESULT.add(ip);
           RESULT.add(ARG_TOK);
        :}
        |
        varg EL:el optVargEsSsList:ouesl argEreOrSre:aeos varg
        {:
           RESULT = list(ARG_TOK);
           RESULT.add(el);
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        :}
        |
        varg ELP:elp optVargEsSsList:ouesl argErepOrSrep:aeos varg
        {:
           RESULT = list(ARG_TOK);
           RESULT.add(elp);
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        :}
        ;

nofixName ::=
        L:l optVargEsSsList:ouesl argErOrSr:aeos
        {:
           RESULT = list(l);
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        :}
        |
        LP:lp optVargEsSsList:ouesl argErpOrSrp:aeos
        {:
           RESULT = list(lp);
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        :}
        ;

optVargEsSsList ::=
        //empty
        {: RESULT = list(); :}
        |
        optVargEsSsList:ouesl argEsOrSs:aeos
        {: 
           ouesl.addAll(aeos);
           RESULT = ouesl;
        :}
        ;

argEsOrSs ::=
        ARG ES:es
        {: RESULT = list(ARG_TOK, es); :}
        |
        LISTARG SS:ss
        {: RESULT = list(LISTARG_TOK, ss); :}
        ;

argEreOrSre ::=
        ARG ERE:ere
        {: RESULT = list(ARG_TOK, ere); :}
        |
        LISTARG SRE:sre
        {: RESULT = list(LISTARG_TOK, sre); :}
        ;

argErepOrSrep ::=
        ARG EREP:erep
        {: RESULT = list(ARG_TOK, erep); :}
        |
        LISTARG SREP:srep
        {: RESULT = list(LISTARG_TOK, srep); :}
        ;

argErOrSr ::=
        ARG ER:er
        {: RESULT = list(ARG_TOK, er); :}
        |
        LISTARG SR:sr
        {: RESULT = list(LISTARG_TOK, sr); :}
        ;

argErpOrSrp ::=
        ARG ERP:erp
        {: RESULT = list(ARG_TOK, erp); :}
        |
        LISTARG SRP:srp
        {: RESULT = list(LISTARG_TOK, srp); :}
        ;

//a genName is returned as a pair, with the first item being the name,
//and the second being a list of generic parameters
genName ::=
        prefixGenName:pgn
        {: RESULT = pgn; :}
        |
        postfixGenName:pgn
        {: RESULT = pgn; :}
        |
        infixGenName:ign
        {: RESULT = ign; :}
        |
        nofixGenName:ngn
        {: RESULT = ngn; :}
        ;

prefixGenName ::=
        PRE:pre formalParameterName:fpn
        {:
           List&lt;String&gt; name = list(pre, ARG_TOK);
           List&lt;DeclName&gt; decls = list(fpn);
           DeclName declName = strListToZDeclName(name, fpnleft, fpnright);
           RESULT = pair(declName, decls);
        :}
        |
        L:l optNameEsSsList:onesl formalParameterName:fpn1
             ereOrSre:eos formalParameterName:fpn2
        {:
           //construct the name
           List&lt;String&gt; name = list(l);
           name.addAll((List) onesl.getSecond());
           name.add(ARG_TOK);
           name.add(eos);
           name.add(ARG_TOK);

           //construct the parameter list
           List&lt;DeclName&gt; fps = (List&lt;DeclName&gt;) onesl.getFirst();
           fps.add(fpn1);
           fps.add(fpn2);

           DeclName declName = strListToZDeclName(name, fpn2left, fpn2right);
           RESULT = pair(declName, fps); 
        :}
        ;

postfixGenName ::=
        formalParameterName:fpn POST:p
        {:
           List&lt;String&gt; name = list(ARG_TOK, p);
           List&lt;DeclName&gt; decls = list(fpn);
           DeclName declName = strListToZDeclName(name, pleft, pright);
           RESULT = pair(declName, decls);
        :}
        |
        formalParameterName:fpn1 EL:el optNameEsSsList:onesl 
           formalParameterName:fpn2 erOrSr:eos
        {:
           //construct the name
           List&lt;String&gt; name = list(ARG_TOK);
           name.add(el);
           name.addAll((List) onesl.getSecond());
           name.add(ARG_TOK);
           name.add(eos);

           //construct the parameter list
           List&lt;DeclName&gt; fps = list(fpn1);
           fps.addAll((List) onesl.getFirst());
           fps.add(fpn2);

           DeclName declName = strListToZDeclName(name, eosleft, eosright);
           RESULT = pair(declName, fps);
         :}
        ;

infixGenName ::=
        formalParameterName:fpn1 I:i formalParameterName:fpn2
        {:
           //construct the name
           List&lt;String&gt; name = list(ARG_TOK);
           name.add(i);
           name.add(ARG_TOK);

           //construct the parameter list
           List&lt;DeclName&gt; fps = list(fpn1, fpn2);

           DeclName declName = strListToZDeclName(name, fpn2left, fpn2right);
           RESULT = pair(declName, fps);
        :}
        |
        formalParameterName:fpn1 EL:el optNameEsSsList:onesl 
           formalParameterName:fpn2 ereOrSre:eos formalParameterName:fpn3
        {:
           //construct the name
           List&lt;String&gt; name = list(ARG_TOK);
           name.add(el);
           name.addAll((List) onesl.getSecond());
           name.add(ARG_TOK);
           name.add(eos);
           name.add(ARG_TOK);
           //construct the parameter list
           List&lt;DeclName&gt; fps = list(fpn1);
           fps.addAll((List) onesl.getFirst());
           fps.add(fpn2);
           fps.add(fpn3);

           DeclName declName = strListToZDeclName(name, fpn3left, fpn3right);
           RESULT = pair(declName, fps);
        :}
        ;

nofixGenName ::=
        L:l optNameEsSsList:onesl formalParameterName:fpn erOrSr:eos
        {:
           //construct the name
           List&lt;String&gt; name = list(l);
           name.addAll((List) onesl.getSecond());
           name.add(ARG_TOK);
           name.add(eos);

           //construct the parameter list
           List&lt;DeclName&gt; fps = (List) onesl.getFirst();
           fps.add(fpn);

           DeclName declName = strListToZDeclName(name, eosleft, eosright);
           RESULT = pair(declName, fps);
        :}
        ;

formalParameterName ::=
        DECORWORD:dw
        {: 
           checkName(dw, dwleft, dwright);
           RESULT = factory_.createZDeclName(dw.getName());
        :}
<add:oz>
        |
        DEFNAME:dn
        {:
           checkName(dn, dnleft, dnright);
           RESULT = factory_.createZDeclName(dn.getName());
        :}
</add:oz>
        ;

//an optNameEsSsList is returned as a pair, with the first item
//being a list comprising generic parameters, and the second being a
//list comprising the name
optNameEsSsList ::=
        //empty
        {: RESULT = pair(list(), list()); :}
        |
        optNameEsSsList:ouesl formalParameterName:fpn esOrSs:eos
        {:
           List gens = (List) ouesl.getFirst();
           gens.add(fpn);
           List name = (List) ouesl.getSecond();
           name.add(ARG_TOK);
           name.add(eos);
           RESULT = ouesl;
        :}
        ;

esOrSs ::=
        ES:es
        {: RESULT = es; :}
        |
        SS:ss
        {: RESULT = ss; :}
        ;

ereOrSre ::=
        ERE:ere
        {: RESULT = ere; :}
        |
        SRE:sre
        {: RESULT = sre; :}
        ;

erOrSr ::=
        ER:er
        {: RESULT = er; :}
        |
        SR:sr
        {: RESULT = sr; :}
        ;

/// predicates and expressions ///////////////////////////////////////////////

// This is for terms which MUST be predicates, so MIGHT contain NL/SEMI.
predicate ::=
        predicate:lhs sep:s term:rhs
        {:
           RESULT = factory_.createAndPred(lhs, pred(rhs), s);
           addLocAnn(RESULT, sleft, sright);
        :}
        |
        term:p
        {: RESULT = pred(p); :}
        ;

expression ::=
        term:t
        {: RESULT = expr(t); :}
        ;

// This is for terms (which may be expr or pred) which MIGHT contain
// NL/SEMI.  If they do contain NL/SEMI, they must be predicates!
septerm ::=
        septerm:lhs sep:s term:rhs
        {:
           RESULT = factory_.createAndPred(pred(lhs), pred(rhs), s);
           addLocAnn(RESULT, sleft, sright);
        :}
	|
	term:t
	{: RESULT = t; :}
	;

term ::=
        /* conditional */
        IF:i predicate:p THEN term:te ELSE term:fe
        {:
           RESULT = factory_.createCondExpr(p, expr(te), expr(fe));
           addLocAnn(RESULT, ileft, iright);
        :}
        |
        /* (schema) universal quantification */
        ALL:all schemaText:st SPOT term:t
        {: 
           if (t instanceof Expr) {
             RESULT = factory_.createForallExpr(st, expr(t));
           }
           else {
             RESULT = factory_.createForallPred(st, pred(t));
           }
           addLocAnn(RESULT, allleft, allright);
        :}
        |
        /* (schema) existential quantification */
        EXI:exi schemaText:st SPOT term:t
        {:
           if (t instanceof Expr) {
             RESULT = factory_.createExistsExpr(st, expr(t));
           }
           else {
             RESULT = factory_.createExistsPred(st, pred(t));
           }
           addLocAnn(RESULT, exileft, exiright);
        :}
        |
        /* (schema) unique existential quantification */
        EXIONE:exione schemaText:st SPOT term:t
        {: 
           if (t instanceof Expr) {
             RESULT = factory_.createExists1Expr(st, expr(t));
           }
           else {
             RESULT = factory_.createExists1Pred(st, pred(t));
           }
           addLocAnn(RESULT, exioneleft, exioneright);
        :}
        |
        /* function construction */
        LAMBDA:lambda schemaText:st SPOT term:t
        {:
           RESULT = factory_.createLambdaExpr(st, expr(t));
           addLocAnn(RESULT, lambdaleft, lambdaright);
        :} %prec LAMBDA
        |
        /* definite description */
        MU:mu schemaText:st SPOT term:t
        {:
           RESULT = factory_.createMuExpr(st, expr(t));
           addLocAnn(RESULT, muleft, muright);
        :} %prec MU
        |
        /* substitution expression */
        LET:let letDefinitionList:ldl SPOT term:t 
        {: 
           ZSchText st = factory_.createZSchText(ldl, null);
           RESULT = factory_.createLetExpr(st, expr(t));
           addLocAnn(RESULT, letleft, letright);
        :} %prec LET
        |
        /* (schema) equivalence */
        term:lhs IFF:iff term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createIffExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createIffPred(pred(lhs), pred(rhs));
          }
          addLocAnn(RESULT, iffleft, iffright);
        :}
        |
        /* (schema) implication */
        term:lhs IMP:imp term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createImpliesExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createImpliesPred(pred(lhs), pred(rhs));
          }
          addLocAnn(RESULT, impleft, impright);
        :}
        |
        /* (schema) disjunction */
        term:lhs OR:or term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createOrExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createOrPred(pred(lhs), pred(rhs));
          }
          addLocAnn(RESULT, orleft, orright);
        :}
        |
        /* (schema) conjunction */
        term:lhs AND:and term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createAndExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createAndPred(pred(lhs), pred(rhs), And.Wedge);
          }
          addLocAnn(RESULT, andleft, andright);
        :}
        |
        /* (schema) negation */
        NOT:not term:t
        {:
          if (t instanceof Expr) {
            RESULT = factory_.createNegExpr(expr(t));
          }
          else {
            RESULT = factory_.createNegPred(pred(t));
          }
          addLocAnn(RESULT, notleft, notright);
        :}
        |
        /* schema composition */
        term:lhs ZCOMP:comp term:rhs
        {:
           RESULT = factory_.createCompExpr(expr(lhs), expr(rhs));
           addLocAnn(RESULT, compleft, compright);
        :}
        |
        /* schema piping */
        term:lhs ZPIPE:pipe term:rhs
        {:
           RESULT = factory_.createPipeExpr(expr(lhs), expr(rhs));
           addLocAnn(RESULT, pipeleft, piperight);
        :}
        |
        /* schema hiding */
        term:t ZHIDE:hide LPAREN refNameList:rnl RPAREN
        {:
           ZRefNameList zRefNameList = factory_.createZRefNameList(rnl);
           RESULT = factory_.createHideExpr(expr(t), zRefNameList);
           addLocAnn(RESULT, hideleft, hideright);
        :}
        |
<add:zpatt>
        /* schema hiding */
        term:t ZHIDE:hide LPAREN JOKERNAMELIST:jnl RPAREN
        {:
           ZRefName rn = factory_.createZRefName(jnl, null);
           List&lt;RefName&gt; rnl = list((RefName) rn);
           ZRefNameList zRefNameList = factory_.createZRefNameList(rnl);
           RESULT = factory_.createHideExpr(expr(t), zRefNameList);
           addLocAnn(RESULT, hideleft, hideright);
        :}
        |
</add:zpatt>
        /* schema projection */
        term:lhs ZPROJ:proj term:rhs
        {:
           RESULT = factory_.createProjExpr(expr(lhs), expr(rhs));
           addLocAnn(RESULT, projleft, projright);
        :}
        |
        /* schema precondition */
        ZPRE:pre term:t
        {:
           RESULT = factory_.createPreExpr(expr(t));
           addLocAnn(RESULT, preleft, preright);
        :}
        |
        /* powerset */
        POWER:power term:t
        {:
           RESULT = factory_.createPowerExpr(expr(t));
           addLocAnn(RESULT, powerleft, powerright);
        :}
        |
        /* Cartesian product */
        prodExpressionList:pel
        {:
           RESULT = factory_.createProdExpr(pel);
           addLocAnn(RESULT, pelleft, pelright);
        :}
        |
        /* relation operator application */
        relation:rel
        {: RESULT = rel; :}
        |
        /* application of operator function */
        application:a
        {: RESULT = a; :}
        |
        /* application of non-operator function */
        func_appl:fa
        {: RESULT = fa; :}
<add:oz>
        |
        /* class union */
        term:lhs CLASSUNION:classunion term:rhs
        {:
           RESULT = factory_.createClassUnionExpr(expr(lhs), expr(rhs));
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        /* polymorphism expression */
        POLY:poly term:t
        {:
           RESULT = factory_.createPolyExpr(expr(t));
           addLocAnn(RESULT, polyleft, polyright);
        :}
        |
        /* object containment */
        term:t CONTAINMENT:containment
        {:
           RESULT = factory_.createContainmentExpr(expr(t));
           addLocAnn(RESULT, tleft, tright);
        :}
</add:oz>
        ;

func_appl ::=
        func_appl:fa inner_term:it
        {:
           RESULT = factory_.createApplExpr(expr(fa), expr(it), Boolean.FALSE);
           addLocAnn(RESULT, faleft, itright);
        :} %prec _APPLICATION
        |
        inner_term:it
        {: RESULT = it; :} %prec _APPLICATION
        ;

inner_term ::=
        /* set extension */
        LBRACE:lbrace optExpressionList:oel RBRACE
        {:
           RESULT = factory_.createSetExpr(oel);
           addLocAnn(RESULT, lbraceleft, lbraceright);
        :}
        |
        /* set comprehension */
        LBRACE:lbrace schemaText:st SPOT expression:e RBRACE
        {:
           RESULT = factory_.createSetCompExpr(st, e);
           addLocAnn(RESULT, lbraceleft, lbraceright);
        :}
	|
        /*  characteristic set comprehension */
        LBRACE:lbrace schemaTextNoExpression:stne RBRACE
        {:
           RESULT = factory_.createSetCompExpr(stne, null);
           addLocAnn(RESULT, lbraceleft, lbraceright);
        :}
	|
        /* tuple extension */
        LPAREN:lparen expressionList:el COMMA expression:e RPAREN
        {: 
           el.add(e);
           RESULT = factory_.createTupleExpr(el);
           addLocAnn(RESULT, lparenleft, lparenright);
        :}
        |
        /* characteristic definite description */
        LPAREN MU schemaText:st RPAREN
        {:
           RESULT = factory_.createMuExpr(st, null);
           RESULT.getAnns().add(factory_.createParenAnn());
        :}
        |
        nofixRel:nfr
        {: RESULT = nfr; :} %prec ERP
        |
        nofixApp:nfa
        {: RESULT = nfa; :} %prec _APPLICATION
        |
        /* binding extension */
        LBIND:lbind optConstDeclList:cdl RBIND
        {:
           RESULT = factory_.createBindExpr(cdl);
           addLocAnn(RESULT, lbindleft, lbindright);
        :}
        |
        /* empty schema construction */
        LSQUARE:lsq RSQUARE
        {:
           DeclList dl = factory_.createZDeclList();
           RESULT = factory_.createSchExpr(factory_.createZSchText(dl, null));
           addLocAnn(RESULT, lsqleft, lsqright);
        :}
        |
        /* schema construction */
        LSQUARE:lsq schemaTextNoExpression:stne RSQUARE
        {:
           RESULT = factory_.createSchExpr(stne);
           addLocAnn(RESULT, lsqleft, lsqright);
        :}
        |
        /* binding selection */
        inner_term:it DOT:dot refName:rn
        {:
           RESULT = factory_.createBindSelExpr(expr(it), rn);
           addLocAnn(RESULT, dotleft, dotright);
        :}
        |
        /* tuple selection */
        inner_term:it DOT:dot NUMERAL:n
        {:
           ZNumeral numeral = factory_.createZNumeral(n);
           RESULT = factory_.createTupleSelExpr(expr(it), numeral);
           addLocAnn(RESULT, dotleft, dotright);
        :}
        |
        /* schema decoration */
        inner_term:it stroke:s
        {:
           //if the inner term is a theta expr, add the stroke to the
           //theta expr instead, which has a tighter binding.
           Object pAnn = it.getAnn(ParenAnn.class);
           if (it instanceof ThetaExpr &amp;&amp; pAnn == null) {
             ThetaExpr te = (ThetaExpr) it;
             List&lt;Stroke&gt; sl = list(te.getStroke());
             sl.add(s);
             RESULT = factory_.createThetaExpr(te.getExpr(), sl);
           }
           else {
             RESULT = factory_.createDecorExpr(expr(it), s);
           }
           addLocAnn(RESULT, itleft, itright);
        :}
        |
        /* binding construction */
        THETA:theta inner_term:it
        {:
           RESULT = factory_.createThetaExpr(expr(it), null);
           addLocAnn(RESULT, thetaleft, thetaright);
        :}
        |
        /* function application with schema expr as argument */
        inner_term:it LSQUARE schemaTextNoExpression:st RSQUARE
        {:
           SchExpr se = factory_.createSchExpr(st);
           RESULT = factory_.createApplExpr(expr(it), se, Boolean.FALSE);
           addLocAnn(RESULT, itleft, itright);
        :}
        |
        /* generic instantiation */
        /* If inner_term is changed to refName
           (as in the grammar given in the Z Standard),
           rename expressions fail to parse. */
        inner_term:it LSQUARE expressionList:el RSQUARE
        {:
           RESULT = factory_.createRefExpr(refname(it), el, Boolean.FALSE);
           addLocAnn(RESULT, itleft, itright);
        :}
        |
        /* schema renaming */
        inner_term:it LSQUARE renameList:rnl RSQUARE
        {:
           RESULT = factory_.createRenameExpr(expr(it), rnl);
           addLocAnn(RESULT, itleft, itright);
        :} %prec _RENAME
        |
        /* number literal */
        NUMERAL:n
        {:
           ZNumeral numeral = factory_.createZNumeral(n);
           RESULT = factory_.createNumExpr(numeral);
           addLocAnn(RESULT, nleft, nright);
        :}
        |
        /* parenthesized expression/predicate */
        LPAREN septerm:t RPAREN
        {:
           t.getAnns().add(factory_.createParenAnn());
           RESULT = t;
        :}
        |
        /* reference */
        refName:rn
        {:
           RESULT = factory_.createRefExpr(rn);
           addLocAnn(RESULT, rnleft, rnright);
        :}
        |
        /* truth */
        TRUE:t
        {:
           RESULT = factory_.createTruePred();
           addLocAnn(RESULT, tright, tleft);
        :}
        |
        /* falsity */
        FALSE:f
        {:
           RESULT = factory_.createFalsePred();
           addLocAnn(RESULT, fleft, fright);
        :}
<add:zpatt>
        |
        jokerRef:jr
        {:
           RESULT = jr;
           addLocAnn(RESULT, jrleft, jrright);
        :}
</add:zpatt>
        ;

prodExpressionList ::=
        term:t1 CROSS term:t2
        {:
           RESULT = factory_.createZExprList();
           RESULT.add(expr(t1));
           RESULT.add(expr(t2));
        :}
        |
        prodExpressionList:pel CROSS term:t
        {:
           pel.add(expr(t));
           RESULT = pel;
        :}
        ;

optExpressionList ::=
        //empty
        {: RESULT = factory_.createZExprList(); :}
        |
        expressionList:el
        {: RESULT = el; :}
        ;

expressionList ::=
        expressionList:el COMMA expression:e
        {:      
           el.add(e);
           RESULT = el;
        :}
        |
        expression:e
        {:
           RESULT = factory_.createZExprList();
           RESULT.add(e);
        :}
        ;


optConstDeclList ::=
        //empty
        {: RESULT = factory_.createZDeclList(); :}
        |
        constDeclList:cdl
        {: RESULT = cdl; :}
        ;

constDeclList ::=
        constDecl:cd COMMA constDeclList:cdl
        {:      
           cdl.getDecl().add(0, cd);
           RESULT = cdl;
        :}
        |
        constDecl:cd
        {: RESULT = factory_.createZDeclList(list(cd)); :}
        ;       

letDefinitionList ::=
        letDefinition:ld SEMICOLON letDefinitionList:ldl 
        {:
           ldl.getDecl().add(0, ld);
           RESULT = ldl;
        :}
        |
        letDefinition:ld
        {: RESULT = factory_.createZDeclList(list(ld)); :}
        ;       

letDefinition ::=
        declName:n DEFEQUAL:defequal expression:e
        {:
           RESULT = factory_.createConstDecl(n,e);
           addLocAnn(RESULT, defequalleft, defequalright);
        :}
        ;

stroke ::=
        INSTROKE
        {: RESULT = factory_.createInStroke(); :}
        |
        OUTSTROKE
        {: RESULT = factory_.createOutStroke(); :}
        |
        NEXTSTROKE
        {: RESULT = factory_.createNextStroke(); :}
        |
        NUMSTROKE:ns
        {: RESULT = factory_.createNumStroke(ns); :}
        ;

renameList ::= 
        rename:rn COMMA renameList:rnl
        {:
           rnl.getNewOldPair().add(0, rn);
           RESULT = rnl;
        :}
        |
        rename:rn  
        {: RESULT = factory_.createZRenameList(list(rn)); :}
        ;    

rename ::=
        declName:lhs SLASH refName:rhs
        {: RESULT = factory_.createNewOldPair(lhs, rhs); :}
        ;


//nofix relation is not included here because it has a different precedence
//than the other types of relation
relation ::=
        prefixRel:pr
        {: RESULT = pr; :}
        |
        postfixRel:pr
        {: RESULT = pr; :}
        |
        infixRel:ir
        {: RESULT = ir; :}
        ;

//according to the ISO standard, op e1 is equivalent to
//e mem op
prefixRel ::=
        PREP:p term:t
        {:
           List&lt;String&gt; opName = list(p);
           opName.add(ARG_TOK);
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(t));
           RESULT = localCreateMemPred(opName, exprs, pleft, pright);
           addLocAnn(RESULT, pleft, pright);
        :}
        |
        LP:lp expSep:es term:t1 EREP:erep term:t2
        {: 
           List&lt;String&gt; opName = list(lp);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erep);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t1));
           expList.add(expr(t2));
           RESULT = localCreateMemPred(opName, expList, lpleft, lpright);
           addLocAnn(RESULT, lpleft, lpright);
        :}
        |
        LP:lp expSep:es optExpressionList:oel SREP:srep term:t
        {:
           List&lt;String&gt; opName = list(lp);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srep);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, oelleft, oelright);
           expList.add(seq);
           expList.add(expr(t));
           RESULT = localCreateMemPred(opName, expList, lpleft, lpright);
           addLocAnn(RESULT, lpleft, lpright);
        :}
        ;

postfixRel ::=
        term:t POSTP:p
        {:
           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t));
           RESULT = localCreateMemPred(list(p), expList, tleft, tright);
           addLocAnn(RESULT, pleft, pright);
        :}
        |
        term:t1 ELP:elp expSep:es term:t2 ERP:erp
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erp);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           RESULT = localCreateMemPred(opName, expList, t1left, t1right);
           addLocAnn(RESULT, elpleft, elpright);
        :}
        |
        term:t ELP:elp expSep:es optExpressionList:oel SRP:srp
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srp);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, oelleft, oelright);
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           RESULT = localCreateMemPred(opName, expList, tleft, tright);
           addLocAnn(RESULT, elpleft, elpright);
        :}
        ;

infixRel ::=
        infixChainRel:icr
        {: RESULT = icr; :}
        |
        term:t1 ELP:elp expSep:es term:t2 EREP:erep term:t3
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erep);
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           expList.add(expr(t3));
           RESULT = localCreateMemPred(opName, expList, t1left, t2right);
           addLocAnn(RESULT, elpleft, elpright);
        :}
        |
        term:t1 ELP:elp expSep:es optExpressionList:oel SREP:erep term:t2
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(erep);
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, oelleft, oelright);
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           expList.add(expr(t2));
           RESULT = localCreateMemPred(opName, expList, t1left, t1right);
           addLocAnn(RESULT, elpleft, elpright);
        :}
        ;

infixChainRel ::=
        term:lhs MEM:m term:rhs
        {:
           previousChain_ = Sym.MEM;
           RESULT = factory_.createMemPred(expr(lhs), expr(rhs), Boolean.FALSE);
           addLocAnn(RESULT, mleft, mright);
        :}
        |
        term:lhs EQUALS:equals term:rhs
        {:
           previousChain_ = Sym.EQUALS;
           RESULT = factory_.createEquality(expr(lhs), expr(rhs));
           addLocAnn(RESULT, equalsleft, equalsright);
        :}
        |
        term:lhs IP:ip term:rhs
        {:
           previousChain_ = Sym.IP;
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(ip);
           opName.add(ARG_TOK);
           ZExprList expList = factory_.createZExprList();
           expList.add(expr(lhs));
           expList.add(expr(rhs));
           RESULT = localCreateMemPred(opName, expList, lhsleft, lhsright);
           addLocAnn(RESULT, ipleft, ipright);
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr MEM term:rhs
        {:
           RESULT = transformChainRel(icr, Sym.MEM, expr(rhs),
                                      icrleft, icrright);
           addLocAnn(RESULT, icrleft, icrright);           
           previousChain_ = Sym.MEM;
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr EQUALS term:rhs
        {:
           RESULT = transformChainRel(icr, Sym.EQUALS, expr(rhs),
                                      icrleft, icrright);
           addLocAnn(RESULT, icrleft, icrright);
           previousChain_ = Sym.EQUALS;
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr IP:ip term:rhs
        {:
           RESULT = transformChainRelInfix(icr, expr(rhs), ip,
                                           icrleft, icrright);
           addLocAnn(RESULT, icrleft, icrright);
           previousChain_ = Sym.IP;
        :}
        ;

nofixRel ::=
        LP:lp expSep:es term:t ERP:erp
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erp);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t));
           RESULT = localCreateMemPred(opName, expList, lpleft, lpright);
           addLocAnn(RESULT, lpleft, lpright);
        :}
        |
        LP:lp expSep:es optExpressionList:oel SRP:srp
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srp);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, oelleft, oelright);
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           RESULT = localCreateMemPred(opName, expList, lpleft, lpright);
           addLocAnn(RESULT, lpleft, lpright);
        :}
        ;


//nofix application is not included here because it has a different
//precedence to the other types of application
application ::=
        prefixApp:pa
        {: RESULT = pa; :}
        |
        postfixApp:pa
        {: RESULT = pa; :}
        |
        infixApp:ia
        {: RESULT = ia; :}
        ;

prefixApp ::=
        PRE:pre term:t
        {:
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(t));
           RESULT = localCreateMixfixExpr(list(pre, ARG_TOK), exprs,
                                          preleft, preright);
           addLocAnn(RESULT, preleft, preright);
        :}
        |
        L:l expSep:es term:t1 ERE:ere term:t2
        {:
           List&lt;String&gt; opName = list(l);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(ere);
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t1));
           expList.add(expr(t2));
           RESULT = localCreateMixfixExpr(opName, expList, lleft, lright);
           addLocAnn(RESULT, lleft, lright);
        :}
        |
        L:l expSep:es optExpressionList:oel SRE:sre term:t
        {:
           List&lt;String&gt; opName = list(l);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sre);
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, oelleft, oelright);
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           expList.add(expr(t));
           RESULT = localCreateMixfixExpr(opName, expList, lleft, lright);
           addLocAnn(RESULT, lleft, lright);
        :}
        ;

postfixApp ::=
        term:t POST:post
        {:
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(t));
           RESULT = localCreateMixfixExpr(list(ARG_TOK, post), exprs,
                                          tleft, tright);
           addLocAnn(RESULT, postleft, postright);
        :}
        |
        term:t1 EL:el expSep:es term:t2 ER:er
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(er);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           RESULT = localCreateMixfixExpr(opName, expList, t1left, t1right);
           addLocAnn(RESULT, elleft, elright);
        :}
        |
        term:t EL:el expSep:es optExpressionList:oel SR:sr
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sr);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, oelleft, oelright);
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           RESULT = localCreateMixfixExpr(opName, expList, tleft, tright);
           addLocAnn(RESULT, elleft, elright);
        :}
        ;

infixApp ::=
        term:lhs I:i term:rhs
        {: 
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(i);
           opName.add(ARG_TOK);
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(lhs));
           exprs.add(expr(rhs));
           RESULT = localCreateMixfixExpr(opName, exprs,
                                          lhsleft, lhsright);
           addLocAnn(RESULT, ileft, iright);
        :}
        |
        term:t1 EL:el expSep:es term:t2 ERE:ere term:t3
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(ere);
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           expList.add(expr(t3));
           RESULT = localCreateMixfixExpr(opName, expList, t1left, t1right);
           addLocAnn(RESULT, elleft, elright);
        :}
        |
        term:t1 EL:el expSep:es optExpressionList:oel SRE:sre term:t2
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sre);
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, oelleft, oelright);
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           expList.add(expr(t2));
           RESULT = localCreateMixfixExpr(opName, expList, t1left, t1right);
           addLocAnn(RESULT, elleft, elright);
        :}
        ;

nofixApp ::=
        L:l expSep:es term:t ER:er
        {:
           List&lt;String&gt; opName = list(l);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(er);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t));
           RESULT = localCreateMixfixExpr(opName, expList, lleft, lright);
           addLocAnn(RESULT, lleft, lright);
        :}
        |
        L:l expSep:es optExpressionList:oel SR:sr
        {:
           List&lt;String&gt; opName = list(l);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sr);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, oelleft, oelright);
           expList.add(seq);
           RESULT = localCreateMixfixExpr(opName, expList, lleft, lright);
           addLocAnn(RESULT, lleft, lright);
        :}
        ;

expSep ::=
        //empty
        {: RESULT = list(); :} %prec I
        |
        expSep:exs term:t ES:es
        {:
           exs.add(list(expr(t)));
           exs.add(es);
           RESULT = exs;
        :}
        |
        expSep:exs expressionList:el SS:ss
        {:
           exs.add(el);
           exs.add(ss);
           RESULT = exs;
        :}
        ;

optNL ::=
        //empty
        |
        NL
        ;

<add:zpatt>
/// Z pattern constructs ///////////////////////////////////////////////
jokerPara ::=
        JOKER:j DECORWORD:dw jokerList:jl END
        {:
           JokerType type = JokerType.Expr;
           try {
             type = JokerType.fromString(dw.getName());
           }
           catch (IllegalArgumentException e) {
             parser.report_error(ZpattParseMessage.MSG_UNKNOWN_JOKER_TYPE,
                          new Object[] { dw },
                          getLocation(dwleft, dwright));
           }
           RESULT = factory_.createJokers(jl, type);
           addLocAnn(RESULT, jleft, jright);
           try {
             jokerTable_.add(RESULT);
           }
           catch (JokerTable.JokerException e) {
             parser.report_error(ZpattParseMessage.MSG_CANNOT_ADD_JOKER,
                                 new Object[0],
                                 getLocation(jleft, jright));
           }
        :}
        ;

rulePara ::=
        RULE:r DECORWORD:dw antecedents:a RULELINE conclusion:c END
        {:
           List&lt;Sequent&gt; sequents = list((Sequent) c);
           sequents.addAll(a);
           RESULT = factory_.createRule(sequents, dw.getName());
           addLocAnn(RESULT, rleft, rright);
        :}
        |
        RULE:r DECORWORD:dw conclusion:c END
        {:
           List&lt;Sequent&gt; sequents = list((Sequent) c);
           RESULT = factory_.createRule(sequents, dw.getName());
           addLocAnn(RESULT, rleft, rright);
        :}
        ;

jokerList ::=
       DECORWORD:dw COMMA jokerList:jl
       {:
          jl.add(0, dw.getName());
          RESULT = jl;
       :}
       |
       DECORWORD:dw
       {: RESULT = list(dw.getName()); :}
       ;

antecedents ::=
        antecedents:a NL sequent:s
        {:
           a.add(s);
           RESULT = a;
        :}
        |
        sequent:s
        {:
           RESULT = list(s);
        :}
        ;

conclusion ::=
        term:t
        {:
           //czt.todo: What is the context?
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createPredSequent(sc, pred(t), null);
           addLocAnn(RESULT, tleft, tright);
        :}
        ;

sequent ::=
        provisoSequent:ps
        {: RESULT = ps; :}
        |
        predSequent:ps
        {: RESULT = ps; :}
        ;

provisoSequent ::=
        sequentLHS:slhs VDASH PROVISO proviso:p
        {: RESULT = p; :}
        |
        PROVISO proviso:p
        {: RESULT = p; :}
        ;

proviso ::=
        expression:e1 DEFEQUAL expression:e2
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createCalculateProviso(sc, e1, e2);
           addLocAnn(RESULT, e1left, e1right);
        :}
        |
        term:t COLON baseType:bt
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createTypeProviso(sc, expr(t), bt);
           addLocAnn(RESULT, tleft, tright);
        :}
        |
        term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createCheckProviso(sc, pred(t));
           addLocAnn(RESULT, tleft, tright);
        :}
        |
        lookupProviso:lp
        {: RESULT = lp; :}
        ;

lookupProviso ::=
        INSTROKE:is expression:e1 DEFEQUAL expression:e2
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createLookupConstDeclProviso(sc, expr(e1), expr(e2));
           addLocAnn(RESULT, isleft, isright);
        :}
        |
        INSTROKE:is term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createLookupPredProviso(sc, pred(t));
           addLocAnn(RESULT, tleft, tright);
        :}        
        ;

predSequent ::=
        sequentLHS:slhs VDASH term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createPredSequent(sc , pred(t), null);
           addLocAnn(RESULT, tleft, tright);
        :}
        |
        term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createPredSequent(sc, pred(t), null);
           addLocAnn(RESULT, tleft, tright);
        :}
        ;

sequentLHS ::=
        sequentLHS:slhs COMMA antecedent:a
        {:
           slhs.add(a);
           RESULT = slhs;
        :}
        |
        antecedent:a
        {:
           RESULT = list(a);
        :}
        ;

antecedent ::=
        term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createPredSequent(sc, pred(t), null);
           addLocAnn(RESULT, tleft, tright);
        :}
        |
        expression:e COLON baseType:bt
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createTypeProviso(sc, e, bt);
           addLocAnn(RESULT, eleft, eright);
        :}
        ;

baseType ::=
        refName:rn /* given type or generic parameter type */
        {:
           RESULT = factory_.createRefExpr(rn);
           addLocAnn(RESULT, rnleft, rnright);
        :}
        |
        POWER:p baseType:bt /* powerset type */
        {:
           RESULT = factory_.createPowerExpr(bt);
           addLocAnn(RESULT, pleft, pright);
        :}
        |
        baseType:lbt CROSS baseType:rbt /* Cartesian product type */
        {:
           if (lbt instanceof ProdExpr) {
             ProdExpr pt = (ProdExpr) lbt;
             pt.getZExprList().add(rbt);
           }
           else {
             ZExprList zExprList = factory_.createZExprList();
             zExprList.add(lbt);
             zExprList.add(rbt);
             RESULT = factory_.createProdExpr(zExprList);
           }
           addLocAnn(RESULT, lbtleft, lbtright);
        :}
        |
        LSQUARE:lsq signature:s RSQUARE /* schema type */
        {:
           ZSchText st = factory_.createZSchText(s, null);
           RESULT = factory_.createSchExpr(st);
           addLocAnn(RESULT, lsqleft, lsqright);
        :}
        |
        LSQUARE:lsq RSQUARE /* schema type with empty signature */
        {:
           RESULT = factory_.createSchExpr();
           addLocAnn(RESULT, lsqleft, lsqright);
        :}
        |
        JOKERTYPE:jt /* joker type */
        {:
           RESULT = factory_.createJokerExpr(jt);
           addLocAnn(RESULT, jtleft, jtright);
        :}
        ;

signature ::=
        varDeclList:vdl
        {: RESULT = vdl; :}
        |
        varJokerDeclList:jdl
        {: RESULT = jdl; :}
        ;

varDeclList ::=
        varDeclList:vdl SEMICOLON declName:dn COLON baseType:bt
        {:
           VarDecl vd = factory_.createVarDecl(list(dn), bt);
           vdl.getDecl().add(vd);
           RESULT = vdl;
        :}
        |
        declName:dn COLON baseType:bt
        {:
           VarDecl vd = factory_.createVarDecl(list(dn), bt);
           RESULT = factory_.createZDeclList(list(vd));
        :}
        ;

varJokerDeclList ::=
        varDeclList:vdl SEMICOLON JOKERDECLLIST:jdl
        {:
           RESULT = factory_.createHeadDeclList(vdl,
             factory_.createJokerDeclList(jdl));
        :}
        |
        JOKERDECLLIST:jdl
        {:
           RESULT = factory_.createJokerDeclList(jdl);
        :}        
        ;

jokerRef ::=
        JOKEREXPR:je
        {: RESULT = factory_.createJokerExpr(je); :}
        |
        JOKERPRED:jp
        {: RESULT = factory_.createJokerPred(jp); :}
        |
        JOKERNAME:jn
        {:
           RefName rn = factory_.createJokerRefName(jn);
           RESULT = factory_.createRefExpr(rn);
        :}
/*
        |
        JOKERDECLLIST:jdl
        {: RESULT = jdl; :}
*/
        |
        JOKERTYPE:jt
        {:
           ZRefName rn = factory_.createZRefName(jt, null);
           RESULT = factory_.createRefExpr(rn);
        :}
        ;

</add:zpatt>

<add:oz>
/// Object-Z constructs ///////////////////////////////////////////////
class ::=
        classHeader:ch optNL
            visibilityList:vl
            inheritedList:il
            innerParaList:ipl
            operationList:ol
        END
        {:
           //local definitions, states, and initial states are all
           //parsed as innerPara, because upon a LSQUARE of a 
           //horizontal state schema, javacup will shift to
           //a basicTypeDefinition
           State s = null;
           InitialState is = null;
           for (Iterator iter = ipl.iterator(); iter.hasNext(); ) {
             Object next = iter.next();
             if (next instanceof State) {
               if (s != null) {
                 parser.report_error(ParseMessage.MSG_DUPLICATE_STATE,
                                     new Object[] { next },
                                     getLocation(chleft, chright));
               }
               s = (State) next;
               iter.remove();
             }
             else if (next instanceof InitialState) {
               if (is != null) {
                 parser.report_error(ParseMessage.MSG_DUPLICATE_INIT,
                                     new Object[] { next },
                                     getLocation(chleft, chright));
               }
               is = (InitialState) next;
               iter.remove();
             }
           }
           DeclName dn = ch.getFirst();
           List&lt;DeclName&gt; ofp = ch.getSecond();
           RESULT = factory_.createClassPara(dn, ofp, vl, il, ipl, s, is, ol);
           addLocAnn(RESULT, chleft, chright);
        :}
        ;

classHeader ::=
        CLASS name:n
        {:
           List&lt;DeclName&gt; decls = list();
           RESULT = pair(n, decls);
        :}
        |
        GENCLASS name:n formalParameters:fp
        {: RESULT = pair(n, fp); :}
        ;

operationList ::=
        //empty
        {: RESULT = list(); :}
        |
        operation:o optNL operationList:ol
        {: 
           ol.add(0, o); 
           RESULT = ol;
        :}
        ;

/// class paragraphs ///////////////////////////////////////////////

visibilityList ::=
        //no list
        {: RESULT = null; :}
        |
        ZPROJ LPAREN RPAREN optNL //an empty list
        {: RESULT = factory_.createVisibilityList(); :}
        |
        ZPROJ LPAREN refNameList:rnl RPAREN optNL
        {: RESULT = factory_.createVisibilityList(rnl); :}
        ;

inheritedList ::=
        //empty
        {:
           RESULT = factory_.createZExprList();
        :}
        |
        inheritedClassList:icl
        {: RESULT = factory_.createZExprList(icl); :}
        ;

inheritedClassList ::=
        inheritedClass:ic optNL inheritedClassList:icl
        {:
           icl.add(0, ic);
           RESULT = icl;
        :}
        |
        inheritedClass:ic optNL
        {: RESULT = list(ic); :}
        ;

inheritedClass ::=
        DECORWORD:dw
        {:
           checkName(dw, dwleft, dwright);
           ZRefName rn = factory_.createZRefName(dw.getName());
           RESULT = factory_.createRefExpr(rn);
           addLocAnn(rn, dwleft, dwright);
           addLocAnn(RESULT, dwleft, dwright);
        :}
        |
        inheritedClass:ic LSQUARE expressionList:el RSQUARE
        {:
           RefName rn = refname(ic);
           RESULT = factory_.createRefExpr(rn, el, Boolean.FALSE);
           addLocAnn(rn, icleft, icright);
           addLocAnn(RESULT, icleft, icright);
        :}
        |
        inheritedClass:ic LSQUARE renameList:rnl RSQUARE
        {:
           RESULT = factory_.createRenameExpr(ic, rnl);
           addLocAnn(RESULT, icleft, icright);
        :} %prec _RENAME
        ;

innerParaList ::=
        innerPara:ip optNL innerParaList:ipl
        {:
           ipl.add(0, ip);
           RESULT = ipl;
        :}
        |
        //empty
        {: RESULT = list(); :}
        ;

innerPara ::=
        axiomaticDefinition:ad
        {: RESULT = ad; :}
        |
        genericAxDefinition:gad
        {: RESULT = gad; :}
        |
        schema:s
        {: RESULT = s; :}
        |
        basicTypeDefinition:gtd
        {: RESULT = gtd; :}
        |
        freeTypeList:ftl
        {: RESULT = factory_.createFreePara(ftl); :}
        |
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        |
        state:s
        {: RESULT = s; :}
        |
        initialState:is
        {: RESULT = is; :}
        ;

state ::=
        STATE:s stateDecl:sd BAR predicate:p END
        {:
           PrimaryDecl pd = sd.getFirst();
           SecondaryDecl scd = sd.getSecond();
           RESULT = factory_.createState(pd, scd, p, Box.SchBox);
           addLocAnn(RESULT, sleft, sright);
        :}
        |
        STATE:s stateDecl:sd END
        {:
           PrimaryDecl pd = sd.getFirst();
           SecondaryDecl scd = sd.getSecond();
           RESULT = factory_.createState(pd, scd, null, Box.SchBox);
           addLocAnn(RESULT, sleft, sright);
        :}
        |
        LSQUARE:lsq stateDecl:sd BAR predicate:p RSQUARE
        {:
           PrimaryDecl pd = sd.getFirst();
           SecondaryDecl scd = sd.getSecond();
           RESULT = factory_.createState(pd, scd, p, Box.OmitBox);
           addLocAnn(RESULT, lsqleft, lsqright);
        :}
        |
        LSQUARE:lsq stateDeclNoExpression:sdne RSQUARE
        {:
           PrimaryDecl pd = sdne.getFirst();
           SecondaryDecl scd = sdne.getSecond();
           RESULT = factory_.createState(pd, scd, null, Box.OmitBox);
           addLocAnn(RESULT, lsqleft, lsqright);
        :}
        ;

//return a pair containing the primary and secondary decls
stateDecl ::=
        optPrimaryDeclPart:opdp
        {: RESULT = statePair(opdp, null); :}
        |
        secondaryDeclPart:sdp
        {: RESULT = statePair(null, sdp); :}
        |
        primaryDeclPart:pdp sep secondaryDeclPart:sdp
        {: RESULT = statePair(pdp, sdp); :}
        ;

stateDeclNoExpression ::=
        //empty
        {: RESULT = statePair(null, null); :} 
        |
        secondaryDeclPart:sdp
        {: RESULT = statePair(null, sdp); :}
        |
        primaryDeclPart:pdp sep declaration:d
        {: RESULT = statePair(pdp, null); :}
        |
        basicDeclaration:bd
        {:
           ZDeclList zdl = factory_.createZDeclList(list(bd));
           RESULT = statePair(zdl, null);
        :}
        |        
        primaryDeclPart:pdp sep secondaryDeclPart:sdp
        {: RESULT = statePair(pdp, sdp); :}
        ;

optPrimaryDeclPart ::=
        //empty
        {: RESULT = factory_.createZDeclList(); :}
        |
        primaryDeclPart:pdp
        {: RESULT = pdp; :}
        ;

primaryDeclPart ::=
        declaration:d
        {:
           RESULT = factory_.createZDeclList(list(d));
           addLocAnn(RESULT, dleft, dright);
        :}
<add:tcoz>
        |
        channelDeclaration:cd
        {:
           RESULT = factory_.createZDeclList(list(cd));
           addLocAnn(RESULT, cdleft, cdright);
        :}
</add:tcoz>
        |
        primaryDeclPart:pdp sep declaration:d
        {:
           pdp.getDecl().add(d);
           RESULT = pdp;
        :}
<add:tcoz>
        |
        primaryDeclPart:pdp sep channelDeclaration:cd
        {:
           pdp.getDecl().add(cd);
           RESULT = pdp;
        :}
</add:tcoz>
        ;

<add:tcoz>
channelDeclaration ::=
        declWordList:dwl COLON:colon channel:ch
        {:
           RESULT = factory_.createVarDecl(dwl, ch);
           addLocAnn(RESULT, colonleft, colonright);
        :}
        ;        

channel ::=
        CHAN:c
        {:
           RESULT = factory_.createChannelExpr();
           addLocAnn(RESULT, cleft, cright);
        :}
        |
        term:t SENSOR
        {:
           RESULT = factory_.createSensorExpr(expr(t));
           addLocAnn(RESULT, tleft, tright);
        :}
        |
        term:t ACTUATOR
        {:
           RESULT = factory_.createActuatorExpr(expr(t));
           addLocAnn(RESULT, tleft, tright);
        :}
        ;
</add:tcoz>

secondaryDeclPart ::=
        DELTA sep declPart:dp
        {: RESULT = dp; :}
        ;

initialState ::=
        INIT:i predicate:p END
        {:
           RESULT = factory_.createInitialState(p, Box.SchBox);
           addLocAnn(RESULT, ileft, iright);
        :}
        |
        INITWORD:iw SDEF LSQUARE predicate:p RSQUARE
        {:
           RESULT = factory_.createInitialState(p, Box.OmitBox);
           addLocAnn(RESULT, iwleft, iwright);
        :}
        ;

operation ::=
        OPSCH:osch name:n opText:ot END
        {:
           OpExpr opExpr = factory_.createAnonOpExpr(ot);
           RESULT = factory_.createOperation(n, opExpr, Box.SchBox);
           addLocAnn(RESULT, oschleft, oschright);
        :}
        |
        OPNAME:on SDEF opExpr:oe
        {:
           ZDeclName dn = factory_.createZDeclName(on.getName());
           RESULT = factory_.createOperation(dn, oe, Box.OmitBox);
           addLocAnn(RESULT, onleft, onright);
           addLocAnn(dn, onleft, onright);
        :}
        ;

opText ::=
        deltaList:dl sep:s declPart:dp BAR predicate:p
        {: RESULT = createOpText(dl, dp, p); :}
        |
        deltaList:dl sep:s declPart:dp
        {: RESULT = createOpText(dl, dp, null); :}
        |
        deltaList:dl BAR predicate:p
        {: RESULT = createOpText(dl, null, p); :}
        |
        deltaList:dl
        {: RESULT = createOpText(dl, null, null); :}
        |
        optDeclPart:dp BAR predicate:p
        {: RESULT = createOpText(null, dp, p); :}
        |
        optDeclPart:dp
        {: RESULT = createOpText(null, dp, null); :}
        ;

opExpr ::=
        DCNJ:dcnj schemaText:st SPOT opExpr:oe
        {:
           RESULT = factory_.createDistConjOpExpr(st, oe);
           addLocAnn(RESULT, dcnjleft, dcnjright);
        :}
        |
        DGCH:dgch schemaText:st SPOT opExpr:oe
        {:
           RESULT = factory_.createDistChoiceOpExpr(st, oe);
           addLocAnn(RESULT, dgchleft, dgchright);
        :}
        |
        /* We need a unicode character for this. */
        /*DSQC*/ ZCOMP:dsqc schemaText:st SPOT opExpr:oe
        {:
           RESULT = factory_.createDistSeqOpExpr(st, oe);
           addLocAnn(RESULT, dsqcleft, dsqcright);
        :}
        |
        <add:tcoz>
        DIC:dic schemaText:st SPOT opExpr:oe
        {: RESULT = factory_.createDistInChoiceProExpr(st, oe);
           addLocAnn(RESULT, dicleft, dicright);
        :}
        |
        DIL:dil schemaText:st SPOT opExpr:oe
        {: RESULT = factory_.createDistInterleaveProExpr(st, oe);
           addLocAnn(RESULT, dilleft, dilright);
        :}
        |
        PARALLEL:dpara LPAREN topology:nt RPAREN
        {:
           RESULT = factory_.createTopologyProExpr(nt);
           addLocAnn(RESULT, dparaleft, dpararight);
        :}
        |
        </add:tcoz>
        opExpr1:oe1
        {: RESULT = oe1; :}
        ;

opExpr1 ::=
        /* a horizontal operation expression */
        LSQUARE opText:ot RSQUARE
        {: RESULT = factory_.createAnonOpExpr(ot); :}
        |
<add:ozz>
        /* operator promotion */
        opPromotionLhs:oplhs DOT refName:rn
        {:
           RESULT = factory_.createOpPromotionExpr(oplhs, rn);
           addLocAnn(RESULT, oplhsleft, oplhsright);
        :}
        |
</add:ozz>
<add:tcoz>
        /* operator promotion */
        opPromotionLhs:oplhs DOT inner_term:it
        {:
           RESULT = factory_.createOpPromotionExpr(oplhs, refname(it));
           addLocAnn(RESULT, oplhsleft, oplhsright);
        :}
        |
</add:tcoz>
        /* operation promotion */
        refName:rn
        {:
           RESULT = factory_.createOpPromotionExpr(null, rn);
           addLocAnn(RESULT, rnleft, rnright);
        :}
        |
        /* variable renaming */
        opExpr1:oe1 LSQUARE renameList:rnl RSQUARE
        {:
           RESULT = factory_.createRenameOpExpr(oe1, rnl);
           addLocAnn(RESULT, oe1left, oe1right);
        :}
        |
        /* variable hiding */
        opExpr1:oe1 ZHIDE LPAREN refNameList:rnl RPAREN
        {:
           ZRefNameList zrnl = factory_.createZRefNameList(rnl);
           RESULT = factory_.createHideOpExpr(oe1, zrnl);
           addLocAnn(RESULT, oe1left, oe1right);
        :}
        |
        /* operation conjunction */
        opExpr1:lhs AND opExpr:rhs
        {:
           RESULT = factory_.createConjOpExpr(lhs, rhs);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        /* parallel conjuntion */
        opExpr1:lhs PARALLEL opExpr:rhs
        {:
           RESULT = factory_.createParallelOpExpr(lhs, rhs);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        /* associative parallel conjunction */
        opExpr1:lhs ASSOPARALLEL opExpr:rhs
        {:
           RESULT = factory_.createAssoParallelOpExpr(lhs, rhs);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        /* angelic choice */
        opExpr1:lhs GCH opExpr:rhs
        {:
           RESULT = factory_.createExChoiceOpExpr(lhs, rhs);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        /* operation composition */
        opExpr1:lhs ZCOMP opExpr:rhs
        {:
           RESULT = factory_.createSeqOpExpr(lhs, rhs);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        /* scope enrichment */
        opExpr1:lhs SPOT opExpr:rhs
        {:
           RESULT = factory_.createScopeEnrichOpExpr(lhs, rhs);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        LPAREN opExpr:oe RPAREN
        {:
           oe.getAnns().add(factory_.createParenAnn());
           RESULT = oe;
        :}
<add:tcoz>
        |
        opExpr1:lhs INTCHOICE opExpr:rhs
        {:
           RESULT = factory_.createInChoiceProExpr(lhs, rhs);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        opExpr1:lhs INTERLEAVE opExpr:rhs
        {:
           RESULT = factory_.createInterleaveProExpr(lhs, rhs);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
/*
 //ambiguity here with opExpr || [opText], where opText has inclDecl
 //although this should be opExpr |[ eventSet |] opExpr
 //Needs to be taken care of in the scanner - this could prove difficult
        opExpr1:lhs PARALLEL LSQUARE eventSet:ets RSQUARE opExpr1:rhs
        {:
           EventSet es = factory_.createEventSet(ets);
           RESULT = factory_.createSynPllProExpr(lhs, rhs, es);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
*/
        opExpr1:lhs TIMEOUT LSQUARE expression:e RSQUARE opExpr1:rhs
        {:
           RESULT = factory_.createTimeoutStartProExpr(lhs, e, rhs);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        opExpr1:lhs TIMEEND LBRACE expression:e RBRACE opExpr1:rhs
        {:
           RESULT = factory_.createTimeoutEndProExpr(lhs, e, rhs);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        opExpr1:lhs INTERRUPT LBRACE expression:e RBRACE opExpr1:rhs
        {:
           RESULT = factory_.createInterruptProExpr(lhs, e, rhs);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        opExpr1:oe SPOT DEADLINE expression:e
        {:
           RESULT = factory_.createDeadlineProExpr(oe, e);
           addLocAnn(RESULT, oeleft, oeright);
        :}
        |
        opExpr1:oe SPOT WAITUNTIL expression:e
        {:
           RESULT = factory_.createWaitUntilProExpr(oe, e);
           addLocAnn(RESULT, oeleft, oeright);
         :}
        |
        WAIT:wait expression:e
        {:
           RESULT = factory_.createWaitProExpr(e);
           addLocAnn(RESULT, waitleft, waitright);
        :}
        |
        inOutEvent:et NEXTPRO opExpr1:oe
        {:
           RESULT = factory_.createAtProExpr(et, null, oe);
           addLocAnn(RESULT, etleft, etright);
        :}
        |
        opPromotionLhs:oplhs DOT inner_term:it NEXTPRO opExpr1:oe
        {:
           Event et = factory_.createEvent(refname(oplhs), expr(it));
           RESULT = factory_.createAtProExpr(et, null, oe);
           addLocAnn(RESULT, oplhsleft, oplhsright);
        :}
        |
        refName:rn NEXTPRO opExpr1:oe
        {:
           Event et = factory_.createEvent(rn, null);
           RESULT = factory_.createAtProExpr(et, null, oe);
           addLocAnn(RESULT, rnleft, rnright);
        :}
        |
        inOutEvent:et ATTIME expression:e NEXTPRO opExpr1:oe
        {:
           RESULT = factory_.createAtProExpr(et, e, oe);
           addLocAnn(RESULT, etleft, etright);
        :}
        |
        opPromotionLhs:oplhs DOT inner_term:it 
           ATTIME expression:e NEXTPRO opExpr1:oe
        {:
           Event et = factory_.createEvent(refname(oplhs), expr(it));
           RESULT = factory_.createAtProExpr(et, e, oe);
           addLocAnn(RESULT, oplhsleft, oplhsright);
        :}
        |
        refName:rn ATTIME expression:e NEXTPRO opExpr1:oe
        {:
           Event et = factory_.createEvent(rn, null);
           RESULT = factory_.createAtProExpr(et, e, oe);
           addLocAnn(RESULT, rnleft, rnright);
        :}
        |
        MU:mu refName:rn SPOT opExpr1:oe
        {:
           RESULT = factory_.createRecProExpr(rn, oe);
           addLocAnn(RESULT, muleft, muright);
        :}
</add:tcoz>
        ;

<add:tcoz>
topology ::=
        connection:cn SEMICOLON topology:tp
        {:
           tp.add(0, cn);
           RESULT = tp; 
        :}
        |
        connection:cn
        {: RESULT = list(cn); :}
        ;
                 
connection ::=
        refNameList:lrnl NETTOPLEFT refNameList:crnl
           NETTOPRIGHT refNameList:rrnl
        {:
           RESULT = factory_.createConnection(lrnl, rrnl, crnl);
           addLocAnn(RESULT, lrnlleft, lrnlright);
        :}
        ;
                   
eventSet ::=
        event:e COMMA eventSet:el
        {: 
           el.add(0, e);
           RESULT = el;
        :}
        |
        event:e
        {: RESULT = list(e); :}
        ;

event ::=
        inOutEvent:ioet
        {: RESULT = ioet; :}
        |
        refName:rn DOT inner_term:it
        {:
           RESULT = factory_.createEvent(rn, expr(it));
           addLocAnn(RESULT, rnleft, rnright);
        :}
        |
        refName:rn
        {:
           RESULT = factory_.createEvent(rn, null);
           addLocAnn(RESULT, rnleft, rnright);
        :}
        ;

inOutEvent ::=
        refName:rn INSTROKE inner_term:it
        {:
           rn.getStroke().add(factory_.createInStroke());
           RESULT = factory_.createEvent(rn, expr(it));
           addLocAnn(RESULT, rnleft, rnright);
        :}
        |
        refName:rn OUTSTROKE inner_term:it
        {:
           rn.getStroke().add(factory_.createOutStroke());
           RESULT = factory_.createEvent(rn, expr(it));
           addLocAnn(RESULT, rnleft, rnright);
        :}
        ;            
</add:tcoz>

opPromotionLhs ::=
        refName:rn
        {:
           RESULT = factory_.createRefExpr(rn);
           addLocAnn(RESULT, rnleft, rnright);
        :}
<add:ozz>
        |
        opPromotionLhs:oplhs DOT refName:rn
        {:
           RESULT = factory_.createBindSelExpr(oplhs, rn);
           addLocAnn(RESULT, oplhsleft, oplhsright);
        :}
</add:ozz>
<add:tcoz>
        |
        opPromotionLhs:oplhs DOT inner_term:it
        {:
           RESULT = factory_.createBindSelExpr(oplhs, refname(it));
           addLocAnn(RESULT, oplhsleft, oplhsright);
        :}
</add:tcoz>
        ;

deltaList ::=
        DELTA:d LPAREN refNameList:rnl RPAREN
        {:
           RESULT = factory_.createDeltaList(rnl);
           addLocAnn(RESULT, dleft, dright);
        :}
        |
        DELTA:d LPAREN RPAREN
        {:
           List&lt;RefName&gt; refNameList = list();
           RESULT = factory_.createDeltaList(refNameList);
           addLocAnn(RESULT, dleft, dright);
        :}
        ;
</add:oz>
</parser>
