<?xml version="1.0" encoding="utf-8"?>
<parser xmlns:add="http://czt.sourceforge.net/templates/additional">
/*
  Copyright (C) 2003, 2004, 2005 Tim Miller
  Copyright (C) 2004, 2005, 2006 Petra Malik
  This file is part of the CZT project.

  The CZT project contains free software;
  you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  The CZT project is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CZT; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package <package/>;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.io.*;

import net.sourceforge.czt.java_cup.runtime.*;

import net.sourceforge.czt.base.ast.*;
<add:zpatt>
import net.sourceforge.czt.zpatt.util.Factory;
import net.sourceforge.czt.zpatt.ast.*;
import net.sourceforge.czt.parser.z.ZParseError;
</add:zpatt>
<add:circus>
import net.sourceforge.czt.circus.util.Factory;
import net.sourceforge.czt.circus.ast.*;
import net.sourceforge.czt.parser.z.ZParseError;
</add:circus>
<add:oz>
import net.sourceforge.czt.oz.util.OzString;
import net.sourceforge.czt.oz.ast.*;
import net.sourceforge.czt.parser.z.ZParseError;
</add:oz>
<add:ozz>
import net.sourceforge.czt.oz.util.Factory;
</add:ozz>
<add:tcoz>
import net.sourceforge.czt.tcoz.util.TcozString;
import net.sourceforge.czt.tcoz.ast.*;
import net.sourceforge.czt.tcoz.util.Factory;
import net.sourceforge.czt.parser.z.ZParseError;
</add:tcoz>

import net.sourceforge.czt.parser.util.*;
import net.sourceforge.czt.parser.z.*;
import net.sourceforge.czt.session.*;
import net.sourceforge.czt.util.CztException;
import net.sourceforge.czt.util.CztLogger;
import net.sourceforge.czt.z.ast.*;
import net.sourceforge.czt.z.util.*;
<add:z>
import net.sourceforge.czt.z.util.Factory;
</add:z>
import net.sourceforge.czt.z.util.OperatorName;
import net.sourceforge.czt.z.util.ZString;
import net.sourceforge.czt.session.SectionInfo;

action code
{:
    /** The ZML Version supported by this parser. */
    public final static String ZML_VERSION = Version.ZML_VERSION;

    /**
     * The name given to an anonymous specification when rule 12.2.2.1
     * (defined in the ISO Standard for Z) is applied.
     */
    public final static String ANONYMOUS_SPEC_NAME = "Specification";

    /** The name of the prelude. */
    public final static String PRELUDE = "prelude";

    /** The name of the mathematical toolkit. */
    public final static String TOOLKIT = "standard_toolkit";

    /** The name of the Object-Z toolkit. */
    public final static String OZ_TOOLKIT = "oz_toolkit";

    /** The symbols used to replace arguments for names in ApplExpr etc. */
    public final static String ARG_TOK = ZString.ARG_TOK;
    public final static String LISTARG_TOK = ZString.LISTARG_TOK;
    public final static String SPACE = ZString.SPACE;

    /** The factory for creating AST objects. */
    protected Factory factory_ = new Factory();

    /** The table of operators. */
    protected OpTable opTable_;

<add:zpatt>
    /** The table of joker names. */
    protected JokerTable jokerTable_;
</add:zpatt>

    /** The name of file currently being parsed. */
    protected String file_ = null;

    /**
     * The symbol returned by the last call to local_next_token().
     */
    protected Symbol previous_;

    /** The type of the previous chain relation e.g. MEM, EQUALS, IP */
    protected int previousChain_ = -1;

<add:oz>
    /**
     * The tope of the stack is true if an operation expr is
     * currently being parsed. This is needed because Z exprs and
     * Object-Z operations are both specified using non-terminal 'term'
     */
    protected Stack &lt; Boolean &gt; isOpExpr_ = 
       new Stack &lt; Boolean &gt; ();
</add:oz>

   /** Section information. */
    protected SectionInfo sectInfo_;

    /** The operator scanner. */
    protected OperatorScanner opScanner_;
    protected NewlineScanner nlScanner_;
<add:zpatt>
    protected JokerScanner jokerScanner_;
</add:zpatt>

    /**
     * Create an empty list.
     */
    protected &lt;E&gt; List&lt;E&gt; list()
    {
      return new ArrayList&lt;E&gt;();
    }

    /**
     * Create a list containing one element.
     */
    protected &lt;E&gt; List&lt;E&gt; list(E elem)
    {
      List&lt;E&gt; result = list();
      result.add(elem);
      return result;
    }

    /**
     * Creates a list containing two elements.
     */
    protected &lt;E&gt; List&lt;E&gt; list(E elem1, E elem2)
    {
      List&lt;E&gt; result = list();
      result.add(elem1);
      result.add(elem2);
      return result;
    }

    /**
     * Creates a list from another list
     */
    protected &lt;E&gt; List&lt;E&gt; list(List&lt;E&gt; list)
    {
      List&lt;E&gt; result = list();
      result.addAll(list);
      return result;
    }

    /**
     * Creates a pair from two elements. 
     */
    protected &lt;X,Y&gt; Pair&lt;X,Y&gt; pair(X x, Y y)
    {
      return new Pair(x, y);
    }

<add:oz>
    /**
     * Create a pair of PrimaryDecl and SecondaryDecl from 2 DeclLists
     */
    protected Pair&lt;PrimaryDecl,SecondaryDecl&gt; 
      statePair(DeclList pDeclList, DeclList sDeclList)
    {
      if (pDeclList == null) {
        pDeclList = factory_.createZDeclList();
      }
      if (sDeclList == null) {
        sDeclList = factory_.createZDeclList();
      }
      PrimaryDecl primaryDecl = factory_.createPrimaryDecl(pDeclList);
      SecondaryDecl secondaryDecl = factory_.createSecondaryDecl(sDeclList);
      return pair(primaryDecl, secondaryDecl);
    }

    protected OpText createOpText(DeltaList del, DeclList dec, Pred p)
    {
      if (dec == null) dec = factory_.createZDeclList();
      return factory_.createOpText(del, factory_.createZSchText(dec, p));
    }
</add:oz>

    /**
     * Create an function application with the SchExpr formed from
     * 'st' and any additional renaming/strokes etc in 'al'.
     */
    private ApplExpr createSchApplExpr(Expr e, SchText st,
                                       List &lt; Object &gt; al) 
    {
      Expr se = factory_.createSchExpr(st);
      for (Object a : al) {
        if (a instanceof Stroke) {
          se = factory_.createDecorExpr(se, (Stroke) a);
        }
        else if (a instanceof RenameExpr) {
          RenameExpr re = (RenameExpr) a;
          se = factory_.createRenameExpr(se, re.getRenameList());
        }
        else if (a instanceof BindSelExpr) {
          BindSelExpr bse = (BindSelExpr) a;
          se  = factory_.createBindSelExpr(se, bse.getRefName());
        }
        else if (a instanceof TupleSelExpr) {
          TupleSelExpr tse = (TupleSelExpr) a;
          se  = factory_.createTupleSelExpr(se, tse.getNumeral());
        }
      }
      ApplExpr result = factory_.createApplExpr(e, se, Boolean.FALSE);
      return result;
    }

    private void checkName(Decorword decorword)
    {
      ZChar unmatched = decorword.check();
      if (unmatched != null) {
        final Object[] params = { unmatched };
        parser.report_error(ZParseMessage.MSG_UNMATCHED_WORDGLUE,
                            params, decorword.getLocation());
      }
    }

    private Spec createSpec(List&lt;? extends Sect&gt; sectList)
    {
      Spec result = factory_.createSpec();
      result.setVersion(ZML_VERSION);
      result.getSect().addAll(sectList);
      return result;
    }

    private ZSchText createZSchText(List&lt;? extends Decl&gt; decl,
                                    Pred pred)
    {
      return factory_.createZSchText(factory_.createZDeclList(decl), pred);
    }

    private Operator createOperator(Decorword decorword, int line, int column)
      throws ParseException
    {
      return createOperator(decorword.getName(), line, column);
    }

    private Operator createOperator(String name, int line, int column)
      throws ParseException
    {
      final ZDeclName dn = factory_.createZDeclName(name);
      if (dn.getStroke().size() != 0) {
        final LocInfo locInfo = getLocation(line, column);
        final Object[] params = { name };
  	parser.report_error(ZParseMessage.MSG_STROKE_IN_OPNAME,
                            params, locInfo);
      }
      Operator result = factory_.createOperator(dn.getWord());
      return result;
    }

    private void misusedOpName(LocString name)
    {
      final Object [] params = {name.getString()};
      parser.report_error(ZParseMessage.MSG_OPNAME_AS_DECLWORD,
                          params, name.getLocation());
    }

    private LocInfo getLocation(int line, int column)
    {
      return new LocInfoImpl(file_, line, column);
    }

    private LocInfo getLocation(Term term)
    {
      return parser.getLocation(term);
    }

    /**
     * Converts a list of String objects to a DeclName object.
     */
    protected ZDeclName strListToZDeclName(List&lt;String&gt; list,
                                           LocInfo location)
      throws ParseException
    {
      try {
        OperatorName opName = new OperatorName(list);
        return factory_.createZDeclName(opName.getWord(), opName.getStroke());
      }
      catch (OperatorName.OperatorNameException e) {
        parser.report_error(ZParseMessage.MSG_OPNAME_ERROR,
                            new Object[0],
                            location);
        return null;
      }
    }

    /**
     * Converts a list of String objects to a RefName object.
     */
    protected RefName strListToRefName(List&lt;String&gt; list, LocInfo loc)
      throws ParseException
    {
      try {
        OperatorName opName = new OperatorName(list);
        RefName result =
          factory_.createZRefName(opName.getWord(), opName.getStroke());
        addLocAnn(result, loc);
        return result;
      }
      catch (OperatorName.OperatorNameException e) {
        final String message = "Syntax error: " + e.getMessage();
        parser.report_error(ZParseMessage.MSG_OPNAME_ERROR,
                            new Object[0],
                            loc);
        return null;
      }
    }

    /**
     * Converts a Term to a Pred.
     */
    protected Pred pred(Term t)
      throws ParseException
    {
      Pred result = null;

      if (t instanceof Pred) {
        result = (Pred) t;
      }
<add:oz>
      else if (t instanceof PredExpr) {
        result = ((PredExpr) t).getPred();
      }
</add:oz>
      else if (t instanceof Expr) {
        result = factory_.createExprPred((Expr) t);
        LocAnn locAnn = (LocAnn) t.getAnn(LocAnn.class);
        if (locAnn != null) result.getAnns().add(locAnn);
      }
      else {
        //I don't think that this is possible...?
        parser.report_error(ZParseMessage.MSG_PRED_EXPECTED,
                            new Object[0], getLocation(t));
      }
      return result;
    }

    /**
     * Converts an Term to an Expr.
     */
    protected Expr expr(Term t)
      throws ParseException
    {
      Expr result = null;

      if (t instanceof Expr) {
        result = (Expr) t;
      }
      else if (t instanceof ExprPred) {
        result = ((ExprPred) t).getExpr();
      }
<add:oz>
      else if (t instanceof OpPromotionExpr) {
        OpPromotionExpr ope = (OpPromotionExpr) t;
        assert ope.getExpr() != null;
        Expr e = ope.getExpr();
        RefName rn = ope.getRefName();
        result = factory_.createBindSelExpr(ope.getExpr(), ope.getRefName());
        LocAnn locAnn = (LocAnn) t.getAnn(LocAnn.class);
        if (locAnn != null) result.getAnns().add(locAnn);
      }
</add:oz>
      else if (t instanceof Pred) {
<add:oz>
        result = factory_.createPredExpr((Pred) t);
        LocAnn locAnn = (LocAnn) t.getAnn(LocAnn.class);
        if (locAnn != null) result.getAnns().add(locAnn);
</add:oz>
<add:z>
        parser.report_error(ZParseMessage.MSG_EXPR_EXPECTED_FOUND_PRED,
                            new Object [0], getLocation(t));
</add:z>
<add:zpatt>
        parser.report_error(ZParseMessage.MSG_EXPR_EXPECTED_FOUND_PRED,
                            new Object [0], getLocation(t));
</add:zpatt>
      }
      else {
        parser.report_error(ZParseMessage.MSG_EXPR_EXPECTED, 
                            new Object [0], getLocation(t));
      }
      return result;
    }

<add:oz>
    /**
     * Converts an Term to an OpExpr.
     */
    protected OpExpr opExpr(Term t)
      throws ParseException
    {
      OpExpr result = null;

      if (t instanceof OpExpr) {
        result = (OpExpr) t;
      }
      else if (t instanceof RefExpr) {
        RefExpr re = (RefExpr) t;
        result = factory_.createOpPromotionExpr(null, re.getRefName());
        LocAnn locAnn = (LocAnn) t.getAnn(LocAnn.class);
        if (locAnn != null) result.getAnns().add(locAnn);
      }
      else {
        parser.report_error(ZParseMessage.MSG_OPEXPR_EXPECTED,
                            new Object[0], getLocation(t));
      }
      return result;
    }
</add:oz>

    /**
     * Converts a Term to a RefName.
     */
    protected RefName refname(Term t)
      throws ParseException
    {
      RefName result = null;

      if (t instanceof RefName) {
        result = (RefName) t; 
      }
      else if (t instanceof RefExpr) {
        RefExpr re = (RefExpr) t;

        if (re.getZExprList().size() > 0) {
          parser.report_error(ZParseMessage.MSG_REFNAME_NO_PARAMS_EXPECTED,
                              new Object [0], getLocation(re));
        }
        result = re.getRefName();
      }
      else {
        parser.report_error(ZParseMessage.MSG_REFNAME_EXPECTED,
                            new Object [0], getLocation(t));
      }

      return result;
    }

    /**
     * Creates a member predicate from a string list and an expression list.
     */
    protected MemPred createMemPred(List&lt;String&gt; name,
                                    ZExprList exprs,
                                    LocInfo loc)
      throws ParseException
    {
      Expr e = createTupleExpr(exprs);
      RefName rn = strListToRefName(name, loc);
      MemPred result = factory_.createRelOpAppl(e, rn);
      addLocAnn(result.getRightExpr(), loc);
      return result;
    }

    /**
     * Creates an application expression or reference expression
     * (depending on the type of operator: function or generic)
     * from a string list and an expression list.
     * The line,column pair are the position of the start of
     * the whole mixfix expression.
     */
    protected Expr createMixfixExpr(List&lt;String&gt; name,
                                    ZExprList exprs,
                                    LocInfo loc)
      throws ParseException
    {
      final RefName rn = strListToRefName(name, loc);
      Expr result = null;

      //get the first operator in the name list, i.e. the first
      //item that is not an ARG_TOK or LISTARG_TOK.
      String firstOperator = null;
      for (Iterator&lt;String&gt; iter = name.iterator(); iter.hasNext(); ) {
        String next = iter.next();
        if (! next.equals(ARG_TOK) &amp;&amp; ! next.equals(LISTARG_TOK)) {
          firstOperator = next;
          break;
        }
      }

      if (opTable_.lookup(name) != null &amp;&amp;
          Cat.Function.equals(opTable_.lookup(name).getCat())) {
        Expr e = createTupleExpr(exprs);
        result = factory_.createFunOpAppl(rn, e);
        addLocAnn(((ApplExpr) result).getLeftExpr(), loc);
      }
      else {
        result = factory_.createRefExpr(rn, exprs, Boolean.TRUE, Boolean.TRUE);
      }

      return result;  
    }

    /**
     * If the list contains just one expression, the expression is
     * returned.  If there is more than one expression in the list, a
     * tuple expression is created and returned.
     */
    private Expr createTupleExpr(ZExprList exprs)
    {
      return exprs.size() == 1 ?
        exprs.get(0) : factory_.createTupleExpr(exprs);
    }

    /**
     * Returns the right hand side of the previous infix relation.
     */
    protected Expr getPreviousRhsExpr(Pred pred)
    {
      Expr result = null;

      MemPred memPred = null;
      if (pred instanceof MemPred) {
        memPred = (MemPred) pred;
      }
      else {   //AndPred
        memPred = (MemPred) ((AndPred) pred).getRightPred();
      }

      if (previousChain_ == Sym.MEM) {
        result = memPred.getRightExpr();
      }
      else if (previousChain_ == Sym.EQUALS) {
        SetExpr se = (SetExpr) memPred.getRightExpr();
        result = se.getZExprList().get(0);
      }
      //previousChain_ == Sym.IP
      else {
        TupleExpr te = (TupleExpr) memPred.getLeftExpr();
        result = te.getZExprList().get(1);
      }

      return result;
    }

    /**
     * Convert a chain relation into a series of and predicates
     * (transformation rule 12.2.10.3).
     */
    protected Pred transformChainRel(Pred chain, int sym, Expr rhs,
                                     LocInfo loc)
    {
      Pred result = null;

      Expr lExpr = getPreviousRhsExpr(chain);
      Expr rExpr = rhs;

      Boolean mixfix = Boolean.FALSE;
      if (sym == Sym.EQUALS) {
        ZExprList expList = factory_.createZExprList();
        expList.add(rhs);
        rExpr = factory_.createSetExpr(expList);
        addLocAnn(rExpr, loc);
        mixfix = Boolean.TRUE;
      }

      MemPred mp = factory_.createMemPred(lExpr, rExpr, mixfix);
      addLocAnn(mp, loc);
      result = factory_.createAndPred(chain, mp, And.Chain);

      previousChain_ = -1;
      return result;
    }

    protected Pred transformChainRelInfix(Pred chain, Expr rhs, String ip,
                                          LocInfo loc)
      throws ParseException
    {
      Pred result = null;

      List&lt;String&gt; opName = list(ARG_TOK);
      opName.add(ip);
      opName.add(ARG_TOK);

      Expr lExpr = getPreviousRhsExpr(chain);
      Expr rExpr = rhs;
      ZExprList exprs = factory_.createZExprList();
      exprs.add(lExpr);
      exprs.add(rExpr);
      MemPred mp = createMemPred(opName, exprs, loc);
      addLocAnn(mp, loc);
      result = factory_.createAndPred(chain, mp, And.Chain);

      previousChain_ = -1;
      return result;
    }

    /**
     * Creates a list of strings for a list returned by expSep.
     * This list will represent the name of the operator to which
     * the expressions were applied.
     */
    protected void addExpSepName(List&lt;String&gt; opName, List es)
    {
      for (int i = 0; i &lt; es.size(); i += 2) {

        List list = (List) es.get(i);
        if (list.size() == 1) {
          opName.add(ARG_TOK);
        }
        else {
          opName.add(LISTARG_TOK);
        }
        opName.add((String) es.get(i + 1));
      }
    }

    /**
     * Returns the list of expressions returned by expSep.
     */
    protected void addExpSepExp(List expList, List es)
    {
      for (int i = 0; i &lt; es.size(); i += 2) {
        expList.addAll((List) es.get(i));
      }
    }

    private OpTable getOperatorTable(String section, int line, int column)
      throws ParseException
    {
      try {
        return (OpTable) sectInfo_.get(new Key(section, OpTable.class));
      }
      catch (CommandException e) {
        Object [] args = { "Operator table",
                           section };
        parser.report_error(ZParseMessage.MSG_OF_PARENT_NOT_FOUND,
                            args, new LocInfoImpl(file_, line, column));
        return null;
      }
    }

    private void resetOpTable(String section, List parents,
                              int line, int column)
      throws ParseException
    {
      List parentOpTables = list();
      if (PRELUDE.equals(section)) {
        assert parents.size() == 0;
      }
      else {
        for (Iterator iter = parents.iterator(); iter.hasNext();) {
          final String parent = ((Parent) iter.next()).getWord();
          OpTable parentOp = getOperatorTable(parent, line, column);
          if (parentOp != null) {
            parentOpTables.add(parentOp);
          }
        }
      }
      try {
        opTable_ = new OpTable(section, parentOpTables);
      }
      catch (OpTable.OperatorException e) {
        parser.report_error(ZParseMessage.MSG_CANNOT_MERGE_OPTABLES,
                            new Object[0],
                            getLocation(line, column));
     }
     opScanner_.setOperatorTable(opTable_);
    }

<add:zpatt>
    private JokerTable getJokerTable(String section, int line, int column)
       throws CommandException
    {
      try {
        return (JokerTable) sectInfo_.get(new Key(section, JokerTable.class));
      }
      catch (CommandException e) {
        Object [] args = { "Joker table",
                           section };
        parser.report_error(ZParseMessage.MSG_OF_PARENT_NOT_FOUND,
                            args, new LocInfoImpl(file_, line, column));
        return null;
      }
    }

    private void resetJokerTable(String section, List parents,
                                 int line, int column)
      throws CommandException
    {
      List parentJokerTables = list();
      if (PRELUDE.equals(section)) {
        assert parents.size() == 0;
      }
      else {
        for (Iterator iter = parents.iterator(); iter.hasNext();) {
          final String parent = ((Parent) iter.next()).getWord();
          JokerTable parentJoker = getJokerTable(parent, line, column);
          if (parentJoker != null) {
            parentJokerTables.add(parentJoker);
          }
        }
      }
      try {
        jokerTable_ = new JokerTable(section, parentJokerTables);
      }
      catch (JokerTable.JokerException e) {
        parser.report_error(ZpattParseMessage.MSG_CANNOT_MERGE_JOKERTABLES,
                            new Object[0],
                            getLocation(line, column));
     }
     jokerScanner_.setJokerTable(jokerTable_);
    }
</add:zpatt>

    private ZSect createZSect(String name, List parents)
    {
      ZSect result = factory_.createZSect(name, parents, null);
      return result;
    }

    private ZSect updateZSect(ZSect zSect, OpTable opTable
      <add:zpatt>, JokerTable jokerTable </add:zpatt>)
    {
      final boolean parseError = ! parser.errorList_.isEmpty();
      final String sectName = zSect.getName();
      final PrecedenceHandlingVisitor visitor =
        new PrecedenceHandlingVisitor(opTable);
      final ZSect sect = (ZSect) zSect.accept(visitor);
      LatexMarkupFunction latexMarkupFunction = null;
      final Key key = new Key(sectName, LatexMarkupFunction.class);
      if (sectInfo_.isCached(key)) {
        try {
          latexMarkupFunction = (LatexMarkupFunction)
            sectInfo_.get(key);
        }
        catch (CommandException exception) {
          String message =
            "Error retrieving LatexMarkupFunction for " + sectName;
          CztLogger.getLogger(<class/>.class).warning(message);
        }
      }
      if (latexMarkupFunction != null) {
        final LatexMarkupPara markupPara = latexMarkupFunction.toAst(factory_);
        sect.getPara().add(0, markupPara);
      }
      if (parseError) return sect;

      Set dependencies = new HashSet();
      for (Iterator iter = sect.getParent().iterator(); iter.hasNext(); ) {
        Parent parent = (Parent) iter.next();
        dependencies.add(new Key(parent.getWord(), OpTable.class));
      }
      sectInfo_.put(new Key(sectName, ZSect.class), sect, dependencies);
      sectInfo_.put(new Key(sectName, OpTable.class), opTable, dependencies);
<add:zpatt>
      sectInfo_.put(new Key(sectName, JokerTable.class), jokerTable, dependencies);
</add:zpatt>
<add:circus>
//      System.out.println("Printing " + sect.getPara().size() + " paragraphs from " +
//         sect.getName() + ".");
//      for(Para para : sect.getPara()) {
//        System.out.println("\t" + para.toString());
//      }      
//      System.out.println();
</add:circus>
      return sect;
    }

    private void addLocAnn(Term term, LocInfo locInfo)
    {
      if (locInfo != null) {
        LocAnn locAnn = (LocAnn) term.getAnn(LocAnn.class);
        if (locAnn == null) {
          locAnn = factory_.createLocAnn();
          term.getAnns().add(locAnn);
        }
        locAnn.setLoc(file_);
        if (locInfo.getLine() >= 0) locAnn.setLine(locInfo.getLine());
        if (locInfo.getColumn() >= 0) locAnn.setCol(locInfo.getColumn());
        if (locInfo.getStart() >= 0) locAnn.setStart(locInfo.getStart());
        if (locInfo.getLength() >= 0) locAnn.setLength(locInfo.getLength());
      }
    }

    private int computeLength(LocInfo start, LocInfo end)
    {
      final int startStart = start.getStart();
      final int endStart = end.getStart();
      final int endLength = end.getLength();
      if (startStart >= 0 &amp;&amp;
          endStart >= 0 &amp;&amp;
          endLength >= 0) {
        return endStart - startStart + endLength;
      }
      return -1;
    }

    private LocInfo getLocation(LocInfo start, LocInfo end)
    {
      if (start != null &amp;&amp; end != null) {
        return new LocInfoImpl(start.getSource(),
                               start.getLine(),
                               start.getColumn(),
                               start.getStart(),
                               computeLength(start, end));
      }
      return null;
    }

    private LocInfo getLocation(Term start, LocInfo end)
    {
      return getLocation(getLocation(start), end);
    }

    private LocInfo getLocation(LocInfo start, Term end)
    {
      return getLocation(start, getLocation(end));
    }

    private LocInfo getLocation(Term start, Term end)
    {
      return getLocation(getLocation(start), getLocation(end));
    }

    private LocInfo getLocation(int line, int column,
                                LocInfo start, LocInfo end)
    {
      if (start != null &amp;&amp; end != null) {
        return new LocInfoImpl(start.getSource(),
                               line,
                               column,
                               start.getStart(),
                               computeLength(start, end));
      }
      return null;
    }

    private LocInfo getLocation(int line, int column,
                                Term start, LocInfo end)
    {
      return getLocation(line, column, getLocation(start), end);
    }

    private LocInfo getLocation(int line, int column,
                                LocInfo start, Term end)
    {
      return getLocation(line, column, start, getLocation(end));
    }

    private LocInfo getLocation(int line, int column,
                                Term start, Term end)
    {
      return getLocation(line, column, getLocation(start), getLocation(end));
    }

<add:oz>
    /**
     * Reset the isOpExpr_ stack.
     */
     protected void resetIsOpExpr()
     {
       isOpExpr_.clear();
     } 

    /**
     * Return the top of the isOpExpr_ stack.
     */
     protected boolean isOpExpr()
     {
       if (isOpExpr_.size() == 0) {
         return false;
       }
       return isOpExpr_.peek();
     } 

    /**
     * Push an item onto the isOpExpr_ stack.
     */
     protected void pushIsOpExpr(boolean b)
     {
//System.err.println("pushing "+  b);
       isOpExpr_.push(b);
     }

    /**
     * Pop the stop of the isOpExpr_ stack.
     */
     protected void popIsOpExpr()
     {
//System.err.println("popping back to " + isOpExpr());
       isOpExpr_.pop();
     }
</add:oz>

<add:circus>
  
    /**
     * Fly-weight Skip Action to be reused at every occurrence of primitive action Skip
     */
    private final SkipAction SKIP_ACTION = factory_.createSkipAction();

    /**
     * Fly-weight Skip Action to be reused at every occurrence of primitive action Stop
     */
    private final StopAction STOP_ACTION = factory_.createStopAction();

    /**
     * Fly-weight Skip Action to be reused at every occurrence of primitive action Chaos
     */    
    private final ChaosAction CHAOS_ACTION = factory_.createChaosAction();
    
    /**
     * Fly-weight True predicate to be reused whenever necessary. For instance, c?x \then A
     * or to differentiate inclusions such as in \{ S | true \} (inclusion) rather than 
     * \{ S \} (singleton).
     */    
    private final Pred TRUE_PREDICATE = factory_.createTruePred();
    
    /**
     * Default number of multisynchronisation occurrences for particular communication pattern.
     * At the moment this feature is still experimental, and may disapear in the future.
     */
    private final Integer DEFAULT_MULTISYNCH = new Integer(0);
    
    /**
     * Creates an empty (basic) channel set expression
     */
    protected Expr createEmptyChannelSetExpr() {
      return factory_.createBasicChannelSetExpr(factory_.createZExprList());      
    }
    
    /**
     * Creates an empty channel set (i.e. ChannelSet with an empty basic channel set expression).
     */
    protected ChannelSet createEmptyChannelSet() {
      return factory_.createChannelSet(createEmptyChannelSetExpr());
    }
    
    /**
     * Creates an empty name set (i.e. NameSet with an empty set expression).
     */
    protected NameSet createEmptyNameSet() {
      return factory_.createNameSet(factory_.createSetExpr(factory_.createZExprList()));
    }  
    
    /**
     * Returns whether the given expression is an empty set as a reference to
     * &lt;code&gt;ZString.EMPTYSET&lt;/code&gt;.
     */
    protected boolean isEmptySetRefExpr(Expr a) {
        boolean result = (a instanceof RefExpr);        
        if (result) {
            RefExpr r = (RefExpr)a;
            // false mixfix, as the result of createGenInst(...)
            result = r.getMixfix() != null &amp;&amp; !r.getMixfix().booleanValue();
            if (result) {
                result = r.getZRefName().getWord().equals(ZString.EMPTYSET);
            }
        }        
        return result;
    }
    
    /**
     * &lt;p&gt;
     * Creates a &lt;code&gt;BasicChannelSetExpr&lt;/code&gt; based on the given list of expressions.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The code ensures that all expressions within the expression list
     * must be &lt;code&gt;RefExpr&lt;/code&gt;, as &lt;code&gt;BasicChannelSetExpr&lt;/code&gt;
     * is just a set extension with special brackets.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If something different from &lt;code&gt;RefExpr&lt;/code&gt; is found within &lt;code&gt;zrl&lt;/code&gt;,
     * the a parsing error is thrown and the result is just an empty &lt;code&gt;BasicChannelSetExpr&lt;/code&gt;.
     * &lt;/p&gt;
     */
    protected Expr createBasicChannelSetExpr(ZExprList zrl) {      
      int errorIdx = -1;
      Iterator&lt;Expr&gt; it = zrl.iterator(); 
      while(it.hasNext() &amp;&amp; (errorIdx==-1)) {
        // If any item at a particular index is not a RefExpr,
        // return the error index and stop the loop.
        if (!(it.next() instanceof RefExpr)) {
          errorIdx++;
        }
      }      
      BasicChannelSetExpr result = factory_.createBasicChannelSetExpr(factory_.createZExprList());      
      if (errorIdx == -1) {
        result.getZExprList().addAll(zrl);
      } else {
        parser.report_error(CircusZParseMessage.MSG_REFEXPR_EXPECPTED_IN_BASICCHANNELSETEXPR,
                            new Object[] { errorIdx }, getLocation(result));
      }       
      return result;
    } 
    
    /**
     * &lt;p&gt;
     * Validates the given Z expression as a valid channel set expression.
     * &lt;/p&gt;
     * &lt;p&gt; 
     * The code returns the given expression but it ensures that &lt;code&gt;e&lt;/code&gt; 
     * is neither a set extension, nor a set comprehension expression.
     * If &lt;code&gt;e&lt;/code&gt; is one of those two, then a parsing error is thrown. 
     * &lt;/p&gt;
     * &lt;p&gt;
     * Moreover, it automatically transforms a reference to the empty set expression
     * (i.e. &lt;code&gt;\emptyset&lt;/code&gt;) to become an empty &lt;code&gt;BasicChannelSetExpr&lt;/code&gt;.
     * Thus, something like &lt;code&gt;validateChannelSetExpr(RefExpr("\emptyset"))&lt;/code&gt;,
     * returns &lt;code&gt;BasicChannelSetExpr(ZExprList())&lt;/code&gt;.
     * &lt;/p&gt;
     */
    protected Expr validateChannelSetExpr(Expr e) {
      Expr result = e;
      // For reference empty sets transform them into basic set extension.
      if (isEmptySetRefExpr(result)) {
        result = createBasicChannelSetExpr(factory_.createZExprList());
      } 
      // For set extensions (possibly empty) or comprehension, report an error.
      else if (result instanceof SetExpr || result instanceof SetCompExpr){
        parser.report_error(CircusZParseMessage.MSG_SETDISPLAY_NOTALLOWED_FORCHANNELSET,
                            new Object[0], getLocation(result));
      } 
      return result;
    }
    
    /**
     * &lt;p&gt;
     * Returns the communication type based on the pattern of the given list of communication fields.
     * &lt;/p&gt;
     * &lt;p&gt;       
     * It returns: 
     * &lt;ul&gt;
     *    &lt;li&gt;&lt;code&gt;CommType.Synch&lt;/code&gt; if the list of fields is empty.
     *    &lt;li&gt;&lt;code&gt;CommType.Input&lt;/code&gt; if the list of fields is not empty and contain only instances of &lt;code&gt;InputField&lt;/code&gt;.
     *    &lt;li&gt;&lt;code&gt;CommType.Output&lt;/code&gt; if the list of fields is not empty and contain instances of either &lt;code&gt;DotField&lt;/code&gt; or &lt;code&gt;OutputField&lt;/code&gt;.
     *    &lt;li&gt;&lt;code&gt;CommType.Mixed&lt;/code&gt; if the list of fields is not empty and contain at least one &lt;code&gt;InputField&lt;/code&gt; and either one &lt;code&gt;DotField&lt;/code&gt; or one &lt;code&gt;OutputField&lt;/code&gt;.
     *    &lt;li&gt;&lt;code&gt;CommType.Mixed&lt;/code&gt; with a parser error if the list of fields is not empty but neither of the above patterns hold.
     * &lt;/ul&gt;
     * &lt;/p&gt;
     */
    private CommType retrieveCommType(List&lt;Field&gt; fields) {
        CommType result;
        if (fields.isEmpty())
            result = CommType.Synch;
        else {
            Field f = null;
            int input = 0;
            int output = 0;
            Iterator&lt;Field&gt; it = fields.iterator();
            while(it.hasNext()) {
                f = it.next();
                if (f instanceof InputField)
                    input++;
                else if (f instanceof DotField)
                    output++;
            }
            if (input &gt; 0 &amp;&amp; output &gt; 0)
                result = CommType.Mixed;
            else if (input &gt; 0 &amp;&amp; output == 0)
                result = CommType.Input;
            else if (input == 0 &amp;&amp; output &gt; 0)
                result = CommType.Output;
            else {
                // This should never happen.
                result = CommType.Mixed; // thrown an error.
                assert f != null; // at least one field must have been checked.
                parser.report_error(CircusZParseMessage.MSG_UNKNOWN_COMMUNICATION_PATTERN,
                            new Object[0], getLocation(f));
            }                
        }
        return result;
    }
        
    /**
     * Checks whether the given lists have the same size. It returns a parser error if the 
     * lists are of a different size. This method is called either through channel renaming or 
     * an assignment command.
     */
    protected boolean checkListSizesAreEqual(int line, int column, 
        List&lt;?&gt; l, List&lt;?&gt; r) {
        boolean result = l.size() == r.size();
        if (!result) {
          parser.report_error(CircusZParseMessage.MSG_UNBALANCED_LISTS,
              new Object[] { l.size(), l.getClass().getTypeParameters()[0].getName(),
                  r.size(), r.getClass().getTypeParameters()[0].getName() }, 
                  getLocation(line, column));
        }
        return result;
    }
    
    /**
     * Creates a &lt;code&gt;ZRenameList&lt;/code&gt; containing &lt;code&gt;NewOldPairt&lt;/code&gt;
     * elements for each list. That is, the elements at the same index on each list are paired to
     * form one list of pairs. The method assumes the lists are of same size. If they are not, 
     * the returned list is empty and a parsing error is generated.
     */
    protected ZRenameList createChannelRenameNewOldPairList(int line, int column,
        List&lt;DeclName&gt; dnl, List&lt;ZRefName&gt; rnl) {
        ZRenameList result = factory_.createZRenameList();
        if (checkListSizesAreEqual(line, column, dnl, rnl)) {        
          Iterator&lt;ZRefName&gt; it = rnl.iterator();
          for(DeclName dn : dnl) {        
            result.add(factory_.createNewOldPair(dn, it.next()));
          } 
        }
        return result;
    }
</add:circus>
:}

parser code
{:
    private static final Map symbolMap_ = DebugUtils.getFieldMap(Sym.class);

    public Symbol parse() throws java.lang.Exception
    {
      Symbol symbol = super.parse();
      if (! errorList_.isEmpty()) throw new ParseException(errorList_);
      return symbol;
    }

    /** The file being parsed. */
    protected String file_;

    /** Section information. */
    protected SectionInfo sectInfo_;

    /**
     * The list of parse errors.
     * Not empty if and only if an error has occured during parsing.
     */
    protected List&lt;CztError&gt; errorList_ =
      new ArrayList&lt;CztError&gt;();
    private OperatorScanner opScanner_;
    private NewlineScanner nlScanner_;
<add:zpatt>
    private JokerScanner jokerScanner_;
</add:zpatt>

    /**
     * Creates a new parser with the given scanner and section information.
     * The section information should be able to provide information of
     * type <code>net.sourceforge.czt.parser.util.OpTable.class</code>.
     */
    public <class/>(Scanner scanner,
                    SectionInfo sectInfo)
    {
      this(scanner, null, sectInfo);
    }

    /**
     * Creates a new parser with the given scanner, source information,
     * and section information.
     * The source information is only used for printing error messages.
     * The section information should be able to provide information of
     * type <code>net.sourceforge.czt.parser.util.OpTable.class</code>.
     */
    public <class/>(Scanner scanner,
                    String source,
                    SectionInfo sectInfo)
    {
      super(scanner);
      file_ = source;
      sectInfo_ = sectInfo;
      opScanner_ = new OperatorScanner(getScanner());
<add:zpatt>
      jokerScanner_ = new JokerScanner(getScanner());
      opScanner_ = new OperatorScanner(jokerScanner_);
</add:zpatt>
      nlScanner_ = new NewlineScanner(opScanner_);
      CztLogger.getLogger(<class/>.class).finer("New parser created.");
    }

    /**
     * Returns the next token.
     */
    protected Symbol local_next_token() throws Exception
    {
      Symbol result = nlScanner_.next_token();
      assert result != action_obj.previous_;
<add:oz>
      //if we are parsing an OpExpr, then convert all SPOT tokens to
      //SCOPE tokens to remove a shift/reduce problem
      //this should be in the SmartScanner, but because this is not
      //able to be referenced from the parser code, we leave it here
      //for now.
      if (action_obj.previous_ !=  null &amp;&amp;
          action_obj.previous_.sym == Sym.RSQUARE) {
        action_obj.popIsOpExpr();
      }
      else if (action_obj.previous_ !=  null &amp;&amp;
          action_obj.previous_.sym == Sym.LSQUARE) {
        action_obj.pushIsOpExpr(false);
      }
      else if (result.sym == Sym.OPNAME) {
        action_obj.pushIsOpExpr(true);
      }

      if (result.sym == Sym.SPOT &amp;&amp; action_obj.isOpExpr()) {
        result.sym = Sym.SCOPE;
      }
</add:oz>
      action_obj.previous_ = result;
      String logMessage =
        "Next token in " + file_ +
        " is (" + symbolMap_.get(result.sym) + ", " + result.value + ").";
      CztLogger.getLogger(<class/>.class).finer(logMessage);
      return result;
    }

    /**
     * @throws ClassCastException if the object is not a CztError
     */
    public void report_error(String message, Object object)
    {
      CztError error = (CztError) object;
      errorList_.add(error);
    }

    public void report_error(ZParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new ZParseError(msg, params, locInfo));
    }

 <add:zpatt>
    public void report_error(ZpattParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new ZpattParseError(msg, params, locInfo));
    }

</add:zpatt>
<add:circus>
    public void report_error(CircusZParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new CircusZParseError(msg, params, locInfo));
    }
</add:circus>
    
    /**
     * @throws ClassCastException if the object is not a CztError
     */
    public void report_fatal_error(String message, Object param)
      throws ParseException
    {
      report_error(message, param);
      done_parsing();
    }

    public void syntax_error(Symbol token)
    {
      report_error("Syntax error", createSyntaxError(token));
    }

    public void unrecovered_syntax_error(Symbol token)
      throws ParseException
    {
      report_fatal_error("Syntax error", createSyntaxError(token));
    }

    protected CztError createSyntaxError(Symbol token)
    {
      return new ZParseError(ZParseMessage.MSG_SYNTAX_ERROR,
                             new Object[] { toObject(token) },
                             getLocation(token));
    }

    protected Object toObject(Symbol symbol)
    {
      if (symbol.value != null) {
        return symbol.value;
      }
      return symbolMap_.get(symbol.sym);
    }

    protected LocInfo getLocation(Symbol token)
    {
      return new LocInfoImpl(file_, token.left, token.right);
    }

    protected LocInfo getLocation(Term term)
    {
      LocAnn locAnn = (LocAnn) term.getAnn(LocAnn.class);
      return getLocation(locAnn);
    }

    protected LocInfo getLocation(LocAnn locAnn)
    {
      if (locAnn != null) {
        Integer line = locAnn.getLine();
        if (line != null &amp;&amp; line > 0) line = line - 1;
        Integer column = locAnn.getCol();
        if (column != null &amp;&amp; column > 0) column = column - 1;
        return new LocInfoImpl(file_, line, column);
      }
      return new LocInfoImpl(file_, -1, -1);
    }
:}

init with
{:
    //share the operator table between the action code and the parser code
    action_obj.file_ = file_;
    action_obj.sectInfo_ = sectInfo_;
    action_obj.opScanner_ = opScanner_;
    action_obj.nlScanner_ = nlScanner_;
<add:zpatt>
    action_obj.jokerScanner_ = jokerScanner_;
</add:zpatt>
:}

scan with {: return local_next_token(); :};

terminal LocInfo
        THETA, MU, LAMBDA,
        NEXTSTROKE, OUTSTROKE, INSTROKE,
        LPAREN, RPAREN, LSQUARE, RSQUARE, LBIND, RBIND,
        LDATA, RDATA, LBRACE, RBRACE,
        BAR, ANDALSO, CONJECTURE, AND, OR, IMP, IFF, NOT, 
        ALL, EXI, CROSS, POWER,
        SLASH, EQUALS, MEM, COLON, SEMICOLON, COMMA, DOT, SPOT, ZHIDE, 
        ZPROJ, ZCOMP, ZPIPE, NL,
        SECTION, PARENTS, TRUE, FALSE, LET, IF, THEN, ELSE, ZPRE,
        RELATION, FUNCTION, GENERIC, LEFTASSOC, RIGHTASSOC, LISTARG, ARG,
        DEFFREE, DEFEQUAL, EXIONE,
        END, AX, SCH, GENSCH, GENAX, ZED,
<add:zpatt>
        JOKER, RULE, RULELINE, VDASH, PROVISO,
</add:zpatt>
<add:circus>
        // Environment chars
        CIRCUSPROCESS,
        
        /**
         * For CSP, we follow the precedences from FDR's user manual v.2.82 June/2005.         
         */      
         
        // Keychars
        CIRCDEF, CIRCINDEX, CIRCMU, CIRCTHEN, CIRCELSE, PREFIXTHEN, PREFIXCOLON,
        CIRCSEQ, INTERLEAVE, REPINTERLEAVE, REPPARALLEL, CIRCHIDING, 
        EXTCHOICE, REPEXTCHOICE, INTCHOICE, REPINTCHOICE, 
        _CIRCGUARD, _REPSEQ, 
        
        /* Note:
         *
         * CIRCGUARD => As there are no similar UNICODE char for &amp;, I am just
         *              using ANDALSO (from free type definition) directly.
         *              In circus_toolkit, \circguard is then mapped to the same 
         *              UNICODE as ANDALSO, which is 0026, and CircChar has no
         *              entry for this token!
         *              Nevertheless, I still nedd the CIRCGUARD token for 
         *              handling precendences apropriately, hence _CIRCGUARD!
         *
         * REPSEQ    => Similarly, as all the UNICODE chars for big ";" I could find
         *              (relational composition COMP = U2A3E, and
         *              schema composition ZCOMP = U2A1F) are taken, we use the
         *              ZCOMP keyword. It must not be COMP, because it is just a 
         *              toolkit symbol (i.e. scanned as DECORWORD), rather than a
         *              proper keyword (i.e. scanned as ZCOMP).
         *              The same idea of precedence applies, hence _REPSEQ.
         *
         *              TODO:CHECK whether REPSEQ needs precedence or not. At the moment
         *                         it is just taking the same as CIRCSEQ.
         */
        
        // Keywords
        CIRCFI, CIRCDO, CIRCOD, CIRCVAR, CIRCVAL,
        CIRCRES, CIRCVRES, CIRCCHAN, CIRCCHANFROM, CIRCCHANSET,
        CIRCNAMESET, CIRCPROC, CIRCPROCESSENV, CIRCBEGIN, CIRCEND, CIRCSTATE,
        CIRCSKIP, CIRCSTOP, CIRCCHAOS, _CIRCIF, 
        
        /* Note:
         *
         * CIRCIF => As I couldn't make CIRCIF different from IF by
         *           using "ifg" or "IF", I am just reusing it here
         *           like before, with the same adjustment on precedences.
         */
        
        // Brackets
        LCIRCCHANSET, RCIRCCHANSET, CIRCLINST, CIRCRINST,
        LPAR, RPAR, LINTER, RINTER, 
                
        // Special bracket terminals to overhide precedence of process renaming
        // acording to how it is expected to be in CSP_M.
        // USE _RENAME :)
        
</add:circus>
<add:oz>
        DELTA, CLASS, GENCLASS, STATE, INIT, OPSCH, SDEF,
        INITWORD, POLY, CONTAINMENT, SCOPE,
        DCNJ, DGCH, DSQC, PARALLEL, ASSOPARALLEL, GCH, CLASSUNION,
</add:oz>
<add:tcoz>
        ATTIME, NEXTPRO, INTCHOICE, DIC, INTERLEAVE,
        DIL, WAITUNTIL, DEADLINE, WAIT, INTERRUPT, TIMEOUT, TIMEEND, 
        DPARA, NETTOPLEFT, NETTOPRIGHT, CHAN, SENSOR, ACTUATOR, 
</add:tcoz>
        //identifiers starting with a '_' are used only to force precedence
        _APPLICATION, _RENAME;

terminal LocString
<add:zpatt>
        JOKERNAME, JOKERNAMELIST, JOKEREXPR, JOKERPRED, JOKERDECLLIST,
</add:zpatt>
        TEXT, PREP, PRE, POSTP, POST, IP, I, LP, L, ELP, EL, ERP, ER,
        SRP, SR, EREP, ERE, SREP, SRE, ES, SS;

terminal LocInt NUMERAL, NUMSTROKE;

terminal Decorword
<add:oz>
        DEFNAME, OPNAME,
</add:oz>
        DECORWORD, DECLWORD;

non terminal Spec
    input,
    specification;

non terminal Sect
    narrSect;

non terminal ZSect
    section,
    emptySectionHeader,
    empty,
    sectionHeader;

non terminal List&lt;Sect&gt;
    sectionList;

non terminal List&lt;Parent&gt;
    parentList,
    parents;

non terminal List&lt;Para&gt;
    paragraphList,
    unboxedParagraphList,
    unboxedParagraphItemList;

non terminal Para 
    boxedParagraph,
    unboxedParagraphItem,
    narrParagraph;

non terminal AxPara
    axiomaticDefinition,
    genericAxDefinition,
    abbreviationDefinition,
    schema;

non terminal ConstDecl
    letDefinition;

non terminal List&lt;Freetype&gt; freeTypeList;
non terminal Freetype freeTypeDefinition;

non terminal List&lt;String&gt;
    narrWordList;

non terminal OptempPara operatorTemplate;
non terminal List /*StringAndOperand?*/ 
    template,
    prefixTemplate,
    postfixTemplate,
    infixTemplate,
    nofixTemplate,
    optWordOperandList;

non terminal Operand 
    varg,
    templateTag;
non terminal Assoc assoc;
non terminal OptempPara catTemplate;

non terminal SchText 
    schemaTextNoExpression,
    schemaText;

non terminal ZDeclList letDefinitionList;

non terminal List&lt;Branch&gt; branchList;
non terminal Branch branch;

non terminal List&lt;DeclName&gt;
    nameList,
    declWordList;

non terminal DeclName
    name,
    declName,
    formalParameterName;

non terminal List&lt;ZRefName&gt; refNameList;
non terminal ZRefName refName;

non terminal ZRenameList renameList;
non terminal NewOldPair rename;
    
non terminal ZDeclList
    zDeclList;

non terminal DeclList
    optDeclPart,
    declPart;

non terminal VarDecl
    varDecl;
non terminal ConstDecl
    constDecl;
non terminal Decl
    basicDeclaration,
    declaration;

non terminal GivenPara basicTypeDefinition;
non terminal List&lt;DeclName&gt;
    formalParameters,
    optFormalParameters;

non terminal Stroke stroke;

non terminal And
    sep;   

non terminal Term
    term,
    septerm,
    func_appl,
    inner_term;

non terminal List &lt; Object &gt;
    optAppendageList,
    appendageList;

non terminal Object
    appendage;

non terminal Pred
    predicate,
    relation,
    infixRel,
    infixChainRel;

non terminal MemPred
    prefixRel,
    postfixRel,
    nofixRel;

non terminal Expr
    expression;

non terminal ZDeclList
    constDeclList,
    optConstDeclList;

non terminal ZExprList
    prodExpressionList,
    optExpressionList,
    expressionList;

non terminal List&lt;String&gt;
    opName,
    prefixName,
    postfixName,
    infixName,
    nofixName;

non terminal Pair&lt;DeclName,List&lt;DeclName&gt;&gt;
    genName,
    prefixGenName,
    postfixGenName,
    infixGenName,
    nofixGenName;

non terminal List&lt;String&gt;
    optVargEsSsList;

non terminal Pair /* List DeclName, List DeclName */
    optNameEsSsList;

non terminal Expr
    application,
    prefixApp,
    postfixApp,
    infixApp,
    nofixApp;

non terminal List&lt;Object&gt;
    expSep;

non terminal List&lt;String&gt;
    argErepOrSrep,
    argEreOrSre,
    argErOrSr,
    argEsOrSs,
    argErpOrSrp;

non terminal LocString
    misusedOpName,
    ereOrSre,
    erOrSr,
    esOrSs;

non terminal And
    optNL;

<add:zpatt>
/// Z pattern constructs ///////////////////////////////////////////////
non terminal Jokers jokerPara;
non terminal Rule rulePara;

non terminal List&lt;String&gt; jokerList;

non terminal List&lt;Sequent&gt;
    sequentLHS,
    antecedents;

non terminal Sequent antecedent;

non terminal PredSequent conclusion;

non terminal Sequent
    sequent,
    proviso,
    lookupProviso,
    provisoSequent,
    predSequent;

non terminal Term jokerRef;

non terminal Expr baseType;

non terminal DeclList
    signature;

non terminal ZDeclList
    varDeclList;

non terminal DeclList
    jokerDeclList,
    varJokerDeclList;
</add:zpatt>

<add:circus>
/// Circus paragraphs ///////////////////////////////////////////////
non terminal Para
    channelPara,
    channelSetPara,
    processPara,
    actionPara,
    namesetPara, 
    unboxedInnerPara;

non terminal List &lt; Para &gt;
    optInnerCircParaList;

/// Circus channel definition ////////////////////////////////////////////////   
non terminal List&lt;ChannelDecl&gt;
    channelDeclList;

non terminal ChannelDecl
    channelDecl, channelFromDecl;

non terminal ChannelSet
    channelSet;
    
/// Circus channel set expression definition ////////////////////////////////

//non terminal Expr
//    cs_expression;
//
//non terminal ZDeclList
//    cs_letDefinitionList;
//
//non terminal ConstDecl
//    cs_letDefinition;    
//
//non terminal Expr   
//    cs_func_appl,
//    cs_inner_expression,
//    cs_nofixApp,
//    cs_application,
//    cs_prefixApp,
//    cs_postfixApp,
//    cs_infixApp;
//
//non terminal List&lt;Object&gt;
//    cs_expSep;
//
//non terminal ZExprList
//    cs_optExpressionList,
//    cs_expressionList;
    
/// Circus process definition ///////////////////////////////////////////////    
non terminal CircusProcess 
    processDesc, 
    paramProcess, 
    indexedProcess, 
    unboxedBasicProcess,
    boxedBasicProcess,
    processCall,    
    process;

non terminal RenameList
    channelRenameList;
    
/// Circus parameters definition /////////////////////////////////////////////    
    
non terminal DeclList
  circusParamDeclList;
  
non terminal ZDeclList
    circusParamZDeclList;  

non terminal QualifiedDecl  
  qualifiedDecl;

non terminal ParamQualifier     
  circusQualifier,
  optCircusQualifier;    
  
non terminal List&lt;DeclName&gt;
  circusParamNameList;  

/// Circus action definition ///////////////////////////////////////////////        
non terminal CircusAction
    paramAction,
    circusAction,
    actionCall,
    cspAction;
    
/// Circus guard //////////////////////////////////////////////////////////        
non terminal Pred
    guard;
   
/// Circus communication /////////////////////////////////////////////////         
non terminal Communication
    communication;

non terminal List&lt;Field&gt;    
    optCommFields,
    commFields;
    
non terminal Field
    commField;

/// Circus guarded commands /////////////////////////////////////////////////             
non terminal CircusCommand
    command;    

non terminal List&lt;GuardedAction&gt;
    guardedCommands;
    
non terminal GuardedAction
    guardedCommand;

/// Circus name set definition /////////////////////////////////////////////
non terminal NameSet
    nameSet;
    
</add:circus>

<add:oz>
/// Object-Z constructs ///////////////////////////////////////////////
non terminal Expr
    inheritedClass;

non terminal ClassPara
    class;

non terminal Pair&lt;DeclName,List&lt;DeclName&gt;&gt;
    classHeader;

non terminal State
    state;

non terminal Pair&lt;PrimaryDecl,SecondaryDecl&gt;
    stateDeclNoExpression,
    stateDecl;

non terminal ZDeclList
    primaryDeclPart,
    optPrimaryDeclPart;

non terminal DeclList
    secondaryDeclPart;

non terminal InitialState
    initialState;

non terminal Term
    innerPara;

non terminal List /* TODO: use generics here! Term */
    innerParaList;

non terminal DeltaList
    deltaList;

non terminal VisibilityList
    visibilityList;
                        
non terminal OpExpr
    opExpr,
    outer_opExpr,
    inner_opExpr;

non terminal ExprList
    inheritedList;

non terminal List&lt;Expr&gt;
    inheritedClassList;

non terminal OpText
    opTextWithDelta,
    opText;

non terminal Operation
    operation;

non terminal List&lt;Operation&gt;
    operationList;

</add:oz>
<add:tcoz>
non terminal VarDecl channelDeclaration;

non terminal Expr channel;

non terminal List&lt;Event&gt; eventSet;
 
non terminal Event
    event,
    inOutEvent;
 
non terminal List&lt;Connection&gt; topology;
       
non terminal Connection connection;

/* non terminal ChannelType chantype;*/
</add:tcoz>

// These are ordered from loosest first to tightest last.
precedence right        BAR;
precedence left         TEXT;
precedence left         <add:tcoz>LPAREN,</add:tcoz> RPAREN;
precedence left         NL, SEMICOLON;
precedence nonassoc     DEFEQUAL <add:circus>, CIRCDEF</add:circus>;
precedence left         ALL, EXI, EXIONE, SPOT <add:circus>, CIRCINDEX </add:circus>;
<add:oz>
precedence left         DCNJ, DGCH, DSQC;
precedence left         ASSOPARALLEL;
<add:tcoz>
precedence left         DIC, DIL;
precedence left         WAIT;
precedence left         NEXTPRO, ATTIME;
precedence left         NETTOPLEFT, NETTOPRIGHT;
</add:tcoz>
precedence left         SCOPE;
precedence left         PARALLEL<add:tcoz>, INTERLEAVE, INTERRUPT,
TIMEOUT, TIMEEND</add:tcoz>;
precedence left         GCH <add:tcoz>, INTCHOICE </add:tcoz>;
</add:oz>
<add:circus>
/* From Z-Std(p.36): default is prefix op=rightassoc, postfix op=leftassoc */  

precedence right        CIRCMU;
precedence right        CIRCVAR;
precedence nonassoc     CIRCDO, CIRCOD;
precedence nonassoc     _CIRCIF, CIRCFI, CIRCTHEN, CIRCELSE;
precedence left         CIRCHIDING;
precedence left         INTERLEAVE;//, REPINTERLEAVE;
precedence nonassoc     LINTER, RINTER;
//precedence left         REPPARALLEL;
precedence nonassoc     LPAR, RPAR;
precedence left         INTCHOICE;//, REPINTCHOICE;
precedence left         EXTCHOICE;//, REPEXTCHOICE;
precedence left         CIRCSEQ, _REPSEQ; //TODO:CHECK _REPSEQ placement.
precedence nonassoc     _CIRCGUARD;
precedence right        PREFIXTHEN;
//, CIRCCOMMDOT
//CIRCVAL, CIRCRES, CIRCVRES, 
//CIRCCHAN, CIRCCHANFROM, CIRCCHANSET,
//CIRCNAMESET, CIRCPROC, CIRCBEGIN, CIRCEND, CIRCSTATE,
//CIRCSKIP, CIRCSTOP, CIRCCHAOS,         
//LCIRCCHANSET, RCIRCCHANSET, CIRCLINST, CIRCRINST,
</add:circus>
precedence left         IFF;
precedence right        IMP;
precedence left         OR;
precedence left         AND;
precedence right        NOT;
precedence left         MEM, EQUALS, PREP, LP, IP, EREP, SREP,
                        POSTP, ELP, ERP, SRP;
precedence right        LAMBDA;
precedence right        MU;
precedence right        LET;
<add:oz>
precedence left         CLASSUNION;
</add:oz>
precedence right        ELSE;
precedence left         ZCOMP;
precedence left         ZPIPE;
precedence left         ZHIDE;
precedence left         ZPROJ;
precedence right        ZPRE;
precedence left         EL, ERE, SRE, I, CROSS;
precedence right        POWER, PRE, L;
<add:oz>
precedence right        POLY;
</add:oz>
precedence left         POST, ER, SR;
<add:oz>
precedence left         CONTAINMENT;
</add:oz>
<add:tcoz>
precedence left         CHAN, SENSOR, ACTUATOR;
</add:tcoz>
precedence left         _APPLICATION;
precedence left         INSTROKE, OUTSTROKE, NEXTSTROKE, NUMSTROKE;
precedence left         _RENAME;
<add:zpatt>
precedence left         RULELINE;
</add:zpatt>
precedence left         DOT;
precedence right        THETA;
precedence left         LSQUARE, RSQUARE;
<add:circus>
precedence nonassoc     CIRCLINST, CIRCRINST;
</add:circus>
precedence left         DECORWORD <add:oz>, INITWORD</add:oz>;


/// specifications /////////////////////////////////////////////////////////

input ::=
        narrSect:narr specification:s
        {:
           if (narr != null) {
             s.getSect().add(0, narr);
           }
           RESULT = s;
        :}
        ;

narrSect ::=
        //empty
        {:
           RESULT = null;
        :}
	|
	narrWordList:nwl
	{:
           RESULT = factory_.createNarrSect(nwl);
           addLocAnn(RESULT, getLocation(nwlleft, nwlright));
        :}
        ;

specification ::=
        // anonymous specification
        emptySectionHeader:header paragraphList:pl
        {:
           header.getPara().addAll(pl);
           ZSect zSect = updateZSect(header, opTable_
             <add:zpatt>, jokerTable_ </add:zpatt>);
           RESULT = createSpec(list(zSect));
        :}
        |
        // sectioned specification
        sectionList:sl
        {:
           RESULT = createSpec(sl);
        :}
        ;

emptySectionHeader ::=
        empty:e
        {:
           // Apply Syntactic Transformation Rule 12.2.1.1
           final String name = ANONYMOUS_SPEC_NAME;
           final Parent p = factory_.createParent(TOOLKIT);
<add:oz>
           final Parent poz = factory_.createParent(OZ_TOOLKIT);
</add:oz>
           final List&lt;Parent&gt; parents = list(p<add:oz>, poz</add:oz>);
           resetOpTable(name, parents, eleft, eright);
<add:zpatt>
           resetJokerTable(name, parents, eleft, eright);
</add:zpatt>
           RESULT = createZSect(name, parents);
           addLocAnn(RESULT, getLocation(eleft, eright));
        :}
        ;

empty ::=
        //empty
        {:
        :}
        ;

sectionList ::= 
        sectionList:sl section:s
        {: 
           sl.add(s);
           RESULT = sl;
        :}
        |
        section:s
        {: RESULT = list((Sect) s); :}
        ;

section ::=
        sectionHeader:header paragraphList:pl
        {:
           header.getPara().addAll(pl);
           RESULT = updateZSect(header, opTable_
             <add:zpatt>, jokerTable_ </add:zpatt>);
        :}
        ;

sectionHeader ::=
        //ZED token at the start of sections is ignored by
        //the smart scanner to avoid a few problems
        SECTION:s DECORWORD:dw parents:p END
        {:
           String name = dw.getName();
           checkName(dw);

           if (! name.equals(PRELUDE) &amp;&amp; p.isEmpty()) {
             Parent parent = factory_.createParent(PRELUDE);
             p.add(parent);
           }
<add:oz>
           final Parent ozParent = factory_.createParent(OZ_TOOLKIT);
           if ((! name.equals(OZ_TOOLKIT)) &amp;&amp;
               (! p.contains(ozParent)) &amp;&amp;
               (! name.equals(PRELUDE))) {
             p.add(ozParent);
           }
</add:oz>
           resetOpTable(name, p, pleft, pright);
<add:zpatt>
           resetJokerTable(name, p, pleft, pright);
</add:zpatt>
           RESULT = createZSect(name, p);
           addLocAnn(RESULT, getLocation(sleft, sright));
        :}
        ;

parents ::=
        //empty
        {: RESULT = list(); :}
        |
        PARENTS
        {: RESULT = list(); :}
        |
        PARENTS parentList:pl
        {: RESULT = pl; :}
        ;

parentList ::=
        parentList:pl COMMA DECORWORD:dw  
        {:
           checkName(dw);
           Parent p = factory_.createParent(dw.getName());
           addLocAnn(p, dw.getLocation());
           pl.add(p);
           RESULT = pl;
        :}
        |
        DECORWORD:dw
        {:
           checkName(dw);
           Parent p = factory_.createParent(dw.getName());
           addLocAnn(p, dw.getLocation());
           RESULT = list(p);
        :}
        ;


//paragraphs are divided into boxed and unboxed paragraphs. 
//Unboxed paragraphs must have a newline after their definition, 
//unless they are the final paragraph within ZED ... END tokens
paragraphList ::= 
        paragraphList:pl boxedParagraph:p
        {:
           if (p != null) pl.add(p);
           RESULT = pl;
        :}
        |
        paragraphList:pl unboxedParagraphList:upl
        {:
           pl.addAll(upl);
           RESULT = pl;
        :}
        |
        paragraphList:pl narrParagraph:np
        {:
           pl.add(np);
           RESULT = pl;
        :}
        |
        //empty
        {: RESULT = list(); :} %prec NL 
        ;


// 6.2 Global Paragraphs //////////////////////////////////////////////////////

boxedParagraph ::=
        axiomaticDefinition:ad
        {: RESULT = ad; :}
        |
        schema:s
        {: RESULT = s; :}
        |
        genericAxDefinition:gd
        {: RESULT = gd; :}
<add:zpatt>
        |
        jokerPara:jp
        {: RESULT = jp; :}
        |
        rulePara:rp
        {: RESULT = rp; :}
</add:zpatt>
<add:oz>
        |
        class:c
        {: RESULT = c; :}
</add:oz>
        |
        error END
<add:oz>
        {: resetIsOpExpr(); :}
</add:oz>
        ;

narrParagraph ::=
        narrWordList:nwl
        {:
           RESULT = factory_.createNarrPara(nwl);
           addLocAnn(RESULT, getLocation(nwlleft, nwlright));
        :}
        ;

unboxedParagraphList ::=
        ZED:zed unboxedParagraphItemList:uil END:end
        {: if (uil.size() == 1) {
             addLocAnn(uil.get(0), getLocation(zed, end));
           }
           RESULT = uil;
        :}
        |        
        ZED error END
        {:
           RESULT = list();
<add:oz>
           resetIsOpExpr();
</add:oz>
        :}
        ;

unboxedParagraphItemList ::=
        unboxedParagraphItemList:uil NL unboxedParagraphItem:ui
        {:
           if (ui != null) uil.add(ui);
           RESULT = uil;
        :}
        |
        unboxedParagraphItem:ui
        {:
           RESULT = list(ui);
        :}
        ;
        
unboxedParagraphItem ::=
        basicTypeDefinition:btd
        {: RESULT = btd; :}
        |
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        |
        freeTypeList:ftl
        {:
           RESULT = factory_.createFreePara(ftl);
           addLocAnn(RESULT, getLocation(ftlleft, ftlright));
        :}
        |
        optFormalParameters:ofp CONJECTURE predicate:p
        {:
           RESULT = factory_.createConjPara(ofp, p);
           addLocAnn(RESULT, getLocation(ofpleft, ofpright));
        :}
        |
        operatorTemplate:ot
        {:
           try {
             opTable_.add(ot);
           }
           catch (OpTable.OperatorException e) {
             final Symbol token = new Symbol(Sym.ZED, otleft, otright);
             parser.report_error(ZParseMessage.MSG_CANNOT_ADD_OP,
                                 new Object[0],
                                 getLocation(otleft, otright));
           }
           RESULT = ot;
        :}
<add:circus>
        |
        channelPara:cp
        {: RESULT = cp; :}
        |
        channelSetPara:csp
        {: RESULT = csp; :}
        |
        processPara:pp
        {: RESULT = pp; :}       
</add:circus>
        ;

basicTypeDefinition ::= 
        LSQUARE:lsq nameList:nl RSQUARE
        {:
           RESULT = factory_.createGivenPara(nl);
           addLocAnn(RESULT, getLocation(lsqleft, lsqright));
        :}
        ;

schema ::=
        SCH:sch name:n optNL schemaText:st END:end
        {:
           RESULT = factory_.createSchema(n, null, st);
           addLocAnn(RESULT, getLocation(sch, end));
        :}
        |
        GENSCH:gensch name:n optNL formalParameters:fp schemaText:st END:end
        {:
           RESULT = factory_.createSchema(n, fp, st);
           addLocAnn(RESULT, getLocation(gensch, end));
        :}
        ;       

genericAxDefinition ::= 
        GENAX:genax formalParameters:fp schemaText:st END:end
        {:
           RESULT = factory_.createAxPara(fp, st, Box.AxBox);
           addLocAnn(RESULT, getLocation(genax, end));
        :}
        ;

optFormalParameters ::=
        formalParameters:fp
        {: RESULT = fp; :}
        |
        //empty
        {: RESULT = list(); :}
        ;

formalParameters ::= 
        LSQUARE nameList:nl RSQUARE optNL
        {: RESULT = nl; :}
        ;

axiomaticDefinition ::= 
        AX:ax schemaText:st END:end
        {:
           RESULT = factory_.createAxPara(null, st, Box.AxBox);
           addLocAnn(RESULT, getLocation(ax, end));
        :}
        ;

//according to the Z ISO standard, an abbreviation definition is to be
//treated as an axiomatic definition, with ConstDecl(dn,e)
abbreviationDefinition ::=
        declName:dn DEFEQUAL:equal expression:e
        {:
           ConstDecl cd = factory_.createConstDecl(dn, e);
           addLocAnn(cd, getLocation(equalleft, equalright, dn, e));
           ZDeclList decls = factory_.createZDeclList();
           decls.add(cd);
           ZSchText st = factory_.createZSchText(decls, null);
           addLocAnn(st, getLocation(dn, e));
           RESULT = factory_.createAxPara(null, st, Box.OmitBox);
           addLocAnn(st, getLocation(dn, e));
        :}
        |
        //TODO: check this. Should be name:n, but the toolkit won't parse
        //"\langle \listarg \rangle [X] == .... without this
        declName:dn formalParameters:fp DEFEQUAL:equal expression:e
        {:
           ConstDecl cd = factory_.createConstDecl(dn, e);
           addLocAnn(cd, getLocation(equalleft, equalright, dn, e));
           ZDeclList decls = factory_.createZDeclList();
           decls.add(cd);
           ZSchText st = factory_.createZSchText(decls, null);
           addLocAnn(st, getLocation(cd, e));
           RESULT = factory_.createAxPara(fp, st, Box.OmitBox);
           addLocAnn(RESULT, getLocation(dn, e));
        :}
        |
        genName:gn DEFEQUAL:equal expression:e
        {:
           DeclName dn = gn.getFirst();
           LocInfo dnLoc = dn != null ?
             getLocation(dn) : getLocation(gnleft, gnright);
           List&lt;DeclName&gt; fp = gn.getSecond();
           ConstDecl cd = factory_.createConstDecl(dn, e);
           LocInfo eLoc = getLocation(e);
           addLocAnn(cd, getLocation(equalleft, equalright, dnLoc, eLoc));
           ZDeclList decls = factory_.createZDeclList();
           decls.add(cd);
           ZSchText st = factory_.createZSchText(decls, null);
           addLocAnn(st, getLocation(dnLoc, eLoc));
           RESULT = factory_.createAxPara(fp, st, Box.OmitBox);
           addLocAnn(RESULT, getLocation(dnLoc, eLoc));
        :}
        ;


freeTypeList ::=
        freeTypeList:ftl ANDALSO freeTypeDefinition:ftd
        {: 
           ftl.add(ftd);
           RESULT = ftl;
        :}
        |
        freeTypeDefinition:ftd
        {: RESULT = list(ftd); :}
        ;

freeTypeDefinition ::=
        name:n DEFFREE:deffree branchList:bl
        {:
           RESULT = factory_.createFreetype(n, bl);
           addLocAnn(RESULT, getLocation(deffreeleft, deffreeright));
        :}
        ;

branchList ::=
        branchList:bl BAR branch:b
        {:
           bl.add(b);
           RESULT = bl;
        :}
        |
        branch:b 
        {: RESULT = list(b); :}
        ;

branch ::=
        declName:dn
        {:
           RESULT = factory_.createBranch(dn, null);
           addLocAnn(RESULT, getLocation(dnleft, dnright));
        :}
        |
        declName:dn LDATA expression:e RDATA
        {:
           RESULT = factory_.createBranch(dn, e);
           addLocAnn(RESULT, getLocation(dnleft, dnright));
        :}
        ;

narrWordList ::=
        narrWordList:nwl TEXT:t  
        {:
           nwl.add(t.getString());
           RESULT = nwl;
        :}
        |
        TEXT:t
        {: RESULT = list(t.getString()); :}
        ;

// operator templates  /////////////////////////////////////////////////////

operatorTemplate ::=
        RELATION:rel template:t
        {:
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(t);
           RESULT.setCat(Cat.Relation);
           addLocAnn(RESULT, getLocation(relleft, relright));
        :}
        |
        FUNCTION:fun catTemplate:ct
        {:
           ct.setCat(Cat.Function);
           addLocAnn(ct, getLocation(funleft, funright));
           RESULT = ct;
        :}
        |
        GENERIC:g catTemplate:ct
        {:
           ct.setCat(Cat.Generic);
           addLocAnn(ct, getLocation(gleft, gright));
           RESULT = ct;
        :}
        ;

template ::=
        prefixTemplate:pt
        {: RESULT = pt; :}
        |
        postfixTemplate:pt
        {: RESULT = pt; :}
        |
        infixTemplate:it
        {: RESULT = it; :}
        |
        nofixTemplate:nt
        {: RESULT = nt; :}
        ;


catTemplate ::=
        prefixTemplate:pt
        {: 
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(pt);
        :}
        |
        postfixTemplate:pt
        {: 
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(pt);
        :}
        |
        NUMERAL:pr assoc:a infixTemplate:it
        {:
           RESULT = factory_.createOptempPara();
           RESULT.setPrec(pr.getInteger());
           RESULT.getOper().addAll(it);
           RESULT.setAssoc(a);
        :}
        |
        nofixTemplate:nt
        {:
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(nt);
        :}
        ;


assoc ::=
        LEFTASSOC
        {: RESULT = Assoc.Left; :}
        |
        RIGHTASSOC
        {: RESULT = Assoc.Right; :}
        ;


prefixTemplate ::=
        LPAREN DECORWORD:n optWordOperandList:ol varg:v RPAREN
        {:
           ol.add(0, createOperator(n, nleft, nright));
           ol.add(v);
           RESULT = ol; 
        :}
	|
	LPAREN POWER:p varg:v RPAREN
	{:
           RESULT = list(createOperator(ZString.POWER, pleft, pright), v);
	:}
        ;


postfixTemplate ::=
        LPAREN varg:v DECORWORD:n optWordOperandList:ol RPAREN
        {:
           ol.add(0, createOperator(n, nleft, nright));
           ol.add(0, v);
           RESULT = ol; 
        :}
        ;


infixTemplate ::=
        LPAREN varg:v1 DECORWORD:n optWordOperandList:ol varg:v2 RPAREN
        {:
           ol.add(0, createOperator(n, nleft, nright));
           ol.add(0, v1);
           ol.add(v2);
           RESULT = ol; 
        :}
        ;


nofixTemplate ::=
        LPAREN DECORWORD:n optWordOperandList:ol RPAREN:rp
        {:
           if (ol.size() &lt; 1) {
             parser.report_error(ZParseMessage.MSG_UNEXPECTED_TOKEN,
                                 new Object[] {"RPAREN"},
                                 getLocation(rpleft, rpright));
           }
           ol.add(0, createOperator(n, nleft, nright));
           RESULT = ol;
        :}
        ;


optWordOperandList ::=
        //empty
        {: RESULT = list(); :}
        |
        optWordOperandList:wl templateTag:t DECORWORD:n
        {:
           wl.add(t);
           wl.add(createOperator(n, nleft, nright));
           RESULT = wl;
        :}
        ;

templateTag ::=
        varg:v
        {: RESULT = v; :}
        |
        LISTARG:listarg
        {: RESULT = factory_.createOperand(Boolean.TRUE); :}
        ;

varg ::=
        ARG:arg
        {: RESULT = factory_.createOperand(Boolean.FALSE); :}
        ;

<add:circus>   
/// Channel Paragraph ////////////////////////////////

channelPara ::= 
        CIRCCHAN:chan channelDeclList:cdl
        {:             
           RESULT = factory_.createChannelPara(cdl);
           addLocAnn(RESULT, getLocation(chanleft, chanright));
        :}
        |
        CIRCCHANFROM:chanf channelFromDecl:cfd
        {:
           RESULT = factory_.createChannelPara(factory_.list(cfd));
           addLocAnn(RESULT, getLocation(chanfleft, chanfright));
        :}                            
        ;

        
channelDeclList ::= 
        channelDecl:cd
        {:
           RESULT = factory_.list(cd);
        :}
        |
        channelDeclList:cdl SEMICOLON channelDecl:cd
        {:
           cdl.add(cd);
           RESULT = cdl;
        :}
        ;
        
channelDecl ::=        
        /* Typed channels */
        declWordList:dwl COLON expression:e
        {:           
           RESULT = factory_.createChannelDecl(null, dwl, e);
           addLocAnn(RESULT, getLocation(dwlleft, dwlright));
        :}
        |
        /* Generically defined channels */
        formalParameters:fp declWordList:dwl COLON expression:e
        {:                       
           RESULT = factory_.createChannelDecl(fp, dwl, e);
           addLocAnn(RESULT, getLocation(fpleft, fpright));
        :}
        |
        /* Synchronisation channels */
        nameList:nl
	{:                  
           RESULT = factory_.createChannelDecl(null, nl, null);
           addLocAnn(RESULT, getlocation(nlleft, nlright));
	:} 
        ;

channelFromDecl ::=
        /* Generic channels declared through generic Z schemas with generic actuals */
        optFormalParameters:ofp refName:rn LSQUARE expressionList:el RSQUARE
        {:  
           RefExpr re = factory_.createRefExpr(rn, el, Boolean.FALSE, Boolean.TRUE);
           RESULT = factory_.createChannelDecl(ofp, null, re);
           addLocAnn(RESULT, getLocation(ofpleft, ofpright));
        :}        
        | 
        /* Channels declared through Z schemas */                
        optFormalParameters:ofp refName:rn 
        {:
           RefExpr re = factory_.createRefExpr(rn);
           RESULT = factory_.createChannelDecl(ofp, null, re);
           addLocAnn(RESULT, getLocation(ofpleft, ofpright));
        :}
        ; 

/// Channel Set Paragraph ////////////////////////////

channelSetPara ::=         
        CIRCCHANSET:ccs optFormalParameters:ofp name:n DEFEQUAL:equal channelSet:cs
        {:                    
           RESULT = factory_.createChannelSetPara(ofp, n, cs);
           addLocAnn(RESULT, getLocation(ccsleft, ccsright));
        :}        
        ;
        
channelSet ::=        
        /* channel set extension */        
        LCIRCCHANSET:lc optExpressionList:oel RCIRCCHANSET:rc
        {:
           // NOTE: It must be an optExpressionList because of generic actuals on channel names.
           Expr e = validateChannelSetExpr(createBasicChannelSetExpr(oel));
           RESULT = factory_.createChannelSet(e);
           addLocAnn(RESULT, getLocation(lcleft, lcright));
        :}
        |
        expression:e
        {:          
           Expr eValid = validateChannelSetExpr(e);
           RESULT = factory_.createChannelSet(eValid);
           addLocAnn(RESULT, getLocation(eleft, eright));
        :}
        ;

///// Channel Set Expression ////////////////////////////
//
//cs_expression ::=
//        /* conditional */
//        IF:i predicate:p THEN cs_expression:te ELSE cs_expression:fe
//        {:
//           RESULT = factory_.createCondExpr(p, expr(te), expr(fe));
//           addLocAnn(RESULT, ileft, iright);
//        :}
//        |
//        /* function construction */
//        LAMBDA:lambda schemaText:st SPOT cs_expression:t
//        {:
//           RESULT = factory_.createLambdaExpr(st, expr(t));
//           addLocAnn(RESULT, lambdaleft, lambdaright);
//        :} %prec LAMBDA
//        |
//        /* definite description */
//        MU:mu schemaText:st SPOT cs_expression:t
//        {:
//           RESULT = factory_.createMuExpr(st, expr(t));
//           addLocAnn(RESULT, muleft, muright);
//        :} %prec MU
//        |
//        /* substitution expression */
//        LET:let cs_letDefinitionList:ldl SPOT cs_expression:t
//        {:
//           ZSchText st = factory_.createZSchText(ldl, null);
//           RESULT = factory_.createLetExpr(st, expr(t));
//           addLocAnn(RESULT, letleft, letright);
//        :} %prec LET
//        |
//        /* application of operator function */
//        cs_application:a
//        {: RESULT = a; :}
//        |
//        /* application of non-operator function */
//        cs_func_appl:fa
//        {: RESULT = fa; :}
//        ;
//
//cs_letDefinitionList ::=
//        cs_letDefinitionList:ldl SEMICOLON cs_letDefinition:ld
//        {:
//           ldl.getDecl().add(ld);
//           RESULT = ldl;
//        :}
//        |
//        cs_letDefinition:ld
//        {: RESULT = factory_.createZDeclList(list(ld)); :}
//        ;
//
//cs_letDefinition ::=
//        name:n DEFEQUAL:defequal cs_expression:e
//        {:
//           RESULT = factory_.createConstDecl(n, expr(e));
//           addLocAnn(RESULT, defequalleft, defequalright);
//        :}
//        ;
//
//cs_func_appl ::=
//        cs_func_appl:fa cs_inner_expression:it
//        {:
//           RESULT = factory_.createApplExpr(expr(fa), expr(it), Boolean.FALSE);
//           addLocAnn(RESULT, faleft, itright);
//        :} %prec _CS_APPLICATION
//        |
//        cs_inner_expression:it
//        {: RESULT = it; :} %prec _CS_APPLICATION
//        ;
//
//cs_inner_expression ::=
//        /* channel set extension */
//        LCIRCCHANSET:lc optExpressionList:oel RCIRCCHANSET:rc
//        {:
//           RESULT = factory_.createBasicChannelSetExpr(oel); 
//           addLocAnn(RESULT, lcleft, lcright);
//        :}
//        //|
//        //cs_nofixApp:nfa
//        //{: RESULT = nfa; :} %prec _CS_APPLICATION
//        |
//        /* generic instantiation */
//        cs_inner_expression:it LSQUARE expressionList:el RSQUARE
//        {:
//           RESULT = factory_.createRefExpr(refname(it), el, Boolean.FALSE);
//           addLocAnn(RESULT, itleft, itright);
//        :}
//        |
//        /* parenthesized cs_term */
//        LPAREN cs_expression:t RPAREN
//        {:
//           t.getAnns().add(factory_.createParenAnn());
//           RESULT = t;
//        :}
//        |
//        /* reference */
//        refName:rn
//        {:
//           RESULT = factory_.createRefExpr(rn);
//           addLocAnn(RESULT, rnleft, rnright);
//        :}
//        ;
//
//cs_nofixApp ::=
//        // Normal applications of op templates (no example, sorry ).
//        L:l cs_expSep:es cs_expression:t ER:er
//        {:
//           List&lt;String&gt; opName = list(l);
//           addExpSepName(opName, es);
//           opName.add(ARG_TOK);
//           opName.add(er);
//
//           ZExprList expList = factory_.createZExprList();
//           addExpSepExp(expList, es);
//           expList.add(t);
//           RESULT = localCreateMixfixExpr(opName, expList, lleft, lright);
//           addLocAnn(RESULT, lleft, lright);
//        :}
//        |
//        // This would allow something like ((&lt;,,&gt;)[...](&lt;x, y&gt;))? Maybe remove?
//        L:l cs_expSep:es cs_optExpressionList:oel SR:sr
//        {:
//           List&lt;String&gt; opName = list(l);
//           addExpSepName(opName, es);
//           opName.add(LISTARG_TOK);
//           opName.add(sr);
//
//           ZExprList expList = factory_.createZExprList();
//           addExpSepExp(expList, es);
//           Expr seq = factory_.createSequence(oel);
//           addLocAnn(seq, oelleft, oelright);
//           expList.add(seq);
//           RESULT = localCreateMixfixExpr(opName, expList, lleft, lright);
//           addLocAnn(RESULT, lleft, lright);
//        :}
//        ;
//
//// Prodcutions for cs_application uses cs_expression rather than cs_term as
//// there are no predicate mixed in the cs_expression subtree. I will put
//// cs_term just for conformance with the old expression/term tree anyway.
//cs_application ::=
//        //cs_prefixApp:pa
//        //{: RESULT = pa; :}
//        //|
//        cs_postfixApp:pa
//        {: RESULT = pa; :}
//        |
//        cs_infixApp:ia
//        {: RESULT = ia; :}
//        ;
//
//cs_prefixApp ::=
//        PRE:pre cs_expression:t
//        {:
//           ZExprList exprs = factory_.createZExprList();
//           exprs.add(expr(t));
//           RESULT = localCreateMixfixExpr(list(pre, ARG_TOK), exprs,
//                                          preleft, preright);
//           addLocAnn(RESULT, preleft, preright);
//        :}
//        |
//        L:l cs_expSep:es cs_expression:t1 ERE:ere cs_expression:t2
//        {:
//           List&lt;String&gt; opName = list(l);
//           addExpSepName(opName, es);
//           opName.add(ARG_TOK);
//           opName.add(ere);
//           opName.add(ARG_TOK);
//
//           ZExprList expList = factory_.createZExprList();
//           addExpSepExp(expList, es);
//           expList.add(expr(t1));
//           expList.add(expr(t2));
//           RESULT = localCreateMixfixExpr(opName, expList, lleft, lright);
//           addLocAnn(RESULT, lleft, lright);
//        :}
//        |
//        L:l cs_expSep:es cs_optExpressionList:oel SRE:sre cs_expression:t
//        {:
//           List&lt;String&gt; opName = list(l);
//           addExpSepName(opName, es);
//           opName.add(LISTARG_TOK);
//           opName.add(sre);
//           opName.add(ARG_TOK);
//
//           ZExprList expList = factory_.createZExprList();
//           addExpSepExp(expList, es);
//           Expr seq = factory_.createSequence(oel);
//           addLocAnn(seq, oelleft, oelright);
//           expList.add(seq);
//           expList.add(expr(t));
//           RESULT = localCreateMixfixExpr(opName, expList, lleft, lright);
//           addLocAnn(RESULT, lleft, lright);
//        :}
//        ;
//
//cs_postfixApp ::=
//        cs_expression:t POST:post
//        {:
//           ZExprList exprs = factory_.createZExprList();
//           exprs.add(expr(t));
//           RESULT = localCreateMixfixExpr(list(ARG_TOK, post), exprs,
//                                          tleft, tright);
//           addLocAnn(RESULT, postleft, postright);
//        :}
//        |
//        cs_expression:t1 EL:el cs_expSep:es cs_expression:t2 ER:er
//        {:
//           List&lt;String&gt; opName = list(ARG_TOK);
//           opName.add(el);
//           addExpSepName(opName, es);
//           opName.add(ARG_TOK);
//           opName.add(er);
//
//           ZExprList expList = factory_.createZExprList();
//           expList.add(expr(t1));
//           addExpSepExp(expList, es);
//           expList.add(expr(t2));
//           RESULT = localCreateMixfixExpr(opName, expList, t1left, t1right);
//           addLocAnn(RESULT, elleft, elright);
//        :}
//        |
//        cs_expression:t EL:el cs_expSep:es cs_optExpressionList:oel SR:sr
//        {:
//           List&lt;String&gt; opName = list(ARG_TOK);
//           opName.add(el);
//           addExpSepName(opName, es);
//           opName.add(LISTARG_TOK);
//           opName.add(sr);
//
//           ZExprList expList = factory_.createZExprList();
//           expList.add(expr(t));
//           addExpSepExp(expList, es);
//           Expr seq = factory_.createSequence(oel);
//           addLocAnn(seq, oelleft, oelright);
//           expList.add(seq);
//           //expList.add(factory_.createSequence(oel));
//           RESULT = localCreateMixfixExpr(opName, expList, tleft, tright);
//           addLocAnn(RESULT, elleft, elright);
//        :}
//        ;
//
//cs_infixApp ::=
//        cs_expression:lhs I:i cs_expression:rhs
//        {:
//           List&lt;String&gt; opName = list(ARG_TOK);
//           opName.add(i);
//           opName.add(ARG_TOK);
//           ZExprList exprs = factory_.createZExprList();
//           exprs.add(expr(lhs));
//           exprs.add(expr(rhs));
//           RESULT = localCreateMixfixExpr(opName, exprs,
//                                          lhsleft, lhsright);
//           addLocAnn(RESULT, ileft, iright);
//        :}
//        |
//        cs_expression:t1 EL:el cs_expSep:es cs_expression:t2 ERE:ere cs_expression:t3
//        {:
//           List&lt;String&gt; opName = list(ARG_TOK);
//           opName.add(el);
//           addExpSepName(opName, es);
//           opName.add(ARG_TOK);
//           opName.add(ere);
//           opName.add(ARG_TOK);
//
//           ZExprList expList = factory_.createZExprList();
//           expList.add(expr(t1));
//           addExpSepExp(expList, es);
//           expList.add(expr(t2));
//           expList.add(expr(t3));
//           RESULT = localCreateMixfixExpr(opName, expList, t1left, t1right);
//           addLocAnn(RESULT, elleft, elright);
//        :}
//        |
//        cs_expression:t1 EL:el cs_expSep:es optExpressionList:oel SRE:sre cs_expression:t2
//        {:
//           List&lt;String&gt; opName = list(ARG_TOK);
//           opName.add(el);
//           addExpSepName(opName, es);
//           opName.add(LISTARG_TOK);
//           opName.add(sre);
//           opName.add(ARG_TOK);
//
//           ZExprList expList = factory_.createZExprList();
//           expList.add(expr(t1));
//           addExpSepExp(expList, es);
//           Expr seq = factory_.createSequence(oel);
//           addLocAnn(seq, oelleft, oelright);
//           expList.add(seq);
//           expList.add(expr(t2));
//           RESULT = localCreateMixfixExpr(opName, expList, t1left, t1right);
//           addLocAnn(RESULT, elleft, elright);
//        :}
//        ;
//
//// Here I am not sure which one to choose: expSep or cs_expSep.
//// Those expressions are from the operator templates and are very
//// difficult to follow/find an example at times. As one of cs_term
//// can be an expression (basic channel set extension) that is outside
//// the Expr subtree, I am playing safe by restricting here to cs_expression
//// as well. Nevertheless, the tail recursion here should use cs_term, as
//// expSep does with term.
//cs_expSep ::=
//        //empty
//        {: RESULT = list(); :} %prec I
//        |
//        cs_expSep:exs cs_expression:t ES:es
//        {:
//           exs.add(list(t));
//           exs.add(es);
//           RESULT = exs;
//        :}
//        |
//        cs_expSep:exs cs_expressionList:el SS:ss
//        {:
//           exs.add(el);
//           exs.add(ss);
//           RESULT = exs;
//        :}
//        ;
//
//cs_optExpressionList ::=
//        //empty
//        {: RESULT = factory_.createZExprList(); :}
//        |
//        cs_expressionList:el
//        {: RESULT = el; :}
//        ;
//
//cs_expressionList ::=
//        cs_expressionList:el COMMA cs_expression:e
//        {:
//           el.add(e);
//           RESULT = el;
//        :}
//        |
//        cs_expression:e
//        {:
//           RESULT = factory_.createZExprList();
//           RESULT.add(e);
//        :}
//        ;
        
/// Process Paragraphs ////////////////////////////////

processPara ::=
        /* Process declaration */
        CIRCPROC:cp optFormalParameters:ofp name:n CIRCDEF processDesc:pd
        {:           
           RESULT = factory_.createProcessPara(n, ofp, pd);
           addLocAnn(RESULT, getLocation(cp, pd));
        :}                
        ;        

processDesc ::=
        paramProcess:pp
        {:
            RESULT = pp;
        :}
        |
        indexedProcess:ip
        {:
            RESULT = ip;
        :}
        |
        process:p
        {:
           RESULT = p;
        :}
        ;

paramProcess ::=
        /* Parameterised process */        
        circusParamDeclList:dp SPOT:sp process:p
        {:
            RESULT = factory_.createParamProcess(p, dp);
            addLocAnn(RESULT, getLocation(dpleft, dpright));
        :}
        ;
        
indexedProcess ::=  
        circusParamDeclList:dp CIRCINDEX:ci process:p
        {: 
            RESULT = factory_.createIndexedProcess(p, dp);
            addLocAnn(RESULT, getLocation(dpleft, dpright));
        :}
        ;
        
process ::=       
        unboxedBasicProcess:bp
        {:
            RESULT = bp;
        :}
        |
        /* Processes operator productions in precendence order */
        process:p CIRCHIDING:h channelSet:cs
        {:
           RESULT = factory_.createHideProcess(p, cs);
           addLocAnn(RESULT, getLocation(hleft, hright, p, cs));
        :}        
        | 
        process:pl INTERLEAVE:in process:pr
        {:
            RESULT = factory_.createInterleaveProcess(pl, pr);
            addLocAnn(RESULT, getLocation(inleft, inright, pl, pr));
        :}     
        |
        process:pl LPAR:lp channelSet:cs RPAR:rp process:pr
        {:
            RESULT = factory_.createParallelProcess(pl, pr, cs);
            addLocAnn(RESULT, getLocation(pl, pr));
        :}             
        |
        process:pl INTCHOICE:ic process:pr
        {:
            RESULT = factory_.createIntChoiceProcess(pl, pr);
            addLocAnn(RESULT, getLocation(icleft, icright, pl, pr);
        :}
        |
        process:pl EXTCHOICE:cs process:pr
        {:
            RESULT = factory_.createExtChoiceProcess(pl, pr);
            addLocAnn(RESULT, getLocation(csleft, csright, pl, pr));
        :}
        |
        process:pl CIRCSEQ:cs process:pr
        {:
            RESULT = factory_.createSeqProcess(pl, pr);
            addLocAnn(RESULT, getLocation(csleft, csright, pl, pr));
        :}        
// CONFLICTS        
//        /* Call and Renaming square bracktes?*/
//        |         
//        processDesc:pd LSQUARE:lsq channelRenameList:crl RSQUARE
//        {: 
//            RESULT = factory_.createRenameProcess(pd, crl);
//            addLocAnn(RESULT, pdleft, pdright);
//        :} %prec _RENAME 
        |
        /* Replicated processes productions in precendence order */
        REPINTERLEAVE:ri circusParamDeclList:dp SPOT:sp process:p
        {:
            RESULT = factory_.createInterleaveProcessIte(p, dp);
            addLocAnn(RESULT, getLocation(ri, p));
        :}
        | 
        REPPARALLEL:rp circusParamDeclList:dp LPAR channelSet:cs RPAR SPOT:sp process:p
        {:
            RESULT = factory_.createParallelProcessIte(p, dp, cs);
            addLocAnn(RESULT, getLocation(rp, p));
        :}
        | 
        REPINTCHOICE:ri circusParamDeclList:dp SPOT:sp process:p
        {:
            RESULT = factory_.createIntChoiceProcessIte(p, dp);
            addLocAnn(RESULT, getLocation(ri, p));
        :}
        | 
        REPEXTCHOICE:re circusParamDeclList:dp SPOT:sp process:p
        {:
            RESULT = factory_.createExtChoiceProcessIte(p, dp);
            addLocAnn(RESULT, getLocation(re, p));
        :}
        | 
        ZCOMP:rs circusParamDeclList:dp SPOT:sp process:p
        {:
            RESULT = factory_.createSeqProcessIte(p, dp);
            addLocAnn(RESULT, getLocation(rs, p));
        :}  %prec _REPSEQ     
        | 
        /* Indexed processes productions in precendence order */
        REPINTERLEAVE:ri circusParamDeclList:dp CIRCINDEX:ci process:p
        {:
            RESULT = factory_.createInterleaveProcessIdx(p, dp);
            addLocAnn(RESULT, getLocation(ri, p));
        :}
        | 
        REPPARALLEL:rp circusParamDeclList:dp LPAR channelSet:cs RPAR CIRCINDEX:ci process:p
        {:
            RESULT = factory_.createParallelProcessIdx(p, dp, cs);
            addLocAnn(RESULT, getLocation(rp, p));
        :}
        | 
        REPINTCHOICE:ri circusParamDeclList:dp CIRCINDEX:ci process:p
        {:
            RESULT = factory_.createIntChoiceProcessIdx(p, dp);
            addLocAnn(RESULT, getLocation(ri, p));
        :}
        | 
        REPEXTCHOICE:re circusParamDeclList:dp CIRCINDEX:ci process:p
        {:
            RESULT = factory_.createExtChoiceProcessIdx(p, dp);
            addLocAnn(RESULT, getLocation(re, p));
        :}
        | 
        ZCOMP:rs circusParamDeclList:dp CIRCINDEX:ci process:p
        {:
            RESULT = factory_.createSeqProcessIdx(p, dp);
            addLocAnn(RESULT, getLocation(rs, p));
        :} %prec _REPSEQ
        |
        /* Parenthesized processes */
        LPAREN process:p RPAREN
        {:
           p.getAnns().add(factory_.createParenAnn());
           RESULT = p;
        :} 
        |
        /* Process calls */
        processCall:pc
        {:
            RESULT = pc;
        :} 
        ;
        
unboxedBasicProcess ::=        
        CIRCBEGIN optInnerCircParaList:ipl1 CIRCSTATE expression:e
            optInnerCircParaList:ipl2 SPOT circusAction:ca CIRCEND
        {: 
           RESULT = null; 
        :}
        ;
        
processCall ::=                        
// CONFLICTS
//        paramProcess:pa LPAREN expressionList:el RPAREN
//        {:
//            RESULT = null;
//        :}
//        |
//        indexedProcess:pa LPAREN expressionList:el RPAREN
//        {:
//            RESULT = null;
//        :}
//        |
        /* Nongenertic parameterised process call with instantiations */
        refName:rn LPAREN expressionList:el RPAREN:rparen
        {:
            /* The CallType is Param and the generic actuals are null */
            RESULT = factory_.createCallProcess(rn, el, null, CallType.Param);
            addLocAnn(RESULT, getLocation(refName, rparen));
        :}
        |
        /* Genertic parameterised process call with instantiations */
        refName:rn LSQUARE expressionList:ga RSQUARE LPAREN expressionList:param RPAREN:rparen
        {:
            /* The CallType is Param and both generic actuals and indexes are not null */
            RESULT = factory_.createCallProcess(rn, ga, param, CallType.Param);
            addLocAnn(RESULT, getLocation(rn, rparen));
        :}
        |
        /* Nongeneric indexed process call with instantiations */
        refName:rn CIRCLINST expressionList:idx CIRCRINST:circrinst
        {:
            /* The CallType is Index and the generic actuals are null */
            RESULT = factory_.createCallProcess(rn, null, idx, CallType.Index);
            addLocAnn(RESULT, getLocation(rn, circrinst));
        :}
        |
        /* Generic indexed process call with instantiations */
        refName:rn LSQUARE expressionList:ga RSQUARE CIRCLINST expressionList:idx CIRCRINST:circrinst
        {:
            /* The CallType is Index and both generic actuals and indexes are not null */
            RESULT = factory_.createCallProcess(rn, ga, idx, CallType.Index);
            addLocAnn(RESULT, getLocation(rn, circrinst));
        :}
        |        
        /* Generic parameterless process call with instantiation */
        refName:rn LSQUARE expressionList:ga RSQUARE:rsq
        {:
            /* The CallType is irrelevant and the parameters are null */
            RESULT = factory_.createCallProcess(rn, ga, null, CallType.Param);
            addLocAnn(RESULT, getLocation(rn, rsq));
        :}
        |        
        /* Nongeneric parameterless process call */
        refName:rn
        {:
            /* The CallType is irrelevant and both generic actuals and parameters are null */
            RESULT = factory_.createCallProcess(rn, null, null, CallType.Param);
            addLocAnn(RESULT, getLocation(rn));
        :}
        ;

/// Circus parameters declaration ////////////////////////////////

/* Just follows the rules for declPart but restricted to QualifiedDecl */
circusParamDeclList ::=
        circusParamZDeclList:cdl
        {: RESULT = cdl; :}
        ;

circusParamZDeclList ::=
        qualifiedDecl:qd
        {: RESULT = factory_.createZDeclList(list(qd)); :}
        |
        circusParamZDeclList:cdl sep qualifiedDecl:qd
        {:
           cdl.add(qd);
           RESULT = cdl;
        :}
        ;  
         
qualifiedDecl ::=       
        /* I've used circusParamNameList previously due to conflicts
         * related to duplicated instances of CIRCVAL/RES/VRES on the
         * action tree.
         * Anyway, it sounds more reasonable for parameter names not
         * to allow any sort of name, such as operator names for circus parameters.
         * TODO:CHECK this choice; maybe use circusParamNameList instead.
         */ 
        optCircusQualifier:ocq declWordList:dwl COLON:colon expression:e
        {:
           RESULT = factory_.createQualifiedDecl(dwl, e, ocq);
           addLocAnn(RESULT, getLocation(colonleft, colonright, ocq, e));
        :}        
        ;

optCircusQualifier ::=
        circusQualifier:cq
        {: RESULT = cq; :}
        |
        //empty
        {: RESULT = ParamQualifier.Value; :}
        ;  
    
circusQualifier ::=
        CIRCVAL
        {: RESULT = ParamQualifier.Value; :}
        |
        CIRCRES
        {: RESULT = ParamQualifier.Result; :}
        |
        CIRCVRES
        {: RESULT = ParamQualifier.ValueResult; :}
        ;        

/*       
circusParamNameList ::=
        circusParamNameList:dwl COMMA DECLWORD:dw
        {: 
           checkName(dw);
           DeclName dn = factory_.createZDeclName(dw.getName());
           addLocAnn(dn, dw.getLocation());
           dwl.add(dn); 
           RESULT = dwl;
        :}     
        |
        DECLWORD:dw
        {:
           checkName(dw);
           DeclName dn = factory_.createZDeclName(dw.getName());
           addLocAnn(dn, dw.getLocation());
           RESULT = list(dn); 
        :}        
        ;        
*/

/// Z paragraphs withing Process paragraphs ////////////////////////////////

optInnerCircParaList ::=
        optInnerCircParaList:ipl optNL boxedParagraph:bp
        {:
           ipl.add(bp);
           RESULT = ipl;
        :}
        |
        optInnerCircParaList:ipl NL unboxedInnerPara:uip
        {:
           ipl.add(uip);
           RESULT = ipl;
        :}
        |
        //empty
        {: 
            RESULT = list(); 
        :}
        ;

unboxedInnerPara ::=
        basicTypeDefinition:btd
        {: RESULT = btd; :}
        |
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        |
        freeTypeList:ftl
        {:
           RESULT = factory_.createFreePara(ftl);
           addLocAnn(RESULT, getLocation(ftlleft, ftlright));
        :}
        |
        optFormalParameters:ofp CONJECTURE predicate:p
        {:
           RESULT = factory_.createConjPara(ofp, p);
           addLocAnn(RESULT, getLocation(ofpleft, ofpright));
        :}
        |
        operatorTemplate:ot
        {:
           try {
             opTable_.add(ot);
           }
           catch (OpTable.OperatorException e) {
             final Symbol token = new Symbol(Sym.ZED, otleft, otright);
             parser.report_error(ZParseMessage.MSG_CANNOT_ADD_OP,
                                 new Object[0],
                                 getLocation(otleft, otright));
           }
           RESULT = ot;
        :}
        |
        namesetPara:np
        {: RESULT = np; :}
        |        
        actionPara:ap
        {: RESULT = ap; :}        
        ;

/// Boxed basic process paragraphs ////////////////////////////////

//boxedBasicProcessPara ::=        
//        |
//        CIRCPROCESSENV:cpe name:n optNL optFormalParameters:ofp basicProcess:bp END 
//        {:
//            RESULT = factory_.createProcessPara(n, ofp, bp);
//            addLocAnn(RESULT, cpeleft, cperight);
//        :} 
//        ;        
        
/// Special productions for process paragraphs ////////////////////////////////
        
channelRenameList ::=
        nameList:nl COLON EQUALS refNameList:rnl
        {:           
           RESULT = factory_.createZRenameList(createChannelRenameNewOldPairList(nlleft, nlright, nl, rnl));
           addLocAnn(RESULT, getLocation(nlleft, nlright));
        :}
        ;   

/// Nameset paragraphs withing Process paragraphs ////////////////////////////////

namesetPara ::=
        CIRCNAMESET:cns name:n DEFEQUAL:equal nameSet:ns
        {:
           RESULT = factory_.createNameSetPara(n, ns);
           addLocAnn(RESULT, getLocation(cns, ns));
        :}
        ;

nameSet ::=
        expression:e
        {:
           RESULT = factory_.createNameSet(e);
           addLocAnn(RESULT, getLocation(e));
        :}
        ;


/// Action paragraphs withing Process paragraphs ////////////////////////////////

actionPara ::=
        name:n CIRCDEF paramAction:pa
        {:
           RESULT = factory_.createActionPara(n, pa);
           addLocAnn(RESULT, getLocation(n, pa));
        :}
        ;
        
paramAction ::=
        circusParamDeclList:cp SPOT paramAction:pa
        {:
            RESULT = factory_.createParamAction(pa, cp);
            addLocAnn(RESULT, getLocation(cpleft, cpright));
        :} 
        |
        circusAction:ca
        {: RESULT = ca; :}
        ;
        
circusAction ::=         
        /* SchExprAction is to disapear from the action tree.
         * That is because not only of conflicts, but confusion.
         * The main source of conflicts is due to RefName that 
         * can come from predicates of guards, calls, and channels
         * from prefixing (communication fields).
         */         
        cspAction:ca
        {: RESULT = ca; :}
        |
        command:c
        {: RESULT = c; :}
        ;        
        
cspAction ::=
        CIRCSKIP:sk
        {:
          RESULT = SKIP_ACTION;
          addLocAnn(RESULT, sk);
        :}
        |
        CIRCSTOP:sp
        {:
          RESULT = STOP_ACTION;
          addLocAnn(RESULT, sp);
        :}
        |
        CIRCCHAOS:cc
        {:
          RESULT = CHAOS_ACTION;
          addLocAnn(RESULT, cc);
        :}
        |
        CIRCMU:cm name:n SPOT circusAction:ca
        {:
            RESULT = factory_.createMuAction(ca, n);
            addLocAnn(RESULT, getLocation(cm, ca));
        :}
        |
        /* Action operator productions in precendence order */
        circusAction:ca CIRCHIDING:h channelSet:cs
        {:
           RESULT = factory_.createHideAction(ca, cs);
           addLocAnn(RESULT, getLocation(ca, cs));
        :}
        |
        circusAction:cal LINTER:li nameSet:nsl BAR nameSet:nsr RINTER:ri circusAction:car
        {:
            RESULT = factory_.createInterleaveAction(cal, car, nsl, nsr);
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal INTERLEAVE:il circusAction:car
        {:
            RESULT = factory_.createInterleaveAction(cal, car, createEmptyNameSet(), createEmptyNameSet());
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal LPAR:lp nameSet:nsl BAR channelSet:cs BAR nameSet:nsr RPAR:rp circusAction:car
        {:
            RESULT = factory_.createParallelAction(cal, car, nsl, nsr, cs);
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal LPAR:lp channelSet:cs RPAR:rp circusAction:car
        {:
            RESULT = factory_.createParallelAction(cal, car, createEmptyNameSet(), createEmptyNameSet(), cs);
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal INTCHOICE:ic circusAction:car
        {:
            RESULT = factory_.createIntChoiceAction(cal, car);
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal EXTCHOICE:cs circusAction:car
        {:
            RESULT = factory_.createExtChoiceAction(cal, car);
            addLocAnn(RESULT, getLocation(cal, car));calleft, calright);
        :}
        |
        circusAction:cal CIRCSEQ:cs circusAction:car
        {:
            RESULT = factory_.createSeqAction(cal, car);
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        guard:g ANDALSO:cg circusAction:ca
        {:
            RESULT = factory_.createGuardedAction(ca, g);
            addLocAnn(RESULT, getLocation(g, ca));
        :} %prec _CIRCGUARD
        |
        communication:comm PREFIXTHEN:pt circusAction:ca
        {:
            RESULT = factory_.createPrefixingAction(ca, comm);
            addLocAnn(RESULT, getLocation(comm, ca));
        :}
        |
        /* Replicated action productions in precendence order */
        REPINTERLEAVE:ri declPart:dp LINTER nameSet:ns RINTER SPOT:sp circusAction:ca
        {:
            RESULT = factory_.createInterleaveActionIte(ca, dp, ns);
            addLocAnn(RESULT, getLocation(ri, ca));
        :}
        |
        REPINTERLEAVE:ri declPart:dp SPOT:sp circusAction:ca
        {:
            RESULT = factory_.createInterleaveActionIte(ca, dp, createEmptyNameSet());
            addLocAnn(RESULT, getLocation(ri, ca));
        :}
        |
        LPAR:lp channelSet:cs RPAR declPart:dp SPOT:sp LPAR nameSet:ns RPAR circusAction:ca
        {:
            RESULT = factory_.createParallelActionIte(ca, dp, ns, cs);
            addLocAnn(RESULT, getLocation(lp, ca));
        :}
//CONFLICTS        
//        /* This syntactic sugar is generating 3 conflicts; just leave it out for the moment.*/
//        |
//        LPAR:lp channelSet:cs RPAR declPart:dp SPOT:sp circusAction:ca
//        {:
//            RESULT = factory_.createParallelActionIte(ca, dp, cs, createEmptyNameSet());
//            addLocAnn(RESULT, lpleft, lpright);
//        :}
        |
        REPINTCHOICE:ri declPart:dp SPOT:sp circusAction:ca
        {:
            RESULT = factory_.createIntChoiceActionIte(ca, dp);
            addLocAnn(RESULT, getLocation(ri, ca));
        :}
        |
        REPEXTCHOICE:re declPart:dp SPOT:sp circusAction:ca
        {:
            RESULT = factory_.createExtChoiceActionIte(ca, dp);
            addLocAnn(RESULT, getLocation(re, ca));
        :}
        |
        ZCOMP:rs declPart:dp SPOT:sp circusAction:ca
        {:
            RESULT = factory_.createSeqActionIte(ca, dp);
            addLocAnn(RESULT, getLocation(rs, ca));
        :} %prec _REPSEQ
        |
        actionCall:ac
        {:
            RESULT = ac;
        :} 
        ;

actionCall ::=                        
// CONFLICTS
//        paramAction:pa LPAREN expressionList:el RPAREN
//        {:
//            RESULT = null;
//        :}
//        |
//        refName:rn LPAREN expressionList:el RPAREN
//        {:            
//            RESULT = factory_.createCallAction(rn, el);
//            addLocAnn(RESULT, rnleft, rnright);
//        :} 
//        | 
        refName:rn
        {:
            RESULT = factory_.createCallAction(rn, null);
            addLocAnn(RESULT, getLocation(rn));
        :}
        ;
       
// Guards will never be an AndPred with And.NL or And.SEMI
guard ::=
       term:p
       {: RESULT = pred(p); :}
       ;        

communication ::=
        /* Synchronisation or communication without generic parameters */
        refName:rn optCommFields:ocf
        {:
            RESULT = factory_.createCommunication(rn, null, ocf, retrieveCommType(ocf), DEFAULT_MULTISYNCH);
            addLocAnn(RESULT, getLocation(rn, ocf));
        :}
        |
        /* Generic channels cannot be through synchronisation, hence commFields cannot be optional */
        refName:rn LSQUARE expressionList:el RSQUARE commFields:cf
        {:
            RESULT = factory_.createCommunication(rn, el, cf, retrieveCommType(cf), DEFAULT_MULTISYNCH);
            addLocAnn(RESULT, getLocation(rn, cf));
        :}
        ;

optCommFields ::=
        commFields:cf
        {: RESULT = cf; :}
        |
        /* Synchronisation has empty communication fields */
        {: RESULT = factory_.&lt;Field&gt;list(); :}
        ;

commFields ::=
        commFields:cfs commField:cf
        {:
            assert cfs != null;
            cfs.add(cf);
            RESULT = cfs;
        :}
        |
        commField:cf
        {:
            RESULT = factory_.list(cf);
        :}
        ;

// Strangelly enough, this productions for FDR allows quite funny
// rules, such as c?expr, or lamda and if terms within a communication pattern.
// We decided to leave then out as they seem to be uncessary.
commField ::=
        /**
         * For fields, something very tricky happens: strokes!
         * Channel names are just refName (hence DECORDWORD), which
         * means strokes are scanned accordingly. 
         * So, "c?x" is different from "c~?x" as:
         * (DECORWORD, "c?"), (DECORDWORD, "x")and
         * (DECORWORD, "c"), (INSTROKE, "?"), (DECORDWORD, "x").
         *
         * In this situation we run out of luck because all possible
         * solutions around it do create trouble somewhere else.
         *
         * Option 1) New Unicode for "?" (input field)
         * ---------
         *
         * That means LaTeX typeset as: "c\commIn x". 
         * This also incurrs change in the KeywordScanner (or ContextFreeScanner) 
         * to recognise this new type of "word-glue".
         *
         * Option 2) Channel names without strokes
         * ---------
         *
         * Doesn't change the fact the scanne will recognise "c?" as
         * one DECORWORD, which means no good will be done here.
         * This in fact is the harder solution, as it demands various
         * chamnges in both ContextFree and Latex2Unicode scanners.
         * As a consequence, everywhere that channel appear, require
         * new productions for refName/declName and corresponding lists.
         * ABSOLUTE NIGHTMARE! Forget it.
         *
         * Option 3) Using INSTROKE to represent input field
         *
         * That means disapearing with CIRCCOMMQUERY (easy) and using
         * INSTROKE instead. This does not require any change anywhere else.
         * The price to pay, is that the LaTeX must have a hard space as "c~?x".
         *
         * That is somehow similar to what happens with DOT. The difference
         * is that "?" and "!" are more complicated because they can be lexed
         * as either part of a DECORWORD or as STROKES.
         *         
         */
        /* Input communicatio as in: c?x */
        INSTROKE:cq refName:rn
        {:
            RESULT = factory_.createInputField(rn, TRUE_PREDICATE);
            addLocAnn(RESULT, getLocation(cq, rn));cqleft, cqright);
        :}
        |
        /* Input communicatio as in: c?x : P */
        INSTROKE:cq refName:rn PREFIXCOLON predicate:p
        {:
            RESULT = factory_.createInputField(rn, p);
            addLocAnn(RESULT, getLocation(cq, p));
        :}
        |
        /* Output communicatio as in: c!e */
        OUTSTROKE:cs expression:e
        {:
            RESULT = factory_.createOutputField(e);
            addLocAnn(RESULT, getLocation(cs, e));
        :}
        |
        // Differently from FDR, we allow expressions to appear at dot fields as well.
        /* Output communicaion as in: c.e */
        DOT:dt expression:e
        {:
            // TODO: Create loads of examples with this comparing it
            //       with the dot field ambiguity.
            //
            //       That is mainly to say when should the DOT be treated
            //       as a tuple selection or not. Surprisingly there was
            //       no conflict, but maybe we might need some sort of
            //       precedence setting for this.
            // TODO:URGENT!
            RESULT = factory_.createDotField(e);
            addLocAnn(RESULT, getLocation(dt, e));
        :}
        ;
        
/// Command (Action) paragraphs (as part of Process paragraph) ////////////////////////////////

command ::=
        /* Variable assignment */
        refNameList:rnl COLON EQUALS expressionList:el
        {:
            // If the lists are not with the same size, generate a parsing error
            // and return an empty assignment.
            if (checkListSizesAreEqual(rnlleft, rnlright, rnl, el))
              RESULT = factory_.createAssignmentCommand(factory_.createZRefNameList(rnl), el);
            else
              RESULT = factory_.createAssignmentCommand(factory_.createZRefNameList(), 
                  factory_.createZExprList());
            addLocAnn(RESULT, getLocation(rnl el));
        :}
        |
        IF:cif guardedCommands:gcs CIRCFI:cfi
        {:
            RESULT = factory_.createIfGuardedCommand(gcs);
            addLocAnn(RESULT, getLocation(cif, cfi));
        :} %prec _CIRCIF
        |
        CIRCDO:cdo guardedCommands:gcs CIRCOD:cod
        {:
            RESULT = factory_.createIfGuardedCommand(gcs);//createWhileGuardedCommand(gcs);
            addLocAnn(RESULT, getLocation(cdo, cod));
        :}
        |
        /* Variable declaration */
        CIRCVAR:cv declPart:dp SPOT circusAction:ca 
        {:
            RESULT = factory_.createVarDeclCommand(dp, ca);
            addLocAnn(RESULT, getLocation(cv, ca));
        :}        
        | 
        /* Specification statement */
        refNameList:rnl COLON LSQUARE predicate:pre COMMA predicate:post RSQUARE
        {:            
            RESULT = factory_.createSpecStmtCommand(factory_.createZRefNameList(rnl), pre, post);
            addLocAnn(RESULT, getLocation(rnlleft, rnlright));
        :}
        |
        /* Specification statement with empty frame*/
        COLON:c LSQUARE predicate:pre COMMA predicate:post RSQUARE:rsq
        {:            
            RESULT = factory_.createSpecStmtCommand(factory_.createZRefNameList(), pre, post);
            addLocAnn(RESULT, getLocation(c, rsq));
        :}
// CONFLICTS        
//        /* Assumption */        
//        |                
//        LBRACE:lb predicate:pre RBRACE
//        {:
//            RESULT = factory_.createSpecStmtCommand(factory_.createZRefNameList(), pre, TRUE_PREDICATE);
//            addLocAnn(RESULT, lbleft, lbright);
//        :}
//        /* Coercion */ 
//        | 
//        LSQUARE:ls predicate:post RSQUARE
//        {:
//            RESULT = factory_.createSpecStmtCommand(factory_.createZRefNameList(), TRUE_PREDICATE, post);
//            addLocAnn(RESULT, lsleft, lsright);
//        :}
        ;
        
guardedCommands ::=      
        guardedCommands:gcs CIRCELSE guardedCommand:g
        {:
           gcs.add(g);
           RESULT = gcs;
        :}
        | 
        guardedCommand:g
        {:
           RESULT = factory_.list(g);
        :}
        ;
        
guardedCommand ::=
        guard:g CIRCTHEN circusAction:ca 
        {:
            RESULT = factory_.createGuardedAction(ca, g);
            addLocAnn(RESULT, getLocation(g, ca));
        :}
        ;
        
</add:circus>     
                
/// schema text ///////////////////////////////////////////

schemaText ::= 
        optDeclPart:odp BAR predicate:p
        {: RESULT = factory_.createZSchText(odp, p); :}
        |
        optDeclPart:odp
        {: RESULT = factory_.createZSchText(odp, null); :}
        ;

optDeclPart ::=
        //empty
        {: RESULT = factory_.createZDeclList(); :}
        |
        declPart:dp
        {: RESULT = dp; :}
        ;

declPart ::=
        zDeclList:zdl
        {: RESULT = zdl; :}
<add:zpatt>
        | jokerDeclList:jdl
        {: RESULT = jdl; :}
        ;

jokerDeclList ::=
        zDeclList:zdl sep:s JOKERDECLLIST:j
        {: RESULT = factory_.createHeadDeclList(zdl,
             factory_.createJokerDeclList(j.getString())); :}
        |
        JOKERDECLLIST:j
        {:
           RESULT = factory_.createJokerDeclList(j.getString());
        :}
</add:zpatt>
        ;

zDeclList ::=
        declaration:d
        {: RESULT = factory_.createZDeclList(list(d)); :}
        |
        zDeclList:zdl sep declaration:d
        {:
           zdl.add(d);
           RESULT = zdl;
        :}
        ;

declaration ::=
        basicDeclaration:bd
        {: RESULT = bd; :}
        |
        expression:e
        {: RESULT = factory_.createInclDecl(e); :}
        ;

schemaTextNoExpression ::=
        optDeclPart:dp BAR predicate:p
        {:
           RESULT = factory_.createZSchText(dp, p);
        :}
        |
        zDeclList:zdl sep declaration:d
	{:
           zdl.add(d);
           RESULT = factory_.createZSchText(zdl, null);
	:}
	|
	basicDeclaration:bd
	{: 
           ZDeclList zdl = factory_.createZDeclList(list(bd));
           RESULT = factory_.createZSchText(zdl, null);
        :}
        ;

basicDeclaration ::=
        varDecl:vd
        {: RESULT = vd; :}
        |
        constDecl:cd
        {: RESULT = cd; :}
        ;

varDecl ::= 
        declWordList:dwl COLON:colon expression:e
        {:
           RESULT = factory_.createVarDecl(dwl, e);
           if (dwl.size() > 0) {
             LocInfo loc = getLocation(colonleft, colonright, dwl.get(0), e);
             addLocAnn(RESULT, loc);
           }
           else {
             addLocAnn(RESULT, getLocation(colon, e));
           }
        :}
<add:zpatt>
        |
        JOKERNAME:jn COLON expression:e
        {:
           DeclName dn = factory_.createJokerDeclName(jn.getString());
           RESULT = factory_.createVarDecl(list(dn), e);
           addLocAnn(RESULT, getLocation(jn.getLocation(), e));
        :}
</add:zpatt>
        ;

constDecl ::= 
        declName:dn DEFEQUAL:defequal expression:e
        {:
           RESULT = factory_.createConstDecl(dn, e);
           addLocAnn(RESULT, getLocation(defequalleft, defequalright, dn, e));
        :}
<add:zpatt>
        |
        JOKERNAME:jn DEFEQUAL:defequal expression:e
        {:
           DeclName dn = factory_.createJokerDeclName(jn.getString());
           RESULT = factory_.createConstDecl(dn, e);
           LocInfo jnLoc = jn.getLocation();
           LocInfo loc = getLocation(defequalleft, defequalright, jnLoc, e);
           addLocAnn(RESULT, loc);
        :}
</add:zpatt>
        ;  

sep ::=
        SEMICOLON
        {: RESULT = And.Semi; :}
        |
        NL
        {: RESULT = And.NL; :}
        ;

/// word, declName, and refName lists ////////////////////////////////////

nameList ::=
        nameList:nl COMMA DECORWORD:dw
        {: 
           checkName(dw);
           DeclName dn = factory_.createZDeclName(dw.getName());
           addLocAnn(dn, dw.getLocation());
           nl.add(dn);
           RESULT = nl;
        :}
        |
        DECORWORD:dw
        {: 
           checkName(dw);
           DeclName dn = factory_.createZDeclName(dw.getName());
           addLocAnn(dn, dw.getLocation());
           RESULT = list(dn);
        :}
        ;

name ::=
        DECORWORD:dw
        {:
           checkName(dw);
           RESULT = factory_.createZDeclName(dw.getName());
           addLocAnn(RESULT, dw.getLocation());
        :}
<add:oz>
        |
        DEFNAME:dfn
        {:
           checkName(dfn);
           RESULT = factory_.createZDeclName(dfn.getName());
           addLocAnn(RESULT, getLocation(dfnleft, dfnright));
        :}
</add:oz>
        ;

declWordList ::=
        declWordList:dwl COMMA DECLWORD:dw
        {: 
           checkName(dw);
           DeclName dn = factory_.createZDeclName(dw.getName());
           addLocAnn(dn, dw.getLocation());
           dwl.add(dn); 
           RESULT = dwl;
        :}
        |
        declWordList:dwl COMMA opName:on
        {:
           LocInfo loc = getLocation(onleft, onright);
           DeclName dn = strListToZDeclName(on, loc);
           if (dn != null) {
             addLocAnn(dn, loc);
             dwl.add(dn);
           }
           RESULT = dwl;
        :} 
        |
        declWordList:dwl COMMA misusedOpName:mon
        {:
           misusedOpName(mon);
        :}        
        |
        opName:on
        {:
           LocInfo loc = getLocation(onleft, onright);
           DeclName dn = strListToZDeclName(on, loc);
           if (dn != null) {
             addLocAnn(dn, loc);
           }
           RESULT = list(dn);
        :}
        |
        DECLWORD:dw
        {:
           checkName(dw);
           DeclName dn = factory_.createZDeclName(dw.getName());
           addLocAnn(dn, dw.getLocation());
           RESULT = list(dn); 
        :}
        |      
        misusedOpName:mon
        {:
           misusedOpName(mon);
        :}
        ;

misusedOpName ::=
        PREP:p
        {: RESULT = p; :}
        |
        PRE:p
        {: RESULT = p; :}
        |
        POSTP:p
        {: RESULT = p; :}
        |
        POST:p
        {: RESULT = p; :}
        |
        IP:ip
        {: RESULT = ip; :}
        |
        I:i
        {: RESULT = i; :}
        |
        LP:lp
        {: RESULT = lp; :}
        |
        L:l
        {: RESULT = l; :}
        |
        ELP:elp
        {: RESULT = elp; :}
        |
        EL:el
        {: RESULT = el; :}
        |
        ERP:erp
        {: RESULT = erp; :}
        |
        ER:er
        {: RESULT = er; :}
        |
        SRP:srp
        {: RESULT = srp; :}
        |
        SR:sr
        {: RESULT = sr; :}
        |
        EREP:erep
        {: RESULT = erep; :}
        |
        ERE:ere
        {: RESULT = ere; :}
        |
        SREP:srep
        {: RESULT = srep; :}
        |
        SRE:sre
        {: RESULT = sre; :}
        |
        ES:es
        {: RESULT = es; :}
        |
        SS:ss
        {: RESULT = ss; :}
        ;

declName ::=
        DECORWORD:dw
        {:
           checkName(dw);
           RESULT = factory_.createZDeclName(dw.getName());
           addLocAnn(RESULT, dw.getLocation());
        :}
        |
<add:oz>
        DEFNAME:dfn
        {:
           checkName(dfn);
           RESULT = factory_.createZDeclName(dfn.getName());
           addLocAnn(RESULT, getLocation(dfnleft, dfnright));
        :}
        |
</add:oz>
        opName:on
        {:
           LocInfo loc = getLocation(onleft, onright);
           RESULT = strListToZDeclName(on, loc);
           addLocAnn(RESULT, loc);
        :}
        ;

refNameList ::=
        refNameList:rnl COMMA DECORWORD:dw
        {:
           checkName(dw);
           ZRefName rn = factory_.createZRefName(dw.getName());
           addLocAnn(rn, dw.getLocation());
           rnl.add(rn);
           RESULT = rnl;
        :}        
        <add:oz>
        |
        refNameList:rnl COMMA INITWORD:iw
        {:
           ZRefName rn = factory_.createZRefName(OzString.INITWORD);
           addLocAnn(rn, getLocation(iwleft, iwright));
           rnl.add(rn);
           RESULT = rnl;
        :}
        </add:oz>
        |
        DECORWORD:dw
        {:
           checkName(dw);
           ZRefName rn = factory_.createZRefName(dw.getName());
           addLocAnn(rn, dw.getLocation());
           RESULT = list(rn);
        :}
        <add:oz>
        |
        INITWORD:iw
        {:
           ZRefName rn = factory_.createZRefName(OzString.INITWORD);
           addLocAnn(rn, getLocation(iwleft, iwright));
           RESULT = list(rn);
        :}
        </add:oz>
        ;

refName ::=
        DECORWORD:dw
        {:
           checkName(dw);
           RESULT = factory_.createZRefName(dw.getName());
           addLocAnn(RESULT, dw.getLocation());
        :}        
        <add:oz>
        |
        INITWORD:iw
        {:
           RESULT = factory_.createZRefName(OzString.INITWORD);
           addLocAnn(RESULT, getLocation(iwleft, iwright));
        :}
        </add:oz>
        |
        LPAREN opName:on RPAREN
        {:
           LocInfo loc = getLocation(onleft, onright);
           ZDeclName declName = strListToZDeclName(on, loc);
           RESULT = factory_.createZRefName(declName.getWord(),
                                            declName.getStroke(),
                                            null);
           RESULT.getAnns().add(factory_.createParenAnn());
           addLocAnn(RESULT, loc);
        :}
        ;


opName ::=
        prefixName:pn
        {: RESULT = pn; :}
        |
        postfixName:pn
        {: RESULT = pn; :}
        |
        infixName:in
        {: RESULT = in; :}
        |
        nofixName:nn
        {: RESULT = nn; :}
        ;

prefixName ::=
        PRE:p varg
        {: RESULT = list(p.getString(), ARG_TOK); :}
        |
        PREP:p varg
        {: RESULT = list(p.getString(), ARG_TOK); :}
        |
        L:l optVargEsSsList:ouesl argEreOrSre:aeos varg
        {: 
           RESULT = list(l.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        :}
        |
        LP:lp optVargEsSsList:ouesl argErepOrSrep:aeos varg
        {: 
           RESULT = list(lp.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        :}
        ;

postfixName ::=
        varg POST:p
        {: RESULT = list(ARG_TOK, p.getString()); :}
        |
        varg POSTP:p
        {: RESULT = list(ARG_TOK, p.getString()); :}
        |
        varg EL:el optVargEsSsList:ouesl argErOrSr:aeos
        {:
           RESULT = list(ARG_TOK);
           RESULT.add(el.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        :}
        |
        varg ELP:elp optVargEsSsList:ouesl argErpOrSrp:aeos
        {:
           RESULT = list(ARG_TOK);
           RESULT.add(elp.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        :}
        ;


infixName ::=
        varg I:i varg
        {:
           RESULT = list(ARG_TOK);
           RESULT.add(i.getString());
           RESULT.add(ARG_TOK);
        :}
        |
        varg IP:ip varg
        {:
           RESULT = list(ARG_TOK);
           RESULT.add(ip.getString());
           RESULT.add(ARG_TOK);
        :}
        |
        varg EL:el optVargEsSsList:ouesl argEreOrSre:aeos varg
        {:
           RESULT = list(ARG_TOK);
           RESULT.add(el.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        :}
        |
        varg ELP:elp optVargEsSsList:ouesl argErepOrSrep:aeos varg
        {:
           RESULT = list(ARG_TOK);
           RESULT.add(elp.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        :}
        ;

nofixName ::=
        L:l optVargEsSsList:ouesl argErOrSr:aeos
        {:
           RESULT = list(l.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        :}
        |
        LP:lp optVargEsSsList:ouesl argErpOrSrp:aeos
        {:
           RESULT = list(lp.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        :}
        ;

optVargEsSsList ::=
        //empty
        {: RESULT = list(); :}
        |
        optVargEsSsList:ouesl argEsOrSs:aeos
        {: 
           ouesl.addAll(aeos);
           RESULT = ouesl;
        :}
        ;

argEsOrSs ::=
        ARG ES:es
        {: RESULT = list(ARG_TOK, es.getString()); :}
        |
        LISTARG SS:ss
        {: RESULT = list(LISTARG_TOK, ss.getString()); :}
        ;

argEreOrSre ::=
        ARG ERE:ere
        {: RESULT = list(ARG_TOK, ere.getString()); :}
        |
        LISTARG SRE:sre
        {: RESULT = list(LISTARG_TOK, sre.getString()); :}
        ;

argErepOrSrep ::=
        ARG EREP:erep
        {: RESULT = list(ARG_TOK, erep.getString()); :}
        |
        LISTARG SREP:srep
        {: RESULT = list(LISTARG_TOK, srep.getString()); :}
        ;

argErOrSr ::=
        ARG ER:er
        {: RESULT = list(ARG_TOK, er.getString()); :}
        |
        LISTARG SR:sr
        {: RESULT = list(LISTARG_TOK, sr.getString()); :}
        ;

argErpOrSrp ::=
        ARG ERP:erp
        {: RESULT = list(ARG_TOK, erp.getString()); :}
        |
        LISTARG SRP:srp
        {: RESULT = list(LISTARG_TOK, srp.getString()); :}
        ;

//a genName is returned as a pair, with the first item being the name,
//and the second being a list of generic parameters
genName ::=
        prefixGenName:pgn
        {: RESULT = pgn; :}
        |
        postfixGenName:pgn
        {: RESULT = pgn; :}
        |
        infixGenName:ign
        {: RESULT = ign; :}
        |
        nofixGenName:ngn
        {: RESULT = ngn; :}
        ;

prefixGenName ::=
        PRE:pre formalParameterName:fpn
        {:
           List&lt;String&gt; name = list(pre.getString(), ARG_TOK);
           List&lt;DeclName&gt; decls = list(fpn);
           LocInfo loc = getLocation(fpnleft, fpnright);
           DeclName declName = strListToZDeclName(name, loc);
           RESULT = pair(declName, decls);
        :}
        |
        L:l optNameEsSsList:onesl formalParameterName:fpn1
             ereOrSre:eos formalParameterName:fpn2
        {:
           //construct the name
           List&lt;String&gt; name = list(l.getString());
           name.addAll((List) onesl.getSecond());
           name.add(ARG_TOK);
           name.add(eos.getString());
           name.add(ARG_TOK);

           //construct the parameter list
           List&lt;DeclName&gt; fps = (List&lt;DeclName&gt;) onesl.getFirst();
           fps.add(fpn1);
           fps.add(fpn2);
           LocInfo loc = getLocation(fpn2left, fpn2right);
           DeclName declName = strListToZDeclName(name, loc);
           RESULT = pair(declName, fps); 
        :}
        ;

postfixGenName ::=
        formalParameterName:fpn POST:p
        {:
           List&lt;String&gt; name = list(ARG_TOK, p.getString());
           List&lt;DeclName&gt; decls = list(fpn);
           LocInfo loc = getLocation(pleft, pright);
           DeclName declName = strListToZDeclName(name, loc);
           RESULT = pair(declName, decls);
        :}
        |
        formalParameterName:fpn1 EL:el optNameEsSsList:onesl 
           formalParameterName:fpn2 erOrSr:eos
        {:
           //construct the name
           List&lt;String&gt; name = list(ARG_TOK);
           name.add(el.getString());
           name.addAll((List) onesl.getSecond());
           name.add(ARG_TOK);
           name.add(eos.getString());

           //construct the parameter list
           List&lt;DeclName&gt; fps = list(fpn1);
           fps.addAll((List) onesl.getFirst());
           fps.add(fpn2);
           LocInfo loc = getLocation(eosleft, eosright);
           DeclName declName = strListToZDeclName(name, loc);
           RESULT = pair(declName, fps);
         :}
        ;

infixGenName ::=
        formalParameterName:fpn1 I:i formalParameterName:fpn2
        {:
           //construct the name
           List&lt;String&gt; name = list(ARG_TOK);
           name.add(i.getString());
           name.add(ARG_TOK);

           //construct the parameter list
           List&lt;DeclName&gt; fps = list(fpn1, fpn2);
           LocInfo loc = getLocation(fpn2left, fpn2right);
           DeclName declName = strListToZDeclName(name, loc);
           RESULT = pair(declName, fps);
        :}
        |
        formalParameterName:fpn1 EL:el optNameEsSsList:onesl 
           formalParameterName:fpn2 ereOrSre:eos formalParameterName:fpn3
        {:
           //construct the name
           List&lt;String&gt; name = list(ARG_TOK);
           name.add(el.getString());
           name.addAll((List) onesl.getSecond());
           name.add(ARG_TOK);
           name.add(eos.getString());
           name.add(ARG_TOK);
           //construct the parameter list
           List&lt;DeclName&gt; fps = list(fpn1);
           fps.addAll((List) onesl.getFirst());
           fps.add(fpn2);
           fps.add(fpn3);
           LocInfo loc = getLocation(fpn3left, fpn3right);
           DeclName declName = strListToZDeclName(name, loc);
           RESULT = pair(declName, fps);
        :}
        ;

nofixGenName ::=
        L:l optNameEsSsList:onesl formalParameterName:fpn erOrSr:eos
        {:
           //construct the name
           List&lt;String&gt; name = list(l.getString());
           name.addAll((List) onesl.getSecond());
           name.add(ARG_TOK);
           name.add(eos.getString());

           //construct the parameter list
           List&lt;DeclName&gt; fps = (List) onesl.getFirst();
           fps.add(fpn);
           LocInfo loc = getLocation(eosleft, eosright);
           DeclName declName = strListToZDeclName(name, loc);
           RESULT = pair(declName, fps);
        :}
        ;

formalParameterName ::=
        DECORWORD:dw
        {: 
           checkName(dw);
           RESULT = factory_.createZDeclName(dw.getName());
           addLocAnn(RESULT, dw.getLocation());
        :}
<add:oz>
        |
        DEFNAME:dn
        {:
           checkName(dn);
           RESULT = factory_.createZDeclName(dn.getName());
        :}
</add:oz>
        ;

//an optNameEsSsList is returned as a pair, with the first item
//being a list comprising generic parameters, and the second being a
//list comprising the name
optNameEsSsList ::=
        //empty
        {: RESULT = pair(list(), list()); :}
        |
        optNameEsSsList:ouesl formalParameterName:fpn esOrSs:eos
        {:
           List gens = (List) ouesl.getFirst();
           gens.add(fpn);
           List name = (List) ouesl.getSecond();
           name.add(ARG_TOK);
           name.add(eos.getString());
           RESULT = ouesl;
        :}
        ;

esOrSs ::=
        ES:es
        {: RESULT = es; :}
        |
        SS:ss
        {: RESULT = ss; :}
        ;

ereOrSre ::=
        ERE:ere
        {: RESULT = ere; :}
        |
        SRE:sre
        {: RESULT = sre; :}
        ;

erOrSr ::=
        ER:er
        {: RESULT = er; :}
        |
        SR:sr
        {: RESULT = sr; :}
        ;

/// predicates and expressions ///////////////////////////////////////////////

// This is for terms which MUST be predicates, so MIGHT contain NL/SEMI.
predicate ::=
        predicate:lhs sep:s term:rhs
        {:
           RESULT = factory_.createAndPred(lhs, pred(rhs), s);
           addLocAnn(RESULT, getLocation(sleft, sright, lhs, rhs));
        :}
        |
        term:p
        {: RESULT = pred(p); :}
        ;

expression ::=
        term:t
        {: RESULT = expr(t); :}
        ;

// This is for terms (which may be expr or pred) which MIGHT contain
// NL/SEMI.  If they do contain NL/SEMI, they must be predicates!
septerm ::=
        septerm:lhs sep:s term:rhs
        {:
           RESULT = factory_.createAndPred(pred(lhs), pred(rhs), s);
           addLocAnn(RESULT, getLocation(sleft, sright, lhs, rhs));
        :}
	|
	term:t
	{: RESULT = t; :}
	;

term ::=
        /* conditional */
        IF:i predicate:p THEN term:te ELSE term:fe
        {:
           RESULT = factory_.createCondExpr(p, expr(te), expr(fe));
           addLocAnn(RESULT, getLocation(i, fe));
        :}
        |
        /* (schema) universal quantification */
        ALL:all schemaText:st SPOT term:t
        {: 
           if (t instanceof Expr) {
             RESULT = factory_.createForallExpr(st, expr(t));
           }
           else {
             RESULT = factory_.createForallPred(st, pred(t));
           }
           addLocAnn(RESULT, getLocation(all, t));
        :}
        |
        /* (schema) existential quantification */
        EXI:exi schemaText:st SPOT term:t
        {:
           if (t instanceof Expr) {
             RESULT = factory_.createExistsExpr(st, expr(t));
           }
           else {
             RESULT = factory_.createExistsPred(st, pred(t));
           }
           addLocAnn(RESULT, getLocation(exi, t));
        :}
        |
        /* (schema) unique existential quantification */
        EXIONE:exione schemaText:st SPOT term:t
        {: 
           if (t instanceof Expr) {
             RESULT = factory_.createExists1Expr(st, expr(t));
           }
           else {
             RESULT = factory_.createExists1Pred(st, pred(t));
           }
           addLocAnn(RESULT, getLocation(exione, t));
        :}
        |
        /* function construction */
        LAMBDA:lambda schemaText:st SPOT term:t
        {:
           RESULT = factory_.createLambdaExpr(st, expr(t));
           addLocAnn(RESULT, getLocation(lambda, t));
        :} %prec LAMBDA
        |
        /* definite description */
        MU:mu schemaText:st SPOT term:t
        {:
           RESULT = factory_.createMuExpr(st, expr(t));
           addLocAnn(RESULT, getLocation(mu, t));
        :} %prec MU
        |
        /* substitution expression */
        LET:let letDefinitionList:ldl SPOT term:t 
        {: 
           ZSchText st = factory_.createZSchText(ldl, null);
           RESULT = factory_.createLetExpr(st, expr(t));
           addLocAnn(RESULT, getLocation(let, t));
        :} %prec LET
        |
        /* (schema) equivalence */
        term:lhs IFF:iff term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createIffExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createIffPred(pred(lhs), pred(rhs));
          }
          addLocAnn(RESULT, getLocation(iffleft, iffright, lhs, rhs));
        :}
        |
        /* (schema) implication */
        term:lhs IMP:imp term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createImpliesExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createImpliesPred(pred(lhs), pred(rhs));
          }
          addLocAnn(RESULT, getLocation(impleft, impright, lhs, rhs));
        :}
        |
        /* (schema) disjunction */
        term:lhs OR:or term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createOrExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createOrPred(pred(lhs), pred(rhs));
          }
          addLocAnn(RESULT, getLocation(orleft, orright, lhs, rhs));
        :}
        |
        /* (schema) conjunction */
        term:lhs AND:and term:rhs
        {:
<add:oz>
          if (isOpExpr()) {
             RESULT = factory_.createConjOpExpr(opExpr(lhs), opExpr(rhs));
          }
          else
</add:oz>
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createAndExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createAndPred(pred(lhs), pred(rhs), And.Wedge);
          }
          addLocAnn(RESULT, getLocation(andleft, andright, lhs, rhs));
        :}
        |
        /* (schema) negation */
        NOT:not term:t
        {:
          if (t instanceof Expr) {
            RESULT = factory_.createNegExpr(expr(t));
          }
          else {
            RESULT = factory_.createNegPred(pred(t));
          }
          addLocAnn(RESULT, getLocation(not, t));
        :}
        |
        /* schema composition */
        term:lhs ZCOMP:comp term:rhs
        {:
<add:oz>
           if (isOpExpr()) {
             RESULT = factory_.createSeqOpExpr(opExpr(lhs), opExpr(rhs));
           }
           else {
</add:oz>
             RESULT = factory_.createCompExpr(expr(lhs), expr(rhs));
<add:oz>
           }
</add:oz>
           addLocAnn(RESULT, getLocation(compleft, compright, lhs, rhs));
        :}
        |
        /* schema piping */
        term:lhs ZPIPE:pipe term:rhs
        {:
           RESULT = factory_.createPipeExpr(expr(lhs), expr(rhs));
           addLocAnn(RESULT, getLocation(pipeleft, piperight, lhs, rhs));
        :}
        |
        /* schema hiding */
        term:t ZHIDE:hide LPAREN refNameList:rnl RPAREN:rparen
        {:
           ZRefNameList zRefNameList = factory_.createZRefNameList(rnl);
<add:oz>
           if (isOpExpr()) {
             RESULT = factory_.createHideOpExpr(opExpr(t), zRefNameList);
           }
           else {
</add:oz>
             RESULT = factory_.createHideExpr(expr(t), zRefNameList);
<add:oz>
           }
</add:oz>
           addLocAnn(RESULT, getLocation(hideleft, hideright, t, rparen));
        :}
        |
<add:zpatt>
        /* schema hiding */
        term:t ZHIDE:hide LPAREN JOKERNAMELIST:jnl RPAREN:rparen
        {:
           ZRefName rn = factory_.createZRefName(jnl.getString(), null);
           List&lt;RefName&gt; rnl = list((RefName) rn);
           ZRefNameList zRefNameList = factory_.createZRefNameList(rnl);
           RESULT = factory_.createHideExpr(expr(t), zRefNameList);
           addLocAnn(RESULT, getLocation(hideleft, hideright, t, rparen));
        :}
        |
</add:zpatt>
        /* schema projection */
        term:lhs ZPROJ:proj term:rhs
        {:
           RESULT = factory_.createProjExpr(expr(lhs), expr(rhs));
           addLocAnn(RESULT, getLocation(projleft, projright, lhs, rhs));
        :}
        |
        /* schema precondition */
        ZPRE:pre term:t
        {:
           RESULT = factory_.createPreExpr(expr(t));
           addLocAnn(RESULT, getLocation(pre, t));
        :}
        |
        /* powerset */
        POWER:power term:t
        {:
           RESULT = factory_.createPowerExpr(expr(t));
           addLocAnn(RESULT, getLocation(power, t));
        :}
        |
        /* Cartesian product */
        prodExpressionList:pel
        {:
           RESULT = factory_.createProdExpr(pel);
           LocInfo loc =
             getLocation(pelleft, pelright, pel.get(0), pel.get(pel.size()-1));
           addLocAnn(RESULT, loc);
        :}
        |
        /* relation operator application */
        relation:rel
        {: RESULT = rel; :}
        |
        /* application of operator function */
        application:a
        {: RESULT = a; :}
        |
        /* application of non-operator function */
        func_appl:fa
        {: RESULT = fa; :}
<add:oz>
        |
        /* class union */
        term:lhs CLASSUNION:classunion term:rhs
        {:
           RESULT = factory_.createClassUnionExpr(expr(lhs), expr(rhs));
           addLocAnn(RESULT, getLocation(lhs, rhs));
        :}
        |
        /* polymorphism expression */
        POLY:poly term:t
        {:
           RESULT = factory_.createPolyExpr(expr(t));
           addLocAnn(RESULT, getLocation(poly, t));
        :}
        |
        /* object containment */
        term:t CONTAINMENT:containment
        {:
           RESULT = factory_.createContainmentExpr(expr(t));
           addLocAnn(RESULT, getLocation(t, containment));
        :}
        |
        outer_opExpr:ooe
        {: RESULT = ooe; :}
</add:oz>
        ;

func_appl ::=
        func_appl:fa inner_term:it
        {:
           RESULT = factory_.createApplExpr(expr(fa), expr(it), Boolean.FALSE);
           addLocAnn(RESULT, getLocation(fa, it));
        :} %prec _APPLICATION
        |
        inner_term:it
        {: RESULT = it; :} %prec _APPLICATION
        ;

inner_term ::=
        /* set extension */
        LBRACE:lbrace optExpressionList:oel RBRACE:rbrace
        {:
           RESULT = factory_.createSetExpr(oel);
           addLocAnn(RESULT, getLocation(lbrace, rbrace));
        :}
        |
        /* set comprehension */
        LBRACE:lbrace schemaText:st SPOT expression:e RBRACE:rbrace
        {:
           RESULT = factory_.createSetCompExpr(st, e);
           addLocAnn(RESULT, getLocation(lbrace, rbrace));
        :}
	|
        /*  characteristic set comprehension */
        LBRACE:lbrace schemaTextNoExpression:stne RBRACE:rbrace
        {:
           RESULT = factory_.createSetCompExpr(stne, null);
           addLocAnn(RESULT, getLocation(lbrace, rbrace));
        :}
	|
        /* tuple extension */
        LPAREN:lparen expressionList:el COMMA expression:e RPAREN:rparen
        {: 
           el.add(e);
           RESULT = factory_.createTupleExpr(el);
           addLocAnn(RESULT, getLocation(lparen, rparen));
        :}
        |
        /* characteristic definite description */
        LPAREN:lparen MU:mu schemaText:st RPAREN:rparen
        {:
           RESULT = factory_.createMuExpr(st, null);
           addLocAnn(RESULT, getLocation(muleft, muright, lparen, rparen));
           RESULT.getAnns().add(factory_.createParenAnn());
        :}
        |
        nofixRel:nfr
        {: RESULT = nfr; :} %prec ERP
        |
        nofixApp:nfa
        {: RESULT = nfa; :} %prec _APPLICATION
        |
        /* binding extension */
        LBIND:lbind optConstDeclList:cdl RBIND:rbind
        {:
           RESULT = factory_.createBindExpr(cdl);
           addLocAnn(RESULT, getLocation(lbind, rbind));
        :}
        |
        /* empty schema construction */
        LSQUARE:lsq RSQUARE:rsq
        {:
           DeclList dl = factory_.createZDeclList();
           SchText st = factory_.createZSchText(dl, null);
<add:oz>
           if (isOpExpr()) {
             OpText ot = factory_.createOpText(null, st);
             RESULT = factory_.createAnonOpExpr(ot);
           }
           else {
</add:oz>
             RESULT = factory_.createSchExpr(st);
<add:oz>
           }
</add:oz>
           addLocAnn(RESULT, getLocation(lsq, rsq));
        :}
        |
        /* schema construction */
        /* push 'false' onto the isOpExpr stack, because both schema
         * exprs and operations contain only expressions
         */  
        LSQUARE:lsq //<add:oz> {: pushIsOpExpr(false); :} </add:oz>
          schemaTextNoExpression:stne
          /* pop the stack now the expr has been parsed */
//          <add:oz> {: popIsOpExpr(); :} </add:oz> 
RSQUARE:rsq
        {:
<add:oz>
           if (isOpExpr()) {
             OpText ot = factory_.createOpText(null, stne);
             RESULT = factory_.createAnonOpExpr(ot);
           }
           else {
</add:oz>
           RESULT = factory_.createSchExpr(stne);
<add:oz>
           }
</add:oz>
           addLocAnn(RESULT, getLocation(lsq, rsq));
        :}
        |
        /* binding selection */
        inner_term:it DOT:dot refName:rn
        {:
<add:oz>
           if (isOpExpr()) {
             RESULT = factory_.createOpPromotionExpr(expr(it), rn);
           }
           else {
</add:oz>
             RESULT = factory_.createBindSelExpr(expr(it), rn);
<add:oz>
           }
</add:oz>
           addLocAnn(RESULT, getLocation(dotleft, dotright, it, rn));
        :}
        |
        /* tuple selection */
        inner_term:it DOT:dot NUMERAL:n
        {:
           ZNumeral numeral = factory_.createZNumeral(n.getInteger());
           addLocAnn(numeral, n.getLocation());
           RESULT = factory_.createTupleSelExpr(expr(it), numeral);
           LocInfo loc = getLocation(dotleft, dotright, it, n.getLocation());
           addLocAnn(RESULT, loc);
        :}
        |
        /* schema decoration */
        inner_term:it stroke:s
        {:
           //if the inner term is a theta expr, add the stroke to the
           //theta expr instead, which has a tighter binding.
           Object pAnn = it.getAnn(ParenAnn.class);
           if (it instanceof ThetaExpr &amp;&amp; pAnn == null) {
             ThetaExpr te = (ThetaExpr) it;
             List&lt;Stroke&gt; sl = list(te.getStroke());
             sl.add(s);
             RESULT = factory_.createThetaExpr(te.getExpr(), sl);
           }
           else {
             RESULT = factory_.createDecorExpr(expr(it), s);
           }
           addLocAnn(RESULT, getLocation(it, s));
        :}
        |
        /* binding construction */
        THETA:theta inner_term:it
        {:
           RESULT = factory_.createThetaExpr(expr(it), null);
           addLocAnn(RESULT, getLocation(theta, it));
        :}
        |
        /* function application with schema expr as argument */
        inner_term:it LSQUARE schemaTextNoExpression:st RSQUARE:rsquare
           optAppendageList:oal
        {:
           RESULT = createSchApplExpr(expr(it), st, oal);
           addLocAnn(RESULT, getLocation(it, rsquare));
        :}
        |
        /* generic instantiation */
        /* If inner_term is changed to refName
           (as in the grammar given in the Z Standard),
           rename expressions fail to parse. */
        inner_term:it LSQUARE expressionList:el RSQUARE:rsquare
        {:
           RESULT = factory_.createRefExpr(refname(it), el, Boolean.FALSE, Boolean.TRUE);
           addLocAnn(RESULT, getLocation(it, rsquare));
        :}
        |
        /* schema renaming */
        inner_term:it LSQUARE renameList:rnl RSQUARE:rsquare
        {:
<add:oz>
           if (isOpExpr()) {
             RESULT = factory_.createRenameOpExpr(opExpr(it), rnl);
           }
           else {
</add:oz>
             RESULT = factory_.createRenameExpr(expr(it), rnl);
<add:oz>
           }
</add:oz>
           addLocAnn(RESULT, getLocation(it, rsquare));
        :} %prec _RENAME
        |
        /* number literal */
        NUMERAL:n
        {:
           ZNumeral numeral = factory_.createZNumeral(n.getInteger());
           addLocAnn(numeral, n.getLocation());
           RESULT = factory_.createNumExpr(numeral);
           addLocAnn(RESULT, n.getLocation());
        :}
        |
        /* parenthesized expression/predicate */
        LPAREN:lparen septerm:t RPAREN:rparen
        {:
           ParenAnn parenAnn = factory_.createParenAnn();
           addLocAnn(parenAnn, getLocation(lparen, rparen));
           t.getAnns().add(parenAnn);
           RESULT = t;
        :}
        |
        /* reference */
        refName:rn
        {:
           RESULT = factory_.createRefExpr(rn);
           addLocAnn(RESULT, getLocation(rn));
        :}
        |
        /* truth */
        TRUE:t
        {:
           RESULT = factory_.createTruePred();
           addLocAnn(RESULT, t);
        :}
        |
        /* falsity */
        FALSE:f
        {:
           RESULT = factory_.createFalsePred();
           addLocAnn(RESULT, f);
        :}
<add:oz>
        |
        inner_opExpr:ioe
        {: RESULT = ioe; :}
</add:oz>        
<add:zpatt>
        |
        jokerRef:jr
        {:
           RESULT = jr;
           addLocAnn(RESULT, getLocation(jrleft, jrright));
        :}
</add:zpatt>
        ;

optAppendageList ::=
       appendageList:al
       {: RESULT = al; :}
       |
       //empty
       {: RESULT = list(); :}
       ;

//a list of possible constructs that come after inner_term LSQUARE
//schemaTextNoExpression RSQUARE
appendageList ::=
       appendageList:al appendage:a 
       {:
          al.add(a);
          RESULT = al;
       :}
       |
       appendage:a
       {: RESULT = list(a); :}
       ;

appendage ::=
        stroke:s
        {: RESULT = s; :}
        |        
        LSQUARE:lsq renameList:rnl RSQUARE
        {: RESULT = factory_.createRenameExpr(null, rnl); :}
        |
        DOT refName:rn
        {: RESULT = factory_.createBindSelExpr(null, rn); :}
        |
        DOT NUMERAL:n
        {:
           ZNumeral numeral = factory_.createZNumeral(n.getInteger());
           addLocAnn(numeral, n.getLocation());
           RESULT = factory_.createTupleSelExpr(null, numeral);
        :}
        ;

prodExpressionList ::=
        term:t1 CROSS term:t2
        {:
           RESULT = factory_.createZExprList();
           RESULT.add(expr(t1));
           RESULT.add(expr(t2));
        :}
        |
        prodExpressionList:pel CROSS term:t
        {:
           pel.add(expr(t));
           RESULT = pel;
        :}
        ;

optExpressionList ::=
        //empty
        {: RESULT = factory_.createZExprList(); :}
        |
        expressionList:el
        {: RESULT = el; :}
        ;

expressionList ::=
        expressionList:el COMMA expression:e
        {:      
           el.add(e);
           RESULT = el;
        :}
        |
        expression:e
        {:
           RESULT = factory_.createZExprList();
           RESULT.add(e);
        :}
        ;


optConstDeclList ::=
        //empty
        {: RESULT = factory_.createZDeclList(); :}
        |
        constDeclList:cdl
        {: RESULT = cdl; :}
        ;

constDeclList ::=
        constDeclList:cdl COMMA constDecl:cd
        {:      
           cdl.getDecl().add(cd);
           RESULT = cdl;
        :}
        |
        constDecl:cd
        {: RESULT = factory_.createZDeclList(list(cd)); :}
        ;       

letDefinitionList ::=
        letDefinitionList:ldl SEMICOLON letDefinition:ld
        {:
           ldl.getDecl().add(ld);
           RESULT = ldl;
        :}
        |
        letDefinition:ld
        {: RESULT = factory_.createZDeclList(list(ld)); :}
        ;       

letDefinition ::=
        declName:n DEFEQUAL:defequal expression:e
        {:
           RESULT = factory_.createConstDecl(n,e);
           addLocAnn(RESULT, getLocation(defequalleft, defequalright, n, e));
        :}
        ;

stroke ::=
        INSTROKE:is
        {:
           RESULT = factory_.createInStroke();
           addLocAnn(RESULT, is);
        :}
        |
        OUTSTROKE:os
        {:
           RESULT = factory_.createOutStroke();
           addLocAnn(RESULT, os);
        :}
        |
        NEXTSTROKE:ns
        {:
           RESULT = factory_.createNextStroke();
           addLocAnn(RESULT, ns);
        :}
        |
        NUMSTROKE:ns
        {:
           RESULT = factory_.createNumStroke(ns.getInteger());
           addLocAnn(RESULT, ns.getLocation());
        :}
        ;

renameList ::= 
        renameList:rnl COMMA rename:rn
        {:
           rnl.getNewOldPair().add(rn);
           RESULT = rnl;
        :}
        |
        rename:rn  
        {: RESULT = factory_.createZRenameList(list(rn)); :}
        ;    

rename ::=
        declName:lhs SLASH refName:rhs
        {:
           RESULT = factory_.createNewOldPair(lhs, rhs);
           addLocAnn(RESULT, getLocation(lhs, rhs));
        :}
        ;


//nofix relation is not included here because it has a different precedence
//than the other types of relation
relation ::=
        prefixRel:pr
        {: RESULT = pr; :}
        |
        postfixRel:pr
        {: RESULT = pr; :}
        |
        infixRel:ir
        {: RESULT = ir; :}
        ;

//according to the ISO standard, op e1 is equivalent to
//e mem op
prefixRel ::=
        PREP:p term:t
        {:
           List&lt;String&gt; opName = list(p.getString());
           opName.add(ARG_TOK);
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(t));
           RESULT = createMemPred(opName, exprs, p.getLocation());
           addLocAnn(RESULT, getLocation(p.getLocation(), t));
        :}
        |
        LP:lp expSep:es term:t1 EREP:erep term:t2
        {: 
           List&lt;String&gt; opName = list(lp.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erep.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t1));
           expList.add(expr(t2));
           LocInfo lpLoc = lp.getLocation();
           LocInfo loc = getLocation(lpLoc, erep.getLocation());
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lpLoc, t2));
        :}
        |
        LP:lp expSep:es optExpressionList:oel SREP:srep term:t
        {:
           List&lt;String&gt; opName = list(lp.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srep.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo lpLoc = lp.getLocation();
           LocInfo loc = getLocation(lpLoc, srep.getLocation());
           addLocAnn(seq, loc);
           expList.add(seq);
           expList.add(expr(t));
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lpLoc, t));
        :}
        ;

postfixRel ::=
        term:t POSTP:p
        {:
           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t));
           LocInfo pLoc = p.getLocation();
           RESULT = createMemPred(list(p.getString()), expList, pLoc);
           addLocAnn(RESULT, getLocation(t, pLoc));
        :}
        |
        term:t1 ELP:elp expSep:es term:t2 ERP:erp
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(elp.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erp.getString());

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           LocInfo erpLoc = erp.getLocation();
           LocInfo loc = getLocation(elp.getLocation(), erpLoc);
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, erpLoc));
        :}
        |
        term:t ELP:elp expSep:es optExpressionList:oel SRP:srp
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(elp.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srp.getString());

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo srpLoc = srp.getLocation();
           addLocAnn(seq, getLocation(elp.getLocation(), srpLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           LocInfo loc = getLocation(elp.getLocation(), srpLoc);
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t, srpLoc));
        :}
        ;

infixRel ::=
        infixChainRel:icr
        {: RESULT = icr; :}
        |
        term:t1 ELP:elp expSep:es term:t2 EREP:erep term:t3
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(elp.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erep.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           expList.add(expr(t3));
           LocInfo loc = getLocation(elp.getLocation(), erep.getLocation());
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, t3));
        :}
        |
        term:t1 ELP:elp expSep:es optExpressionList:oel SREP:erep term:t2
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(elp.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(erep.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, getLocation(oelleft, oelright));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           expList.add(expr(t2));
           LocInfo loc = getLocation(elp.getLocation(), erep.getLocation());
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, t2));
        :}
        ;

infixChainRel ::=
        term:lhs MEM:m term:rhs
        {:
           previousChain_ = Sym.MEM;
           RESULT =
             factory_.createMemPred(expr(lhs), expr(rhs), Boolean.FALSE);
           addLocAnn(RESULT, getLocation(mleft, mright, lhs, rhs));
        :}
        |
        term:lhs EQUALS:equals term:rhs
        {:
           previousChain_ = Sym.EQUALS;
           RESULT = factory_.createEquality(expr(lhs), expr(rhs));
           addLocAnn(RESULT, getLocation(equalsleft, equalsright, lhs, rhs));
        :}
        |
        term:lhs IP:ip term:rhs
        {:
           previousChain_ = Sym.IP;
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(ip.getString());
           opName.add(ARG_TOK);
           ZExprList expList = factory_.createZExprList();
           expList.add(expr(lhs));
           expList.add(expr(rhs));
           RESULT = createMemPred(opName, expList, ip.getLocation());
           addLocAnn(RESULT, getLocation(lhs, rhs));
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr MEM term:rhs
        {:
           RESULT =
             transformChainRel(icr, Sym.MEM, expr(rhs), getLocation(icr));
           addLocAnn(RESULT, getLocation(icr, rhs));           
           previousChain_ = Sym.MEM;
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr EQUALS term:rhs
        {:
           RESULT = transformChainRel(icr, Sym.EQUALS, expr(rhs),
                                      getLocation(icrleft, icrright));
           addLocAnn(RESULT, getLocation(icrleft, icrright));
           previousChain_ = Sym.EQUALS;
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr IP:ip term:rhs
        {:
           RESULT = transformChainRelInfix(icr, expr(rhs), ip.getString(),
                                           getLocation(icrleft, icrright));
           addLocAnn(RESULT, getLocation(icrleft, icrright));
           previousChain_ = Sym.IP;
        :}
        ;

nofixRel ::=
        LP:lp expSep:es term:t ERP:erp
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erp.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t));
           LocInfo erpLoc = erp.getLocation();
           LocInfo loc = getLocation(lp.getLocation(), erpLoc);
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lp.getLocation(), erpLoc));
        :}
        |
        LP:lp expSep:es optExpressionList:oel SRP:srp
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srp.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo srpLoc =  srp.getLocation();
           LocInfo lpLoc = lp.getLocation();
           addLocAnn(seq, getLocation(lpLoc, srpLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           LocInfo loc = getLocation(lpLoc, srpLoc);
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, loc);
        :}
        ;


//nofix application is not included here because it has a different
//precedence to the other types of application
application ::=
        prefixApp:pa
        {: RESULT = pa; :}
        |
        postfixApp:pa
        {: RESULT = pa; :}
        |
        infixApp:ia
        {: RESULT = ia; :}
        ;

prefixApp ::=
        PRE:pre term:t
        {:
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(t));
           LocInfo loc = pre.getLocation();
           RESULT =
             createMixfixExpr(list(pre.getString(), ARG_TOK), exprs, loc);
           addLocAnn(RESULT, getLocation(pre.getLocation(), t));
        :}
        |
        L:l expSep:es term:t1 ERE:ere term:t2
        {:
           List&lt;String&gt; opName = list(l.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(ere.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t1));
           expList.add(expr(t2));
           LocInfo lloc = l.getLocation();
           LocInfo loc = getLocation(lloc, ere.getLocation());
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lloc, t2));
        :}
        |
        L:l expSep:es optExpressionList:oel SRE:sre term:t
        {:
           List&lt;String&gt; opName = list(l.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sre.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo sreLoc = sre.getLocation();
           LocInfo lLoc = l.getLocation();
           addLocAnn(seq, getLocation(lLoc, sreLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           expList.add(expr(t));
           LocInfo loc = getLocation(lLoc, sreLoc);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lLoc, t));
        :}
        ;

postfixApp ::=
        term:t POST:post
        {:
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(t));
           LocInfo loc = post.getLocation();
           RESULT =
             createMixfixExpr(list(ARG_TOK, post.getString()), exprs, loc);
           addLocAnn(RESULT, getLocation(t, post.getLocation()));
        :}
        |
        term:t1 EL:el expSep:es term:t2 ER:er
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(el.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(er.getString());

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           LocInfo erLoc = er.getLocation();
           LocInfo elLoc = el.getLocation();
           LocInfo loc = getLocation(elLoc, erLoc);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, erLoc));
        :}
        |
        term:t EL:el expSep:es optExpressionList:oel SR:sr
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(el.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sr.getString());

           LocInfo srLoc = sr.getLocation();
           LocInfo elLoc = el.getLocation();
           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, getLocation(el.getLocation(), srLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           LocInfo loc = getLocation(elLoc, srLoc);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t, srLoc));
        :}
        ;

infixApp ::=
        term:lhs I:i term:rhs
        {: 
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(i.getString());
           opName.add(ARG_TOK);
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(lhs));
           exprs.add(expr(rhs));
           RESULT = createMixfixExpr(opName, exprs, i.getLocation());
           addLocAnn(RESULT, getLocation(ileft, iright, lhs, rhs));
        :}
        |
        term:t1 EL:el expSep:es term:t2 ERE:ere term:t3
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(el.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(ere.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           expList.add(expr(t3));
           LocInfo loc = getLocation(el.getLocation(), ere.getLocation());
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, t3));
        :}
        |
        term:t1 EL:el expSep:es optExpressionList:oel SRE:sre term:t2
        {:
           List&lt;String&gt; opName = list(ARG_TOK);
           opName.add(el.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sre.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo sreLoc = sre.getLocation();
           addLocAnn(seq, getLocation(el.getLocation(), sreLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           expList.add(expr(t2));
           LocInfo loc = getLocation(el.getLocation(), sreLoc);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(elleft, elright, t1, t2));
        :}
        ;

nofixApp ::=
        L:l expSep:es term:t ER:er
        {:
           List&lt;String&gt; opName = list(l.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(er.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t));
           LocInfo loc = getLocation(l.getLocation(), er.getLocation());
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, loc);
        :}
        |
        L:l expSep:es optExpressionList:oel SR:sr
        {:
           List&lt;String&gt; opName = list(l.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sr.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo loc = getLocation(l.getLocation(), sr.getLocation());
           addLocAnn(seq, loc);
           expList.add(seq);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, loc);
        :}
        ;

expSep ::=
        //empty
        {: RESULT = list(); :} %prec I
        |
        expSep:exs term:t ES:es
        {:
           exs.add(list(expr(t)));
           exs.add(es.getString());
           RESULT = exs;
        :}
        |
        expSep:exs expressionList:exprList SS:ss
        {:
           exs.add(exprList);
           exs.add(ss.getString());
           RESULT = exs;
        :}
        ;

optNL ::=
        //empty
        |
        NL
        ;

<add:zpatt>
/// Z pattern constructs ///////////////////////////////////////////////
jokerPara ::=
        JOKER:j DECORWORD:dw jokerList:jl END:end
        {:
           JokerType type = JokerType.Expr;
           try {
             type = JokerType.fromString(dw.getName());
           }
           catch (IllegalArgumentException e) {
             parser.report_error(ZpattParseMessage.MSG_UNKNOWN_JOKER_TYPE,
                          new Object[] { dw },
                          getLocation(dwleft, dwright));
           }
           RESULT = factory_.createJokers(jl, type);
           addLocAnn(RESULT, getLocation(j, end));
           try {
             jokerTable_.add(RESULT);
           }
           catch (JokerTable.JokerException e) {
             parser.report_error(ZpattParseMessage.MSG_CANNOT_ADD_JOKER,
                                 new Object[0],
                                 getLocation(jleft, jright));
           }
        :}
        ;

rulePara ::=
        RULE:r DECORWORD:dw antecedents:a RULELINE conclusion:c END:end
        {:
           List&lt;Sequent&gt; sequents = list((Sequent) c);
           sequents.addAll(a);
           RESULT = factory_.createRule(sequents, dw.getName());
           addLocAnn(RESULT, getLocation(r, end));
        :}
        |
        RULE:r DECORWORD:dw conclusion:c END:end
        {:
           List&lt;Sequent&gt; sequents = list((Sequent) c);
           RESULT = factory_.createRule(sequents, dw.getName());
           addLocAnn(RESULT, getLocation(r, end));
        :}
        ;

jokerList ::=
       jokerList:jl COMMA DECORWORD:dw
       {:
          jl.add(dw.getName());
          RESULT = jl;
       :}
       |
       DECORWORD:dw
       {: RESULT = list(dw.getName()); :}
       ;

antecedents ::=
        antecedents:a NL sequent:s
        {:
           a.add(s);
           RESULT = a;
        :}
        |
        sequent:s
        {:
           RESULT = list(s);
        :}
        ;

conclusion ::=
        term:t
        {:
           //czt.todo: What is the context?
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createPredSequent(sc, pred(t), null);
           addLocAnn(RESULT, getLocation(t));
        :}
        ;

sequent ::=
        provisoSequent:ps
        {: RESULT = ps; :}
        |
        predSequent:ps
        {: RESULT = ps; :}
        ;

provisoSequent ::=
        sequentLHS:slhs VDASH PROVISO proviso:p
        {: RESULT = p; :}
        |
        PROVISO proviso:p
        {: RESULT = p; :}
        ;

proviso ::=
        expression:e1 DEFEQUAL:de expression:e2
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createCalculateProviso(sc, e1, e2);
           addLocAnn(RESULT, getLocation(deleft, deright, e1, e2));
        :}
        |
        term:t COLON baseType:bt
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createTypeProviso(sc, expr(t), bt);
           addLocAnn(RESULT, getLocation(t, bt));
        :}
        |
        term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createCheckProviso(sc, pred(t));
           addLocAnn(RESULT, getLocation(t));
        :}
        |
        lookupProviso:lp
        {: RESULT = lp; :}
        ;

lookupProviso ::=
        INSTROKE:is expression:e1 DEFEQUAL expression:e2
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createLookupConstDeclProviso(sc, expr(e1), expr(e2));
           addLocAnn(RESULT, getLocation(is, e2));
        :}
        |
        INSTROKE:is term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createLookupPredProviso(sc, pred(t));
           addLocAnn(RESULT, getLocation(is, t));
        :}        
        ;

predSequent ::=
        sequentLHS:slhs VDASH term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createPredSequent(sc , pred(t), null);
           addLocAnn(RESULT, getLocation(slhs.get(0), t));
        :}
        |
        term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createPredSequent(sc, pred(t), null);
           addLocAnn(RESULT, getLocation(t));
        :}
        ;

sequentLHS ::=
        sequentLHS:slhs COMMA antecedent:a
        {:
           slhs.add(a);
           RESULT = slhs;
        :}
        |
        antecedent:a
        {:
           RESULT = list(a);
        :}
        ;

antecedent ::=
        term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createPredSequent(sc, pred(t), null);
           addLocAnn(RESULT, getLocation(t));
        :}
        |
        expression:e COLON baseType:bt
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createTypeProviso(sc, e, bt);
           addLocAnn(RESULT, getLocation(e, bt));
        :}
        ;

baseType ::=
        refName:rn /* given type or generic parameter type */
        {:
           RESULT = factory_.createRefExpr(rn);
           addLocAnn(RESULT, getLocation(rn));
        :}
        |
        POWER:p baseType:bt /* powerset type */
        {:
           RESULT = factory_.createPowerExpr(bt);
           addLocAnn(RESULT, getLocation(p, bt));
        :}
        |
        baseType:lbt CROSS baseType:rbt /* Cartesian product type */
        {:
           if (lbt instanceof ProdExpr) {
             ProdExpr pt = (ProdExpr) lbt;
             pt.getZExprList().add(rbt);
           }
           else {
             ZExprList zExprList = factory_.createZExprList();
             zExprList.add(lbt);
             zExprList.add(rbt);
             RESULT = factory_.createProdExpr(zExprList);
           }
           addLocAnn(RESULT, getLocation(lbt, rbt));
        :}
        |
        LSQUARE:lsq signature:s RSQUARE:rsq /* schema type */
        {:
           ZSchText st = factory_.createZSchText(s, null);
           RESULT = factory_.createSchExpr(st);
           addLocAnn(RESULT, getLocation(lsq, rsq));
        :}
        |
        LPAREN:lp baseType:bt RPAREN /* parenthesized type */
        {:
           RESULT = bt;
           // It would be nice to add this, but multiple LocAnns are
           // not allowed.
           // addLocAnn(RESULT, lpleft, right);
        :}
        |
        JOKEREXPR:je /* joker type */
        {:
           RESULT = factory_.createJokerExpr(je.getString());
           addLocAnn(RESULT, je.getLocation());
        :}
        ;

signature ::=
        varDeclList:vdl
        {: RESULT = vdl; :}
        |
        varJokerDeclList:jdl
        {: RESULT = jdl; :}
        ;

varDeclList ::=
        varDeclList:vdl SEMICOLON declName:dn COLON baseType:bt
        {:
           VarDecl vd = factory_.createVarDecl(list(dn), bt);
           vdl.getDecl().add(vd);
           RESULT = vdl;
        :}
        |
        declName:dn COLON baseType:bt
        {:
           VarDecl vd = factory_.createVarDecl(list(dn), bt);
           addLocAnn(vd, getLocation(dn, bt));
           RESULT = factory_.createZDeclList(list(vd));
        :}
        ;

varJokerDeclList ::=
        varDeclList:vdl SEMICOLON JOKERDECLLIST:jdl
        {:
           RESULT = factory_.createHeadDeclList(vdl,
             factory_.createJokerDeclList(jdl.getString()));
        :}
        |
        JOKERDECLLIST:jdl
        {:
           RESULT = factory_.createJokerDeclList(jdl.getString());
           addLocAnn(RESULT, jdl.getLocation());
        :}        
        ;

jokerRef ::=
        JOKEREXPR:je
        {:
           RESULT = factory_.createJokerExpr(je.getString());
           addLocAnn(RESULT, je.getLocation());
        :}
        |
        JOKERPRED:jp
        {:
           RESULT = factory_.createJokerPred(jp.getString());
           addLocAnn(RESULT, jp.getLocation());
        :}
        |
        JOKERNAME:jn
        {:
           final LocInfo loc = jn.getLocation();
           RefName rn = factory_.createJokerRefName(jn.getString());
           addLocAnn(rn, loc);
           RESULT = factory_.createRefExpr(rn);
           addLocAnn(RESULT, loc);
        :}
        ;

</add:zpatt>

<add:oz>
/// Object-Z constructs ///////////////////////////////////////////////
class ::=
        classHeader:ch optNL
            visibilityList:vl
            inheritedList:il
            innerParaList:ipl
            operationList:ol
        END:end
        {:
           //local definitions, states, and initial states are all
           //parsed as innerPara, because upon a LSQUARE of a 
           //horizontal state schema, javacup will shift to
           //a basicTypeDefinition
           State s = null;
           InitialState is = null;
           for (Iterator iter = ipl.iterator(); iter.hasNext(); ) {
             Object next = iter.next();
             if (next instanceof State) {
               if (s != null) {
                 parser.report_error(ZParseMessage.MSG_DUPLICATE_STATE,
                                     new Object[] { next },
                                     getLocation(chleft, chright));
               }
               s = (State) next;
               iter.remove();
             }
             else if (next instanceof InitialState) {
               if (is != null) {
                 parser.report_error(ZParseMessage.MSG_DUPLICATE_INIT,
                                     new Object[] { next },
                                     getLocation(chleft, chright));
               }
               is = (InitialState) next;
               iter.remove();
             }
           }
           DeclName dn = ch.getFirst();
           List&lt;DeclName&gt; ofp = ch.getSecond();
           RESULT = factory_.createClassPara(dn, ofp, vl, il, ipl, s, is, ol);
           addLocAnn(RESULT, getLocation(ch.getFirst(), end));
           assert isOpExpr() == false;
        :}
        ;

classHeader ::=
        CLASS name:n
        {:
           List&lt;DeclName&gt; decls = list();
           RESULT = pair(n, decls);
        :}
        |
        GENCLASS name:n formalParameters:fp
        {: RESULT = pair(n, fp); :}
        ;

operationList ::=
        //empty
        {: RESULT = list(); :}
        |
        operationList:ol optNL operation:o
        {: 
           ol.add(o); 
           RESULT = ol;
        :}
        ;

/// class paragraphs ///////////////////////////////////////////////

visibilityList ::=
        //no list
        {: RESULT = null; :}
        |
        ZPROJ LPAREN RPAREN optNL //an empty list
        {: RESULT = factory_.createVisibilityList(); :}
        |
        ZPROJ LPAREN refNameList:rnl RPAREN optNL
        {: RESULT = factory_.createVisibilityList(rnl); :}
        ;

inheritedList ::=
        //empty
        {:
           RESULT = factory_.createZExprList();
        :}
        |
        inheritedClassList:icl optNL 
        {: RESULT = factory_.createZExprList(icl); :}
        ;

inheritedClassList ::=
        inheritedClassList:icl NL inheritedClass:ic
        {:
           icl.add(0, ic);
           RESULT = icl;
        :}
        |
        inheritedClass:ic 
        {: RESULT = list(ic); :}
        ;

inheritedClass ::=
        DECORWORD:dw
        {:
           checkName(dw);
           ZRefName rn = factory_.createZRefName(dw.getName());
           addLocAnn(rn, dw.getLocation());
           RESULT = factory_.createRefExpr(rn);
           addLocAnn(RESULT, dw.getLocation());
        :}
        |
        inheritedClass:ic LSQUARE expressionList:el RSQUARE:rsq
        {:
           RefName rn = refname(ic);
           addLocAnn(rn, getLocation(icleft, icright));
           RESULT =
             factory_.createRefExpr(rn, el, Boolean.FALSE, Boolean.TRUE);
           addLocAnn(RESULT, getLocation(ic, rsq));
        :}
        |
        inheritedClass:ic LSQUARE renameList:rnl RSQUARE:rsq
        {:
           RESULT = factory_.createRenameExpr(ic, rnl);
           addLocAnn(RESULT, getLocation(ic, rsq));
        :} %prec _RENAME
        ;

innerParaList ::=
        innerPara:ip optNL innerParaList:ipl
        {:
           ipl.add(0, ip);
           RESULT = ipl;
        :}
        |
        //empty
        {: RESULT = list(); :}
        ;

innerPara ::=
        axiomaticDefinition:ad
        {: RESULT = ad; :}
        |
        genericAxDefinition:gad
        {: RESULT = gad; :}
        |
        schema:s
        {: RESULT = s; :}
        |
        basicTypeDefinition:gtd
        {: RESULT = gtd; :}
        |
        freeTypeList:ftl
        {: RESULT = factory_.createFreePara(ftl); :}
        |
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        |
        state:s
        {: RESULT = s; :}
        |
        initialState:is
        {: RESULT = is; :}
        ;

state ::=
        STATE:s stateDecl:sd BAR predicate:p END:end
        {:
           PrimaryDecl pd = sd.getFirst();
           SecondaryDecl scd = sd.getSecond();
           RESULT = factory_.createState(pd, scd, p, Box.SchBox);
           addLocAnn(RESULT, getLocation(s, end));
        :}
        |
        STATE:s stateDecl:sd END:end
        {:
           PrimaryDecl pd = sd.getFirst();
           SecondaryDecl scd = sd.getSecond();
           RESULT = factory_.createState(pd, scd, null, Box.SchBox);
           addLocAnn(RESULT, getLocation(s, end));
        :}
        |
        LSQUARE:lsq stateDecl:sd BAR predicate:p RSQUARE:rsq
        {:
           PrimaryDecl pd = sd.getFirst();
           SecondaryDecl scd = sd.getSecond();
           RESULT = factory_.createState(pd, scd, p, Box.OmitBox);
           addLocAnn(RESULT, getLocation(lsq, rsq));
        :}
        |
        LSQUARE:lsq stateDeclNoExpression:sdne RSQUARE:rsq
        {:
           PrimaryDecl pd = sdne.getFirst();
           SecondaryDecl scd = sdne.getSecond();
           RESULT = factory_.createState(pd, scd, null, Box.OmitBox);
           addLocAnn(RESULT, getLocation(rsq, rsq));
        :}
        ;

//return a pair containing the primary and secondary decls
stateDecl ::=
        optPrimaryDeclPart:opdp
        {: RESULT = statePair(opdp, null); :}
        |
        secondaryDeclPart:sdp
        {: RESULT = statePair(null, sdp); :}
        |
        primaryDeclPart:pdp sep secondaryDeclPart:sdp
        {: RESULT = statePair(pdp, sdp); :}
        ;

stateDeclNoExpression ::=
        //empty
        {: RESULT = statePair(null, null); :} 
        |
        secondaryDeclPart:sdp
        {: RESULT = statePair(null, sdp); :}
        |
        primaryDeclPart:pdp sep declaration:d
        {: RESULT = statePair(pdp, null); :}
        |
        basicDeclaration:bd
        {:
           ZDeclList zdl = factory_.createZDeclList(list(bd));
           RESULT = statePair(zdl, null);
        :}
        |        
        primaryDeclPart:pdp sep secondaryDeclPart:sdp
        {: RESULT = statePair(pdp, sdp); :}
        ;

optPrimaryDeclPart ::=
        //empty
        {: RESULT = factory_.createZDeclList(); :}
        |
        primaryDeclPart:pdp
        {: RESULT = pdp; :}
        ;

primaryDeclPart ::=
        declaration:d
        {:
           RESULT = factory_.createZDeclList(list(d));
           addLocAnn(RESULT, getLocation(dleft, dright));
        :}
<add:tcoz>
        |
        channelDeclaration:cd
        {:
           RESULT = factory_.createZDeclList(list(cd));
           addLocAnn(RESULT, getLocation(cdleft, cdright));
        :}
</add:tcoz>
        |
        primaryDeclPart:pdp sep declaration:d
        {:
           pdp.getDecl().add(d);
           RESULT = pdp;
        :}
<add:tcoz>
        |
        primaryDeclPart:pdp sep channelDeclaration:cd
        {:
           pdp.getDecl().add(cd);
           RESULT = pdp;
        :}
</add:tcoz>
        ;

<add:tcoz>
channelDeclaration ::=
        declWordList:dwl COLON:colon channel:ch
        {:
           RESULT = factory_.createVarDecl(dwl, ch);
           addLocAnn(RESULT, getLocation(colonleft, colonright));
        :}
        ;        

channel ::=
        CHAN:c
        {:
           RESULT = factory_.createChannelExpr();
           addLocAnn(RESULT, c);
        :}
        |
        term:t SENSOR:sensor
        {:
           RESULT = factory_.createSensorExpr(expr(t));
           addLocAnn(RESULT, getLocation(t, sensor));
        :}
        |
        term:t ACTUATOR:actuator
        {:
           RESULT = factory_.createActuatorExpr(expr(t));
           addLocAnn(RESULT, getLocation(t, actuator));
        :}
        ;
</add:tcoz>

secondaryDeclPart ::=
        DELTA sep declPart:dp
        {: RESULT = dp; :}
        ;

initialState ::=
        INIT:i predicate:p END:end
        {:
           RESULT = factory_.createInitialState(p, Box.SchBox);
           addLocAnn(RESULT, getLocation(i, end));
        :}
        |
        INITWORD:iw SDEF LSQUARE predicate:p RSQUARE:rsquare
        {:
           RESULT = factory_.createInitialState(p, Box.OmitBox);
           addLocAnn(RESULT, getLocation(iw, rsquare));
        :}
        ;

operation ::=
        OPSCH:osch name:n optNL opText:ot END:end
        {:
           OpExpr opExpr = factory_.createAnonOpExpr(ot);
           RESULT = factory_.createOperation(n, opExpr, Box.SchBox);
           addLocAnn(RESULT, getLocation(osch, end));
        :}
        |
        /* push true onto the stack now that this is an op expr */
        OPNAME:on /*{: pushIsOpExpr(true); :}*/ SDEF opExpr:oe
        {:
           //the op expr has finished parsing, so pop the stack.
           popIsOpExpr();
           ZDeclName dn = factory_.createZDeclName(on.getName());
           addLocAnn(dn, on.getLocation());
           RESULT = factory_.createOperation(dn, oe, Box.OmitBox);
           addLocAnn(RESULT, getLocation(on.getLocation(), oe));
        :}
        ;

opText ::=
        opTextWithDelta:otwd
        {: RESULT = otwd; :}
        |
        optDeclPart:dp BAR predicate:p
        {: RESULT = createOpText(null, dp, p); :}
        |
        optDeclPart:dp
        {: RESULT = createOpText(null, dp, null); :}
        ;

opTextWithDelta ::=
        deltaList:dl sep:s declPart:dp BAR predicate:p
        {: RESULT = createOpText(dl, dp, p); :}
        |
        deltaList:dl sep:s declPart:dp
        {: RESULT = createOpText(dl, dp, null); :}
        |
        deltaList:dl BAR predicate:p
        {: RESULT = createOpText(dl, null, p); :}
        |
        deltaList:dl
        {: RESULT = createOpText(dl, null, null); :}
        ;     

opExpr ::=
        //all operation expressions that have a syntactic
        //counterpart Z expression.
        term:t
        {: RESULT = opExpr(t); :}
        ;

//operations that do not have a syntactic counterpart Z
//expression. We push false onto the isOpExpr stack because we parse
//the schemaText, but count the @ as a SPOT token to remove an ambiguity
outer_opExpr ::=
        DCNJ:dcnj {: pushIsOpExpr(false); :} schemaText:st
             SPOT {: pushIsOpExpr(true); :} term:t
        {:
           RESULT = factory_.createDistConjOpExpr(st, opExpr(t));
           addLocAnn(RESULT, getLocation(dcnj, t));
        :}
        |
        DGCH:dgch {: pushIsOpExpr(false); :} schemaText:st
             SPOT {: pushIsOpExpr(true); :} term:t
        {:
           RESULT = factory_.createDistChoiceOpExpr(st, opExpr(t));
           addLocAnn(RESULT, getLocation(dgch, t));
        :}
        |
        /* We need a unicode character for this. */
        /*DSQC*/ ZCOMP:dsqc {: pushIsOpExpr(false); :} schemaText:st
             SPOT {: pushIsOpExpr(true); :} term:t
        {:
           RESULT = factory_.createDistSeqOpExpr(st, opExpr(t));
           addLocAnn(RESULT, getLocation(dsqc, t));
        :}
<add:tcoz>
        |
        DIC:dic {: pushIsOpExpr(false); :} schemaText:st 
           SPOT {: pushIsOpExpr(true); :} term:t
        {:
           RESULT = factory_.createDistInChoiceProExpr(st, opExpr(t));
           addLocAnn(RESULT, getLocation(dic, t));
        :}
        |
        DIL:dil {: pushIsOpExpr(false); :} schemaText:st
           SPOT {: pushIsOpExpr(true); :} term:t
        {:
           RESULT = factory_.createDistInterleaveProExpr(st, opExpr(t));
           addLocAnn(RESULT, getLocation(dil, t));
        :}
        |
        PARALLEL:dpara LPAREN topology:nt RPAREN:rparen
        {:
           RESULT = factory_.createTopologyProExpr(nt);
           addLocAnn(RESULT, getLocation(dpara, rparen));
        :}
</add:tcoz>
        ;

inner_opExpr ::=
        /* a horizontal operation expression with a delta list */
        LSQUARE opTextWithDelta:ot RSQUARE
        {: RESULT = factory_.createAnonOpExpr(ot); :}  
        |
        /*  a horizontal operation expression with just a predicate */
        LSQUARE:l term:t RSQUARE:r
        {:
           ZDeclList dl = factory_.createZDeclList();
           OpText ot = createOpText(null, dl, pred(t));
           RESULT = factory_.createAnonOpExpr(ot);
           addLocAnn(RESULT, getLocation(l, r));
        :}
        |
        /* parallel conjuntion */
        inner_term:lhs PARALLEL:p inner_term:rhs
        {:
           RESULT = 
             factory_.createParallelOpExpr(opExpr(lhs), opExpr(rhs));
           addLocAnn(RESULT, getLocation(pleft, pright, lhs, rhs));
        :}    
        |
        /* associative parallel conjunction */
        inner_term:lhs ASSOPARALLEL:ap inner_term:rhs
        {:
           RESULT = 
             factory_.createAssoParallelOpExpr(opExpr(lhs), opExpr(rhs));
           addLocAnn(RESULT, getLocation(apleft, apright, lhs, rhs));
        :}
        |
        /* angelic choice */
        inner_term:lhs GCH:gch inner_term:rhs
        {:
           RESULT =
             factory_.createExChoiceOpExpr(opExpr(lhs), opExpr(rhs));
           addLocAnn(RESULT, getLocation(gchleft, gchright, lhs, rhs));
        :}
        |
        /* scope enrichment */
        inner_term:lhs SCOPE:s inner_term:rhs
        {:
           RESULT =
             factory_.createScopeEnrichOpExpr(opExpr(lhs), opExpr(rhs));
           addLocAnn(RESULT, getLocation(sleft, sright, lhs, rhs));
        :}
/*
<add:tcoz>
        |
        inner_term:lhs INTCHOICE inner_term:rhs
        {:
           RESULT = factory_.createInChoiceProExpr(opExpr(lhs), opExpr(rhs));
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        inner_term:lhs INTERLEAVE inner_term:rhs
        {:
           RESULT = factory_.createInterleaveProExpr(opExpr(lhs), opExpr(rhs));
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
 //ambiguity here with opExpr || [opText], where opText has inclDecl
 //although this renders as opExpr |[ eventSet |] opExpr
 //Needs to be taken care of in the scanner - this could prove difficult
        inner_term:lhs PARALLEL LSQUARE eventSet:ets RSQUARE inner_term:rhs
        {:
           EventSet es = factory_.createEventSet(ets);
           RESULT = factory_.createSynPllProExpr(lhs, rhs, es);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
*/
/*
        inner_term:lhs TIMEOUT LSQUARE expression:e RSQUARE inner_term:rhs
        {:
           RESULT =
             factory_.createTimeoutStartProExpr(opExpr(lhs), e, opExpr(rhs));
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        inner_term:lhs TIMEEND LBRACE expression:e RBRACE inner_term:rhs
        {:
           RESULT =
             factory_.createTimeoutEndProExpr(opExpr(lhs), e, opExpr(rhs));
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        inner_term:lhs INTERRUPT LBRACE expression:e RBRACE inner_term:rhs
        {:
           RESULT =
            factory_.createInterruptProExpr(opExpr(lhs), e, opExpr(rhs));
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        inner_term:t SCOPE DEADLINE expression:e
        {:
           RESULT = factory_.createDeadlineProExpr(opExpr(t), e);
           addLocAnn(RESULT, tleft, tright);
        :}
        |
        inner_term:t SCOPE WAITUNTIL expression:e
        {:
           RESULT = factory_.createWaitUntilProExpr(opExpr(t), e);
           addLocAnn(RESULT, tleft, tright);
         :}
        |
        WAIT:wait expression:e
        {:
           RESULT = factory_.createWaitProExpr(e);
           addLocAnn(RESULT, waitleft, waitright);
        :}
        |
        inOutEvent:et NEXTPRO inner_term:t
        {:
           RESULT = factory_.createAtProExpr(et, null, opExpr(t));
           addLocAnn(RESULT, etleft, etright);
        :}
        |
*/
/*
        inner_inner_term:it NEXTPRO inner_opExpr:t
        {:
           Event et = factory_.createEvent(refname(oplhs), expr(it));
           RESULT = factory_.createAtProExpr(et, null, oe);
           addLocAnn(RESULT, oplhsleft, oplhsright);
        :}
        |
*/
/*
        refName:rn NEXTPRO inner_term:t
        {:
           Event et = factory_.createEvent(rn, null);
           RESULT = factory_.createAtProExpr(et, null, opExpr(t));
           addLocAnn(RESULT, rnleft, rnright);
        :}
        |
        inOutEvent:et ATTIME expression:e NEXTPRO inner_term:t
        {:
           RESULT = factory_.createAtProExpr(et, e, opExpr(t));
           addLocAnn(RESULT, etleft, etright);
        :}
        |
        opPromotionLhs:oplhs DOT inner_term:it 
           ATTIME expression:e NEXTPRO inner_term:t
        {:
           Event et = factory_.createEvent(refname(oplhs), expr(it));
           RESULT = factory_.createAtProExpr(et, e, oe);
           addLocAnn(RESULT, oplhsleft, oplhsright);
        :}
        |
        refName:rn ATTIME expression:e NEXTPRO inner_term:t
        {:
           Event et = factory_.createEvent(rn, null);
           RESULT = factory_.createAtProExpr(et, e, opExpr(t));
           addLocAnn(RESULT, rnleft, rnright);
        :}
        |
        MU:mu refName:rn SCOPE inner_term:t
        {:
           RESULT = factory_.createRecProExpr(rn, opExpr(t));
           addLocAnn(RESULT, muleft, muright);
        :}
</add:tcoz>
*/
        ;

<add:tcoz>
topology ::=
        topology:tp SEMICOLON connection:cn
        {:
           tp.add(cn);
           RESULT = tp; 
        :}
        |
        connection:cn
        {: RESULT = list(cn); :}
        ;
                 
connection ::=
        refNameList:lrnl NETTOPLEFT refNameList:crnl
           NETTOPRIGHT refNameList:rrnl
        {:
           RESULT = factory_.createConnection(lrnl, rrnl, crnl);
           addLocAnn(RESULT, getLocation(lrnlleft, lrnlright));
        :}
        ;
                   
eventSet ::=
        eventSet:el COMMA event:e
        {: 
           el.add(e);
           RESULT = el;
        :}
        |
        event:e
        {: RESULT = list(e); :}
        ;

event ::=
        inOutEvent:ioet
        {: RESULT = ioet; :}
        |
        refName:rn DOT inner_term:it
        {:
           RESULT = factory_.createEvent(rn, expr(it));
           addLocAnn(RESULT, getLocation(rn, it));
        :}
        |
        refName:rn
        {:
           RESULT = factory_.createEvent(rn, null);
           addLocAnn(RESULT, getLocation(rn));
        :}
        ;

inOutEvent ::=
        refName:rn INSTROKE inner_term:it
        {:
           rn.getStroke().add(factory_.createInStroke());
           RESULT = factory_.createEvent(rn, expr(it));
           addLocAnn(RESULT, getLocation(rn, it));
        :}
        |
        refName:rn OUTSTROKE inner_term:it
        {:
           rn.getStroke().add(factory_.createOutStroke());
           RESULT = factory_.createEvent(rn, expr(it));
           addLocAnn(RESULT, getLocation(rn, it));
        :}
        ;            
</add:tcoz>

deltaList ::=
        DELTA:d LPAREN refNameList:rnl RPAREN:rparen
        {:
           RESULT = factory_.createDeltaList(rnl);
           addLocAnn(RESULT, getLocation(d, rparen));
        :}
        |
        DELTA:d LPAREN RPAREN:lparen
        {:
           List&lt;RefName&gt; refNameList = list();
           RESULT = factory_.createDeltaList(refNameList);
           addLocAnn(RESULT, getLocation(d, lparen));
        :}
        ;
</add:oz>
</parser>
