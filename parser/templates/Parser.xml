<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright 2003 Tim Miller
     This file is part of the CZT project.

     The CZT project contains free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with CZT; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<parser xmlns:add="http://czt.sourceforge.net/templates/additional">
package <package/>;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Logger;
import java.io.*;

import java_cup.runtime.*;

import net.sourceforge.czt.base.ast.*;
<add:oz>
import net.sourceforge.czt.oz.util.OzString;
import net.sourceforge.czt.oz.ast.*;
import net.sourceforge.czt.oz.impl.OzFactoryImpl;
</add:oz>
import net.sourceforge.czt.parser.util.*;
import net.sourceforge.czt.util.CztException;
import net.sourceforge.czt.util.CztLogger;
import net.sourceforge.czt.util.ParseException;
import net.sourceforge.czt.z.ast.*;
<add:z>
import net.sourceforge.czt.z.impl.ZFactoryImpl;
</add:z>
import net.sourceforge.czt.z.util.ZString;
import net.sourceforge.czt.session.SectionManager;

action code
{:
    /** The name of the prelude */
    public final static String PRELUDE = "prelude";

    /** The name of the mathematical toolkit */
    public final static String TOOLKIT = "standard_toolkit";

    /** The symbols used to replace arguments for names in ApplExpr etc. */
    public final static String ARG_TOK = " _ ";
    public final static String LISTARG_TOK = " _ ";
    public final static String SPACE = " ";

    /** The two types of name */
    protected final static int DECLNAME = 1;
    protected final static int REFNAME = DECLNAME + 1;
<add:z>
    /** The factory for creating AST objects. */
    protected ZFactory factory_ = new ZFactoryImpl();
</add:z>
<add:oz>
    /** The factory for creating AST objects. */
    protected OzFactory factory_ = new OzFactoryImpl();
</add:oz>
    /** The table of operators. */
    protected OperatorTable table_;

    /** The name of file currently being parsed */
    protected String file_ = null;

    /** The previous symbol returned by the scanner */
    protected Symbol previous_;

    /** A list of parsed sections */
    protected List parsedSections_ = list();

    /** The "fix" of the current operator being parsed. */
    protected int fix_ = -1;

    /** The type of the previous chain relation e.g. MEM, EQUALS, IP */
    protected int previousChain_ = -1;

    /** The section manager */
    protected SectionManager manager_;

    /**
     * Create an empty list
     */
    protected List list()
    {
      return new ArrayList();
    }

    /**
     * Create a list containing one element
     */
    protected List list(Object o)
    {
      List result = new ArrayList();
      result.add(o);
      return result;
    }

    /**
     * Create a list containing two elements
     */
    protected List list(Object o1, Object o2)
    {
      List result = new ArrayList();
      result.add(o1);
      result.add(o2);
      return result;
    }

    protected void parseParent(String parent)
      throws Exception
    {
      //only parse the parent if it has not already been
      if (!table_.isParsed(parent)) {
        try {
          Reader reader = new InputStreamReader(getClass().getResource("/lib/" + parent + ".tex").openStream());
          LatexParser parser = new LatexParser(reader, table_, parent + ".tex", manager_);
          parser.parse();
          return;
        }
        catch (Exception e) {
        String [] locations = getLocations();
        String [] extensions = new String [] {"tex", "utf8", "utf16"};

        //for each combinations of possible file locations and
        //extensions, try to parse a file of that type       
        for (int i = 0; i &lt; locations.length; i++) {
          String nextLocation = locations[i];

          for (int j = 0; j &lt; extensions.length; j++) {
            String nextExtension = extensions[j];

            //construct the file
            File file =
              new File(nextLocation, parent + "." + nextExtension);

            //if the file exists, parse it an return
            if (file.exists()) {
              ParseUtils.parse(file.getAbsolutePath(), table_, manager_);
              return;
            }
          }
        }
        }

        //if we get to here, the file has not been found
        String message = "Try setting the system property " +
          "czt.lib to point to the path of " + parent + "\n";
        throw new ParentNotFoundException(parent, message);
      }
    }
 
    //this is implemented as a method in case we decide in the future
    //that the library path may contain more than one path
    protected String [] getLocations()
    {

      String currentDir = null;
      if (file_ != null) {
        currentDir = (new File(file_)).getParent();
      }

      String libPath = Settings.getCztLib();

      List list = list();
      if (currentDir != null) {
        list.add(currentDir);
      }
      list.add(libPath);

      String [] result = new String [list.size()];
      for (int i = 0; i &lt; list.size(); i++) {
        result[i] = (String) list.get(i);
      }
      return result;
    }

    /**
     * Create a Name from a string, extracting out the
     * appropriate decoration tokens, and return a DeclName
     * or RefName as specified
     */
    protected Name localCreateName(String name, int type)
    {
      Name result = null;

      DeclName dn = Strokes.getWordAndStroke(name);

      if (type == DECLNAME) {
        result = dn;
      }
      else {
        String baseName = dn.getWord();
        List strokes = dn.getStroke();
        result = factory_.createRefName(baseName, strokes, null);
      }
      return result;
    }

    /**
     * Create a DeclName from a string, extracting out the
     * appropriate decoration tokens
     */
    protected DeclName localCreateDeclName(String name) {
      return (DeclName) localCreateName(name, DECLNAME);
    }

    /**
     * Create a RefName from a string, extracting out the
     * appropriate decoration tokens
     */
    protected RefName localCreateRefName(String name) {
      return (RefName) localCreateName(name, REFNAME);
    }

    /**
     * Converts a list of strings into one long string.
     */
    protected String concatStrList(List list)
    {
      StringBuffer name = new StringBuffer();

      for (Iterator iter = list.iterator(); iter.hasNext(); ) {
        String next = (String) iter.next();
        name.append(next);
      }
      return name.toString();
    }

    /**
     * Converts a list of String objects to a DeclName object
     */
    protected DeclName strListToDeclName(List list)
    {
      return factory_.createDeclName(concatStrList(list), list(), null);
    }

    /**
     * Converts a list of String objects to a RefName object
     */
    protected RefName strListToRefName(List list)
    {
      return factory_.createRefName(concatStrList(list), list(), null);
    }

    /**
     * Converts a Term to a Pred
     */
    protected Pred pred(Term t)
      throws ParseException
    {
      Pred result = null;

      if (t instanceof Pred) {
        result = (Pred) t;
      }
      else if (t instanceof Expr) {
        result = factory_.createExprPred((Expr) t);
      }
      else {
        //I don't think that this is possible...?
        exception("Predicate expected, but read: " + t.getClass().getName());
      }
      return result;
    }

    /**
     * Converts an Term to an Expr
     */
    protected Expr expr(Term t)
      throws ParseException
    {
      Expr result = null;

      if (t instanceof Expr) {
        result = (Expr) t;
      }
      else if (t instanceof ExprPred) {
        result = ((ExprPred) t).getExpr();
      }
      else {
        exception("Expression expected, but read: " + t.getClass().getName());
      }
      return result;
    }

    /**
     * Converts a Term to a RefName
     */
    protected RefName refname(Term t)
      throws ParseException
    {
      RefName result = null;

      if (t instanceof RefName) {
        result = (RefName) t; 
      }
      else if (t instanceof RefExpr) {
        RefExpr re = (RefExpr) t;

        if (re.getExpr().size() > 0) {
          exception("RefName with no generic instantiation list expected");
        }
        result = re.getRefName();
      }
      else {
        exception("RefName expected, but read: " + t.getClass().getName());
      }

      return result;
    }

    /**
     * Throws a ParseException with the specified error message
     */
    protected void exception(String message)
      throws ParseException
    {
       exception(message, null);
    }

    /**
     * Throws a ParseException with the specified error message and 
     * nested Throwable
     */
    protected void exception(String message, Throwable cause)
      throws ParseException
    {
      ParseException exception =
        new ParseException(message,
                           file_,
                           previous_.left,
                           previous_.right);

      throw exception;
    }

    /**
     * Creates a member predicate from a string list and an expression list
     */
    protected MemPred localCreateMemPred(List name, List exprList)
    {
      TupleExpr te = factory_.createTupleExpr(exprList);
      RefName rn = strListToRefName(name);
      RefExpr re = factory_.createRefExpr(rn, list(), Boolean.FALSE);
      MemPred result = factory_.createMemPred(te, re, Boolean.TRUE);
      return result;
    }

    /**
     * Creates an application expression or reference expression
     * (depending on the type of operator: function or generic)
     * from string string list and an expression list
     */
    protected Expr localCreateMixfixExpr(List name, List exprList)
    {
      Expr result = null;

      //get the first operator in the name list, i.e. the first
      //item that is not an "_".
      String firstOperator = null;
      for (Iterator iter = name.iterator(); iter.hasNext(); ) {
        String next = (String) iter.next();
        if (!next.equals(ARG_TOK) &amp;&amp; !next.equals(LISTARG_TOK)) {
          firstOperator = next;
          break;
        }
      }

      if (table_.getCat(firstOperator) == Cat.Function) {
        //if exprList contains only 1 element, do not create a TupleExpr
        Expr e = null;
        if (exprList.size() == 1) {
          e = (Expr) exprList.get(0);
        }
        else {
          e = factory_.createTupleExpr(exprList);
        }

        RefName rn = strListToRefName(name);
        RefExpr re = factory_.createRefExpr(rn, list(), Boolean.FALSE);
        result = factory_.createApplExpr(re, e, Boolean.TRUE);
      }
      else {
        RefName rn = strListToRefName(name);
        result = factory_.createRefExpr(rn, exprList, Boolean.TRUE);
      }

      return result;
    }

    /**
     * Returns the right hand side of the previous infix relation
     */
    protected Expr getPreviousRhsExpr(Pred pred)
    {
      Expr result = null;

      MemPred memPred = null;
      if (pred instanceof MemPred) {
        memPred = (MemPred) pred;
      }
      else {   //AndPred
        memPred = (MemPred) ((AndPred) pred).getRightPred();
      }

      if (previousChain_ == Sym.MEM) {
        result = memPred.getRightExpr();
      }
      else if (previousChain_ == Sym.EQUALS) {
        SetExpr se = (SetExpr) memPred.getRightExpr();
        result = (Expr) se.getExpr().get(0);
      }
      //previousChain_ == Sym.IP
      else {
        TupleExpr te = (TupleExpr) memPred.getLeftExpr();
        result = (Expr) te.getExpr().get(1);
      }

      return result;
    }

    /**
     * Convert a chain relation into a series of and predicates
     * (transformation rule 12.2.10.3)
     */
    protected Pred transformChainRel(Pred chain, int sym, Expr rhs)
    {
      Pred result = null;

      Expr lExpr = getPreviousRhsExpr(chain);
      Expr rExpr = rhs;

      if (sym == Sym.EQUALS) {
        rExpr = factory_.createSetExpr(list(rhs));
      }
      
      MemPred mp = factory_.createMemPred(lExpr, rExpr, Boolean.TRUE);
      result = factory_.createAndPred(chain, mp, Op.Chain);

      previousChain_ = -1;
      return result;
    }

    protected Pred transformChainRelInfix(Pred chain, Expr rhs, String ip)
    {
      Pred result = null;

      List opName = list(ARG_TOK);
      opName.add(ip);
      opName.add(ARG_TOK);

      Expr lExpr = getPreviousRhsExpr(chain);
      Expr rExpr = rhs;

      MemPred mp = localCreateMemPred(opName, list(lExpr, rExpr));
      result = factory_.createAndPred(chain, mp, Op.Chain);

      previousChain_ = -1;
      return result;
    }

    /**
     * Creates a list of strings for a list returned by expSep.
     * This list will represent the name of the operator to which
     * the expressions were applied
     */
    protected void addExpSepName(List opName, List es)
    {
      for (int i = 0; i &lt; es.size(); i += 2) {

        List list = (List) es.get(i);
        if (list.size() == 1) {
          opName.add(ARG_TOK);
        }
        else {
          opName.add(LISTARG_TOK);
        }
        opName.add((String) es.get(i + 1));
      }
    }

    /**
     * Returns the list of expressions returned by expSep.
     */
    protected void addExpSepExp(List expList, List es)
    {
      for (int i = 0; i &lt; es.size(); i += 2) {
        expList.addAll((List) es.get(i));
      }
    }
:}

parser code
{:
    public Symbol parse() throws java.lang.Exception
    {
      Symbol symbol = super.parse();
      Term term = (Term) symbol.value;

      //pass the specification to the visitor for reordering
      //infix operators
      PrecedenceHandlingVisitor visitor =
        new PrecedenceHandlingVisitor(table_);
      term.accept(visitor);

      return symbol;
    }

    /** The tokens that can have soft new lines both before and after */
    protected int [] nlBoth_ =
      new int [] {Sym.LEFTASSOC, Sym.PARENTS,
        Sym.RIGHTASSOC, Sym.ELSE, Sym.THEN, Sym.DEFFREE,
        Sym.BAR, Sym.LDATA, Sym.ANDALSO,
        Sym.CONJECTURE, Sym.LISTARG, Sym.AND, Sym.OR,
        Sym.IMP, Sym.IFF, Sym.CROSS, Sym.SLASH,
        Sym.EQUALS, Sym.MEM, Sym.DEFEQUAL, Sym.COLON,
        Sym.COMMA, Sym.DOT, Sym.SEMICOLON, Sym.SPOT,
        Sym.ZHIDE, Sym.ZPROJ, Sym.ZCOMP, Sym.ZPIPE,
        Sym.I, Sym.IP, Sym.EL, Sym.ELP, Sym.ERE,
        Sym.EREP, Sym.ES, Sym.SS, Sym.SRE, Sym.SREP,
        Sym.VISIBILITY, Sym.INHERITS, Sym.PARALLEL,
        Sym.ASSOCPARALLEL, Sym.GCH, Sym.END,
        Sym.SCH, Sym.GENSCH, Sym.OPSCH, Sym.AX, 
        Sym.GENAX, Sym.ZED, Sym.CLASS, Sym.STATE, 
        Sym.INIT,
      };

    //in the ISO standard, "function", "generic", "relation", and
    //"section" are in the "both" category, but a new line before one of
    //these is possible if multiple paragraphs are permitted inside in
    //a zed paragraph, so have been moved into the "after" category
    /** The tokens that can only have soft new lines after */
    protected int [] nlAfter_ =
      new int [] {Sym.IF, Sym.LET, Sym.ZPRE,
        Sym.FUNCTION, Sym.GENERIC, Sym.RELATION, Sym.SECTION,
        Sym.LSQUARE, Sym.ARG, Sym.NOT, Sym.ALL,
        Sym.EXI, Sym.EXIONE, Sym.LPAREN, Sym.LBRACE,
        Sym.LBIND, Sym.LAMBDA, Sym.MU, Sym.THETA,
        Sym.PRE, Sym.PREP, Sym.L, Sym.LP,
        Sym.DCNJ, Sym.DGCH, Sym.DSQC,
      };

    //RDATA has been moved from "both" to "before"
    /** The tokens that can only have soft new lines before */
    protected int [] nlBefore_ =
      new int [] {Sym.RSQUARE, Sym.RPAREN, Sym.RBRACE,
        Sym.RBIND, Sym.POST, Sym.POSTP, Sym.ER,
        Sym.ERP, Sym.SR, Sym.SRP,
        Sym.RDATA
      };

    /** A symbol used for lookAhead */
    protected Symbol lookAhead_ = null;

    /** The previous symbol */
    protected Symbol previous_ = null;

    /** The table of operators */
    protected OperatorTable table_;

    /** The file being parsed */
    protected String file_;

    /** The section manager */
    protected SectionManager manager_;

    /**
     * The constructor that receives the operator table
     */
    public <class/>(Scanner scanner,
                    OperatorTable table,
                    SectionManager manager)
    {
      super(scanner);
      table_ = table;
      manager_ = manager;
    }

    /**
     * The constructor that receives the operator table
     */
    public <class/>(Scanner scanner,
                    OperatorTable table,
                    String file,
                    SectionManager manager)
    {
      super(scanner);
      table_ = table;
      file_ = file;
      manager_ = manager;
    }

    /**
     * Returns true if and only if a symbol is in an array of symbols
     */
    protected boolean contains(int [] symbols, int symbol)
    {
      boolean result = false;

      for (int i = 0; i &lt; symbols.length; i++) {
        if (symbols[i] == symbol) {
          result = true;
          break;
        }
      }
      return result;
    }

    /**
     * Return the next token, returning the operator symbol if it is a 
     * user defined operator
     */
    protected Symbol local_next_token() throws Exception
    {
        Symbol symbol = null;
        Symbol result = null;

        if (lookAhead_ == null) {
          symbol = getScanner().next_token();
        }
        else {
          symbol = new Symbol(lookAhead_.sym,
                              lookAhead_.left,
                              lookAhead_.right,
                              lookAhead_.value);
          lookAhead_ = null;
        }
        result = localLookup(symbol);

        //remove any soft newline characters
        if (result.sym == Sym.NL) {
          if (previous_ != null &amp;&amp;
              (contains(nlBoth_, previous_.sym) ||
              contains(nlAfter_, previous_.sym))) {

              return local_next_token();
          }
          else {
            lookAhead_ = localLookup(getScanner().next_token());
            if (lookAhead_.sym == Sym.NL) {
              return local_next_token();
            }
            else if (contains(nlBoth_, lookAhead_.sym) ||
                contains(nlBefore_, lookAhead_.sym)) {

                result = lookAhead_;
                lookAhead_ = null;
            }
          }
        }
        //If a ZED token is followed by a SECTION, ignore the ZED.
        //This solves some shift/reduce problems
        else if (result.sym == Sym.ZED) {
          if (lookAhead_ == null) {
            lookAhead_ = local_next_token();
          }

          if (lookAhead_.sym == Sym.SECTION) {
            result = lookAhead_;
            lookAhead_ = null;
          }
        }

        previous_ = result;
        action_obj.previous_ = previous_;
        return result;
    }

    /**
     * Lookup the value of this symbol
     */
    protected Symbol localLookup(Symbol symbol)
    {
       Symbol result = null;

       if (symbol.sym == Sym.DECORWORD || symbol.sym == Sym.DECLWORD) {

         String name = (String) symbol.value;
         int type = table_.lookup(name);
         result = (type == -1) ? symbol : new Symbol(type, 
                                                     symbol.left, 
                                                     symbol.right, name);
       }
       else {
         result = symbol;
       }

       return result;
    }

    public void report_error(String message, Object info)
    {
      ParseException exception =
        new ParseException(message,
                           file_,
                           previous_.left,
                           previous_.right);
      Logger logger = CztLogger.getLogger(<class/>.class);
      logger.warning(exception.toString());
    }

    public void report_fatal_error(String message, Object info)
      throws ParseException
    {
      ParseException exception =
        new ParseException(message,
                           file_,
                           previous_.left,
                           previous_.right);
      done_parsing();
      throw exception;
    }
:}

init with
{:
    //share the operator table between the action code and the parser code
    action_obj.table_ = table_;
    action_obj.file_ = file_;
    action_obj.previous_ = previous_;
    action_obj.manager_ = manager_;
:}

scan with {: return local_next_token(); :};

terminal
        DELTA, THETA, MU, LAMBDA,
        NEXTSTROKE, OUTSTROKE, INSTROKE,
        LPAREN, RPAREN, LSQUARE, RSQUARE, LBIND, RBIND,
        LDATA, RDATA, LBRACE, RBRACE,
        BAR, ANDALSO, CONJECTURE, AND, OR, IMP, IFF, NOT, 
        ALL, EXI, CROSS, POWER, 
        SLASH, EQUALS, MEM, COLON, SEMICOLON, COMMA, DOT, SPOT, ZHIDE, 
        ZPROJ, ZCOMP, ZPIPE, NL,
        SECTION, PARENTS, TRUE, FALSE, LET, IF, THEN, ELSE, ZPRE,
        RELATION, FUNCTION, GENERIC, LEFTASSOC, RIGHTASSOC, LISTARG, ARG,
        DEFFREE, DEFEQUAL, EXIONE,
        END, AX, SCH, GENSCH, GENAX, ZED, CLASS, STATE, INIT, OPSCH,
        VISIBILITY, INHERITS, INITWORD,
        DCNJ, DGCH, DSQC, PARALLEL, ASSOCPARALLEL, GCH,
        //identifiers starting with a '_' are used only to force precedence
        _APPLICATION, _RENAME;

terminal String
        TEXT, DECORWORD, DECLWORD,
        PREP, PRE, POSTP, POST, IP, I, LP, L, ELP, EL, ERP, ER,
        SRP, SR, EREP, ERE, SREP, SRE, ES, SS;

terminal Integer NUMERAL, NUMSTROKE;

non terminal Spec
    specification;

non terminal List /*ZSect*/ sectionList;
non terminal ZSect section;
non terminal List emptySectionHeader;

non terminal List /*Parent*/ parentList;
non terminal String sectionName;

non terminal List /*Para*/ 
    paragraphList,
    unboxedParagraphList,
    unboxedParagraphItemList;

non terminal Para 
    boxedParagraph,
    unboxedParagraphItem;

non terminal NarrPara narrParagraph;

non terminal List /*String*/
    optParents;

non terminal AxPara
    axiomaticDefinition,
    genericAxDefinition,
    abbreviationDefinition,
    schema;

non terminal ConstDecl
    letDefinition;

non terminal List /*Freetype*/ freeTypeList;
non terminal Freetype freeTypeDefinition;

non terminal List /*String*/
    optNarrWordList,
    narrWordList;

non terminal OptempPara operatorTemplate;
non terminal List /*StringAndOperand?*/ 
    template,
    prefixTemplate,
    postfixTemplate,
    infixTemplate,
    nofixTemplate,
    optWordOperandList;
non terminal
    functionToken,
    genericToken,
    relationToken;

non terminal Operand 
    varg,
    templateTag;
non terminal Assoc assoc;
non terminal OptempPara catTemplate;

non terminal SchText 
    schemaTextNoExpression,
    expressionSchemaText,
    schemaText;

non terminal List /*ConstDecl*/ letDefinitionList;

non terminal List /*InheritedClass*/ 
    inheritedList,
    inheritedClassList;
non terminal RenameList optRenameList;

non terminal RefNameList 
    deltaList,
    visibilityList;
                        
non terminal FormalParameters classFormalParameters;

non terminal List /*Branch*/ branchList;
non terminal Branch branch;

non terminal List /*Operation*/ operationList;

non terminal List /*Para*/
    localDefinitionList,
    unboxedLocalDefinitionBlock,
    unboxedLocalDefinitionList;

non terminal AxPara
    boxedLocalDefinition;

non terminal Para
    unboxedLocalDefinition;

non terminal LocalDef
    localDefinitionBlock;

non terminal List /*DeclName*/ 
    nameList,
    declWordList,
    declNameList;
non terminal DeclName
    name,
    declName,
    formalParameterName;

non terminal List /*RefName*/ refNameList;
non terminal RefName refName;

non terminal List /*NameNamePair*/ renameList;
non terminal NameNamePair rename;
    
non terminal List /*Decl*/ 
    optDeclPart,
    declPart;
non terminal Decl 
    basicDeclaration,
    declaration;

non terminal GivenPara basicTypeDefinition;
non terminal List /*DeclName*/
    formalParameters,
    optFormalParameters;

non terminal List /*Stroke*/ optStrokeList;
non terminal Stroke stroke;

non terminal Op 
    optSep,
    sep,    
    optNL;

non terminal TermA
    term,
    func_appl,
    inner_term;

non terminal Pred
    predicate,
    predicate1;

non terminal MemPred
    prefixRel,
    postfixRel,
    nofixRel;

non terminal Pred
    relation,
    infixRel,
    infixChainRel;

non terminal Expr
    opPromotionLhs,
    expression;

non terminal List /*NameExprPair*/
    optNameExprPairList,
    nameExprPairList;

non terminal NameExprPair nameExprPair;

non terminal List /*Expr*/ prodExpressionList;

non terminal List /*Expr*/ 
    optExpressionList,
    expressionList;

non terminal Operation operation;

non terminal OperationBox operationBox;
non terminal OperationExpr
    operationExpression,
    operationExpression1;

non terminal MainOpExpr mainOpExpression;

non terminal List /*String*/ 
    opName,
    prefixName,
    postfixName,
    infixName,
    nofixName,
    genName,
    prefixGenName,
    postfixGenName,
    infixGenName,
    nofixGenName;

non terminal List /*String*/
    optVargEsSsList,
    optNameEsSsList;

non terminal Expr
    application,
    prefixApp,
    postfixApp,
    infixApp,
    nofixApp;

non terminal List /*Object*/
    expSep;

non terminal List /*String*/
    argErepOrSrep,
    argEreOrSre,
    argErOrSr,
    argEsOrSs,
    argErpOrSrp;

non terminal String
    ereOrSre,
    erOrSr,
    esOrSs;

non terminal String
    visibility;

<add:oz>
/// Object-Z constructs ///////////////////////////////////////////////
non terminal InheritedClass inheritedClass;
non terminal ActualParameters optActualParameters;
non terminal ClassPara
    class;

non terminal State state;
non terminal List stateDecl;
non terminal SecondaryAttributes secondaryDecl;

non terminal InitialState initialState;
</add:oz>

precedence right        BAR;
precedence left         TEXT;
precedence left         RPAREN;
precedence left         NL, SEMICOLON;
precedence nonassoc     DEFEQUAL;
precedence left         ALL, EXI, EXIONE, SPOT;
precedence left         IFF;
precedence right        IMP;
precedence left         OR;
precedence left         AND;
precedence right        NOT;
precedence left         MEM, EQUALS, PREP, LP, IP, EREP, SREP, POSTP, ELP, ERP, SRP;
precedence right        LAMBDA;
precedence right        MU;
precedence right        LET;
precedence left         ASSOCPARALLEL;
precedence left         PARALLEL;
precedence left         GCH;
precedence right        ELSE;
precedence left         ZCOMP;
precedence left         ZPIPE;
precedence left         ZHIDE;
precedence left         ZPROJ;
precedence right        ZPRE;
precedence left         EL, ERE, SRE, I;
precedence left         CROSS;
precedence right        POWER, PRE, L;
precedence left         POST, ER, SR;
precedence left         _APPLICATION;
precedence left         INSTROKE, OUTSTROKE, NEXTSTROKE, NUMSTROKE;
precedence left         _RENAME;
precedence left         DOT;
precedence right        THETA;
precedence left         LSQUARE, RSQUARE;
precedence left         DECORWORD;

/// specifications /////////////////////////////////////////////////////////

//both anonymous and sectioned specifications have an optional narrative
//paragraph list to avoid precedence problems
specification ::=
        optNarrWordList:onwl emptySectionHeader:sh paragraphList:pl
        {:
           // Apply Syntactic Transformation Rule 12.2.1.1
           Parent p = factory_.createParent(TOOLKIT);
           ZSect sect = factory_.createZSect("Specification", list(p), pl);
           if (onwl.size() > 0) {
             NarrPara ns = factory_.createNarrPara(onwl);
             sect.getPara().add(0, ns);
           }
           Spec spec = factory_.createSpec();
           spec.setVersion("1.2");
           spec.getSect().add(sect);
           RESULT = spec;
        :}
        |
        optNarrWordList:onwl sectionList:sl
        {:
           Spec spec = factory_.createSpec();
           spec.setVersion("1.2");
           if (onwl.size() > 0) {
             NarrSect ns = factory_.createNarrSect(onwl);
             spec.getSect().add(ns);
           }
           spec.getSect().addAll(sl);
           RESULT = spec;
        :}
        ;

//if there is no section header, then the specification is anonymous,
//so parse the standard toolkit because that is implicitly a parent
emptySectionHeader ::=
        //empty
        {:
           parseParent(TOOLKIT);
        :}
        ;

optNarrWordList ::=
        //empty
        {:
           RESULT = list();
        :}
	|
	narrWordList:nwl
	{:
           RESULT = nwl;
        :}
        ;

sectionList ::= 
        sectionList:sl section:s
        {: 
           sl.add(s);
           RESULT = sl;
        :}
        |
        section:s
        {: RESULT = list(s); :}
        ;

section ::=
        //ZED token at the start of sections is ignored by
        //local_next_token to avoid a few problems
        SECTION sectionName:n optParents:ops END paragraphList:pl
        {: 
           table_.endSection();
           RESULT = factory_.createZSect(n, ops, pl);
        :}
        ;

//reduce this separately so we can set the current section
//in the operator table, and stop the lookup to the operator table
//(see section 8.4)
sectionName ::=
        DECORWORD:dw
        {:
           //do not parse the prelude as a parent for itself
           if (! dw.equals(PRELUDE)) {
             parseParent(PRELUDE);
           }
           table_.setSection(dw);
           table_.setLookup(false);
           RESULT = dw;
        :}
        ;

optParents ::=
        //empty
        {:
           table_.setLookup(true);
           RESULT = list();
        :}
        |
        PARENTS parentList:pl
        {:
           table_.setLookup(true);
           RESULT = pl;
        :}
        |
        PARENTS
        {:
           table_.setLookup(true);
           RESULT = list();
        :}
        ;

parentList ::=
        DECORWORD:dw COMMA parentList:pl
        {:
           table_.addParent(dw);
           parseParent(dw);
           Parent p = factory_.createParent(dw);
           pl.add(0, p);
           RESULT = pl;
        :}
        |
        DECORWORD:dw
        {:
           table_.addParent(dw);
           parseParent(dw);
           Parent p = factory_.createParent(dw);
           RESULT = list(p);
        :}
        ;


//paragraphs are divided into boxed and unboxed paragraphs. 
//Unboxed paragraphs must have a newline after their definition, 
//unless they are the final paragraph within ZED ... END tokens
paragraphList ::= 
        paragraphList:pl boxedParagraph:p
        {: 
           pl.add(p);
           RESULT = pl;
        :}
        |
        paragraphList:pl unboxedParagraphList:upl
        {:
           pl.addAll(upl);
           RESULT = pl;
        :}
        |
        paragraphList:pl narrParagraph:np
        {:
           pl.add(np);
           RESULT = pl;
        :}
        |
        //empty
        {: RESULT = list(); :} %prec NL 
        ;


// 6.2 Global Paragraphs //////////////////////////////////////////////////////

boxedParagraph ::=
        axiomaticDefinition:ad
        {: RESULT = ad; :}
        |
        schema:s
        {: RESULT = s; :}
        |
        genericAxDefinition:gd
        {: RESULT = gd; :}
<add:oz>
        |
        class:c
        {: RESULT = c; :}
</add:oz>
        ;

narrParagraph ::=
        narrWordList:nwl
        {: RESULT = factory_.createNarrPara(nwl); :}
        ;

unboxedParagraphList ::=
        ZED unboxedParagraphItemList:uil END
        {: RESULT = uil; :}
        ;

unboxedParagraphItemList ::=
        unboxedParagraphItemList:uil NL unboxedParagraphItem:ui
        {:
           uil.add(ui);
           RESULT = uil;
        :}
        |
        unboxedParagraphItem:ui
        {: RESULT = list(ui); :}
        ;

unboxedParagraphItem ::=
        basicTypeDefinition:btd
        {: RESULT = btd; :}
        |
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        |
        freeTypeList:ftl
        {: RESULT = factory_.createFreePara(ftl); :}
        |
        optFormalParameters:ofp CONJECTURE predicate1:p1
        {: RESULT = factory_.createConjPara(ofp, p1); :}
        |
        operatorTemplate:ot
        {:
           table_.add(fix_, ot);
           fix_ = -1;
           RESULT = ot;
        :}
        ;

basicTypeDefinition ::= 
        LSQUARE nameList:nl RSQUARE
        {: RESULT = factory_.createGivenPara(nl); :}
        ;

//according to the Z ISO, a schema is an axiomatic definition with
//ConstDecl(n, st) as the declaration
schema ::=
        SCH name:n optFormalParameters:ofp schemaText:st END
        {: 
           SchExpr se = factory_.createSchExpr(st);
           ConstDecl cd = factory_.createConstDecl(n, se);
           SchText stC = factory_.createSchText(list(cd), null);
           RESULT = factory_.createAxPara(ofp, stC, Box.SchBox);
        :}
        |
        GENSCH name:n formalParameters:fp schemaText:st END
        {: 
           SchExpr se = factory_.createSchExpr(st);
           ConstDecl cd = factory_.createConstDecl(n, se);
           SchText stC = factory_.createSchText(list(cd), null);
           RESULT = factory_.createAxPara(fp, stC, Box.SchBox);
        :}
        ;       

genericAxDefinition ::= 
        GENAX formalParameters:fp schemaText:st END
        {: RESULT = factory_.createAxPara(fp, st, Box.AxBox); :}
        ;

optFormalParameters ::=
        formalParameters:fp
        {: RESULT = fp; :}
        |
        //empty
        {: RESULT = list(); :}
        ;

formalParameters ::= 
        LSQUARE nameList:nl RSQUARE
        {: RESULT = nl; :}
        ;

axiomaticDefinition ::= 
        AX schemaText:st END
        {: RESULT = factory_.createAxPara(list(), st, Box.AxBox); :}
        ;

//according to the Z ISO standard, an abbreviation definition is to be
//treated as an axiomatic definition, with ConstDecl(dn,e)
abbreviationDefinition ::=
        declName:dn DEFEQUAL expression:e
        {:
           ConstDecl cd = factory_.createConstDecl(dn, e);
           SchText st = factory_.createSchText(list(cd), null);
           RESULT = factory_.createAxPara(list(), st, Box.OmitBox);      
        :}
        |
        //TODO: check this. Should be name:n, but the toolkit won't parse
        //"\langle \_ \rangle [X] == .... without this
        declName:dn formalParameters:fp DEFEQUAL expression:e
        {:
           ConstDecl cd = factory_.createConstDecl(dn, e);
           SchText st = factory_.createSchText(list(cd), null);
           RESULT = factory_.createAxPara(fp, st, Box.OmitBox);
        :}
        | 
        genName:gn DEFEQUAL expression:e
        {:
           DeclName dn = (DeclName) gn.get(0);
           List fp = (List) gn.get(1);
           ConstDecl cd = factory_.createConstDecl(dn, e);
           SchText st = factory_.createSchText(list(cd), null);
           RESULT = factory_.createAxPara(fp, st, Box.OmitBox);
        :}
        ;


freeTypeList ::=
        freeTypeList:ftl ANDALSO freeTypeDefinition:ftd
        {: 
           ftl.add(ftd);
           RESULT = ftl;
        :}
        |
        freeTypeDefinition:ftd
        {: RESULT = list(ftd); :}
        ;


freeTypeDefinition ::=
        name:n DEFFREE branchList:bl
        {: RESULT = factory_.createFreetype(n, bl); :}
        ;


branchList ::=
        branchList:bl BAR branch:b
        {:
           bl.add(b);
           RESULT = bl;
        :}
        |
        branch:b 
        {: RESULT = list(b); :}
        ;

branch ::=
        declName:dn
        {: RESULT = factory_.createBranch(dn, null); :}
        |
        declName:dn LDATA expression:e RDATA
        {: RESULT = factory_.createBranch(dn, e); :}
        ;

narrWordList ::=
        narrWordList:nwl TEXT:t
        {:
           nwl.add(t);
           RESULT = nwl;
        :}
        |
        TEXT:t
        {: RESULT = list(t); :}
        ;

// operator templates  /////////////////////////////////////////////////////

operatorTemplate ::=
        relationToken template:t
        {:
           OptempPara otp =
             factory_.createOptempPara();
           otp.getOper().addAll(t);
           otp.setCat(Cat.Relation);
           otp.setPrec(new Integer(0));
           table_.setLookup(true);
           RESULT = otp;
        :}
        |
        functionToken catTemplate:ct
        {:
           ct.setCat(Cat.Function);
           table_.setLookup(true);
           RESULT = ct;
        :}
        |
        genericToken catTemplate:ct
        {:
           ct.setCat(Cat.Generic);
           table_.setLookup(true);
           RESULT = ct;
        :}
        ;

//we do not perform lookup on the table when parsing an operator
//(see section 8.3)
relationToken ::=
        RELATION
        {: table_.setLookup(false); :}
        ;

functionToken ::=
        FUNCTION
        {: table_.setLookup(false); :}
        ;

genericToken ::=
        GENERIC
        {: table_.setLookup(false); :}
        ;

template ::=
        prefixTemplate:pt
        {: RESULT = pt; :}
        |
        postfixTemplate:pt
        {: RESULT = pt; :}
        |
        infixTemplate:it
        {: RESULT = it; :}
        |
        nofixTemplate:nt
        {: RESULT = nt; :}
        ;


catTemplate ::=
        prefixTemplate:pt
        {: 
           OptempPara otp = factory_.createOptempPara();
           otp.getOper().addAll(pt);
           otp.setPrec(new Integer(0));
           RESULT = otp;
        :}
        |
        postfixTemplate:pt
        {: 
           OptempPara otp = factory_.createOptempPara();
           otp.getOper().addAll(pt);
           otp.setPrec(new Integer(0));
           RESULT = otp;
        :}
        |
        NUMERAL:pr assoc:a infixTemplate:it
        {:
           OptempPara otp = factory_.createOptempPara();
           otp.setPrec(pr);
           otp.getOper().addAll(it);
           otp.setAssoc(a);
           RESULT = otp;
        :}
        |
        nofixTemplate:nt
        {:
           OptempPara otp = factory_.createOptempPara();
           otp.getOper().addAll(nt);
           otp.setPrec(new Integer(0));
           RESULT = otp;
        :}
        ;


assoc ::=
        LEFTASSOC
        {: RESULT = Assoc.Left; :}
        |
        RIGHTASSOC
        {: RESULT = Assoc.Right; :}
        ;


prefixTemplate ::=
        LPAREN DECORWORD:n optWordOperandList:ol varg:v RPAREN
        {: 
           List l = list(factory_.createOperator(n));
           l.addAll(ol);
           l.add(v);
           fix_ = OperatorTable.PREFIX;
           RESULT = l; 
        :}
	|
	LPAREN POWER varg:v RPAREN
	{:
           List l = list(factory_.createOperator(ZString.POWER), v);
           fix_ = OperatorTable.PREFIX;
           RESULT = l;
	:}
        ;


postfixTemplate ::=
        LPAREN varg:v DECORWORD:n optWordOperandList:ol RPAREN
        {: 
           List l = list(v);
           l.add(factory_.createOperator(n));
           l.addAll(ol);
           fix_ = OperatorTable.POSTFIX;
           RESULT = l; 
        :}
        ;


infixTemplate ::=
        LPAREN varg:v1 DECORWORD:n optWordOperandList:ol varg:v2 RPAREN
        {: 
           List l = list(v1);
           l.add(factory_.createOperator(n));
           l.addAll(ol);
           l.add(v2);
           fix_ = OperatorTable.INFIX;
           RESULT = l; 
        :}
        ;


nofixTemplate ::=
        LPAREN DECORWORD:n optWordOperandList:ol RPAREN
        {: 
           List l = list(factory_.createOperator(n));
           l.addAll(ol);
           fix_ = OperatorTable.NOFIX;
           RESULT = l;
        :}
        ;


optWordOperandList ::=
        //empty
        {: RESULT = list(); :}
        |
        optWordOperandList:wl templateTag:t DECORWORD:n
        {:
           wl.add(t);
           wl.add(factory_.createOperator(n));
           RESULT = wl;
        :}
        ;

templateTag ::=
        varg:v
        {: RESULT = v; :}
        |
        LISTARG
        {: RESULT = factory_.createOperand(Boolean.TRUE); :}
        ;

varg ::=
        ARG
        {: RESULT = factory_.createOperand(Boolean.FALSE); :}
        ;


/// schema text ///////////////////////////////////////////

schemaText ::= 
        optDeclPart:odp BAR predicate:p
        {: RESULT = factory_.createSchText(odp, p); :}
        |
        optDeclPart:odp
        {: RESULT = factory_.createSchText(odp, null); :}
        ;

optDeclPart ::=
        //empty
        {: RESULT = list(); :}
        |
        declPart:dp
        {: RESULT = dp; :}
        ;

declPart ::=
        declaration:d
        {: RESULT = list(d); :}
        |
        declPart:dp sep:s declaration:d
        {:
           dp.add(d);
           RESULT = dp;
        :}
        ;

declaration ::=
        basicDeclaration:bd
        {: RESULT = bd; :}
        |
        expression:e
        {: RESULT = factory_.createInclDecl(e); :}
        ;

expressionSchemaText ::=
	expression:e BAR predicate1:p1
	{:
           InclDecl id = factory_.createInclDecl(e);
           RESULT = factory_.createSchText(list(id), p1);
        :}
	|
	expression:e
	{:
           InclDecl id = factory_.createInclDecl(e);
           RESULT = factory_.createSchText(list(id), null);
        :}
	;

schemaTextNoExpression ::=
        declPart:dp BAR predicate1:p1
        {: RESULT = factory_.createSchText(dp, p1); :}
        |
	BAR predicate1:p1
        {: RESULT = factory_.createSchText(list(), p1); :}
        |
	declPart:dp sep declaration:d
	{:
           dp.add(d);
           RESULT = factory_.createSchText(dp, null);
	:}
	|
	basicDeclaration:bd
	{: RESULT = factory_.createSchText(list(bd), null); :}
        ;


basicDeclaration ::=
        declWordList:dwl COLON expression:e
        {: RESULT = factory_.createVarDecl(dwl, e); :}
        |
        declName:dn DEFEQUAL expression:e
        {: RESULT = factory_.createConstDecl(dn, e); :}
        ;       

sep ::=
        SEMICOLON
        {: RESULT = Op.Semi; :}
        |
        NL
        {: RESULT = Op.NL; :}
        ;

optSep ::=
        optNL
        |
        SEMICOLON
        ;

optNL ::=
        //empty
        |
        NL
        ;

/// word, declName, and refName lists ////////////////////////////////////

nameList ::=
        nameList:nl COMMA DECORWORD:dw
        {: 
           DeclName dn = localCreateDeclName(dw);
           nl.add(dn);
           RESULT = nl;
        :}
        |
        DECORWORD:dw
        {: 
           DeclName dn = localCreateDeclName(dw);
           RESULT = list(dn);
        :}
        ;

name ::=
        DECORWORD:dw
        {: RESULT = localCreateDeclName(dw); :}
        ;

declWordList ::=
        declWordList:dwl COMMA DECLWORD:dw
        {: 
           DeclName dn = localCreateDeclName(dw);
           dwl.add(dn); 
           RESULT = dwl;
        :}
        |
        declWordList:dwl COMMA opName:on
        {: 
           dwl.add(strListToDeclName(on)); 
           RESULT = dwl;
        :}
        |
        opName:on
        {: RESULT = list(strListToDeclName(on)); :}
        |
        DECLWORD:dw
        {:
           DeclName dn = localCreateDeclName(dw);
           RESULT = list(dn); 
        :}
        ;


declNameList ::=
        declNameList:dnl COMMA declName:dn
        {:
           dnl.add(dn);
           RESULT = dnl;
        :}
        |
        declName:dn
        {: RESULT = list(dn); :}
        ;

declName ::=
        DECORWORD:dw
        {: 
           RESULT = localCreateDeclName(dw);
        :}
        |
        opName:on
        {:
           //because we return opNames as RefName instances, we must convert
           //to a DeclName
           RESULT = strListToDeclName(on);
        :}
        ;

refNameList ::=
        refNameList:rnl COMMA DECORWORD:dw
        {:
           RefName rn = localCreateRefName(dw);
           rnl.add(rn);
           RESULT = rnl;
        :}
        <add:oz>
        |
        refNameList:rnl COMMA INITWORD
        {:
           RefName rn = localCreateRefName(OzString.INITWORD);
           rnl.add(rn);
           RESULT = rnl;
        :}
        </add:oz>
        |
        DECORWORD:dw
        {:
           RefName rn = localCreateRefName(dw);
           RESULT = list(rn);
        :}
        <add:oz>
        |
        INITWORD
        {:
           RefName rn = localCreateRefName(OzString.INITWORD);
           RESULT = list(rn);
        :}
        </add:oz>
        ;

refName ::=
        DECORWORD:dw
        {: RESULT = localCreateRefName(dw); :}
        <add:oz>
        |
        INITWORD
        {:
           RefName rn = localCreateRefName(OzString.INITWORD);
           RESULT = rn;
        :}
        </add:oz>
        |
        LPAREN opName:on RPAREN
        {:
           RefName rn = factory_.createRefName(strListToDeclName(on).getWord(),
                                                 strListToDeclName(on).getStroke(),
                                                 null);
           rn.getAnns().add(factory_.createParenAnn());
           RESULT = rn;
        :}
        ;


opName ::=
        prefixName:pn
        {: RESULT = pn; :}
        |
        postfixName:pn
        {: RESULT = pn; :}
        |
        infixName:in
        {: RESULT = in; :}
        |
        nofixName:nn
        {: RESULT = nn; :}
        ;

prefixName ::=
        PRE:p varg
        {: RESULT = list(p, ARG_TOK); :}
        |
        PREP:p varg
        {: RESULT = list(p, ARG_TOK); :}
        |
        L:l optVargEsSsList:ouesl argEreOrSre:aeos varg
        {: 
           List pName = list(l);
           pName.addAll(ouesl);
           pName.addAll(aeos);
           pName.add(ARG_TOK);
           RESULT = pName;
        :}
        |
        LP:lp optVargEsSsList:ouesl argErepOrSrep:aeos varg
        {: 
           List pName = list(lp);
           pName.addAll(ouesl);
           pName.addAll(aeos);
           pName.add(ARG_TOK);
           RESULT = pName;
        :}
        ;

postfixName ::=
        varg POST:p
        {: RESULT = list(ARG_TOK, p); :}
        |
        varg POSTP:p
        {: RESULT = list(ARG_TOK, p); :}
        |
        varg EL:el optVargEsSsList:ouesl argErOrSr:aeos
        {:
           List pName = list(ARG_TOK);
           pName.add(el);
           pName.addAll(ouesl);
           pName.addAll(aeos);
           RESULT = pName;
        :}
        |
        varg ELP:elp optVargEsSsList:ouesl argErpOrSrp:aeos
        {:
           List pName = list(ARG_TOK);
           pName.add(elp);
           pName.addAll(ouesl);
           pName.addAll(aeos);
           RESULT = pName;
        :}
        ;


infixName ::=
        varg I:i varg
        {:
           List iName = list(ARG_TOK);
           iName.add(i);
           iName.add(ARG_TOK);
           RESULT = iName;
        :}
        |
        varg IP:ip varg
        {:
           List iName = list(ARG_TOK);
           iName.add(ip);
           iName.add(ARG_TOK);
           RESULT = iName;
        :}
        |
        varg EL:el optVargEsSsList:ouesl argEreOrSre:aeos varg
        {:
           List iName = list(ARG_TOK);
           iName.add(el);
           iName.addAll(ouesl);
           iName.addAll(aeos);
           iName.add(ARG_TOK);
           RESULT = iName;
        :}
        |
        varg ELP:elp optVargEsSsList:ouesl argErepOrSrep:aeos varg
        {:
           List iName = list(ARG_TOK);
           iName.add(elp);
           iName.addAll(ouesl);
           iName.addAll(aeos);
           iName.add(ARG_TOK);
           RESULT = iName;
        :}
        ;

nofixName ::=
        L:l optVargEsSsList:ouesl argErOrSr:aeos
        {:
           List nName = list(l);
           nName.addAll(ouesl);
           nName.addAll(aeos);
           RESULT = nName;
        :}
        |
        LP:lp optVargEsSsList:ouesl argErpOrSrp:aeos
        {:
           List nName = list(lp);
           nName.addAll(ouesl);
           nName.addAll(aeos);
           RESULT = nName;
        :}
        ;

optVargEsSsList ::=
        //empty
        {: RESULT = list(); :}
        |
        optVargEsSsList:ouesl argEsOrSs:aeos
        {: 
           ouesl.addAll(aeos);
           RESULT = ouesl;
        :}
        ;

argEsOrSs ::=
        ARG ES:es
        {: RESULT = list(ARG_TOK, es); :}
        |
        LISTARG SS:ss
        {: RESULT = list(LISTARG_TOK, ss); :}
        ;

argEreOrSre ::=
        ARG ERE:ere
        {: RESULT = list(ARG_TOK, ere); :}
        |
        LISTARG SRE:sre
        {: RESULT = list(LISTARG_TOK, sre); :}
        ;

argErepOrSrep ::=
        ARG EREP:erep
        {: RESULT = list(ARG_TOK, erep); :}
        |
        LISTARG SREP:srep
        {: RESULT = list(LISTARG_TOK, srep); :}
        ;

argErOrSr ::=
        ARG ER:er
        {: RESULT = list(ARG_TOK, er); :}
        |
        LISTARG SR:sr
        {: RESULT = list(LISTARG_TOK, sr); :}
        ;

argErpOrSrp ::=
        ARG ERP:erp
        {: RESULT = list(ARG_TOK, erp); :}
        |
        LISTARG SRP:srp
        {: RESULT = list(LISTARG_TOK, srp); :}
        ;

//a genName is returned as a list of size 2, with the first being the
//name, and the second being a list of generic parameters
genName ::=
        prefixGenName:pgn
        {: RESULT = pgn; :}
        |
        postfixGenName:pgn
        {: RESULT = pgn; :}
        |
        infixGenName:ign
        {: RESULT = ign; :}
        |
        nofixGenName:ngn
        {: RESULT = ngn; :}
        ;

prefixGenName ::=
        PRE:pre formalParameterName:fpn
        {:
           List name = list(pre, ARG_TOK);
           RESULT = list(strListToDeclName(name), list(fpn));
        :}
        |
        L:l optNameEsSsList:onesl formalParameterName:fpn1
             ereOrSre:eos formalParameterName:fpn2
        {:
           //construct the name
           List name = list(l);
           name.addAll((List) onesl.get(1));
           name.add(ARG_TOK);
           name.add(eos);
           name.add(ARG_TOK);

           //construct the parameter list
           List fps = (List) onesl.get(0);
           fps.add(fpn1);
           fps.add(fpn2);

           RESULT = list(strListToDeclName(name), fps); 
        :}
        ;

postfixGenName ::=
        formalParameterName:fpn POST:p
        {:
           List name = list(ARG_TOK, p);
           RESULT = list(strListToDeclName(name), list(fpn));
        :}
        |
        formalParameterName:fpn1 EL:el optNameEsSsList:onesl 
           formalParameterName:fpn2 erOrSr:eos
        {:
           //construct the name
           List name = list(ARG_TOK);
           name.add(el);
           name.addAll((List) onesl.get(1));
           name.add(ARG_TOK);
           name.add(eos);

           //construct the parameter list
           List fps = list(fpn1);
           fps.addAll((List) onesl.get(0));
           fps.add(fpn2);

           RESULT = list(strListToDeclName(name), fps);
         :}
        ;

infixGenName ::=
        formalParameterName:fpn1 I:i formalParameterName:fpn2
        {:
           //construct the name
           List name = list(ARG_TOK);
           name.add(i);
           name.add(ARG_TOK);

           //construct the parameter list
           List fps = list(fpn1, fpn2);

           RESULT = list(strListToDeclName(name), fps);
        :}
        |
        formalParameterName:fpn1 EL:el optNameEsSsList:onesl 
           formalParameterName:fpn2 ereOrSre:eos formalParameterName:fpn3
        {:
           //construct the name
           List name = list(ARG_TOK);
           name.add(el);
           name.addAll((List) onesl.get(1));
           name.add(ARG_TOK);
           name.add(eos);
           name.add(ARG_TOK);

           //construct the parameter list
           List fps = list(fpn1);
           fps.addAll((List) onesl.get(0));
           fps.add(fpn2);
           fps.add(fpn3);

           RESULT = list(strListToDeclName(name), fps);
        :}
        ;

nofixGenName ::=
        L:l optNameEsSsList:onesl formalParameterName:fpn erOrSr:eos
        {:
           //construct the name
           List name = list(l);
           name.addAll((List) onesl.get(1));
           name.add(ARG_TOK);
           name.add(eos);

           //construct the parameter list
           List fps = (List) onesl.get(0);
           fps.add(fpn);

           RESULT = list(strListToDeclName(name), fps);
        :}
        ;

formalParameterName ::=
        DECORWORD:dw
        {: 
           RESULT = localCreateDeclName(dw);
        :}
        ;

//an optNameEsSsList is returned as a list of size 2, with the first
//being a list comprising the list of generic parameters, and the
//second being a list comprising the name
optNameEsSsList ::=
        //empty
        {: RESULT = list(list(), list()); :}
        |
        optNameEsSsList:ouesl formalParameterName:fpn esOrSs:eos
        {:
           List gens = (List) ouesl.get(0);
           gens.add(fpn);
           List name = (List) ouesl.get(1);
           name.add(ARG_TOK);
           name.add(eos);
           RESULT = ouesl;
        :}
        ;


esOrSs ::=
        ES:es
        {: RESULT = es; :}
        |
        SS:ss
        {: RESULT = ss; :}
        ;

ereOrSre ::=
        ERE:ere
        {: RESULT = ere; :}
        |
        SRE:sre
        {: RESULT = sre; :}
        ;

erOrSr ::=
        ER:er
        {: RESULT = er; :}
        |
        SR:sr
        {: RESULT = sr; :}
        ;

/// predicates and expressions ///////////////////////////////////////////////

predicate ::=
        predicate:lhs sep:s predicate1:rhs
        {: RESULT = factory_.createAndPred(lhs, rhs, s); :}
        |
        predicate1:p1
        {: RESULT = p1; :}
        ;

predicate1 ::=
        term:t
        {: RESULT = pred(t); :}
        ;

expression ::=
        term:t
        {: RESULT = expr(t); :}
        ;

term ::=
        IF predicate1:p1 THEN term:te ELSE term:fe
        {: RESULT = factory_.createCondExpr(p1, expr(te), expr(fe)); :}
        |
        ALL schemaText:st SPOT term:t
        {: 
           if (t instanceof Expr) {
             ForallExpr ee = factory_.createForallExpr(st, expr(t));
             RESULT = factory_.createExprPred(ee);
           }
           else {
             RESULT = factory_.createForallPred(st, pred(t));
           }
        :}
        |
        EXI schemaText:st SPOT term:t
        {:
           if (t instanceof Expr) {
             ExistsExpr ee = factory_.createExistsExpr(st, expr(t));
             RESULT = factory_.createExprPred(ee);
           }
           else {
             RESULT = factory_.createExistsPred(st, pred(t));
           }
        :}
        |
        EXIONE schemaText:st SPOT term:t
        {: 
           if (t instanceof Expr) {
             Exists1Expr ee = factory_.createExists1Expr(st, expr(t));
             RESULT = factory_.createExprPred(ee);
           }
           else {
             RESULT = factory_.createExists1Pred(st, pred(t));
           }
        :}
        |
        LAMBDA schemaText:st SPOT term:t
        {: RESULT = factory_.createLambdaExpr(st, expr(t)); :} %prec LAMBDA
        |
        MU schemaText:st SPOT term:t
        {: RESULT = factory_.createMuExpr(st, expr(t)); :} %prec MU
        |
        LET letDefinitionList:ldl SPOT term:t 
        {: 
           SchText st = factory_.createSchText(ldl, null);
           RESULT = factory_.createLetExpr(st, expr(t));
        :} %prec LET
        |
        term:lhs IFF term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createIffExpr(expr(lhs), expr(rhs)); 
          }
          else {
            RESULT = factory_.createIffPred(pred(lhs), pred(rhs));
          }
        :}
        |
        term:lhs IMP term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createImpliesExpr(expr(lhs), expr(rhs)); 
          }
          else {
            RESULT = factory_.createImpliesPred(pred(lhs), pred(rhs));
          }
        :}
        |
        term:lhs OR term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createOrExpr(expr(lhs), expr(rhs)); 
          }
          else {
            RESULT = factory_.createOrPred(pred(lhs), pred(rhs));
          }
        :}
        |
        term:lhs AND term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createAndExpr(expr(lhs), expr(rhs)); 
          }
          else {
            RESULT = factory_.createAndPred(pred(lhs), pred(rhs), Op.And);
          }
        :}
        |
        NOT term:t
        {:
          if (t instanceof Expr) {
            RESULT = factory_.createNegExpr(expr(t));
          }
          else {
            RESULT = factory_.createNegPred(pred(t));
          }
        :}
        |
        term:lhs ZCOMP term:rhs
        {: RESULT = factory_.createCompExpr(expr(lhs), expr(rhs)); :}
        |
        term:lhs ZPIPE term:rhs
        {: RESULT = factory_.createPipeExpr(expr(lhs), expr(rhs)); :}
        |
        term:t ZHIDE LPAREN refNameList:rnl RPAREN
        {: RESULT = factory_.createHideExpr(expr(t), rnl); :}
        |
        term:lhs ZPROJ term:rhs
        {: RESULT = factory_.createProjExpr(expr(lhs), expr(rhs)); :}
        |
        ZPRE term:t
        {: RESULT = factory_.createPreExpr(expr(t)); :}
        |
        POWER term:t
        {: RESULT = factory_.createPowerExpr(expr(t)); :}
        |
        prodExpressionList:pel
        {: RESULT = factory_.createProdExpr(pel); :}
        |
        relation:rel
        {: RESULT = rel; :}
        |
        application:a
        {: RESULT = a; :}
        |
        func_appl:fa
        {: RESULT = fa; :}
        ;

func_appl ::=
        func_appl:fa inner_term:it
        {:
           RESULT = factory_.createApplExpr(expr(fa), expr(it), Boolean.FALSE);
        :} %prec _APPLICATION
        |
        inner_term:it
        {: RESULT = it; :} %prec _APPLICATION
        ;

inner_term ::=
        LBRACE optExpressionList:oel RBRACE
        {: RESULT = factory_.createSetExpr(oel); :}
        |
        LBRACE schemaTextNoExpression:stne SPOT expression:e RBRACE
        {: RESULT = factory_.createSetCompExpr(stne, e); :}
	|
	LBRACE expressionSchemaText:est SPOT expression:e RBRACE
        {: RESULT = factory_.createSetCompExpr(est, e); :}
        |
        LBRACE schemaTextNoExpression:stne RBRACE
        {: RESULT = factory_.createSetCompExpr(stne, null); :}
        |
        LPAREN expressionList:el COMMA expression:e RPAREN
        {: 
           el.add(e);
           RESULT = factory_.createTupleExpr(el);
        :}
        |
        LPAREN MU schemaText:st RPAREN
        {:
           MuExpr me = factory_.createMuExpr(st, null);
           me.getAnns().add(factory_.createParenAnn());
           RESULT = me;
        :}
        |
        nofixRel:nfr
        {: RESULT = nfr; :} %prec ERP
        |
        nofixApp:nfa
        {: RESULT = nfa; :} %prec _APPLICATION
        |
        LBIND optNameExprPairList:onepl RBIND
        {: RESULT = factory_.createBindExpr(onepl); :}
        |
        LSQUARE schemaTextNoExpression:stne RSQUARE
        {: RESULT = factory_.createSchExpr(stne); :}
        |
        inner_term:it DOT refName:rn
        {: RESULT = factory_.createBindSelExpr(expr(it), rn); :}
        |
        inner_term:it DOT NUMERAL:n
        {: RESULT = factory_.createTupleSelExpr(expr(it), n); :}
        |
        inner_term:it stroke:s
        {: RESULT = factory_.createDecorExpr(expr(it), s); :}
        |
        THETA inner_term:it optStrokeList:sl
        {: RESULT = factory_.createThetaExpr(expr(it), sl); :}
        |
        inner_term:rn LSQUARE expressionList:el RSQUARE
        {: RESULT = factory_.createRefExpr(refname(rn), el, Boolean.FALSE); :}
        |
        inner_term:it LSQUARE renameList:rnl RSQUARE
        {: RESULT = factory_.createRenameExpr(expr(it), rnl); :} %prec _RENAME
        |
        NUMERAL:n
        {: RESULT = factory_.createNumExpr(new BigInteger(n.toString())); :}
        |
        LPAREN term:t RPAREN
        {:
           t.getAnns().add(factory_.createParenAnn());
           RESULT = t;
        :}
        |
        refName:rn
        {: RESULT = factory_.createRefExpr(rn, list(), Boolean.FALSE); :}
        |
        TRUE
        {: RESULT = factory_.createTruePred(); :}
        |
        FALSE
        {: RESULT = factory_.createFalsePred(); :}
        ;

prodExpressionList ::=
        term:t1 CROSS term:t2
        {: RESULT = list(t1, t2); :}
        |
        prodExpressionList:pel CROSS term:t
        {:
           pel.add(t);
           RESULT = pel;
        :}
        ;

optExpressionList ::=
        //empty
        {: RESULT = list(); :}
        |
        expressionList:el
        {: RESULT = el; :}
        ;

expressionList ::=
        expressionList:el COMMA expression:e
        {:      
           el.add(e);
           RESULT = el;
        :} 
        |
        expression:e
        {: RESULT = list(e); :}
        ;


optNameExprPairList ::=
        //empty
        {: RESULT = list(); :}
        |
        nameExprPairList:nepl
        {: RESULT = nepl; :}
        ;

nameExprPairList ::=
        nameExprPairList:nepl COMMA nameExprPair:nep
        {:      
           nepl.add(nep);
           RESULT = nepl;
        :} 
        |
        nameExprPair:nep
        {: RESULT = list(nep); :}
        ;       

nameExprPair ::=
        declName:dn DEFEQUAL expression:e
        {: RESULT = factory_.createNameExprPair(dn, e); :}
        ;


letDefinitionList ::=
        letDefinitionList:ldl SEMICOLON letDefinition:ld
        {:
           ldl.add(ld);
           RESULT = ldl;
        :}
        |
        letDefinition:ld
        {: RESULT = list(ld); :}
        ;       

letDefinition ::=
        declName:n DEFEQUAL expression:e
        {: RESULT = factory_.createConstDecl(n,e); :}
        ;

optStrokeList ::=
        optStrokeList:sl stroke:s
        {:
           sl.add(s);
           RESULT = sl;
        :}
        |
        //empty
        {: RESULT = list(); :} %prec INSTROKE
        ;

stroke ::=
        INSTROKE
        {: RESULT = factory_.createInStroke(); :}
        |
        OUTSTROKE
        {: RESULT = factory_.createOutStroke(); :}
        |
        NEXTSTROKE
        {: RESULT = factory_.createNextStroke(); :}
        |
        NUMSTROKE:ns
        {: RESULT = factory_.createNumStroke(ns); :}
        ;

renameList ::= 
        renameList:rl COMMA rename:rn
        {:
           rl.add(rn);
           RESULT = rl;
        :}
        |
        rename:rn  
        {: RESULT = list(rn); :}
        ;    

rename ::=
        declName:lhs SLASH refName:rhs
        {: RESULT = factory_.createNameNamePair(rhs, lhs); :}
        ;


//nofix relation is not included here because it has a different precedence
//than the other types of relation
relation ::=
        prefixRel:pr
        {: RESULT = pr; :}
        |
        postfixRel:pr
        {: RESULT = pr; :}
        |
        infixRel:ir
        {: RESULT = ir; :}
        ;

//according to the ISO standard, op e1 is equivalent to
//e mem op
prefixRel ::=
        PREP:p term:t
        {: RESULT = localCreateMemPred(list(p), list(expr(t))); :}
        |
        LP:lp expSep:es term:t1 EREP:erep term:t2
        {: 
           List opName = list(lp);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erep);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(expr(t1));
           expList.add(expr(t2));
           RESULT = localCreateMemPred(opName, expList);
        :}
        |
        LP:lp expSep:es optExpressionList:oel SREP:srep term:t
        {:
           List opName = list(lp);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srep);

           List expList = list();
           addExpSepExp(expList, es);
           expList.addAll(oel);
           expList.add(expr(t));
           RESULT = localCreateMemPred(opName, expList);
        :}
        ;

postfixRel ::=
        term:t POSTP:p
        {: RESULT = localCreateMemPred(list(p), list(expr(t))); :}
        |
        term:t1 ELP:elp expSep:es term:t2 ERP:erp
        {:
           List opName = list(ARG_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erp);

           List expList = list(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           RESULT = localCreateMemPred(opName, expList);
        :}
        |
        term:t ELP:elp expSep:es optExpressionList:oel SRP:srp
        {:
           List opName = list(ARG_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srp);

           List expList = list(expr(t));
           addExpSepExp(expList, es);
           expList.addAll(oel);
           RESULT = localCreateMemPred(opName, expList);
        :}
        ;

infixRel ::=
        infixChainRel:icr
        {: RESULT = icr; :}
        |
        term:t1 ELP:elp expSep:es term:t2 EREP:erep term:t3
        {:
           List opName = list(ARG_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erep);
           opName.add(ARG_TOK);

           List expList = list(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           expList.add(expr(t3));
           RESULT = localCreateMemPred(opName, expList);
        :}
        |
        term:t1 ELP:elp expSep:es optExpressionList:oel SREP:erep term:t2
        {:
           List opName = list(ARG_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(erep);
           opName.add(ARG_TOK);

           List expList = list(expr(t1));
           addExpSepExp(expList, es);
           expList.addAll(oel);
           expList.add(expr(t2));
           RESULT = localCreateMemPred(opName, expList);
        :}
        ;

infixChainRel ::=
        term:lhs MEM term:rhs
        {:
           previousChain_ = Sym.MEM;
           RESULT = factory_.createMemPred(expr(lhs), expr(rhs), Boolean.FALSE);
        :}
        |
        term:lhs EQUALS term:rhs
        {:
           previousChain_ = Sym.EQUALS;
           SetExpr se = factory_.createSetExpr(list(expr(rhs)));
           RESULT = factory_.createMemPred(expr(lhs), se, Boolean.TRUE);
        :}
        |
        term:lhs IP:ip term:rhs
        {:
           previousChain_ = Sym.IP;
           List opName = list(ARG_TOK);
           opName.add(ip);
           opName.add(ARG_TOK);
           RESULT = localCreateMemPred(opName, list(expr(lhs), expr(rhs)));
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr MEM term:rhs
        {:
           RESULT = transformChainRel(icr, Sym.MEM, expr(rhs));
           previousChain_ = Sym.MEM;
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr EQUALS term:rhs
        {:
           RESULT = transformChainRel(icr, Sym.EQUALS, expr(rhs));
           previousChain_ = Sym.EQUALS;
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr IP:ip term:rhs
        {:
           RESULT = transformChainRelInfix(icr, expr(rhs), ip);
           previousChain_ = Sym.IP;
        :}
        ;

nofixRel ::=
        LP:lp expSep:es term:t ERP:erp
        {:
           List opName = list(ARG_TOK);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erp);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(expr(t));
           RESULT = localCreateMemPred(opName, expList);
        :}
        |
        LP:lp expSep:es optExpressionList:oel SRP:srp
        {:
           List opName = list(ARG_TOK);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srp);

           List expList = list();
           addExpSepExp(expList, es);
           expList.addAll(oel);
           RESULT = localCreateMemPred(opName, expList);
        :}
        ;


//nofix application is not included here because it has a different
//precedence to the other types of application
application ::=
        prefixApp:pa
        {: RESULT = pa; :}
        |
        postfixApp:pa
        {: RESULT = pa; :}
        |
        infixApp:ia
        {: RESULT = ia; :}
        ;

prefixApp ::=
        PRE:pre term:t
        {: RESULT = localCreateMixfixExpr(list(pre, ARG_TOK), list(expr(t))); :}
        |
        L:l expSep:es term:t1 ERE:ere term:t2
        {:
           List opName = list(l);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(ere);
           opName.add(ARG_TOK);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(expr(t1));
           expList.add(expr(t2));
           RESULT = localCreateMixfixExpr(opName, expList);
        :}
        |
        L:l expSep:es optExpressionList:oel SRE:sre term:t
        {:
           List opName = list(l);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sre);
           opName.add(ARG_TOK);

           List expList = list();
           addExpSepExp(expList, es);
           expList.addAll(oel);
           expList.add(expr(t));
           RESULT = localCreateMixfixExpr(opName, expList);
        :}
        ;

postfixApp ::=
        term:t POST:post
        {: RESULT = localCreateMixfixExpr(list(ARG_TOK, post), list(expr(t))); :}
        |
        term:t1 EL:el expSep:es term:t2 ER:er
        {:
           List opName = list(ARG_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(er);

           List expList = list(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           RESULT = localCreateMixfixExpr(opName, expList);
        :}
        |
        term:t EL:el expSep:es optExpressionList:oel SR:sr
        {:
           List opName = list(ARG_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sr);

           List expList = list(expr(t));
           addExpSepExp(expList, es);
           expList.addAll(oel);
           RESULT = localCreateMixfixExpr(opName, expList);
        :}
        ;

infixApp ::=
        term:lhs I:i term:rhs
        {: 
           List opName = list(ARG_TOK);
           opName.add(i);
           opName.add(ARG_TOK);
           RESULT = localCreateMixfixExpr(opName, list(lhs, rhs));
        :}
        |
        term:t1 EL:el expSep:es term:t2 ERE:ere term:t3
        {:
           List opName = list(ARG_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(ere);
           opName.add(ARG_TOK);

           List expList = list(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           expList.add(expr(t3));
           RESULT = localCreateMixfixExpr(opName, expList);
        :}
        |
        term:t1 EL:el expSep:es optExpressionList:oel SRE:sre term:t2
        {:
           List opName = list(ARG_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sre);
           opName.add(ARG_TOK);

           List expList = list(expr(t1));
           addExpSepExp(expList, es);
           expList.addAll(oel);
           expList.add(expr(t2));
           RESULT = localCreateMixfixExpr(opName, expList);
        :}
        ;

nofixApp ::=
        L:l expSep:es term:t ER:er
        {:
           List opName = list(l);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(er);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(expr(t));
           RESULT = localCreateMixfixExpr(opName, expList);
        :}
        |
        L:l expSep:es optExpressionList:oel SR:sr
        {:
           List opName = list(l);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sr);

           List expList = list();
           addExpSepExp(expList, es);
           expList.addAll(oel);
           RESULT = localCreateMixfixExpr(opName, expList);
        :}
        ;

expSep ::=
        //empty
        {: RESULT = list(); :} %prec I
        |
        expSep:exs term:t ES:es
        {:
           exs.add(list(expr(t)));
           exs.add(es);
           RESULT = exs;
        :}
        |
        expSep:exs expressionList:el SS:ss
        {:
           exs.add(el);
           exs.add(ss);
           RESULT = exs;
        :}
        ;

<add:oz>
/// Object-Z constructs ///////////////////////////////////////////////
class ::= 
        CLASS name:n
            classFormalParameters:fp
            visibilityList:vl
            inheritedList:il
            localDefinitionBlock:ldb
            state:s
            initialState:is
            operationList:ol
        END
        {: 
          RESULT = factory_.createClassPara(n, fp, vl, il, ldb, s, is, ol);
        :}
        ;

classFormalParameters ::=
        //empty
        {: RESULT = null; :}
        |
        formalParameters:fp
        {: RESULT = factory_.createFormalParameters(fp); :}
        ;


operationList ::=
        //empty
        {: RESULT = list(); :}
        |
        operationList:ol optNL operation:o
        {: 
           ol.add(o); 
           RESULT = ol;
        :}
        ;


/// class paragraphs ///////////////////////////////////////////////

visibilityList ::=
        //empty
        {: RESULT = null; :}
        |
        visibility LPAREN refNameList:rnl RPAREN optNL
        {: RESULT = factory_.createRefNameList(rnl); :}
        ;

visibility ::=
        VISIBILITY
        |
        ZPROJ %prec VISIBILITY
        ;

inheritedList ::=
        //empty
        {: RESULT = list(); :}
        |
        INHERITS inheritedClassList:icl optNL
        {: RESULT = icl; :}
        ;

inheritedClassList ::=
        inheritedClassList:icl COMMA inheritedClass:ic
        {:
           icl.add(ic);
           RESULT = icl;
        :}
        |
        inheritedClass:ic
        {: RESULT = list(ic); :}
        ;

inheritedClass ::=
        refName:rn optActualParameters:oap optRenameList:ore
        {: RESULT = factory_.createInheritedClass(rn, oap, ore); :}
        ;

optActualParameters ::=
        //empty
        {: RESULT = null; :}
        |
        LSQUARE expressionList:el RSQUARE
        {: RESULT = factory_.createActualParameters(el); :}
        ;

optRenameList ::=
        //empty
        {: RESULT = null; :}
        |
        LSQUARE renameList:rnl  RSQUARE
        {: factory_.createRenameList(rnl); :}
        ;

localDefinitionBlock ::=
        // empty
        {: RESULT = null; :}
        |
        localDefinitionList:ldl
        {:
           //get the list of definitions and put them in lists depending on
           //their type...
           List axParaList = list();
           List freeTypeList = list();
           List basicTypeList = list();

           for (Iterator it = ldl.iterator(); it.hasNext(); ) {
               Object item = it.next();

               if (item instanceof AxPara) {
                   axParaList.add(item);
               }
               else if (item instanceof Freetype) {
                   freeTypeList.add(item);
               }
               else if (item instanceof GivenPara) {
                   basicTypeList.add(item);
               }
           }
           RESULT = factory_.createLocalDef(basicTypeList, axParaList, freeTypeList);
        :}
        ;


localDefinitionList ::=
        localDefinitionList:ldl boxedLocalDefinition:bld
        {:
           ldl.add(bld);
           RESULT = ldl;
        :}
        |
        localDefinitionList:ldl unboxedLocalDefinitionBlock:uldb
        {: 
           ldl.addAll(uldb);
           RESULT = ldl;
        :}
	|
        boxedLocalDefinition:bld
	{: RESULT = list(bld); :}
        |
        unboxedLocalDefinitionBlock:uldb
        {: RESULT = uldb; :}
        ;

boxedLocalDefinition ::=
        axiomaticDefinition:ad
        {: RESULT = ad; :}
        |
        genericAxDefinition:gad
        {: RESULT = gad; :}
        ;

unboxedLocalDefinitionBlock ::=
        ZED unboxedLocalDefinitionList:uldl END
        {: RESULT = uldl; :}
        ;

unboxedLocalDefinitionList ::=
        unboxedLocalDefinitionList:uldl NL unboxedLocalDefinition:uld
        {:
           uldl.add(uld);
           RESULT = uldl;
        :}
        |
        unboxedLocalDefinition:uld
        {: RESULT = list(uld); :}
        ;

unboxedLocalDefinition ::=
        basicTypeDefinition:gtd
        {: RESULT = gtd; :}
        |
        freeTypeList:ftl
        {: RESULT = factory_.createFreePara(ftl); :}
        |
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        ;

state ::=
        // empty
        {: RESULT = null; :}
        |
        STATE stateDecl:sd BAR predicate:p END
        {:
           List dp = (List) sd.get(0);
           SecondaryAttributes sa = (SecondaryAttributes) sd.get(1);
           RESULT = factory_.createState(dp, sa, list(p));
        :}
        |
        STATE stateDecl:sd END
        {:
           List dp = (List) sd.get(0);
           SecondaryAttributes sa = (SecondaryAttributes) sd.get(1);
           RESULT = factory_.createState(dp, sa, list());
        :}
        | 
        LSQUARE stateDecl:sd BAR predicate:p RSQUARE
        {:
           List dp = (List) sd.get(0);
           SecondaryAttributes sa = (SecondaryAttributes) sd.get(1);
           RESULT = factory_.createState(dp, sa, list(p));
        :}
        |
        LSQUARE stateDecl:sd RSQUARE
        {:
           List dp = (List) sd.get(0);
           SecondaryAttributes sa = (SecondaryAttributes) sd.get(1);
           RESULT = factory_.createState(dp, sa, list());
        :}
        ;

//return a list with 2 elements: the declPart and the secondaryDecl
stateDecl ::=
        optDeclPart:odp
        {: RESULT = list(odp, null); :}
        |
        secondaryDecl:sd
        {: RESULT = list(list(), sd); :}
        |
        declPart:dp sep secondaryDecl:sd
        {: RESULT = list(dp, sd); :}
        ;

secondaryDecl ::=
        DELTA sep declPart:dp
        {: RESULT = factory_.createSecondaryAttributes(dp); :}
        ;

initialState ::=
        // empty
        {: RESULT = null; :}
        |
        INIT predicate:p END
        {: RESULT = factory_.createInitialState(list(p)); :}
        |
        INITWORD DEFEQUAL LSQUARE predicate:p RSQUARE
        {: RESULT = factory_.createInitialState(list(p)); :}
        ;

operation ::=
        SCH name:n operationBox:ob END
        {: RESULT = factory_.createOperation(n, ob); :}
        |
        OPSCH name:n operationBox:ob END
        {: RESULT = factory_.createOperation(n, ob); :}
        |
        declName:dn DEFEQUAL operationExpression:oe
        {: RESULT = factory_.createOperation(dn, oe); :}
        ;

operationBox ::=
        deltaList:dl sep:s declPart:dp BAR predicate:p
        {: RESULT = factory_.createOperationBox(dl, dp, list(p)); :}
        | 
        deltaList:dl sep:s declPart:dp
        {: RESULT = factory_.createOperationBox(dl, dp, list()); :}
        |        
        deltaList:dl BAR predicate:p  
        {: RESULT = factory_.createOperationBox(dl, list(), list(p)); :}
        | 
        deltaList:dl
        {: RESULT = factory_.createOperationBox(dl, list(), list()); :}
        | 
        declPart:dp BAR predicate:p
        {: RESULT = factory_.createOperationBox(null, dp, list(p)); :}
        | 
        declPart:dp
        {: RESULT = factory_.createOperationBox(null, dp, list()); :}
        ;


operationExpression ::=
        DCNJ mainOpExpression:moe
        {: RESULT = factory_.createDistConjOpExpr(moe); :}
        |
        DGCH mainOpExpression:moe
        {: RESULT = factory_.createDistChoiceOpExpr(moe); :}
        |
        /*DSQC*/ ZCOMP mainOpExpression:moe
        {: RESULT = factory_.createDistSeqOpExpr(moe); :}
        |
        operationExpression1:oe1
        {: RESULT = oe1; :}
        ;

mainOpExpression ::=
        schemaText:st SPOT operationExpression:oe
        {: RESULT = factory_.createMainOpExpr(st, oe); :}
        ;

operationExpression1 ::=
        LSQUARE deltaList:dl optSep schemaText:st RSQUARE
        {: RESULT = factory_.createBasicOpExpr(dl, st); :}
        |
        opPromotionLhs:oplhs DOT refName:rn
        {: RESULT = factory_.createOpPromotionExpr(oplhs, rn); :}
        |
        refName:rn
        {: RESULT = factory_.createOpPromotionExpr(null, rn); :}
        |
        operationExpression1:oe1 LSQUARE renameList:rnl RSQUARE
        {: RESULT = factory_.createRenameOpExpr(oe1, rnl); :}
        |
        operationExpression1:oe1 ZHIDE LPAREN declNameList:onl RPAREN
        {: RESULT = factory_.createHideOpExpr(oe1, onl);:}
        |
        operationExpression1:lhs AND operationExpression1:rhs
        {: RESULT = factory_.createConjOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs PARALLEL operationExpression1:rhs
        {: RESULT = factory_.createParallelOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs ASSOCPARALLEL operationExpression1:rhs
        {: RESULT = factory_.createAssoParallelOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs GCH operationExpression1:rhs
        {: RESULT = factory_.createExChoiceOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs ZCOMP operationExpression1:rhs
        {: RESULT = factory_.createSeqOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs SPOT operationExpression1:rhs
        {: RESULT = factory_.createScopeEnrichOpExpr(lhs, rhs); :}
        |
        LPAREN operationExpression:oe RPAREN
        {:
           oe.getAnns().add(factory_.createParenAnn());
           RESULT = oe;
        :}
        ;

opPromotionLhs ::=
        refName:rn
        {: RESULT = factory_.createRefExpr(rn, list(), Boolean.FALSE); :}
        |
        opPromotionLhs:oplhs DOT refName:rn
        {: RESULT = factory_.createBindSelExpr(oplhs, rn); :}
        ;

deltaList ::=
        //empty
        {: RESULT = null; :}
        |
        DELTA LPAREN refNameList:rnl RPAREN
        {: RESULT = factory_.createRefNameList(rnl); :}
        ;
</add:oz>
</parser>
