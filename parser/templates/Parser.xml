<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright (C) 2003 Tim Miller
     Copyright (C) 2004 Petra Malik
     This file is part of the CZT project.

     The CZT project contains free software;
     you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with CZT; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<parser xmlns:add="http://czt.sourceforge.net/templates/additional">
package <package/>;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;
import java.io.*;

import java_cup.runtime.*;

import net.sourceforge.czt.base.ast.*;
<add:oz>
import net.sourceforge.czt.oz.util.OzString;
import net.sourceforge.czt.oz.ast.*;
//import net.sourceforge.czt.oz.util.Factory;
</add:oz>
<add:ozz>
import net.sourceforge.czt.oz.util.Factory;
</add:ozz>
<add:tcoz>
import net.sourceforge.czt.tcoz.util.TcozString;
import net.sourceforge.czt.tcoz.ast.*;
import net.sourceforge.czt.tcoz.util.Factory;
</add:tcoz>

import net.sourceforge.czt.parser.util.*;
import net.sourceforge.czt.util.CztException;
import net.sourceforge.czt.util.CztLogger;
import net.sourceforge.czt.util.ParseException;
import net.sourceforge.czt.z.ast.*;
<add:z>
import net.sourceforge.czt.z.util.Factory;
</add:z>
import net.sourceforge.czt.z.util.OperatorName;
import net.sourceforge.czt.z.util.ZString;
import net.sourceforge.czt.session.SectionInfo;

action code
{:
    /** The ZML Version. */
    public final static String ZML_VERSION = "1.2";

    /**
     * The name given to an anonymous specification when rule 12.2.2.1
     * is applied.
     */
    public final static String ANONYMOUS_SPEC_NAME = "Specification";

    /** The name of the prelude. */
    public final static String PRELUDE = "prelude";

    /** The name of the mathematical toolkit. */
    public final static String TOOLKIT = "standard_toolkit";

    /** The symbols used to replace arguments for names in ApplExpr etc. */
    public final static String ARG_TOK = ZString.ARG_TOK;
    public final static String LISTARG_TOK = ZString.LISTARG_TOK;
    public final static String SPACE = ZString.SPACE;

    /** The factory for creating AST objects. */
    protected Factory factory_ = new Factory();

    /** The table of operators. */
    protected OpTable opTable_;

    /** The map of all operator tables created. */
    protected Map opTables_ = new HashMap();

    /** The name of file currently being parsed. */
    protected String file_ = null;

    /**
     * The symbol returned by the last call to local_next_token().
     */
    protected Symbol previous_;

    /** A list of parsed sections. */
    protected List parsedSections_ = list();

    /** The type of the previous chain relation e.g. MEM, EQUALS, IP */
    protected int previousChain_ = -1;

    /** Section information. */
    protected SectionInfo sectInfo_;

    /** The operator scanner. */
    protected OperatorScanner scanner_;

    /**
     * Create an empty list.
     */
    protected List list()
    {
      return new ArrayList();
    }

    /**
     * Create a list containing one element.
     */
    protected List list(Object o)
    {
      List result = new ArrayList();
      result.add(o);
      return result;
    }

    /**
     * Creates a list containing two elements.
     */
    protected List list(Object o1, Object o2)
    {
      List result = new ArrayList();
      result.add(o1);
      result.add(o2);
      return result;
    }

    private Spec createSpec(List sectList)
    {
      Spec result = factory_.createSpec();
      result.setVersion(ZML_VERSION);
      result.getSect().addAll(sectList);
      return result;
    }

    private Operator createOperator(String name, int line, int column)
      throws ParseException
    {
      final DeclName dn = factory_.createDeclName(name);
      if (dn.getStroke().size() != 0) {
        final String message =
          "Syntax error (names in operator templates cannot contain strokes)";
        final Symbol token = new Symbol(Sym.DECORWORD, line, column);
        parser.report_error(message, token);
        parser.report_fatal_error(message, token);
      }
      assert name.equals(dn.getWord());
      Operator result = factory_.createOperator(name);
      return result;
    }

    /**
     * Converts a list of String objects to a DeclName object.
     */
    protected DeclName strListToDeclName(List list)
      throws ParseException
    {
      try {
        OperatorName opName = new OperatorName(list);
        return factory_.createDeclName(opName.getWord(), opName.getStroke());
      }
      catch (OperatorName.OperatorNameException e) {
        final String message = "Syntax error: " + e.getMessage();
        parser.report_error(message, null);
        parser.report_fatal_error(message, null);
        return null;
      }
    }

    /**
     * Converts a list of String objects to a RefName object.
     */
    protected RefName strListToRefName(List list)
      throws ParseException
    {
      try {
        OperatorName opName = new OperatorName(list);
        return factory_.createRefName(opName.getWord(), opName.getStroke());
      }
      catch (OperatorName.OperatorNameException e) {
        final String message = "Syntax error: " + e.getMessage();
        parser.report_error(message, null);
        parser.report_fatal_error(message, null);
        return null;
      }
    }

    /**
     * Converts a Term to a Pred.
     */
    protected Pred pred(Term t)
      throws ParseException
    {
      Pred result = null;

      if (t instanceof Pred) {
        result = (Pred) t;
      }
      else if (t instanceof Expr) {
        result = factory_.createExprPred((Expr) t);
      }
      else {
        //I don't think that this is possible...?
        exception("Predicate expected, but read: " + t.getClass().getName());
      }
      return result;
    }

    /**
     * Converts an Term to an Expr.
     */
    protected Expr expr(Term t)
      throws ParseException
    {
      Expr result = null;

      if (t instanceof Expr) {
        result = (Expr) t;
      }
      else if (t instanceof ExprPred) {
        result = ((ExprPred) t).getExpr();
      }
      else {
        exception("Expression expected, but read: " + t.getClass().getName());
      }
      return result;
    }

    /**
     * Converts a Term to a RefName.
     */
    protected RefName refname(Term t)
      throws ParseException
    {
      RefName result = null;

      if (t instanceof RefName) {
        result = (RefName) t; 
      }
      else if (t instanceof RefExpr) {
        RefExpr re = (RefExpr) t;

        if (re.getExpr().size() > 0) {
          exception("RefName with no generic instantiation list expected");
        }
        result = re.getRefName();
      }
      else {
        exception("RefName expected, but read: " + t.getClass().getName());
      }

      return result;
    }

    /**
     * Throws a ParseException with the specified error message.
     */
    protected void exception(String message)
      throws ParseException
    {
       exception(message, null);
    }

    /**
     * Throws a ParseException with the specified error message and 
     * nested Throwable.
     */
    protected void exception(String message, Throwable cause)
      throws ParseException
    {
      ParseException exception =
        new ParseException(message,
                           file_,
                           previous_.left,
                           previous_.right);

      throw exception;
    }

    /**
     * Creates a member predicate from a string list and an expression list.
     */
    protected MemPred localCreateMemPred(List name, List exprList)
      throws ParseException
    {
      //if there is more than one expr in the list, the
      //right-hand-side is a tuple
      Expr e = null;
      if (exprList.size() == 1) {
        e = expr((Term) exprList.get(0));
      }
      else {
        e = factory_.createTupleExpr(exprList);
      }
      RefName rn = strListToRefName(name);
      MemPred result = factory_.createRelOpAppl(e, rn);
      return result;
    }

    /**
     * Creates an application expression or reference expression
     * (depending on the type of operator: function or generic)
     * from string string list and an expression list.
     */
    protected Expr localCreateMixfixExpr(List name, List exprList)
      throws ParseException
    {
      final RefName rn = strListToRefName(name);
      Expr result = null;

      //get the first operator in the name list, i.e. the first
      //item that is not an ARG_TOK or LISTARG_TOK.
      String firstOperator = null;
      for (Iterator iter = name.iterator(); iter.hasNext(); ) {
        String next = (String) iter.next();
        if (!next.equals(ARG_TOK) &amp;&amp; !next.equals(LISTARG_TOK)) {
          firstOperator = next;
          break;
        }
      }

      if (opTable_.lookup(name) != null &amp;&amp;
          Cat.Function.equals(opTable_.lookup(name).getCat())) {
        //if exprList contains only 1 element, do not create a TupleExpr
        Expr e = null;
        if (exprList.size() == 1) {
          e = (Expr) exprList.get(0);
        }
        else {
          e = factory_.createTupleExpr(exprList);
        }
        result = factory_.createFunOpAppl(rn, e);
      }
      else {
        result = factory_.createRefExpr(rn, exprList, Boolean.TRUE);
      }

      return result;
    }

    /**
     * Returns the right hand side of the previous infix relation.
     */
    protected Expr getPreviousRhsExpr(Pred pred)
    {
      Expr result = null;

      MemPred memPred = null;
      if (pred instanceof MemPred) {
        memPred = (MemPred) pred;
      }
      else {   //AndPred
        memPred = (MemPred) ((AndPred) pred).getRightPred();
      }

      if (previousChain_ == Sym.MEM) {
        result = memPred.getRightExpr();
      }
      else if (previousChain_ == Sym.EQUALS) {
        SetExpr se = (SetExpr) memPred.getRightExpr();
        result = (Expr) se.getExpr().get(0);
      }
      //previousChain_ == Sym.IP
      else {
        TupleExpr te = (TupleExpr) memPred.getLeftExpr();
        result = (Expr) te.getExpr().get(1);
      }

      return result;
    }

    /**
     * Convert a chain relation into a series of and predicates
     * (transformation rule 12.2.10.3).
     */
    protected Pred transformChainRel(Pred chain, int sym, Expr rhs)
    {
      Pred result = null;

      Expr lExpr = getPreviousRhsExpr(chain);
      Expr rExpr = rhs;

      if (sym == Sym.EQUALS) {
        rExpr = factory_.createSetExpr(list(rhs));
      }
      
      MemPred mp = factory_.createMemPred(lExpr, rExpr, Boolean.TRUE);
      result = factory_.createAndPred(chain, mp, Op.Chain);

      previousChain_ = -1;
      return result;
    }

    protected Pred transformChainRelInfix(Pred chain, Expr rhs, String ip)
      throws ParseException
    {
      Pred result = null;

      List opName = list(ARG_TOK);
      opName.add(ip);
      opName.add(ARG_TOK);

      Expr lExpr = getPreviousRhsExpr(chain);
      Expr rExpr = rhs;

      MemPred mp = localCreateMemPred(opName, list(lExpr, rExpr));
      result = factory_.createAndPred(chain, mp, Op.Chain);

      previousChain_ = -1;
      return result;
    }

    /**
     * Creates a list of strings for a list returned by expSep.
     * This list will represent the name of the operator to which
     * the expressions were applied.
     */
    protected void addExpSepName(List opName, List es)
    {
      for (int i = 0; i &lt; es.size(); i += 2) {

        List list = (List) es.get(i);
        if (list.size() == 1) {
          opName.add(ARG_TOK);
        }
        else {
          opName.add(LISTARG_TOK);
        }
        opName.add((String) es.get(i + 1));
      }
    }

    /**
     * Returns the list of expressions returned by expSep.
     */
    protected void addExpSepExp(List expList, List es)
    {
      for (int i = 0; i &lt; es.size(); i += 2) {
        expList.addAll((List) es.get(i));
      }
    }

    private OpTable getOperatorTable(String section)
    {
      OpTable result = (OpTable) opTables_.get(section);
      if (result == null) {
        result = (OpTable) sectInfo_.getInfo(section, OpTable.class);
      }
      return result;
    }

    private void resetOpTable(String section, List parents)
      throws ParseException
    {
      List parentOpTables = list();
      if (PRELUDE.equals(section)) {
        assert parents.size() == 0;
      }
      else {
        parentOpTables.add(getOperatorTable(PRELUDE));
        for (Iterator iter = parents.iterator(); iter.hasNext();) {
          final String parent = ((Parent) iter.next()).getWord();
          final OpTable parentOp = getOperatorTable(parent);
          if (parentOp != null) {
            parentOpTables.add(parentOp);
          }
        }
      }
      try {
        opTable_ = new OpTable(section, parentOpTables);
      }
      catch (OpTable.OperatorException e) {
        final String message = "Parse error while merging the parent " +
          "operator tables of section " + section +": " +
          e.getMessage();
        parser.report_error(message, null);
        parser.report_fatal_error(message, null);
     }
      scanner_.setOperatorTable(opTable_);
      opTables_.put(section, opTable_);
    }

    private void addLocAnn(TermA termA, int line, int column)
    {
      String loc = file_;
      Integer lineNr = new Integer(line + 1);
      Integer columnNr = new Integer(column + 1);
      LocAnn locAnn = factory_.createLocAnn(loc, lineNr, columnNr);
      if (loc == null) loc = "unknown";
      assert loc != null;
      List anns = termA.getAnns();
      for (Iterator iter = anns.iterator(); iter.hasNext();) {
        Object o = iter.next();
        if (o instanceof LocAnn) {
          LocAnn existingAnn = (LocAnn) o;
          if (! locAnn.equals(existingAnn)) {
            String message =
              "Found existing LocAnn " + locAnnToString(existingAnn) +
              " annotated to " + termA +
              " while adding LocAnn " + locAnnToString(locAnn);
            throw new CztException(message);
          }
          return;
        }
      }
      anns.add(locAnn);
    }

    private String locAnnToString(LocAnn locAnn)
    {
      StringBuffer result = new StringBuffer();
      result.append("(");
      result.append(locAnn.getLoc());
      result.append(", ");
      result.append(locAnn.getLine());
      result.append(", ");
      result.append(locAnn.getCol());
      result.append(")");
      return result.toString();
    }
:}

parser code
{:
    public Symbol parse() throws java.lang.Exception
    {
      Symbol symbol = super.parse();
      Term term = (Term) symbol.value;

      //pass the specification to the visitor for reordering
      //infix operators
      PrecedenceHandlingVisitor visitor =
        new PrecedenceHandlingVisitor(action_obj.opTables_);
      symbol.value = term.accept(visitor);
      return symbol;
    }

    public Map getOperatorTables()
    {
      return action_obj.opTables_;
    }

    /** The file being parsed. */
    protected String file_;

    /** Section information. */
    protected SectionInfo sectInfo_;

    private OperatorScanner scanner_;

    /**
     * Creates a new parser with the given scanner and section information.
     * The section information should be able to provide information of
     * type <code>net.sourceforge.czt.parser.util.OpTable.class</code>.
     */
    public <class/>(Scanner scanner,
                    SectionInfo sectInfo)
    {
      this(scanner, null, sectInfo);
    }

    /**
     * Creates a new parser with the given scanner, source information,
     * and section information.
     * The source information is only used for printing error messages.
     * The section information should be able to provide information of
     * type <code>net.sourceforge.czt.parser.util.OpTable.class</code>.
     */
    public <class/>(Scanner scanner,
                    String source,
                    SectionInfo sectInfo)
    {
      super(scanner);
      file_ = source;
      sectInfo_ = sectInfo;
      scanner_ = new OperatorScanner(getScanner());
    }

    /**
     * Returns the next token.
     */
    protected Symbol local_next_token() throws Exception
    {
        Symbol result = scanner_.next_token();
        action_obj.previous_ = result;
        return result;
    }

    public void report_error(String message, Object info)
    {
      StringBuffer msg = new StringBuffer();
      msg.append(message);
      if (info instanceof Symbol) {
        Symbol token = (Symbol) info;
        final int line = token.left + 1;
        final int column = token.right + 1;
        msg.append(" at line " + line + " column " + column);
      }
      if (file_ != null) msg.append(" in " + file_);
      Logger logger = CztLogger.getLogger(<class/>.class);
      logger.warning(msg.toString());
    }

    public void report_fatal_error(String message, Object info)
      throws ParseException
    {
      int line = -1;
      int column = -1;
      if (info instanceof Symbol) {
        Symbol token = (Symbol) info;
        line = token.left + 1;
        column = token.right + 1;
      }
      ParseException exception =
        new ParseException(message, file_, line, column);
      done_parsing();
      throw exception;
    }

    public void syntax_error(Symbol cur_token)
    {
      String message = "Syntax error";
      report_error(message, cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token)
      throws ParseException
    {
      String message = "Syntax error";
      report_fatal_error("Couldn't repair and continue parse", cur_token);
    }
:}

init with
{:
    //share the operator table between the action code and the parser code
    action_obj.file_ = file_;
    action_obj.sectInfo_ = sectInfo_;
    action_obj.scanner_ = scanner_;
:}

scan with {: return local_next_token(); :};

terminal
        THETA, MU, LAMBDA,
        NEXTSTROKE, OUTSTROKE, INSTROKE,
        LPAREN, RPAREN, LSQUARE, RSQUARE, LBIND, RBIND,
        LDATA, RDATA, LBRACE, RBRACE,
        BAR, ANDALSO, CONJECTURE, AND, OR, IMP, IFF, NOT, 
        ALL, EXI, CROSS, POWER, 
        SLASH, EQUALS, MEM, COLON, SEMICOLON, COMMA, DOT, SPOT, ZHIDE, 
        ZPROJ, ZCOMP, ZPIPE, NL,
        SECTION, PARENTS, TRUE, FALSE, LET, IF, THEN, ELSE, ZPRE,
        RELATION, FUNCTION, GENERIC, LEFTASSOC, RIGHTASSOC, LISTARG, ARG,
        DEFFREE, DEFEQUAL, EXIONE,
        END, AX, SCH, GENSCH, GENAX, ZED,
<add:oz>
        DELTA, CLASS, STATE, INIT, OPSCH,
        VISIBILITY, INHERITS, INITWORD,
        DCNJ, DGCH, DSQC, PARALLEL, ASSOCPARALLEL, GCH,
</add:oz>
<add:tcoz>
        MAINOP, ATTIME, NEXTPRO, INTCHOICE, DIC, INTERLEAVE,
        DIL, WAITUNTIL, DEADLINE, WAIT, INTERRUPT, TIMEOUT, TIMEEND, 
        DPARA, NETTOPOLOGY, CHANTYPE, 
</add:tcoz>
        //identifiers starting with a '_' are used only to force precedence
        _APPLICATION, _RENAME;

terminal String
        TEXT, DECORWORD, DECLWORD,
        PREP, PRE, POSTP, POST, IP, I, LP, L, ELP, EL, ERP, ER,
        SRP, SR, EREP, ERE, SREP, SRE, ES, SS;

terminal Integer NUMERAL, NUMSTROKE;

<add:tcoz>
terminal _Guard;
</add:tcoz>

non terminal Spec
    input,
    specification;

non terminal Sect
    narrSect;

non terminal ZSect
    section,
    emptySectionHeader,
    sectionHeader;

non terminal List /*ZSect*/
    sectionList;

non terminal List /*Parent*/
    parentList,
    parents;

non terminal List /*Para*/ 
    paragraphList,
    unboxedParagraphList,
    unboxedParagraphItemList;

non terminal Para 
    boxedParagraph,
    unboxedParagraphItem,
    narrParagraph;

non terminal AxPara
    axiomaticDefinition,
    genericAxDefinition,
    abbreviationDefinition,
    schema;

non terminal ConstDecl
    letDefinition;

non terminal List /*Freetype*/ freeTypeList;
non terminal Freetype freeTypeDefinition;

non terminal List /*String*/
    narrWordList;

non terminal OptempPara operatorTemplate;
non terminal List /*StringAndOperand?*/ 
    template,
    prefixTemplate,
    postfixTemplate,
    infixTemplate,
    nofixTemplate,
    optWordOperandList;

non terminal Operand 
    varg,
    templateTag;
non terminal Assoc assoc;
non terminal OptempPara catTemplate;

non terminal SchText 
    schemaTextNoExpression,
    expressionSchemaText,
    schemaText;

non terminal List /*ConstDecl*/ letDefinitionList;

non terminal List /*Branch*/ branchList;
non terminal Branch branch;

non terminal List /*DeclName*/ 
    nameList,
    declWordList;

non terminal DeclName
    name,
    declName,
    formalParameterName;

non terminal List /*RefName*/ refNameList;
non terminal RefName refName;

non terminal List /*NameNamePair*/ renameList;
non terminal NameNamePair rename;
    
non terminal List /*Decl*/ 
    optDeclPart,
    declPart;
non terminal Decl 
    basicDeclaration,
    declaration;

non terminal GivenPara basicTypeDefinition;
non terminal List /*DeclName*/
    formalParameters,
    optFormalParameters;

non terminal List /*Stroke*/ optStrokeList;
non terminal Stroke stroke;

non terminal Op
    sep;   

non terminal TermA
    term,
    septerm,
    func_appl,
    inner_term;

non terminal Pred
    predicate,
    relation,
    infixRel,
    infixChainRel;

non terminal MemPred
    prefixRel,
    postfixRel,
    nofixRel;

non terminal Expr
    expression;

non terminal List /*NameExprPair*/
    optNameExprPairList,
    nameExprPairList;

non terminal NameExprPair
    nameExprPair;

non terminal List /*Expr*/
    prodExpressionList,
    optExpressionList,
    expressionList;

non terminal List /*String*/ 
    opName,
    prefixName,
    postfixName,
    infixName,
    nofixName,
    genName,
    prefixGenName,
    postfixGenName,
    infixGenName,
    nofixGenName;

non terminal List /*String*/
    optVargEsSsList,
    optNameEsSsList;

non terminal Expr
    application,
    prefixApp,
    postfixApp,
    infixApp,
    nofixApp;

non terminal List /*Object*/
    expSep;

non terminal List /*String*/
    argErepOrSrep,
    argEreOrSre,
    argErOrSr,
    argEsOrSs,
    argErpOrSrp;

non terminal String
    ereOrSre,
    erOrSr,
    esOrSs;

<add:oz>
/// Object-Z constructs ///////////////////////////////////////////////
non terminal InheritedClass
    inheritedClass;

non terminal ActualParameters
    optActualParameters;

non terminal ClassPara
    class;

non terminal State
    state;

non terminal List
    stateDecl;

non terminal SecondaryAttributes
    secondaryDecl;

non terminal InitialState
    initialState;

non terminal Para
    unboxedLocalDefinition;

non terminal List /*Para*/
    localDefinitionList,
    unboxedLocalDefinitionBlock,
    unboxedLocalDefinitionList;

non terminal RefNameList 
    deltaList,
    visibilityList;
                        
non terminal FormalParameters
    classFormalParameters;

non terminal String
    visibility;

non terminal Expr
    opPromotionLhs;

non terminal OperationExpr
    operationExpression1;

non terminal AxPara
    boxedLocalDefinition;

non terminal List /*DeclName*/ 
    declNameList;

non terminal List /*InheritedClass*/ 
    inheritedList,
    inheritedClassList;

non terminal MainOpExpr
    mainOpExpression;

non terminal LocalDef
    localDefinitionBlock;

non terminal RenameList
    optRenameList;

non terminal Operation
    operation;

non terminal List /*Operation*/
    operationList;

non terminal OperationBox
    operationBox;

non terminal OperationExpr
    operationExpression;

non terminal Op 
    optNL,
    optSep;

</add:oz>
<add:tcoz>
non terminal List EventList;
 
non terminal Event event;
 
non terminal List Topology;
       
non terminal Connection connection;

/* non terminal ChannelType chantype;*/
</add:tcoz>

// These are ordered from loosest first to tightest last.
precedence right        BAR;
precedence left         TEXT;
precedence left         <add:tcoz>LPAREN,</add:tcoz> RPAREN;
precedence left         NL, SEMICOLON;
precedence nonassoc     DEFEQUAL;
precedence left         ALL, EXI, EXIONE, SPOT;
<add:tcoz>
precedence left 	_Guard;
</add:tcoz>
precedence left         IFF;
precedence right        IMP;
precedence left         OR;
precedence left         AND;
precedence right        NOT;
precedence left         MEM, EQUALS, PREP, LP, IP, EREP, SREP,
                        POSTP, ELP, ERP, SRP;
precedence right        LAMBDA;
precedence right        MU;
precedence right        LET;
<add:oz>
precedence left         ASSOCPARALLEL;
precedence left         PARALLEL<add:tcoz> , INTERLEAVE, INTERRUPT, TIMEOUT, TIMEEND</add:tcoz>;
precedence left         GCH <add:tcoz>, INTCHOICE </add:tcoz>;
</add:oz>
precedence right        ELSE;
precedence left         ZCOMP;
precedence left         ZPIPE;
precedence left         ZHIDE;
precedence left         ZPROJ;
precedence right        ZPRE;
precedence left         EL, ERE, SRE, I, CROSS;
precedence right        POWER, PRE, L;
precedence left         POST, ER, SR;
precedence left         _APPLICATION;
precedence left         INSTROKE, OUTSTROKE, NEXTSTROKE, NUMSTROKE;
precedence left         _RENAME;
precedence left         DOT;
precedence right        THETA;
precedence left         LSQUARE, RSQUARE;
precedence left         DECORWORD <add:tcoz>, INITWORD</add:tcoz>;


/// specifications /////////////////////////////////////////////////////////

input ::=
        narrSect:narr specification:s
        {:
           if (narr != null) {
             s.getSect().add(0, narr);
           }
           RESULT = s;
        :}
        ;

narrSect ::=
        //empty
        {:
           RESULT = null;
        :}
	|
	narrWordList:nwl
	{:
           NarrSect narrSect = factory_.createNarrSect(nwl);
           addLocAnn(narrSect, nwlleft, nwlright);
           RESULT = narrSect;
        :}
        ;

specification ::=
        // anonymous specification
        emptySectionHeader:header paragraphList:pl
        {:
           header.getPara().addAll(pl);
           RESULT = createSpec(list(header));
        :}
        |
        // sectioned specification
        sectionList:sl
        {:
           RESULT = createSpec(sl);
        :}
        ;

emptySectionHeader ::=
        //empty
        {:
           // Apply Syntactic Transformation Rule 12.2.1.1
           final String name = ANONYMOUS_SPEC_NAME;
           final Parent p = factory_.createParent(TOOLKIT);
           final List parents = list(p);
           resetOpTable(name, parents);
           RESULT = factory_.createZSect(name, parents, null);
        :}
        ;

sectionList ::= 
        sectionList:sl section:s
        {: 
           sl.add(s);
           RESULT = sl;
        :}
        |
        section:s
        {:
           RESULT = list(s); :}
        ;

section ::=
        sectionHeader:header paragraphList:pl
        {:
           header.getPara().addAll(pl);
           RESULT = header;
        :}
        ;

sectionHeader ::=
        //ZED token at the start of sections is ignored by
        //local_next_token to avoid a few problems
        SECTION:s DECORWORD:name parents:p END 
        {:
           resetOpTable(name, p);
           if (! name.equals(PRELUDE) &amp;&amp; p.isEmpty()) {
             Parent parent = factory_.createParent(PRELUDE);
             p.add(parent);
           }
           ZSect zSect = factory_.createZSect(name, p, null);
           addLocAnn(zSect, sleft, sright);
           RESULT = zSect;
        :}
        ;

parents ::=
        //empty
        {:
           RESULT = list();
        :}
        |
        PARENTS
        {:
           RESULT = list();
        :}
        |
        PARENTS parentList:pl
        {:
           RESULT = pl;
        :}
        ;

parentList ::=
        parentList:pl COMMA DECORWORD:dw
        {:
           Parent p = factory_.createParent(dw);
           addLocAnn(p, dwleft, dwright);
           pl.add(p);
           RESULT = pl;
        :}
        |
        DECORWORD:dw
        {:
           Parent p = factory_.createParent(dw);
           addLocAnn(p, dwleft, dwright);
           RESULT = list(p);
        :}
        ;


//paragraphs are divided into boxed and unboxed paragraphs. 
//Unboxed paragraphs must have a newline after their definition, 
//unless they are the final paragraph within ZED ... END tokens
paragraphList ::= 
        paragraphList:pl boxedParagraph:p
        {:
           pl.add(p);
           RESULT = pl;
        :}
        |
        paragraphList:pl unboxedParagraphList:upl
        {:
           pl.addAll(upl);
           RESULT = pl;
        :}
        |
        paragraphList:pl narrParagraph:np
        {:
           pl.add(np);
           RESULT = pl;
        :}
        |
        //empty
        {: RESULT = list(); :} %prec NL 
        ;


// 6.2 Global Paragraphs //////////////////////////////////////////////////////

boxedParagraph ::=
        axiomaticDefinition:ad
        {: RESULT = ad; :}
        |
        schema:s
        {: RESULT = s; :}
        |
        genericAxDefinition:gd
        {: RESULT = gd; :}
<add:oz>
        |
        class:c
        {: RESULT = c; :}
</add:oz>
        ;

narrParagraph ::=
        narrWordList:nwl
        {:
           NarrPara narrPara = factory_.createNarrPara(nwl);
           addLocAnn(narrPara, nwlleft, nwlright);
           RESULT = narrPara;
        :}
        ;

unboxedParagraphList ::=
        ZED unboxedParagraphItemList:uil END
        {: RESULT = uil; :}
        ;

unboxedParagraphItemList ::=
        unboxedParagraphItemList:uil NL unboxedParagraphItem:ui
        {:
           uil.add(ui);
           RESULT = uil;
        :}
        |
        unboxedParagraphItem:ui
        {:
           RESULT = list(ui);
        :}
        ;

unboxedParagraphItem ::=
        basicTypeDefinition:btd
        {: RESULT = btd; :}
        |
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        |
        freeTypeList:ftl
        {:
           FreePara freePara = factory_.createFreePara(ftl);
           addLocAnn(freePara, ftlleft, ftlright);
           RESULT = freePara;
        :}
        |
        optFormalParameters:ofp CONJECTURE predicate:p
        {:
           RESULT = factory_.createConjPara(ofp, p);
        :}
        |
        operatorTemplate:ot
        {:
           try {
             opTable_.add(ot);
           }
           catch (OpTable.OperatorException e) {
             final Symbol token = new Symbol(Sym.ZED, otleft, otright);
             parser.report_error(e.getMessage(), token);
             parser.report_fatal_error(e.getMessage(), token);
           }
           RESULT = ot;
        :}
        ;

basicTypeDefinition ::= 
        LSQUARE:lsquare nameList:nl RSQUARE
        {:
           GivenPara givenPara = factory_.createGivenPara(nl);
           addLocAnn(givenPara, lsquareleft, lsquareright);
           RESULT = givenPara;
        :}
        ;

schema ::=
        SCH:sch name:n optFormalParameters:ofp schemaText:st END
        {:
           AxPara axPara = factory_.createSchema(n, ofp, st);
           addLocAnn(axPara, schleft, schright);
           RESULT = axPara;
        :}
        |
        GENSCH:gensch name:n formalParameters:fp schemaText:st END
        {:
           AxPara axPara = factory_.createSchema(n, fp, st);
           addLocAnn(axPara, genschleft, genschright);
           RESULT = axPara;
        :}
        ;       

genericAxDefinition ::= 
        GENAX:genax formalParameters:fp schemaText:st END
        {:
           AxPara axPara = factory_.createAxPara(fp, st, Box.AxBox);
           addLocAnn(axPara, genaxleft, genaxright);
           RESULT = axPara;
        :}
        ;

optFormalParameters ::=
        formalParameters:fp
        {: RESULT = fp; :}
        |
        //empty
        {: RESULT = list(); :}
        ;

formalParameters ::= 
        LSQUARE nameList:nl RSQUARE
        {: RESULT = nl; :}
        ;

axiomaticDefinition ::= 
        AX:ax schemaText:st END
        {:
           AxPara axPara = factory_.createAxPara(null, st, Box.AxBox);
           RESULT = axPara;
        :}
        ;

//according to the Z ISO standard, an abbreviation definition is to be
//treated as an axiomatic definition, with ConstDecl(dn,e)
abbreviationDefinition ::=
        declName:dn DEFEQUAL:equal expression:e
        {:
           ConstDecl cd = factory_.createConstDecl(dn, e);
           addLocAnn(cd, equalleft, equalright);
           SchText st = factory_.createSchText(list(cd), null);
           addLocAnn(st, dnleft, dnright);
           RESULT = factory_.createAxPara(null, st, Box.OmitBox);      
        :}
        |
        //TODO: check this. Should be name:n, but the toolkit won't parse
        //"\langle \_ \rangle [X] == .... without this
        declName:dn formalParameters:fp DEFEQUAL:equal expression:e
        {:
           ConstDecl cd = factory_.createConstDecl(dn, e);
           addLocAnn(cd, equalleft, equalright);
           SchText st = factory_.createSchText(list(cd), null);
           addLocAnn(st, dnleft, dnright);
           RESULT = factory_.createAxPara(fp, st, Box.OmitBox);
        :}
        | 
        genName:gn DEFEQUAL:equal expression:e
        {:
           DeclName dn = (DeclName) gn.get(0);
           List fp = (List) gn.get(1);
           ConstDecl cd = factory_.createConstDecl(dn, e);
           addLocAnn(cd, equalleft, equalright);
           SchText st = factory_.createSchText(list(cd), null);
           AxPara axPara = factory_.createAxPara(fp, st, Box.OmitBox);
           addLocAnn(axPara, gnleft, gnright);
           RESULT = axPara;
        :}
        ;


freeTypeList ::=
        freeTypeList:ftl ANDALSO freeTypeDefinition:ftd
        {: 
           ftl.add(ftd);
           RESULT = ftl;
        :}
        |
        freeTypeDefinition:ftd
        {: RESULT = list(ftd); :}
        ;


freeTypeDefinition ::=
        name:n DEFFREE:deffree branchList:bl
        {:
           Freetype freetype = factory_.createFreetype(n, bl);
           addLocAnn(freetype, deffreeleft, deffreeright);
           RESULT = freetype;
        :}
        ;


branchList ::=
        branchList:bl BAR branch:b
        {:
           bl.add(b);
           RESULT = bl;
        :}
        |
        branch:b 
        {: RESULT = list(b); :}
        ;

branch ::=
        declName:dn
        {:
           Branch branch = factory_.createBranch(dn, null);
           addLocAnn(branch, dnleft, dnright);
           RESULT = branch;
        :}
        |
        declName:dn LDATA expression:e RDATA
        {:
           Branch branch = factory_.createBranch(dn, e);
           addLocAnn(branch, dnleft, dnright);
           RESULT = branch;
        :}
        ;

narrWordList ::=
        narrWordList:nwl TEXT:t
        {:
           nwl.add(t);
           RESULT = nwl;
        :}
        |
        TEXT:t
        {: RESULT = list(t); :}
        ;

// operator templates  /////////////////////////////////////////////////////

operatorTemplate ::=
        RELATION:rel template:t
        {:
           OptempPara otp =
             factory_.createOptempPara();
           otp.getOper().addAll(t);
           otp.setCat(Cat.Relation);
           addLocAnn(otp, relleft, relright);
           RESULT = otp;
        :}
        |
        FUNCTION:fun catTemplate:ct
        {:
           ct.setCat(Cat.Function);
           addLocAnn(ct, funleft, funright);
           RESULT = ct;
        :}
        |
        GENERIC:g catTemplate:ct
        {:
           ct.setCat(Cat.Generic);
           addLocAnn(ct, gleft, gright);
           RESULT = ct;
        :}
        ;

template ::=
        prefixTemplate:pt
        {: RESULT = pt; :}
        |
        postfixTemplate:pt
        {: RESULT = pt; :}
        |
        infixTemplate:it
        {: RESULT = it; :}
        |
        nofixTemplate:nt
        {: RESULT = nt; :}
        ;


catTemplate ::=
        prefixTemplate:pt
        {: 
           OptempPara otp = factory_.createOptempPara();
           otp.getOper().addAll(pt);
           RESULT = otp;
        :}
        |
        postfixTemplate:pt
        {: 
           OptempPara otp = factory_.createOptempPara();
           otp.getOper().addAll(pt);
           RESULT = otp;
        :}
        |
        NUMERAL:pr assoc:a infixTemplate:it
        {:
           OptempPara otp = factory_.createOptempPara();
           otp.setPrec(pr);
           otp.getOper().addAll(it);
           otp.setAssoc(a);
           RESULT = otp;
        :}
        |
        nofixTemplate:nt
        {:
           OptempPara otp = factory_.createOptempPara();
           otp.getOper().addAll(nt);
           RESULT = otp;
        :}
        ;


assoc ::=
        LEFTASSOC
        {: RESULT = Assoc.Left; :}
        |
        RIGHTASSOC
        {: RESULT = Assoc.Right; :}
        ;


prefixTemplate ::=
        LPAREN DECORWORD:n optWordOperandList:ol varg:v RPAREN
        {:
           ol.add(0, createOperator(n, nleft, nright));
           ol.add(v);
           RESULT = ol; 
        :}
	|
	LPAREN POWER:p varg:v RPAREN
	{:
           List l = list(createOperator(ZString.POWER, pleft, pright), v);
           RESULT = l;
	:}
        ;


postfixTemplate ::=
        LPAREN varg:v DECORWORD:n optWordOperandList:ol RPAREN
        {:
           ol.add(0, createOperator(n, nleft, nright));
           ol.add(0, v);
           RESULT = ol; 
        :}
        ;


infixTemplate ::=
        LPAREN varg:v1 DECORWORD:n optWordOperandList:ol varg:v2 RPAREN
        {:
           ol.add(0, createOperator(n, nleft, nright));
           ol.add(0, v1);
           ol.add(v2);
           RESULT = ol; 
        :}
        ;


nofixTemplate ::=
        LPAREN DECORWORD:n optWordOperandList:ol RPAREN:rp
        {:
           if (ol.size() &lt; 1) {
             final String message = "Syntax error " +
               "(ARG or LISTARG token expected but found RPAREN)";
             final Symbol token = new Symbol(Sym.RPAREN, rpleft, rpright);
             parser.report_error(message, token);
             parser.report_fatal_error(message, token);
           }
           ol.add(0, createOperator(n, nleft, nright));
           RESULT = ol;
        :}
        ;


optWordOperandList ::=
        //empty
        {: RESULT = list(); :}
        |
        optWordOperandList:wl templateTag:t DECORWORD:n
        {:
           wl.add(t);
           wl.add(createOperator(n, nleft, nright));
           RESULT = wl;
        :}
        ;

templateTag ::=
        varg:v
        {: RESULT = v; :}
        |
        LISTARG:listarg
        {:
           Operand operand = factory_.createOperand(Boolean.TRUE);
           RESULT = operand;
        :}
        ;

varg ::=
        ARG:arg
        {:
           Operand operand = factory_.createOperand(Boolean.FALSE);
           RESULT = operand;
        :}
        ;


/// schema text ///////////////////////////////////////////

schemaText ::= 
        optDeclPart:odp BAR predicate:p
        {: RESULT = factory_.createSchText(odp, p); :}
        |
        optDeclPart:odp
        {: RESULT = factory_.createSchText(odp, null); :}
        ;

optDeclPart ::=
        //empty
        {: RESULT = list(); :}
        |
        declPart:dp
        {: RESULT = dp; :}
        ;

declPart ::=
        declaration:d
        {: RESULT = list(d); :}
        |
        declPart:dp sep:s declaration:d
        {:
           dp.add(d);
           RESULT = dp;
        :}
        ;

declaration ::=
        basicDeclaration:bd
        {: RESULT = bd; :}
        |
        expression:e
        {: RESULT = factory_.createInclDecl(e); :}
        ;

expressionSchemaText ::=
	expression:e BAR predicate:p
	{:
           InclDecl id = factory_.createInclDecl(e);
           RESULT = factory_.createSchText(list(id), p);
        :}
	|
	expression:e
	{:
           InclDecl id = factory_.createInclDecl(e);
           RESULT = factory_.createSchText(list(id), null);
        :}
	;

schemaTextNoExpression ::=
        declPart:dp BAR predicate:p
        {: RESULT = factory_.createSchText(dp, p); :}
        |
	BAR predicate:p
        {: RESULT = factory_.createSchText(null, p); :}
        |
	declPart:dp sep declaration:d
	{:
           dp.add(d);
           RESULT = factory_.createSchText(dp, null);
	:}
	|
	basicDeclaration:bd
	{: RESULT = factory_.createSchText(list(bd), null); :}
        ;


basicDeclaration ::=
        declWordList:dwl COLON:colon expression:e
        {:
           VarDecl varDecl = factory_.createVarDecl(dwl, e);
           addLocAnn(varDecl, colonleft, colonright);
           RESULT = varDecl;
        :}
        |
        declName:dn DEFEQUAL:defequal expression:e
        {:
           ConstDecl constDecl = factory_.createConstDecl(dn, e);
           addLocAnn(constDecl, defequalleft, defequalright);
           RESULT = constDecl;
        :}
        ;       

sep ::=
        SEMICOLON
        {: RESULT = Op.Semi; :}
        |
        NL
        {: RESULT = Op.NL; :}
        ;

/// word, declName, and refName lists ////////////////////////////////////

nameList ::=
        nameList:nl COMMA DECORWORD:dw
        {: 
           DeclName dn = factory_.createDeclName(dw);
           addLocAnn(dn, dwleft, dwright);
           nl.add(dn);
           RESULT = nl;
        :}
        |
        DECORWORD:dw
        {: 
           DeclName dn = factory_.createDeclName(dw);
           addLocAnn(dn, dwleft, dwright);
           RESULT = list(dn);
        :}
        ;

name ::=
        DECORWORD:dw
        {:
           DeclName dn = factory_.createDeclName(dw);
           addLocAnn(dn, dwleft, dwright);
           RESULT = dn;
        :}
        ;

declWordList ::=
        declWordList:dwl COMMA DECLWORD:dw
        {: 
           DeclName dn = factory_.createDeclName(dw);
           addLocAnn(dn, dwleft, dwright);
           dwl.add(dn); 
           RESULT = dwl;
        :}
        |
        declWordList:dwl COMMA opName:on
        {: 
           dwl.add(strListToDeclName(on)); 
           RESULT = dwl;
        :}
        |
        opName:on
        {: RESULT = list(strListToDeclName(on)); :}
        |
        DECLWORD:dw
        {:
           DeclName dn = factory_.createDeclName(dw);
           addLocAnn(dn, dwleft, dwright);
           RESULT = list(dn); 
        :}
        ;


declName ::=
        DECORWORD:dw
        {:
           DeclName dn = factory_.createDeclName(dw);
           addLocAnn(dn, dwleft, dwright);
           RESULT = dn;
        :}
        |
        opName:on
        {:
           //because we return opNames as RefName instances, we must convert
           //to a DeclName
           RESULT = strListToDeclName(on);
        :}
        ;

refNameList ::=
        refNameList:rnl COMMA DECORWORD:dw
        {:
           RefName rn = factory_.createRefName(dw);
           addLocAnn(rn, dwleft, dwright);
           rnl.add(rn);
           RESULT = rnl;
        :}        
        <add:oz>
        |
        refNameList:rnl COMMA INITWORD:iw
        {:
           RefName rn = factory_.createRefName(OzString.INITWORD);
           addLocAnn(rn, iwleft, iwright);
           rnl.add(rn);
           RESULT = rnl;
        :}
        </add:oz>
        |
        DECORWORD:dw
        {:
           RefName rn = factory_.createRefName(dw);
           addLocAnn(rn, dwleft, dwright);
           RESULT = list(rn);
        :}
        <add:oz>
        |
        INITWORD:iw
        {:
           RefName rn = factory_.createRefName(OzString.INITWORD);
           addLocAnn(rn, iwleft, iwright);
           RESULT = list(rn);
        :}
        </add:oz>
        ;

refName ::=
        DECORWORD:dw
        {:
           RefName rn = factory_.createRefName(dw);
           addLocAnn(rn, dwleft, dwright);
           RESULT = rn;
        :}        
        <add:oz>
        |
        INITWORD:iw
        {:
           RefName rn = factory_.createRefName(OzString.INITWORD);
           addLocAnn(rn, iwleft, iwright);
           RESULT = rn;
        :}
        </add:oz>
        |
        LPAREN opName:on RPAREN
        {:
           DeclName declName = strListToDeclName(on);
           RefName rn = factory_.createRefName(declName.getWord(),
                                               declName.getStroke(),
                                               null);
           rn.getAnns().add(factory_.createParenAnn());
           RESULT = rn;
        :}
        ;


opName ::=
        prefixName:pn
        {: RESULT = pn; :}
        |
        postfixName:pn
        {: RESULT = pn; :}
        |
        infixName:in
        {: RESULT = in; :}
        |
        nofixName:nn
        {: RESULT = nn; :}
        ;

prefixName ::=
        PRE:p varg
        {: RESULT = list(p, ARG_TOK); :}
        |
        PREP:p varg
        {: RESULT = list(p, ARG_TOK); :}
        |
        L:l optVargEsSsList:ouesl argEreOrSre:aeos varg
        {: 
           List pName = list(l);
           pName.addAll(ouesl);
           pName.addAll(aeos);
           pName.add(ARG_TOK);
           RESULT = pName;
        :}
        |
        LP:lp optVargEsSsList:ouesl argErepOrSrep:aeos varg
        {: 
           List pName = list(lp);
           pName.addAll(ouesl);
           pName.addAll(aeos);
           pName.add(ARG_TOK);
           RESULT = pName;
        :}
        ;

postfixName ::=
        varg POST:p
        {: RESULT = list(ARG_TOK, p); :}
        |
        varg POSTP:p
        {: RESULT = list(ARG_TOK, p); :}
        |
        varg EL:el optVargEsSsList:ouesl argErOrSr:aeos
        {:
           List pName = list(ARG_TOK);
           pName.add(el);
           pName.addAll(ouesl);
           pName.addAll(aeos);
           RESULT = pName;
        :}
        |
        varg ELP:elp optVargEsSsList:ouesl argErpOrSrp:aeos
        {:
           List pName = list(ARG_TOK);
           pName.add(elp);
           pName.addAll(ouesl);
           pName.addAll(aeos);
           RESULT = pName;
        :}
        ;


infixName ::=
        varg I:i varg
        {:
           List iName = list(ARG_TOK);
           iName.add(i);
           iName.add(ARG_TOK);
           RESULT = iName;
        :}
        |
        varg IP:ip varg
        {:
           List iName = list(ARG_TOK);
           iName.add(ip);
           iName.add(ARG_TOK);
           RESULT = iName;
        :}
        |
        varg EL:el optVargEsSsList:ouesl argEreOrSre:aeos varg
        {:
           List iName = list(ARG_TOK);
           iName.add(el);
           iName.addAll(ouesl);
           iName.addAll(aeos);
           iName.add(ARG_TOK);
           RESULT = iName;
        :}
        |
        varg ELP:elp optVargEsSsList:ouesl argErepOrSrep:aeos varg
        {:
           List iName = list(ARG_TOK);
           iName.add(elp);
           iName.addAll(ouesl);
           iName.addAll(aeos);
           iName.add(ARG_TOK);
           RESULT = iName;
        :}
        ;

nofixName ::=
        L:l optVargEsSsList:ouesl argErOrSr:aeos
        {:
           List nName = list(l);
           nName.addAll(ouesl);
           nName.addAll(aeos);
           RESULT = nName;
        :}
        |
        LP:lp optVargEsSsList:ouesl argErpOrSrp:aeos
        {:
           List nName = list(lp);
           nName.addAll(ouesl);
           nName.addAll(aeos);
           RESULT = nName;
        :}
        ;

optVargEsSsList ::=
        //empty
        {: RESULT = list(); :}
        |
        optVargEsSsList:ouesl argEsOrSs:aeos
        {: 
           ouesl.addAll(aeos);
           RESULT = ouesl;
        :}
        ;

argEsOrSs ::=
        ARG ES:es
        {: RESULT = list(ARG_TOK, es); :}
        |
        LISTARG SS:ss
        {: RESULT = list(LISTARG_TOK, ss); :}
        ;

argEreOrSre ::=
        ARG ERE:ere
        {: RESULT = list(ARG_TOK, ere); :}
        |
        LISTARG SRE:sre
        {: RESULT = list(LISTARG_TOK, sre); :}
        ;

argErepOrSrep ::=
        ARG EREP:erep
        {: RESULT = list(ARG_TOK, erep); :}
        |
        LISTARG SREP:srep
        {: RESULT = list(LISTARG_TOK, srep); :}
        ;

argErOrSr ::=
        ARG ER:er
        {: RESULT = list(ARG_TOK, er); :}
        |
        LISTARG SR:sr
        {: RESULT = list(LISTARG_TOK, sr); :}
        ;

argErpOrSrp ::=
        ARG ERP:erp
        {: RESULT = list(ARG_TOK, erp); :}
        |
        LISTARG SRP:srp
        {: RESULT = list(LISTARG_TOK, srp); :}
        ;

//a genName is returned as a list of size 2, with the first being the
//name, and the second being a list of generic parameters
genName ::=
        prefixGenName:pgn
        {: RESULT = pgn; :}
        |
        postfixGenName:pgn
        {: RESULT = pgn; :}
        |
        infixGenName:ign
        {: RESULT = ign; :}
        |
        nofixGenName:ngn
        {: RESULT = ngn; :}
        ;

prefixGenName ::=
        PRE:pre formalParameterName:fpn
        {:
           List name = list(pre, ARG_TOK);
           RESULT = list(strListToDeclName(name), list(fpn));
        :}
        |
        L:l optNameEsSsList:onesl formalParameterName:fpn1
             ereOrSre:eos formalParameterName:fpn2
        {:
           //construct the name
           List name = list(l);
           name.addAll((List) onesl.get(1));
           name.add(ARG_TOK);
           name.add(eos);
           name.add(ARG_TOK);

           //construct the parameter list
           List fps = (List) onesl.get(0);
           fps.add(fpn1);
           fps.add(fpn2);

           RESULT = list(strListToDeclName(name), fps); 
        :}
        ;

postfixGenName ::=
        formalParameterName:fpn POST:p
        {:
           List name = list(ARG_TOK, p);
           RESULT = list(strListToDeclName(name), list(fpn));
        :}
        |
        formalParameterName:fpn1 EL:el optNameEsSsList:onesl 
           formalParameterName:fpn2 erOrSr:eos
        {:
           //construct the name
           List name = list(ARG_TOK);
           name.add(el);
           name.addAll((List) onesl.get(1));
           name.add(ARG_TOK);
           name.add(eos);

           //construct the parameter list
           List fps = list(fpn1);
           fps.addAll((List) onesl.get(0));
           fps.add(fpn2);

           RESULT = list(strListToDeclName(name), fps);
         :}
        ;

infixGenName ::=
        formalParameterName:fpn1 I:i formalParameterName:fpn2
        {:
           //construct the name
           List name = list(ARG_TOK);
           name.add(i);
           name.add(ARG_TOK);

           //construct the parameter list
           List fps = list(fpn1, fpn2);

           RESULT = list(strListToDeclName(name), fps);
        :}
        |
        formalParameterName:fpn1 EL:el optNameEsSsList:onesl 
           formalParameterName:fpn2 ereOrSre:eos formalParameterName:fpn3
        {:
           //construct the name
           List name = list(ARG_TOK);
           name.add(el);
           name.addAll((List) onesl.get(1));
           name.add(ARG_TOK);
           name.add(eos);
           name.add(ARG_TOK);

           //construct the parameter list
           List fps = list(fpn1);
           fps.addAll((List) onesl.get(0));
           fps.add(fpn2);
           fps.add(fpn3);

           RESULT = list(strListToDeclName(name), fps);
        :}
        ;

nofixGenName ::=
        L:l optNameEsSsList:onesl formalParameterName:fpn erOrSr:eos
        {:
           //construct the name
           List name = list(l);
           name.addAll((List) onesl.get(1));
           name.add(ARG_TOK);
           name.add(eos);

           //construct the parameter list
           List fps = (List) onesl.get(0);
           fps.add(fpn);

           RESULT = list(strListToDeclName(name), fps);
        :}
        ;

formalParameterName ::=
        DECORWORD:dw
        {: 
           RESULT = factory_.createDeclName(dw);
        :}
        ;

//an optNameEsSsList is returned as a list of size 2, with the first
//being a list comprising the list of generic parameters, and the
//second being a list comprising the name
optNameEsSsList ::=
        //empty
        {: RESULT = list(list(), list()); :}
        |
        optNameEsSsList:ouesl formalParameterName:fpn esOrSs:eos
        {:
           List gens = (List) ouesl.get(0);
           gens.add(fpn);
           List name = (List) ouesl.get(1);
           name.add(ARG_TOK);
           name.add(eos);
           RESULT = ouesl;
        :}
        ;


esOrSs ::=
        ES:es
        {: RESULT = es; :}
        |
        SS:ss
        {: RESULT = ss; :}
        ;

ereOrSre ::=
        ERE:ere
        {: RESULT = ere; :}
        |
        SRE:sre
        {: RESULT = sre; :}
        ;

erOrSr ::=
        ER:er
        {: RESULT = er; :}
        |
        SR:sr
        {: RESULT = sr; :}
        ;

/// predicates and expressions ///////////////////////////////////////////////

// This is for terms which MUST be predicates, so MIGHT contain NL/SEMI.
predicate ::=
        predicate:lhs sep:s term:rhs
        {:
           AndPred andPred = factory_.createAndPred(lhs, pred(rhs), s);
           addLocAnn(andPred, sleft, sright);
           RESULT = andPred;
        :}
        |
        term:p
        {: RESULT = pred(p); :}
        ;

expression ::=
        term:t
        {: RESULT = expr(t); :}
        ;

// This is for terms (which may be expr or pred) which MIGHT contain
// NL/SEMI.  If they do contain NL/SEMI, they must be predicates!
septerm ::=
        septerm:lhs sep:s term:rhs
        {:
           AndPred andPred = factory_.createAndPred(pred(lhs), pred(rhs), s);
           addLocAnn(andPred, sleft, sright);
           RESULT = andPred;
        :}
	|
	term:t
	{: RESULT = t; :}
	;

term ::=
        IF:i predicate:p THEN term:te ELSE term:fe
        {:
           CondExpr condExpr = factory_.createCondExpr(p, expr(te), expr(fe));
           addLocAnn(condExpr, ileft, iright);
           RESULT = condExpr;
        :}
        |
        ALL:all schemaText:st SPOT term:t
        {: 
           if (t instanceof Expr) {
             ForallExpr forallExpr = factory_.createForallExpr(st, expr(t));
             addLocAnn(forallExpr, allleft, allright);
             RESULT = factory_.createExprPred(forallExpr);
           }
           else {
             ForallPred forallPred = factory_.createForallPred(st, pred(t));
             addLocAnn(forallPred, allleft, allright);
             RESULT = forallPred;
           }
        :}
        |
        EXI:exi schemaText:st SPOT term:t
        {:
           if (t instanceof Expr) {
             ExistsExpr existsExpr = factory_.createExistsExpr(st, expr(t));
             addLocAnn(existsExpr, exileft, exiright);
             RESULT = factory_.createExprPred(existsExpr);
           }
           else {
             ExistsPred existsPred = factory_.createExistsPred(st, pred(t));
             addLocAnn(existsPred, exileft, exiright);
             RESULT = existsPred;
           }
        :}
        |
        EXIONE:exione schemaText:st SPOT term:t
        {: 
           if (t instanceof Expr) {
             Exists1Expr ee = factory_.createExists1Expr(st, expr(t));
             addLocAnn(ee, exioneleft, exioneright);
             RESULT = factory_.createExprPred(ee);
           }
           else {
             Exists1Pred exists1Pred = factory_.createExists1Pred(st, pred(t));
             addLocAnn(exists1Pred, exioneleft, exioneright);
             RESULT = exists1Pred;
           }
        :}
        |
        LAMBDA:lambda schemaText:st SPOT term:t
        {:
           LambdaExpr lambdaExpr = factory_.createLambdaExpr(st, expr(t));
           addLocAnn(lambdaExpr, lambdaleft, lambdaright);
           RESULT = lambdaExpr;
        :} %prec LAMBDA
        |
        MU:mu schemaText:st SPOT term:t
        {:
           MuExpr muExpr = factory_.createMuExpr(st, expr(t));
           addLocAnn(muExpr, muleft, muright);
           RESULT = muExpr;
        :} %prec MU
        |
        LET:let letDefinitionList:ldl SPOT term:t 
        {: 
           SchText st = factory_.createSchText(ldl, null);
           LetExpr letExpr = factory_.createLetExpr(st, expr(t));
           addLocAnn(letExpr, letleft, letright);
           RESULT = letExpr;
        :} %prec LET
        |
        term:lhs IFF:iff term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            IffExpr iffExpr = factory_.createIffExpr(expr(lhs), expr(rhs));
            addLocAnn(iffExpr, iffleft, iffright);
            RESULT = iffExpr;
          }
          else {
            IffPred iffPred = factory_.createIffPred(pred(lhs), pred(rhs));
            addLocAnn(iffPred, iffleft, iffright);
            RESULT = iffPred;
          }
        :}
        |
        term:lhs IMP:imp term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            ImpliesExpr impliesExpr =
              factory_.createImpliesExpr(expr(lhs), expr(rhs));
            addLocAnn(impliesExpr, impleft, impright);
            RESULT = impliesExpr;
          }
          else {
            ImpliesPred impliesPred =
              factory_.createImpliesPred(pred(lhs), pred(rhs));
            addLocAnn(impliesPred, impleft, impright);
            RESULT = impliesPred;
          }
        :}
        |
        term:lhs OR:or term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            OrExpr orExpr = factory_.createOrExpr(expr(lhs), expr(rhs));
            addLocAnn(orExpr, orleft, orright);
            RESULT = orExpr;
          }
          else {
            OrPred orPred = factory_.createOrPred(pred(lhs), pred(rhs));
            addLocAnn(orPred, orleft, orright);
            RESULT = orPred;
          }
        :}
        |
        term:lhs AND:and term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            AndExpr andExpr = factory_.createAndExpr(expr(lhs), expr(rhs));
            addLocAnn(andExpr, andleft, andright);
            RESULT = andExpr;
          }
          else {
            AndPred andPred =
              factory_.createAndPred(pred(lhs), pred(rhs), Op.And);
            addLocAnn(andPred, andleft, andright);
            RESULT = andPred;
          }
        :}
        |
        NOT:not term:t
        {:
          if (t instanceof Expr) {
            NegExpr negExpr = factory_.createNegExpr(expr(t));
            addLocAnn(negExpr, notleft, notright);
            RESULT = negExpr;
          }
          else {
            NegPred negPred = factory_.createNegPred(pred(t));
            addLocAnn(negPred, notleft, notright);
            RESULT = negPred;
          }
        :}
        |
        term:lhs ZCOMP:comp term:rhs
        {:
           CompExpr compExpr = factory_.createCompExpr(expr(lhs), expr(rhs));
           addLocAnn(compExpr, compleft, compright);
           RESULT = compExpr;
        :}
        |
        term:lhs ZPIPE:pipe term:rhs
        {:
           PipeExpr pipeExpr = factory_.createPipeExpr(expr(lhs), expr(rhs));
           addLocAnn(pipeExpr, pipeleft, piperight);
           RESULT = pipeExpr;
        :}
        |
        term:t ZHIDE:hide LPAREN refNameList:rnl RPAREN
        {:
           HideExpr hideExpr = factory_.createHideExpr(expr(t), rnl);
           addLocAnn(hideExpr, hideleft, hideright);
           RESULT = hideExpr;
        :}
        |
        term:lhs ZPROJ:proj term:rhs
        {:
           ProjExpr projExpr = factory_.createProjExpr(expr(lhs), expr(rhs));
           addLocAnn(projExpr, projleft, projright);
           RESULT = projExpr;
        :}
        |
        ZPRE:pre term:t
        {:
           PreExpr preExpr = factory_.createPreExpr(expr(t));
           addLocAnn(preExpr, preleft, preright);
           RESULT = preExpr;
        :}
        |
        POWER:power term:t
        {:
           PowerExpr powerExpr = factory_.createPowerExpr(expr(t));
           addLocAnn(powerExpr, powerleft, powerright);
           RESULT = powerExpr;
        :}
        |
<add:tcoz>
	term:t CHANTYPE:cht
	{:
	  if (cht.equals("actuator"))
	        RESULT = factory_.createChannelExpr((Expr)t, ChannelType.Actuator);        
	  else if (cht.equals("chan"))
	        RESULT = factory_.createChannelExpr((Expr)t, ChannelType.Chan); 
	  else if (cht.equals("sensor"))
   	        RESULT = factory_.createChannelExpr((Expr)t, ChannelType.Sensor); 
   	  else System.err.print("Errror occur for the channel type");
	:}
        |
        CHANTYPE : cht
	{: 
   	  if (cht.equals("actuator"))
   	        RESULT = factory_.createChannelExpr(null, ChannelType.Actuator);        
   	  else if (cht.equals("chan"))
   	        RESULT = factory_.createChannelExpr(null, ChannelType.Chan); 
   	  else if (cht.equals("sensor"))
      	        RESULT = factory_.createChannelExpr(null, ChannelType.Sensor); 
   	  else System.err.print("Errror occur for the channel type");
	:}
        |
</add:tcoz>
        prodExpressionList:pel
        {: RESULT = factory_.createProdExpr(pel); :}
        |
        relation:rel
        {: RESULT = rel; :}
        |
        application:a
        {: RESULT = a; :}
        |
        func_appl:fa
        {: RESULT = fa; :}
        ;

func_appl ::=
        func_appl:fa inner_term:it
        {:
           ApplExpr applExpr =
             factory_.createApplExpr(expr(fa), expr(it), Boolean.FALSE);
           addLocAnn(applExpr, faleft, itright);
           RESULT = applExpr;
        :} %prec _APPLICATION
        |
        inner_term:it
        {: RESULT = it; :} %prec _APPLICATION
        ;

inner_term ::=
        LBRACE:lbrace optExpressionList:oel RBRACE
        {:
           SetExpr setExpr = factory_.createSetExpr(oel);
           addLocAnn(setExpr, lbraceleft, lbraceright);
           RESULT = setExpr;
        :}
        |
        LBRACE:lbrace schemaTextNoExpression:stne SPOT expression:e RBRACE
        {:
           SetCompExpr setCompExpr = factory_.createSetCompExpr(stne, e);
           addLocAnn(setCompExpr, lbraceleft, lbraceright);
           RESULT = setCompExpr;
        :}
	|
	LBRACE:lbrace expressionSchemaText:est SPOT expression:e RBRACE
        {:
           SetCompExpr setCompExpr = factory_.createSetCompExpr(est, e);
           addLocAnn(setCompExpr, lbraceleft, lbraceright);
           RESULT = setCompExpr;
        :}
        |
        LBRACE:lbrace schemaTextNoExpression:stne RBRACE
        {:
           SetCompExpr setCompExpr = factory_.createSetCompExpr(stne, null);
           addLocAnn(setCompExpr, lbraceleft, lbraceright);
           RESULT = setCompExpr;
        :}
        |
        LPAREN expressionList:el COMMA expression:e RPAREN
        {: 
           el.add(e);
           RESULT = factory_.createTupleExpr(el);
        :}
        |
        LPAREN MU schemaText:st RPAREN
        {:
           MuExpr me = factory_.createMuExpr(st, null);
           me.getAnns().add(factory_.createParenAnn());
           RESULT = me;
        :}
        |
        nofixRel:nfr
        {: RESULT = nfr; :} %prec ERP
        |
        nofixApp:nfa
        {: RESULT = nfa; :} %prec _APPLICATION
        |
        LBIND:lbind optNameExprPairList:onepl RBIND
        {:
           BindExpr bindExpr = factory_.createBindExpr(onepl);
           addLocAnn(bindExpr, lbindleft, lbindright);
           RESULT = bindExpr;
        :}
        |
        LSQUARE:lsquare schemaTextNoExpression:stne RSQUARE
        {:
           SchExpr schExpr = factory_.createSchExpr(stne);
           addLocAnn(schExpr, lsquareleft, lsquareright);
           RESULT = schExpr;
        :}
        |
        inner_term:it DOT:dot refName:rn
        {:
           BindSelExpr bindSelExpr = factory_.createBindSelExpr(expr(it), rn);
           addLocAnn(bindSelExpr, dotleft, dotright);
           RESULT = bindSelExpr;
        :}
        |
        inner_term:it DOT:dot NUMERAL:n
        {:
           TupleSelExpr tupleSelExpr =
             factory_.createTupleSelExpr(expr(it), n);
           addLocAnn(tupleSelExpr, dotleft, dotright);
           RESULT = tupleSelExpr;
        :}
        |
        inner_term:it stroke:s
        {: RESULT = factory_.createDecorExpr(expr(it), s); :}
        |
        THETA:theta inner_term:it optStrokeList:sl
        {:
           ThetaExpr thetaExpr = factory_.createThetaExpr(expr(it), sl);
           addLocAnn(thetaExpr, thetaleft, thetaright);
           RESULT = thetaExpr;
        :}
        |
        inner_term:rn LSQUARE expressionList:el RSQUARE
        {: RESULT = factory_.createRefExpr(refname(rn), el, Boolean.FALSE); :}
        |
        inner_term:it LSQUARE renameList:rnl RSQUARE
        {: RESULT = factory_.createRenameExpr(expr(it), rnl); :} %prec _RENAME
        |
        NUMERAL:n
        {:
           NumExpr numExpr =
             factory_.createNumExpr(new BigInteger(n.toString()));
           addLocAnn(numExpr, nleft, nright);
           RESULT = numExpr;
        :}
        |
        LPAREN septerm:t RPAREN
        {:
           t.getAnns().add(factory_.createParenAnn());
           RESULT = t;
        :}
        |
        refName:rn
        {:
           RefExpr refExpr = factory_.createRefExpr(rn);
           addLocAnn(refExpr, rnleft, rnright);
           RESULT = refExpr;
        :}
        |
        TRUE:t
        {:
           TruePred truePred = factory_.createTruePred();
           addLocAnn(truePred, tright, tleft);
           RESULT = truePred;
        :}
        |
        FALSE:f
        {:
           FalsePred falsePred = factory_.createFalsePred();
           addLocAnn(falsePred, fleft, fright);
           RESULT = falsePred;
        :}
        ;

prodExpressionList ::=
        term:t1 CROSS term:t2
        {: RESULT = list(t1, t2); :}
        |
        prodExpressionList:pel CROSS term:t
        {:
           pel.add(t);
           RESULT = pel;
        :}
        ;

optExpressionList ::=
        //empty
        {: RESULT = list(); :}
        |
        expressionList:el
        {: RESULT = el; :}
        ;

expressionList ::=
        expressionList:el COMMA expression:e
        {:      
           el.add(e);
           RESULT = el;
        :} 
        |
        expression:e
        {: RESULT = list(e); :}
        ;


optNameExprPairList ::=
        //empty
        {: RESULT = list(); :}
        |
        nameExprPairList:nepl
        {: RESULT = nepl; :}
        ;

nameExprPairList ::=
        nameExprPairList:nepl COMMA nameExprPair:nep
        {:      
           nepl.add(nep);
           RESULT = nepl;
        :} 
        |
        nameExprPair:nep
        {: RESULT = list(nep); :}
        ;       

nameExprPair ::=
        declName:dn DEFEQUAL expression:e
        {: RESULT = factory_.createNameExprPair(dn, e); :}
        ;


letDefinitionList ::=
        letDefinitionList:ldl SEMICOLON letDefinition:ld
        {:
           ldl.add(ld);
           RESULT = ldl;
        :}
        |
        letDefinition:ld
        {: RESULT = list(ld); :}
        ;       

letDefinition ::=
        declName:n DEFEQUAL:defequal expression:e
        {:
           ConstDecl constDecl = factory_.createConstDecl(n,e);
           addLocAnn(constDecl, defequalleft, defequalright);
           RESULT = constDecl;
        :}
        ;

optStrokeList ::=
        optStrokeList:sl stroke:s
        {:
           sl.add(s);
           RESULT = sl;
        :}
        |
        //empty
        {: RESULT = list(); :} %prec INSTROKE
        ;

stroke ::=
        INSTROKE
        {: RESULT = factory_.createInStroke(); :}
        |
        OUTSTROKE
        {: RESULT = factory_.createOutStroke(); :}
        |
        NEXTSTROKE
        {: RESULT = factory_.createNextStroke(); :}
        |
        NUMSTROKE:ns
        {: RESULT = factory_.createNumStroke(ns); :}
        ;

renameList ::= 
        renameList:rl COMMA rename:rn
        {:
           rl.add(rn);
           RESULT = rl;
        :}
        |
        rename:rn  
        {: RESULT = list(rn); :}
        ;    

rename ::=
        declName:lhs SLASH refName:rhs
        {: RESULT = factory_.createNameNamePair(rhs, lhs); :}
        ;


//nofix relation is not included here because it has a different precedence
//than the other types of relation
relation ::=
        prefixRel:pr
        {: RESULT = pr; :}
        |
        postfixRel:pr
        {: RESULT = pr; :}
        |
        infixRel:ir
        {: RESULT = ir; :}
        ;

//according to the ISO standard, op e1 is equivalent to
//e mem op
prefixRel ::=
        PREP:p term:t
        {:
           List opName = list(p);
           opName.add(ARG_TOK);
           MemPred memPred = localCreateMemPred(opName, list(expr(t)));
           addLocAnn(memPred, pleft, pright);
           RESULT = memPred;
        :}
        |
        LP:lp expSep:es term:t1 EREP:erep term:t2
        {: 
           List opName = list(lp);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erep);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(expr(t1));
           expList.add(expr(t2));
           MemPred memPred = localCreateMemPred(opName, expList);
           addLocAnn(memPred, lpleft, lpright);
           RESULT = memPred;
        :}
        |
        LP:lp expSep:es optExpressionList:oel SREP:srep term:t
        {:
           List opName = list(lp);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srep);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(factory_.createSequence(oel));
           expList.add(expr(t));
           MemPred memPred = localCreateMemPred(opName, expList);
           addLocAnn(memPred, lpleft, lpright);
           RESULT = memPred;
        :}
        ;

postfixRel ::=
        term:t POSTP:p
        {:
           MemPred memPred = localCreateMemPred(list(p), list(expr(t)));
           addLocAnn(memPred, pleft, pright);
           RESULT = memPred;
        :}
        |
        term:t1 ELP:elp expSep:es term:t2 ERP:erp
        {:
           List opName = list(ARG_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erp);

           List expList = list(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           MemPred memPred = localCreateMemPred(opName, expList);
           addLocAnn(memPred, elpleft, elpright);
           RESULT = memPred;
        :}
        |
        term:t ELP:elp expSep:es optExpressionList:oel SRP:srp
        {:
           List opName = list(ARG_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srp);

           List expList = list(expr(t));
           addExpSepExp(expList, es);
           expList.add(factory_.createSequence(oel));
           MemPred memPred = localCreateMemPred(opName, expList);
           addLocAnn(memPred, elpleft, elpright);
           RESULT = memPred;
        :}
        ;

infixRel ::=
        infixChainRel:icr
        {: RESULT = icr; :}
        |
        term:t1 ELP:elp expSep:es term:t2 EREP:erep term:t3
        {:
           List opName = list(ARG_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erep);
           opName.add(ARG_TOK);

           List expList = list(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           expList.add(expr(t3));
           MemPred memPred = localCreateMemPred(opName, expList);
           addLocAnn(memPred, elpleft, elpright);
           RESULT = memPred;
        :}
        |
        term:t1 ELP:elp expSep:es optExpressionList:oel SREP:erep term:t2
        {:
           List opName = list(ARG_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(erep);
           opName.add(ARG_TOK);

           List expList = list(expr(t1));
           addExpSepExp(expList, es);
           expList.add(factory_.createSequence(oel));
           expList.add(expr(t2));
           MemPred memPred = localCreateMemPred(opName, expList);
           addLocAnn(memPred, elpleft, elpright);
           RESULT = memPred;
        :}
        ;

infixChainRel ::=
        term:lhs MEM:m term:rhs
        {:
           previousChain_ = Sym.MEM;
           MemPred memPred = factory_.createMemPred(expr(lhs), expr(rhs), Boolean.FALSE);
           addLocAnn(memPred, mleft, mright);
           RESULT = memPred;
        :}
        |
        term:lhs EQUALS:equals term:rhs
        {:
           previousChain_ = Sym.EQUALS;
           MemPred memPred = factory_.createEquality(expr(lhs), expr(rhs));
           addLocAnn(memPred, equalsleft, equalsright);
           RESULT = memPred;
        :}
        |
        term:lhs IP:ip term:rhs
        {:
           previousChain_ = Sym.IP;
           List opName = list(ARG_TOK);
           opName.add(ip);
           opName.add(ARG_TOK);
           MemPred memPred =
             localCreateMemPred(opName, list(expr(lhs), expr(rhs)));
           addLocAnn(memPred, ipleft, ipright);
           RESULT = memPred;
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr MEM term:rhs
        {:
           RESULT = transformChainRel(icr, Sym.MEM, expr(rhs));
           previousChain_ = Sym.MEM;
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr EQUALS term:rhs
        {:
           RESULT = transformChainRel(icr, Sym.EQUALS, expr(rhs));
           previousChain_ = Sym.EQUALS;
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr IP:ip term:rhs
        {:
           RESULT = transformChainRelInfix(icr, expr(rhs), ip);
           previousChain_ = Sym.IP;
        :}
        ;

nofixRel ::=
        LP:lp expSep:es term:t ERP:erp
        {:
           List opName = list(ARG_TOK);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erp);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(expr(t));
           MemPred memPred = localCreateMemPred(opName, expList);
           addLocAnn(memPred, lpleft, lpright);
           RESULT = memPred;
        :}
        |
        LP:lp expSep:es optExpressionList:oel SRP:srp
        {:
           List opName = list(ARG_TOK);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srp);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(factory_.createSequence(oel));
           MemPred memPred = localCreateMemPred(opName, expList);
           addLocAnn(memPred, lpleft, lpright);
           RESULT = memPred;
        :}
        ;


//nofix application is not included here because it has a different
//precedence to the other types of application
application ::=
        prefixApp:pa
        {: RESULT = pa; :}
        |
        postfixApp:pa
        {: RESULT = pa; :}
        |
        infixApp:ia
        {: RESULT = ia; :}
        ;

prefixApp ::=
        PRE:pre term:t
        {:
           Expr expr =
             localCreateMixfixExpr(list(pre, ARG_TOK), list(expr(t)));
           addLocAnn(expr, preleft, preright);
           RESULT = expr;
        :}
        |
        L:l expSep:es term:t1 ERE:ere term:t2
        {:
           List opName = list(l);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(ere);
           opName.add(ARG_TOK);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(expr(t1));
           expList.add(expr(t2));
           Expr expr = localCreateMixfixExpr(opName, expList);
           addLocAnn(expr, lleft, lright);
           RESULT = expr;
        :}
        |
        L:l expSep:es optExpressionList:oel SRE:sre term:t
        {:
           List opName = list(l);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sre);
           opName.add(ARG_TOK);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(factory_.createSequence(oel));
           expList.add(expr(t));
           Expr expr = localCreateMixfixExpr(opName, expList);
           addLocAnn(expr, lleft, lright);
           RESULT = expr;
        :}
        ;

postfixApp ::=
        term:t POST:post
        {:
           Expr expr =
             localCreateMixfixExpr(list(ARG_TOK, post), list(expr(t)));
           addLocAnn(expr, postleft, postright);
           RESULT = expr;
        :}
        |
        term:t1 EL:el expSep:es term:t2 ER:er
        {:
           List opName = list(ARG_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(er);

           List expList = list(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           Expr expr = localCreateMixfixExpr(opName, expList);
           addLocAnn(expr, elleft, elright);
           RESULT = expr;
        :}
        |
        term:t EL:el expSep:es optExpressionList:oel SR:sr
        {:
           List opName = list(ARG_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sr);

           List expList = list(expr(t));
           addExpSepExp(expList, es);
           expList.add(factory_.createSequence(oel));
           Expr expr = localCreateMixfixExpr(opName, expList);
           addLocAnn(expr, elleft, elright);
           RESULT = expr;
        :}
        ;

infixApp ::=
        term:lhs I:i term:rhs
        {: 
           List opName = list(ARG_TOK);
           opName.add(i);
           opName.add(ARG_TOK);
           Expr expr = localCreateMixfixExpr(opName, list(lhs, rhs));
           addLocAnn(expr, ileft, iright);
           RESULT = expr;
        :}
        |
        term:t1 EL:el expSep:es term:t2 ERE:ere term:t3
        {:
           List opName = list(ARG_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(ere);
           opName.add(ARG_TOK);

           List expList = list(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           expList.add(expr(t3));
           Expr expr = localCreateMixfixExpr(opName, expList);
           addLocAnn(expr, elleft, elright);
           RESULT = expr;
        :}
        |
        term:t1 EL:el expSep:es optExpressionList:oel SRE:sre term:t2
        {:
           List opName = list(ARG_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sre);
           opName.add(ARG_TOK);

           List expList = list(expr(t1));
           addExpSepExp(expList, es);
           expList.add(factory_.createSequence(oel));
           expList.add(expr(t2));
           Expr expr = localCreateMixfixExpr(opName, expList);
           addLocAnn(expr, elleft, elright);
           RESULT = expr;
        :}
        ;

nofixApp ::=
        L:l expSep:es term:t ER:er
        {:
           List opName = list(l);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(er);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(expr(t));
           Expr expr = localCreateMixfixExpr(opName, expList);
           addLocAnn(expr, lleft, lright);
           RESULT = expr;
        :}
        |
        L:l expSep:es optExpressionList:oel SR:sr
        {:
           List opName = list(l);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sr);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(factory_.createSequence(oel));
           Expr expr = localCreateMixfixExpr(opName, expList);
           addLocAnn(expr, lleft, lright);
           RESULT = expr;
        :}
        ;

expSep ::=
        //empty
        {: RESULT = list(); :} %prec I
        |
        expSep:exs term:t ES:es
        {:
           exs.add(list(expr(t)));
           exs.add(es);
           RESULT = exs;
        :}
        |
        expSep:exs expressionList:el SS:ss
        {:
           exs.add(el);
           exs.add(ss);
           RESULT = exs;
        :}
        ;

<add:oz>
/// Object-Z constructs ///////////////////////////////////////////////
class ::= 
        CLASS:c name:n
            classFormalParameters:fp
            visibilityList:vl
            inheritedList:il
            localDefinitionBlock:ldb
            state:s
            initialState:is
            operationList:ol
        END
        {:
           ClassPara classPara =
             factory_.createClassPara(n, fp, vl, il, ldb, s, is, ol);
           addLocAnn(classPara, cleft, cright);
           RESULT = classPara;
        :}
        ;

classFormalParameters ::=
        //empty
        {: RESULT = null; :}
        |
        formalParameters:fp
        {: RESULT = factory_.createFormalParameters(fp); :}
        ;


operationList ::=
        //empty
        {: RESULT = list(); :}
        |
        operationList:ol optNL operation:o
        {: 
           ol.add(o); 
           RESULT = ol;
        :}
        ;

optNL ::=
        //empty
        |
        NL
        ;

/// class paragraphs ///////////////////////////////////////////////

visibilityList ::=
        //empty
        {: RESULT = null; :}
        |
        visibility LPAREN refNameList:rnl RPAREN optNL
        {: RESULT = factory_.createRefNameList(rnl); :}
        ;

visibility ::=
        VISIBILITY
        |
        ZPROJ %prec VISIBILITY
        ;

inheritedList ::=
        //empty
        {: RESULT = list(); :}
        |
        INHERITS inheritedClassList:icl optNL
        {: RESULT = icl; :}
        ;

inheritedClassList ::=
        inheritedClassList:icl COMMA inheritedClass:ic
        {:
           icl.add(ic);
           RESULT = icl;
        :}
        |
        inheritedClass:ic
        {: RESULT = list(ic); :}
        ;

inheritedClass ::=
        refName:rn optActualParameters:oap optRenameList:ore
        {: RESULT = factory_.createInheritedClass(rn, oap, ore); :}
        ;

optActualParameters ::=
        //empty
        {: RESULT = null; :}
        |
        LSQUARE expressionList:el RSQUARE
        {: RESULT = factory_.createActualParameters(el); :}
        ;

optRenameList ::=
        //empty
        {: RESULT = null; :}
        |
        LSQUARE renameList:rnl  RSQUARE
        {: factory_.createRenameList(rnl); :}
        ;

localDefinitionBlock ::=
        // empty
        {: RESULT = null; :}
        |
        localDefinitionList:ldl
        {:
           //get the list of definitions and put them in lists depending on
           //their type...
           List axParaList = list();
           List freeTypeList = list();
           List basicTypeList = list();

           for (Iterator it = ldl.iterator(); it.hasNext(); ) {
               Object item = it.next();

               if (item instanceof AxPara) {
                   axParaList.add(item);
               }
               else if (item instanceof Freetype) {
                   freeTypeList.add(item);
               }
               else if (item instanceof GivenPara) {
                   basicTypeList.add(item);
               }
           }
           LocalDef localDef =
             factory_.createLocalDef(basicTypeList, axParaList, freeTypeList);
           RESULT = localDef;
        :}
        ;


localDefinitionList ::=
        localDefinitionList:ldl boxedLocalDefinition:bld
        {:
           ldl.add(bld);
           RESULT = ldl;
        :}
        |
        localDefinitionList:ldl unboxedLocalDefinitionBlock:uldb
        {: 
           ldl.addAll(uldb);
           RESULT = ldl;
        :}
	|
        boxedLocalDefinition:bld
	{: RESULT = list(bld); :}
        |
        unboxedLocalDefinitionBlock:uldb
        {: RESULT = uldb; :}
        ;

boxedLocalDefinition ::=
        axiomaticDefinition:ad
        {: RESULT = ad; :}
        |
        genericAxDefinition:gad
        {: RESULT = gad; :}
        ;

unboxedLocalDefinitionBlock ::=
        ZED unboxedLocalDefinitionList:uldl END
        {: RESULT = uldl; :}
        ;

unboxedLocalDefinitionList ::=
        unboxedLocalDefinitionList:uldl NL unboxedLocalDefinition:uld
        {:
           uldl.add(uld);
           RESULT = uldl;
        :}
        |
        unboxedLocalDefinition:uld
        {: RESULT = list(uld); :}
        ;

unboxedLocalDefinition ::=
        basicTypeDefinition:gtd
        {: RESULT = gtd; :}
        |
        freeTypeList:ftl
        {: RESULT = factory_.createFreePara(ftl); :}
        |
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        ;

state ::=
        // empty
        {: RESULT = null; :}
        |
        STATE stateDecl:sd BAR predicate:p END
        {:
           List dp = (List) sd.get(0);
           SecondaryAttributes sa = (SecondaryAttributes) sd.get(1);
           RESULT = factory_.createState(dp, sa, list(p));
        :}
        |
        STATE stateDecl:sd END
        {:
           List dp = (List) sd.get(0);
           SecondaryAttributes sa = (SecondaryAttributes) sd.get(1);
           RESULT = factory_.createState(dp, sa, null);
        :}
        | 
        LSQUARE stateDecl:sd BAR predicate:p RSQUARE
        {:
           List dp = (List) sd.get(0);
           SecondaryAttributes sa = (SecondaryAttributes) sd.get(1);
           RESULT = factory_.createState(dp, sa, list(p));
        :}
        |
        LSQUARE stateDecl:sd RSQUARE
        {:
           List dp = (List) sd.get(0);
           SecondaryAttributes sa = (SecondaryAttributes) sd.get(1);
           RESULT = factory_.createState(dp, sa, null);
        :}
        ;

//return a list with 2 elements: the declPart and the secondaryDecl
stateDecl ::=
        optDeclPart:odp
        {: RESULT = list(odp, null); :}
        |
        secondaryDecl:sd
        {: RESULT = list(list(), sd); :}
        |
        declPart:dp sep secondaryDecl:sd
        {: RESULT = list(dp, sd); :}
        ;

secondaryDecl ::=
        DELTA sep declPart:dp
        {: RESULT = factory_.createSecondaryAttributes(dp); :}
        ;

initialState ::=
        // empty
        {: RESULT = null; :}
        |
        INIT predicate:p END
        {: RESULT = factory_.createInitialState(list(p)); :}
        |
        INITWORD DEFEQUAL LSQUARE predicate:p RSQUARE
        {: RESULT = factory_.createInitialState(list(p)); :}
        ;

operation ::=
        SCH name:n operationBox:ob END
        {: RESULT = factory_.createOperation(n, ob); :}
        |
        OPSCH name:n operationBox:ob END
        {: RESULT = factory_.createOperation(n, ob); :}
        |
        declName:dn DEFEQUAL operationExpression:oe
        {: RESULT = factory_.createOperation(dn, oe); :}
        ;

operationBox ::=
        deltaList:dl sep:s declPart:dp BAR predicate:p
        {: RESULT = factory_.createOperationBox(dl, dp, list(p)); :}
        | 
        deltaList:dl sep:s declPart:dp
        {: RESULT = factory_.createOperationBox(dl, dp, null); :}
        |        
        deltaList:dl BAR predicate:p  
        {: RESULT = factory_.createOperationBox(dl, null, list(p)); :}
        | 
        deltaList:dl
        {: RESULT = factory_.createOperationBox(dl, null, null); :}
        | 
        declPart:dp BAR predicate:p
        {: RESULT = factory_.createOperationBox(null, dp, list(p)); :}
        | 
        declPart:dp
        {: RESULT = factory_.createOperationBox(null, dp, null); :}
        ;


operationExpression ::=
        DCNJ mainOpExpression:moe
        {: RESULT = factory_.createDistConjOpExpr(moe); :}
        |
        DGCH mainOpExpression:moe
        {: RESULT = factory_.createDistChoiceOpExpr(moe); :}
        |
        /*DSQC*/ ZCOMP mainOpExpression:moe
        {: RESULT = factory_.createDistSeqOpExpr(moe); :}
        |
        <add:tcoz>
        DSQC mainOpExpression:moe
        {: RESULT = factory_.createDistSeqOpExpr(moe); :}
        |
        DIC mainOpExpression:moe
        {: RESULT = factory_.createDistInChoiceProExpr(moe); :}
        |
        DIL mainOpExpression:moe
        {: RESULT = factory_.createDistInterleaveProExpr(moe); :}
        |
        </add:tcoz>
        operationExpression1:oe1
        {: RESULT = oe1; :}
        ;

mainOpExpression ::=
        schemaText:st SPOT operationExpression:oe
        {: RESULT = factory_.createMainOpExpr(st, oe); :}
        ;

operationExpression1 ::=
        LSQUARE deltaList:dl optSep schemaText:st RSQUARE
        {: RESULT = factory_.createBasicOpExpr(dl, st); :}
        |
        opPromotionLhs:oplhs DOT refName:rn
        {: RESULT = factory_.createOpPromotionExpr(oplhs, rn); :}
        |
        refName:rn
        {: RESULT = factory_.createOpPromotionExpr(null, rn); :}
        |
        operationExpression1:oe1 LSQUARE renameList:rnl RSQUARE
        {: RESULT = factory_.createRenameOpExpr(oe1, rnl); :}
        |
        operationExpression1:oe1 ZHIDE LPAREN declNameList:onl RPAREN
        {: RESULT = factory_.createHideOpExpr(oe1, onl);:}
        |
        operationExpression1:lhs AND operationExpression1:rhs
        {: RESULT = factory_.createConjOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs PARALLEL operationExpression1:rhs
        {: RESULT = factory_.createParallelOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs ASSOCPARALLEL operationExpression1:rhs
        {: RESULT = factory_.createAssoParallelOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs GCH operationExpression1:rhs
        {: RESULT = factory_.createExChoiceOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs ZCOMP operationExpression1:rhs
        {: RESULT = factory_.createSeqOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs SPOT operationExpression1:rhs
        {: RESULT = factory_.createScopeEnrichOpExpr(lhs, rhs); :}
        |
        LPAREN operationExpression:oe RPAREN
        {:
           oe.getAnns().add(factory_.createParenAnn());
           RESULT = oe;
        :}
        <add:tcoz>
        |
        //added for tcoz by Chen Chunqing (15/06/2004)
        DPARA LPAREN Topology:nt RPAREN
        {: RESULT = factory_.createTopologyProExpr(nt); :}
        |
        Topology:nt
        {: RESULT = factory_.createTopologyProExpr(nt); :}
        |
//        LSQUARE schemaText:st RSQUARE SPOT operationExpression:oe 
//        {: RESULT = factory_.createGuardProExpr(st, oe); :}%prec _Guard
//        | 
        operationExpression1:lhs INTCHOICE operationExpression1:rhs
        {: RESULT = factory_.createInChoiceProExpr(lhs, rhs); :}
        |
        operationExpression1:lhs INTERLEAVE operationExpression1:rhs
        {: RESULT = factory_.createInterleaveProExpr(lhs, rhs); :}
        |
        operationExpression1:lhs PARALLEL LSQUARE EventList:ets RSQUARE operationExpression1:rhs
        {: EventSet es = factory_.createEventSet(ets);
            RESULT = factory_.createSynPllProExpr(lhs, rhs, es); :}
        |
        operationExpression1:lhs TIMEOUT LSQUARE expression:exp RSQUARE operationExpression1:rhs
        {: RESULT = factory_.createTimeoutStartProExpr(lhs, (Expr1)exp, rhs); :}
        |
        operationExpression1:lhs TIMEEND LBRACE expression:exp RBRACE operationExpression1:rhs
        {: RESULT = factory_.createTimeoutEndProExpr(lhs, (Expr1)exp, rhs); :}
        |
        operationExpression1:lhs INTERRUPT LBRACE expression:exp RBRACE operationExpression1:rhs
        {: RESULT = factory_.createInterruptProExpr(lhs, (Expr1)exp, rhs); :}
        |
        operationExpression1:oexp SPOT DEADLINE expression:deadline
        {: RESULT = factory_.createDeadlineProExpr(oexp, (Expr1)deadline); :}
        | 
        operationExpression1:oexp SPOT WAITUNTIL expression:deadline
        {: RESULT = factory_.createWaitUntilProExpr(oexp, (Expr1)deadline); :}
        |
        WAIT expression:time
        {: RESULT = factory_.createWaitProExpr(time); :}
        |
        event:et NEXTPRO operationExpression1:oexp
        {: RESULT = factory_.createAtProExpr(et, null, oexp); :}
        |
        event:et ATTIME expression:exp NEXTPRO operationExpression1:oexp
        {: RESULT = factory_.createAtProExpr(et, exp, oexp); :}
        |        
        MU refName:rn SPOT operationExpression1:oexp
        {: RESULT = factory_.createRecProExpr(rn, oexp); :}        
       </add:tcoz>        
        ;

<add:tcoz>
//added for handling network topology by Chen Chunqing (15/06/2004)
Topology ::= Topology:tp COMMA connection:cn
                 {: tp.add(cn);
                    RESULT = tp; 
                 :}
                 |
                 connection:cn
                 {: RESULT = list(cn); :}
                 ;
                 
connection ::= NETTOPOLOGY 
                  //has problem here
                   {: RESULT = factory_.createConnection(); :}
                   ;
                   
//added for handling Event list by Chen Chunqing (15/06/2004)
EventList ::= EventList: el COMMA event:e
                 {: el.add(e);
                    RESULT = el; 
                 :}
                 |
                 event:e
                 {: RESULT = list(e); :}
                 ;
                
event ::= refName:rn DOT expression:exp
            {: RESULT = factory_.createEvent(rn, exp); :}
            |
            refName:rn 
            {: RESULT = factory_.createEvent(rn, null); :}
            ;
            
</add:tcoz>


optSep ::=
        optNL
        |
        SEMICOLON
        ;

declNameList ::=
        declNameList:dnl COMMA declName:dn
        {:
           dnl.add(dn);
           RESULT = dnl;
        :}
        |
        declName:dn
        {: RESULT = list(dn); :}
        ;

opPromotionLhs ::=
        refName:rn
        {: RESULT = factory_.createRefExpr(rn, null, Boolean.FALSE); :}
        |
        opPromotionLhs:oplhs DOT refName:rn
        {: RESULT = factory_.createBindSelExpr(oplhs, rn); :}
        ;

deltaList ::=
        //empty
        {: RESULT = null; :}
        |
        DELTA LPAREN refNameList:rnl RPAREN
        {: RESULT = factory_.createRefNameList(rnl); :}
        ;
</add:oz>
</parser>
