<?xml version="1.0" encoding="utf-8"?>
<!--
     Copyright (C) 2003, 2004, 2005 Petra Malik, Tim Miller
     This file is part of the CZT project: http://czt.sourceforge.net

     The CZT project contains free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License as published
     by the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     The CZT project is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License along
     with CZT; if not, write to the Free Software Foundation, Inc.,
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<scanner xmlns:add="http://czt.sourceforge.net/templates/additional">
/* --------------------------Usercode Section------------------------ */
package <package/>;

import java.io.*;
import java.net.URL;
import java.util.Map;
import java.util.Properties;
import java.util.Stack;
import java.util.logging.Logger;

import java_cup.runtime.*;

<add:oz>
import net.sourceforge.czt.oz.util.OzString;
</add:oz>
<add:tcoz>
import net.sourceforge.czt.tcoz.util.TcozString;
</add:tcoz>

import net.sourceforge.czt.util.CztLogger;
import net.sourceforge.czt.z.util.ZString;
import net.sourceforge.czt.parser.util.LatexCommand;
import net.sourceforge.czt.parser.util.LatexMarkupFunction;
import net.sourceforge.czt.parser.util.LatexSym;
import net.sourceforge.czt.parser.util.ScanException;

/**
 * &lt;p&gt;
*   The low-level latex to unicode scanner for <add:oz>Object </add:oz>Z<add:tcoz> and TCOZ</add:tcoz>.
 *   See {@link LatexToUnicode} for a high level latex to unicode converter.
 * &lt;/p&gt;
 * &lt;p&gt;
 *   This is a JFlex generated scanner for translating
 *   <add:oz>Object </add:oz>Z
 *   specifications written in the latex mark-up language into unicode.
 *   It provides tokens (instances of class {@link Symbol}) whos values
 *   are unicode strings and which contain line and column number
 *   information of the original latex file or stream.
 *   See {@link LatexSym} for a list of possible token kinds.
 * &lt;/p&gt;
 * &lt;p&gt;
 *   In order to work properly, a map containing the latex mark-up function
 *   of the current section to be scanned is needed.  This map must be
 *   updated when a new section header is recognised.
 *   The {@link net.sourceforge.czt.parser.util.LatexMarkupParser} is
 *   responsible for this task, and should process the output of an instance
 *   of this class before it can be processed further.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Limitations:
 * &lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;
 *     The name of a generic schema definition should not contain
 *     nested braces.
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *     Latex markup directive are only recognised outside of a formal section
 *     or paragraph.
 *   &lt;/li&gt;
 * &lt;/ul&gt;
 */
%%

/* -----------------Options and Declarations Section----------------- */

%class <class/>
%public
%unicode
%line
%column
%implements net.sourceforge.czt.parser.util.LatexMarkupParser.LatexScanner
%cupsym LatexSym
%cup

%{
  public static final String PROP_ADD_SPACE_BEFORE_PUNCTATION =
    "add_space_before_punctation";

  private static final Logger LOGGER = CztLogger.getLogger(<class/>.class);

  /**
   * &lt;p&gt;
   * The latex markup function for the current section to be scanned.
   * It must be kept up to date by another class that recognises
   * section headers.
   * &lt;/p&gt;
   */
  private LatexMarkupFunction latexCommands_ = null;

<add:oz>
  /**
   * Records whether the current paragraph is nested within an
   * Object-Z class paragraph
   */
  private boolean nested_ = false;
</add:oz>

  /**
   * A stack of BraceType.
   * Each "{"-token pushs a BraceType on the stack,
   * each "}"-token pops a BraceType from the stack.
   *
   * A "^"-token followed by "{"-token pushs
   * a &lt;code&gt;BraceType.SUPER&lt;/code&gt;
   * (no space to be inserted after the scripts)
   * or &lt;code&gt;BraceType.SUPER_SPACE&lt;/code&gt;
   * (space has to be inserted after
   * the scripts) on the stack.  A "_"-token followed by "{"-token pushs
   * a &lt;code&gt;BraceType.SUB&lt;/code&gt;
   * (no space to be inserted after the scripts)
   * or &lt;code&gt;BraceType.SUB_SPACE&lt;/code&gt;
   * (space has to be inserted after
   * the scripts) on the stack.  All other "{"-token just push a
   * &lt;code&gt;BraceType.BRACE&lt;/code&gt; on the stack.
   */
  private Stack braceStack_ = new Stack();

  /**
   * A boolean indicating whether a space has to inserted after all
   * following subscripts and superscripts.
   */
  private boolean addSpace_ = false;

  /**
   * A flag telling whether the next "}" is tranlated into space or not.
   * This is used when a /begin{schema} is found. This is followed by
   * {NAME} and the "}" should be translated into space.
   */
  private boolean braceToSpace_ = false;

  /**
   * True iff we are scanning a directive.
   */
  private boolean directive_ = false;

  /**
   * The name of the file to be scanned.
   * This is used when warnings are printed.
   */
  private String source_ = null;

  private boolean addSpaceBeforePunctation_ = false;

  /**
   * Creates a new scanner for the given URL.
   */
  public <class/>(URL url, Properties properties)
    throws IOException
  {
    this(url.openStream());
    source_ = url.toString();
    addSpaceBeforePunctation_ =
      "true".equals(properties.getProperty(PROP_ADD_SPACE_BEFORE_PUNCTATION));
  }

  public <class/>(Reader in, Properties properties)
  {
    this(in);
    addSpaceBeforePunctation_ =
      "true".equals(properties.getProperty(PROP_ADD_SPACE_BEFORE_PUNCTATION));
  }

  /**
   * Prints the given message to the output stream.
   */
  private Symbol result(String message)
    throws IOException
  {
    return new Symbol(LatexSym.UNICODE, yyline, yycolumn, message);
  }

  /**
   * Writes a space to the output and sets
   * &lt;code&gt;addSpace_&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;
   * if &lt;code&gt;addSpace_&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.
   * Does nothing if &lt;code&gt;addSpace_&lt;/code&gt; is
   * &lt;code&gt;false&lt;/code&gt;.
   */
  private String addSpace()
    throws IOException
  {
    if (addSpace_) {
      addSpace_ = false;
      return ZString.SPACE;
    }
    return "";
  }

  /**
   * Returns a north east arrow if &lt;code&gt;string&lt;/code&gt;
   * equals "^" and a south east arrow if
   * &lt;code&gt;string&lt;/code&gt; equalas "_".
   * Throws an IllegalArgumentException for all other strings.
   */
  private String beginScript(String string)
  {
    if ("^".equals(string)) return ZString.NE;
    if ("_".equals(string)) return ZString.SE;
    throw new IllegalArgumentException();
  }

  /**
   * Returns a south west arrow if &lt;code&gt;string&lt;/code&gt;
   * equals "^" and a north west arrow if
   * &lt;code&gt;string&lt;/code&gt; equalas "_".
   * Throws an IllegalArgumentException for all other strings.
   */
  private String endScript(String string)
  {
    if ("^".equals(string)) return ZString.SW;
    if ("_".equals(string)) return ZString.NW;
    throw new IllegalArgumentException();
  }

  /**
   * Returns the latex mark-up function.
   * @see #setMarkupFunction
   */
  public LatexMarkupFunction getMarkupFunction()
  {
    return latexCommands_;
  }

  /**
   * Sets the latex mark-up function.  This is a mapping
   * from string (representing a latex command)
   * to {@link LatexCommand} containing the unicode representation.
   *
   * This map must be kept up to date to ensure proper working of
   * instances of this class.
   */
  public void setMarkupFunction(LatexMarkupFunction markupFunction)
  {
    latexCommands_ = markupFunction;
  }

  /**
   * Returns the source of the file that is currently scanned.
   * @see #setSource
   */
  public String getSource()
  {
    return source_;
  }

  /**
   * Sets the source to be scanned.
   *
   * This information is only needed by instances of this class
   * when warning or information messages are provided.
   */
  public void setSource(String source)
  {
    source_ = source;
  }

  /**
   * Returns an unicode string representation of the given latex
   * command.
   *
   * @param latexCommand the latex command.
   * @param spaces indicates whether spaces should be added or not.
   * @return the unicode represention of the given latex command,
   *          or null if the command cannot be found.  Spaces are
   *          added (depending on the type of the command) if spaces
   *          is true.
   */
  private String toUnicode(String latexCommand, boolean spaces)
  {
    if (latexCommands_ == null) {
      System.out.println("Should not happen");
      return null;
    }
    LatexMarkupFunction.MarkupDirective directive =
      (LatexMarkupFunction.MarkupDirective)
      latexCommands_.getCommandDirective(latexCommand);
    if (directive == null) {
      return null;
    }
    String result = directive.getUnicode();
    if (spaces) {
      if (directive.addLeftSpace()) result = ZString.SPACE + result;
      if (directive.addRightSpace()) addSpace_ = true;
    }
    return result;
  }

  /**
   * Adds line and column information and, if possible, file name information
   * to a given message.
   */
  private String getMessage(String message)
  {
    StringBuffer result = new StringBuffer();
    result.append(message + " at line " + yyline + " column " + yycolumn);
    if (source_ != null) {
      result.append(" in " + source_);
    }
    return result.toString();
  }

  private void unknownLatexCommand(String command)
  {
    String message = getMessage("Unknown latex command " + command);
    LOGGER.warning(message);
  }

  /**
   * A typesafe enumeration of brace types.
   */
  public static final class BraceType
  {
    /**
     * Subscript enclosed in braces.
     */
    public final static BraceType SUB = new BraceType("SUB");

    /**
     * Superscript enclodes in braces.
     */
    public final static BraceType SUPER = new BraceType("SUPER");

    /**
     * Subscript enclosed in braces and space has to be added after
     * all superscripts and subscripts.
     */
    public final static BraceType SUB_SPACE = new BraceType("SUB_SPACE");

    /**
     * Superscript enclosed in braces and space has to be added after
     * all superscripts and subscripts.
     */
    public final static BraceType SUPER_SPACE = new BraceType("SUPER_SPACE");
    /**
     * All remaining braces.
     */
    public final static BraceType BRACE = new BraceType("BRACE");
    private final String name_;

    /**
     * Only this class can construct instances.
     */
    private BraceType(String name)
    {
      name_ = name;
    }

    public String toString()
    {
      return name_;
    }

    public final int hashCode()
    {
      return super.hashCode();
    }

    public final boolean equals(Object o)
    {
      return super.equals(o);
    }

    public static BraceType fromString(String value)
    {
      if (value.equals("BRACE")) {
        return BRACE;
      }
      if (value.equals("SUB")) {
        return SUB;
      }
      if (value.equals("SUPER")) {
        return SUPER;
      }
      if (value.equals("SUB_SPACE")) {
        return SUB_SPACE;
      }
      if (value.equals("SUPER_SPACE")) {
        return SUB_SPACE;
      }
      throw new IllegalArgumentException();
    }
  }
%}




/* white spaces */
NL = "\n" | "\r" | "\r\n"
WS = [\ \t\b\012] | {NL}

/* hard spaces */
HS = "~" | "\\," | "\\:" | "\\;" | "\\ "
  | "\\t1" | "\\t2" | "\\t3" | "\\t4" | "\\t5" | "\\t6" | "\\t7"
  | "\\t8" | "\\t9"
NOT_NL = !(![^] | {NL})
COMMENT = "%" ~{NL}
IGNORE = {WS} | {COMMENT}

LETTER = [a-zA-Z]
NOT_LETTER = !(![^] | {LETTER})

COMMAND = "\\" . | "\\" {LETTER}*
SCRIPT = "^" | "_"
FUNCTION = "*" | "+" | "|"
PUNCTATION = ";" | ","
RELATION = ":" | "&lt;" | "=" | "&gt;"

START_COMMENT = "%"
CHAR_MARKUP = "%%Zchar" {NOT_NL}* {NL}?
         | "%%Zinchar" {NOT_NL}* {NL}?
         | "%%Zprechar" {NOT_NL}* {NL}?
         | "%%Zpostchar" {NOT_NL}* {NL}?
WORD_MARKUP = "%%Zword"
INWORD_MARKUP = "%%Zinword"
PREWORD_MARKUP = "%%Zpreword"
POSTWORD_MARKUP = "%%Zpostword"

SPECIAL = "\\" | "%"
NOT_SPECIAL = !(![^] | {SPECIAL})
TEXT = {NOT_SPECIAL}*

NOT_LB = !(![^] | "{")
NAME =   {NOT_LB}*
       | {NOT_LB}* "{" {NOT_LB}* "}" {NOT_LB}*
%state ZED
%state MARKUP
%state COMMENT_STATE

%%
/* ------------------------Lexical Rules Section---------------------- */

&lt;YYINITIAL&gt; {
  "\\begin" {IGNORE}* "{axdef}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          return result(ZString.AX);
        }
  "\\begin" {IGNORE}* "{gendef}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          return result(ZString.GENAX);
        }
  "\\begin" {IGNORE}* "{schema}" / {IGNORE}* "{" {NAME} "}" {IGNORE}* "["
        {
          yybegin(ZED);
          assert ! addSpace_;
          braceToSpace_ = true;
          return result(ZString.SCHCHAR + ZString.GENCHAR);
        }
  "\\begin" {IGNORE}* "{schema}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          braceToSpace_ = true;
          return result(ZString.SCH);
        }
  "\\begin" {IGNORE}* "{zed}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          return result(ZString.ZED);
        }
  "\\begin" {IGNORE}* "{zsection}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          return new Symbol(LatexSym.SECT, yyline, yycolumn, ZString.ZED);
        }
<add:oz>
  "\\begin" {IGNORE}* "{class}"
        {
          yybegin(ZED);
          nested_ = true;
          assert ! addSpace_;
          braceToSpace_ = true;
          String result = ZString.SCH + ZString.SPACE + "class" + ZString.SPACE;
          return result(result);
        }
</add:oz>
  ^{CHAR_MARKUP}
        {
          return new Symbol(LatexSym.CHAR_MARKUP, yyline, yycolumn, yytext());
        }
  ^{WORD_MARKUP}
        {
          yybegin(MARKUP);
          directive_ = true;
          return new Symbol(LatexSym.WORD_MARKUP, yyline, yycolumn);
        }
  ^{INWORD_MARKUP}
        {
          yybegin(MARKUP);
          directive_ = true;
          return new Symbol(LatexSym.INWORD_MARKUP, yyline, yycolumn);
        }
  ^{PREWORD_MARKUP}
        {
          yybegin(MARKUP);
          directive_ = true;
          return new Symbol(LatexSym.PREWORD_MARKUP, yyline, yycolumn);
        }
  ^{POSTWORD_MARKUP}
        {
          yybegin(MARKUP);
          directive_ = true;
          return new Symbol(LatexSym.POSTWORD_MARKUP, yyline, yycolumn);
        }
  {START_COMMENT}
        {
          yybegin(COMMENT_STATE);
        }
  {TEXT}
        {
          return new Symbol(LatexSym.TEXT, yyline, yycolumn, yytext());
        }
  [^]
        {
          return new Symbol(LatexSym.TEXT, yyline, yycolumn, yytext());
        }
}

&lt;ZED&gt; {
  {NL}
        {
          if (directive_) {
            yybegin(YYINITIAL);
            directive_ = false;            
            addSpace_ = false; // TODO: what about spaces?
            return new Symbol(LatexSym.END_MARKUP, yyline, yycolumn);
          }
        }

  {IGNORE}
        {
          /* ignore whitespace (except NL) and comments */
        }
  {HS}
        {
          String result = addSpace();
          result += ZString.SPACE;
          return result(result);
        }
  "\\\\" | "\\also" | "\\znewpage"
        {
          String result = addSpace();
          return result(result + ZString.NLCHAR);
        }
  "\\end" {IGNORE}* ("{axdef}"|"{gendef}"|"{schema}"|"{zed}"|"{zsection}")
        {
<add:oz>
          if (!nested_) {
</add:oz>
             yybegin(YYINITIAL);
<add:oz>
          }
</add:oz>
          String result = addSpace() + ZString.END;
          return new Symbol(LatexSym.END, yyline, yycolumn, result);
        }
<add:oz>
  "\\begin" {IGNORE}* "{axdef}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          return result(ZString.AX);
        }
  "\\begin" {IGNORE}* "{gendef}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          return result(ZString.GENAX);
        }
  "\\begin" {IGNORE}* "{op}"
 	{
 	 yybegin(ZED);
 	 assert ! addSpace_;
	 braceToSpace_ = true;
	 return result(ZString.SCH);
        }
  "\\begin" {IGNORE}* "{schema}"
        {
          yybegin(ZED);
          assert ! addSpace_;
          braceToSpace_ = true;
          return result(ZString.SCH);
        }
  "\\begin" {IGNORE}* ("{zed}" | "{zsection}")
        {
          yybegin(ZED);
          assert ! addSpace_;
          return result(ZString.ZED);
        }
  "\\end" {IGNORE}* "{class}"
        {
          yybegin(YYINITIAL);
          nested_ = false;
          String result = addSpace();
          return result(result + ZString.END);
        }
  "\\end" {IGNORE}* ("{state}"|"{init}"|"{op}")
        {
          String result = addSpace();
          return result(result + ZString.END);
        }
  "\\begin" {IGNORE}* "{state}"
        {
          String result = addSpace();
          return result(result + ZString.SCH + ZString.ZEDCHAR);
        }
  "\\begin" {IGNORE}* "{init}"
        {
          String result = addSpace();
          return result(result + ZString.SCH + ZString.SPACE + OzString.INITWORD + ZString.SPACE);
        }
</add:oz>
  "\\where"
        {
          String result = addSpace();
          return result(result + ZString.SPACE + ZString.VL + ZString.SPACE);
        }
  "@"
        {
          String result = addSpace();
          return result(result + ZString.SPACE + ZString.SPOT + ZString.SPACE);
        }
  "'"
        {
          String result = addSpace();
          return result(result + ZString.PRIME);
        }
  "-"
        {
          String result = addSpace();
          return result(result + ZString.SPACE + ZString.MINUS + ZString.SPACE);
        }
  {SCRIPT} {IGNORE}* ({RELATION}|{PUNCTATION}|{FUNCTION}|{LETTER}|[0-9])
        {
          String script = yytext().substring(0, 1);
          return result(beginScript(script)
                        + yytext().substring(yytext().length() - 1)
                        + endScript(script));
        }
  {SCRIPT} {IGNORE}* {COMMAND}
        {
          String result = "";
          String script = yytext().substring(0, 1);
          String command = yytext().substring(yytext().indexOf("\\"));
          String zstring = toUnicode(command, false);
          result += beginScript(script);
          if (zstring != null) {
            result += zstring;
          } else {
            unknownLatexCommand(command);
            result += command.substring(1);
          }
          result += endScript(script);
          return result(result);
        }
  {SCRIPT} {IGNORE}* "{"
        {
          String script = yytext().substring(0, 1);
          if ("^".equals(script)) {
            if (addSpace_) {
              braceStack_.push(BraceType.SUPER_SPACE);
            } else {
              braceStack_.push(BraceType.SUPER);
            }
          } else if ("_".equals(script)) {
            if (addSpace_) {
              braceStack_.push(BraceType.SUB_SPACE);
            } else {
              braceStack_.push(BraceType.SUB);
            }
          }
          addSpace_ = false;
          return result(beginScript(script));
        }
  {SCRIPT} {IGNORE}* .
        {
          String message = "Unexpected subscript or superscript " + yytext();
          throw new ScanException(message, yyline, yycolumn);
        }
  "\\_" | "\\{" | "\\}"
        {
          String result = addSpace();
          return result(result + yytext().substring(1));
        }
  "\\SECTION"
        {
          String result = addSpace() + "section";
          addSpace_ = true;
          return new Symbol(LatexSym.SECTION, yyline, yycolumn, result);
        }
  "\\parents"
        {
          String result = addSpace() + ZString.SPACE + "parents";
          addSpace_ = true;
          return new Symbol(LatexSym.PARENTS, yyline, yycolumn, result);
        }
  {COMMAND}
        {
          String result = addSpace();
          boolean spaces = braceStack_.empty();
          String zstring = toUnicode(yytext(), spaces);
          if (zstring != null) {
            result += zstring;
          }
          else {
            unknownLatexCommand(yytext());
            if (spaces) result += ZString.SPACE;
            result += yytext().substring(1);
            if (spaces) result += ZString.SPACE;
          }
          return result(result);
        }
  "{"
        {
          String result = addSpace();
          braceStack_.push(BraceType.BRACE);
          return result(result);
        }
  "}"
        {
          String result = "";
          if (braceToSpace_) {
            result += ZString.SPACE;
            braceToSpace_ = false;
          }
          if (braceStack_.empty()) {
            String message = getMessage("Unmatched braces");
            LOGGER.warning(message);
          }
          BraceType brace = (BraceType) braceStack_.pop();
          assert ! addSpace_;
          if (brace.equals(BraceType.SUPER)) {
            result += ZString.SW;
          } else if (brace.equals(BraceType.SUPER_SPACE)) {
            result += ZString.SW;
            addSpace_ = true;
          } else if (brace.equals(BraceType.SUB)) {
            result += ZString.NW;
          } else if (brace.equals(BraceType.SUB_SPACE)) {
            result += ZString.NW;
            addSpace_ = true;
          }
          return result(result);
        }
  {FUNCTION} | {RELATION}({RELATION}|{WS})*
        {
          String result = addSpace();
          if (braceStack_.empty()) {
            result += ZString.SPACE;
          }
          result += yytext().replaceAll("[ ]", "");
          if (braceStack_.empty()) {
            addSpace_ = true;
          }
          return result(result);
        }
  {PUNCTATION}
        {
          String result = addSpace();
          if (addSpaceBeforePunctation_ &amp;&amp; braceStack_.empty()) {
            result += ZString.SPACE;
          }
          result += yytext();
          if (braceStack_.empty()) addSpace_ = true;
          return result(result);
        }
  ({LETTER} | [0-9])*
        {
          String result = addSpace();
          result += yytext();
          return result(result);
        }
  .
        {
          String result = addSpace();
          result += yytext();
          return result(result);
        }
}

&lt;MARKUP&gt; {
  {WS}
        {
          /* ignore whitespaces */
        }
  {COMMAND}
        {
          yybegin(ZED);
          return new Symbol(LatexSym.NAME, yyline, yycolumn, yytext());
        }
  .
        {
          yybegin(YYINITIAL);
          LOGGER.warning(getMessage("Unexpected token " + yytext()));
        }
}

&lt;COMMENT_STATE&gt; {
  {NL}
       {
         yybegin(YYINITIAL);
       }
  
  .
       {
         // do nothing
       }
}
</scanner>
