/** Copyright 2003 CHEN Chunqing.  chenchun@comp.nus.edu.sg This file is part of 
the CZT project: http://czt.sourceforge.net

The CZT project contains free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

The CZT project is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with CZT; if not, write to the Free Software Foundation, Inc., 
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
package net.sourceforge.czt.parser.z;

import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import java.text.DateFormat;
import java.math.BigInteger;

//changed by Chen Chunqing 
//import net.sourceforge.czt.base.impl.*;   // for Term
//import net.sourceforge.czt.z.impl.*;   // the CZT corejava AST classes

import net.sourceforge.czt.base.ast.*;   // for Term
import net.sourceforge.czt.z.ast.*;   // the CZT corejava AST classes

action code
{:
  // NOTE: these are local copies of the corresponding variables
  // in the main parser object.   They are updated each time 
  // the parser starts (in the 'init with' method).
  public ZFactory factory;
  
  public OpMaps map;
  
//added by Chen Chunqing (31/01/2004)
protected static final String ARG_STRING = " _ "; 
  
  //==============================================================
  // Helper methods for creating AST nodes/subtrees.
  //
  // Usually we just call factory.createXYZ(...), but some kinds of
  // nodes require more processing, so are created by these methods.
  //==============================================================

  /** Create a list with zero elements.
   */
  protected List list() {
    return new ArrayList();
  }

  /** Create a list with one element.
   */
  protected List list(Object e1) {
    List result = new ArrayList();
    result.add(e1);
    return result;
  }

  /** Create a list with two elements.
   */
  protected List list(Object e1, Object e2) {
    List result = new ArrayList();
    result.add(e1);
    result.add(e2);
    return result;
  }

  /** This coerces an Expr/Pred term into a Pred.
   */
  protected Pred pred(Term t) {
      if (t instanceof Pred)
          return (Pred)t;
      else
          return factory.createExprPred((Expr)t);
  }

  /** This coerces an Expr/Pred term into an Expr.
   */
  protected Expr expr(Term t) {
      if (t instanceof Expr)
          return (Expr)t;
      else
          // TODO: use  parser.report_error(message,info);
          throw new RuntimeException("predicate found where expression required...");
  }

  protected Spec createSpec(List sects) {
    return factory.createSpec(sects, 
                              "1.1", // version of this ZML schema.
                              "",    // author of this spec.
                              Calendar.getInstance(),
                              parser.getSourceName() // file name of the spec.
                              );
  }

/** By Chen Chunqing:
For 'name', 'declname', and 'refname' method, we can apply one more method to test whether the
word is a 'decorword or not, well since it requires to return two variables, one is the modified name and
the other is the possible stroke character. We have to repeat the similar java code inside the three 
methods respectively.
The structure of a decroword is following the definition in chapter 7.2 of ISO Z. 
Well, some notes to be mentioned:
1. Can one strok has more than one stroke characters? e.g.,  A?? where variable A has two stroke
    characters. If it allows, what is the semantics of such expression?
2. If the input string is a decorword, when create the object name, declanme or refname, the string n
    in the "create..." method is not the original one but the updated one.
*/
// Check whether a string ends with stroke character "?", "!" or "'".
  private boolean decor1(String n){
     return n.endsWith("?") || n.endsWith("!") || n.endsWith("'");
  }
//check whether a string ends with a substript integer that between 0 and 9 like "name_8"
  private boolean decor2(String n){
     int nlen = n.length();
     char l1 = n.charAt(nlen-1);
     char l2 = n.charAt(nlen-2);
//     char l3 = n.charAt(nlen-3);
//     char l4 = n.charAt(nlen-4);
//     if(l1 == '}' && l3 == '{' && l4 == '_'){
     if(l2 == '_'){
        return (l1 > '0') &&(l1 < '9');
     }
     else return false;
  }
/* crazy or not...the method isn't called by others in the whole parser....(31/01/2004)  
  protected Name name(String n) {
    // TODO: extend this to extract the decorations from n
    int nlen = n.length();
    String temp = "";
    List toks = list();
    while(nlen >=2){
       if(decor1(n)){
            temp = n.substring(nlen -1);
            n = n.substring(0, nlen-1);
	    toks.add(0, temp);
	    nlen = n.length();
	    //to make sure the order of the toks is the same as it appears originally.
            //return factory.createName(n, list(temp));
       }
       else if(nlen >=3){
             if(decor2(n)){
                temp = n.substring(nlen-2, nlen-1);
                n = n.substring(0, nlen-4);
		toks.add(0, temp);
		nlen = n.length();
                //return factory.createName(n, list(temp));
             }
	     else break;
       }
       else break;
    }//end while
//it seems there is no 'creatName' such method in the class 'zfactory'
//well, here i modified it into createNameNamePair.
//the problem is the type of return is not a "Name" but a "NameNamePair"?!
//so i leave it here...but it cause compile error...
    return factory.createName(n, toks);
  }
*/       
  protected DeclName declname(String n) {
    // TODO: extend this to extract the decorations from n
    int nlen = n.length();
    String temp = "";
    List toks = list();
    while(nlen >=2){
       if(decor1(n)){
            temp = n.substring(nlen -1);
            n = n.substring(0, nlen-1);
	    toks.add(0, temp);
	    nlen = n.length();
            //return factory.createName(n, list(temp));
       }
       else if(nlen >=3){
             if(decor2(n)){
                temp = n.substring(nlen-2, nlen-1);
                n = n.substring(0, nlen-4);
		toks.add(0, temp);
		nlen = n.length();
                //return factory.createName(n, list(temp));
             }
	     else break;
       }
       else break;
    }//end while
    return factory.createDeclName(n, toks, null);
  }

/**
Added by Chen Chunqing (05/01/2004)
To analyze the basic infix relation in "e1 ip e2" format with the advice from Dr. Mark:

The restriction about not being \mem or = is AFTER the chained
relations have been expanded into separate relations:   E1 rel E2.
Then it says that you do the following:
    E1 rel E2    ==>  E1 rel E2          if rel is \mem  (that is, no change)
    E1 rel E2    ==>  E1 \mem {E2}       if rel is =
    E1 rel E2    ==>  (E1,E2) \mem rel   otherwise

*/

//modified by Chen Chunqing (31/01/2004)
//the "createMemPred" requires the two input parameters are 'expr' type.
//so we have to force the two parameters to be 'expr' by class type casting.
//but can we do that? or anything will lose in that way?
protected MemPred MakeBasicMemPred(Term t1, Term t2, String ip){
       Expr le = (Expr)t1;
       Expr re = (Expr)t2;
       if(ip.equals("\\mem")){
         return factory.createMemPred(le, re, Boolean.TRUE);
       }
       else if(ip.equals("=")){
          List ts = list(t2);              
          SetExpr se = factory.createSetExpr(ts);     
          return factory.createMemPred(le, se, Boolean.TRUE);
       }
       else{
          List ts = list(t1, t2);
          String ops = " " + ip + " ";
          return MakeMemPred(ops, ts); 
       }
}

/**Added by Chen Chunqing.
To create the MemPred when dealing with all types of relation.
*/
protected MemPred MakeMemPred(String ops, List ts){
     RefName rn = refname(ops);
     TupleExpr te = factory.createTupleExpr(ts);
     RefExpr re = factory.createRefExpr(rn, list(), Boolean.FALSE);
     return factory.createMemPred(te, re, Boolean.TRUE);
}
 
/** Added by Chen Chunqing
To create an application.
*/   
protected ApplExpr MakeApplExpr(RefName rn, List ts){
      RefExpr re = factory.createRefExpr(rn, list(), Boolean.FALSE);
      TupleExpr te = factory.createTupleExpr(ts);
      return factory.createApplExpr(re, te, Boolean.TRUE); 
}
  /** Converts a list of strings into a list of DeclName objects.
   */
  protected List declnamelist(List strings) {
    List result = list();
    Iterator i = strings.iterator();
    while (i.hasNext()) {
        result.add(declname((String)i.next()));
    }
    return result;
  }

//modified by Chen Chunqing (31/01/2004)
//The 'createRefName' in 'ZFactory' is 
//" RefName createRefName(String word, java.util.List stroke, DeclName decl)"
//so what to do with "DeclName decl" in this case? or pass a null to it?
//or define a 'declname'?
  protected RefName refname(String n) {
    // TODO: extend this to extract the decorations from n
    int nlen = n.length();
    String temp = "";
    List toks = list();
    while(nlen >=2){
       if(decor1(n)){
            temp = n.substring(nlen -1);
            n = n.substring(0, nlen-1);
            toks.add(0, temp);
	    nlen = n.length();
       }
       else if(nlen >=3){
             if(decor2(n)){
                temp = n.substring(nlen-2, nlen-1);
                n = n.substring(0, nlen-4);
		toks.add(0, temp);
		nlen = n.length();
             }
	     else break;
       }
       else break;
    }//end while
    return factory.createRefName(n, toks, factory.createDeclName());
  }

//perform the checking of whether the annotations list of an object contains the ParenAnn object or not.
protected boolean CheckParenAnn(List ann){
      for(int i = 0; i < ann.size(); i++){
            if(ann.get(i) instanceof ParenAnn) return true;
      }
      return false;
}

//Check whether a given operator is a functional operator or not.
//return true if it is, false, otherwise.
protected boolean isFunctionOp(String op){
      List l = map.getOp(op);
      String opfun = (String)l.get(1);
      if(opfun.equals("function")) return true;
      else return false;      
}

//according to the email from Dr. Mark, the genName2String method splits a genname into
//a string and a list of types. The genname is a string type.
//need to assume some methods in class OpMap
protected String genName2String(String gn, List fl){
              StringTokenizer st = new StringTokenizer(gn);
              String genResult = "";
              String temp = "";
              while(st.hasMoreTokens()){
                      temp = st.nextToken();                     
                      if(map.inMap(temp)){
                          List l = map.getOp(temp);
                          String optype = (String)l.get(0);
                          if(optype.equals("estok") || optype.equals("sstok") ||
                              optype.equals("pretok") || optype.equals("ltok") || 
                              optype.equals("eretok") || optype.equals("sretok"))                          
                                 genResult = genResult + temp + ARG_STRING;
                          else if(optype.equals("posttok") )                          
                                    genResult = genResult +  ARG_STRING + temp;
                          else if(optype.equals("itok") || optype.equals("eltok"))
                                    genResult = genResult + ARG_STRING + temp + ARG_STRING;
                          else if(optype.equals("ertok") || optype.equals("srtok"))
                                    genResult = genResult + temp;
                      }
                      else fl.add(temp);
              }
              return genResult;
}
:};

                
parser code
{:
//added by chen chunqing (31/01/2004)
LTZscanner lexer;

//  protected OpMaps map = new OpMaps();
protected static final String ARG_STRING = " _ "; 
  protected OpMaps map;
  public OpMaps getOpMap(){
    return map;
  }

  protected ZFactory factory = new net.sourceforge.czt.z.impl.ZFactoryImpl();

  /** Get the object factory used for creating AST objects.
   */
  public ZFactory getFactory(){
    return factory;
  }
    
  /** Set the object factory used for creating AST objects.
   */
  public void setFactory(ZFactory fact){
    factory = fact;
  }

  protected String sourceName = "";
  
  /** Get the source name of the file being parsed.
   */
  public String getSourceName(){
    return sourceName;
  }
    
  /** Set the source name of the file being parsed.
   *   This is put into the "source" attribute of the
   *   Spec tag in the resulting XML file.
   */
  public void setSourceName(String name) {
    sourceName = name;
  }
:};

//modify by Chen Chunqing (31/01/2004)
init with
{:
    lexer = new LTZscanner(System.in);
//why need to initialize the action object???!!!
//  action_obj.map = map;
//  action_obj.factory = factory;
:};

scan with {:       Symbol s = super.scan();
                        String svalue = (String)s.value;
                        System.out.println("Token "+s.sym+"  ("+svalue+")");
                        
//added by Chen Chunqing (31/01/2004) to connect the lexer map.
                        map = lexer.map;
                           
//added by Chen Chunqing (18/12/2003)
//to complete the 20 kinds of tokens.
                        if(s.value != null){
                           if(s.sym == LTZsym.WORD || s.sym == LTZsym.DECLWORD){
                               if(map.inMap(svalue)){
                                   List l = map.getOp(svalue);
                                   String temp = (String)l.get(0);
                                   if(temp.equals("preptok")) 
                                      return new Symbol(LTZsym.PREPTOK, svalue);
                                   else if(temp.equals("pretok"))
                                      return new Symbol(LTZsym.PRETOK, svalue);
                                   else if(temp.equals("postptok"))
                                      return new Symbol(LTZsym.POSTPTOK, svalue);
                                   else if(temp.equals("posttok"))
                                      return new Symbol(LTZsym.POSTTOK, svalue); 
                                   else if(temp.equals("iptok"))
                                      return new Symbol(LTZsym.IPTOK, svalue);
                                   else if(temp.equals("itok"))
                                      return new Symbol(LTZsym.ITOK, svalue);
                                   else if(temp.equals("ltok"))
                                      return new Symbol(LTZsym.LTOK, svalue);
                                   else if(temp.equals("lptok"))
                                      return new Symbol(LTZsym.LPTOK, svalue);
                                   else if(temp.equals("elptok"))
                                      return new Symbol(LTZsym.ELPTOK, svalue);
                                   else if(temp.equals("eltok"))
                                      return new Symbol(LTZsym.ELTOK, svalue);
                                   else if(temp.equals("erptok"))
                                      return new Symbol(LTZsym.ERPTOK, svalue);
                                   else if(temp.equals("ertok"))
                                      return new Symbol(LTZsym.ERTOK, svalue);
                                   else if(temp.equals("srptok"))
                                      return new Symbol(LTZsym.SRPTOK, svalue);
                                   else if(temp.equals("srtok"))
                                      return new Symbol(LTZsym.SRTOK, svalue);
                                   else if(temp.equals("ereptok"))
                                      return new Symbol(LTZsym.EREPTOK, svalue);
                                   else if(temp.equals("eretok"))
                                      return new Symbol(LTZsym.ERETOK, svalue);
                                   else if(temp.equals("sreptok"))
                                      return new Symbol(LTZsym.SREPTOK, svalue);
                                   else if(temp.equals("sretok"))
                                      return new Symbol(LTZsym.SRETOK, svalue);
                                   else if(temp.equals("estok"))
                                      return new Symbol(LTZsym.ESTOK, svalue);
                                   else if(temp.equals("sstok"))
                                      return new Symbol(LTZsym.SSTOK, svalue);
                                   else
                                      System.out.println("not defined opertor!");
                                }//end first inner if
                             }//end second outer if
                        }//end outest if
                        return s; 
:};

terminal String THETA, LAMBDA, MU, POWER;
terminal String UNDERSCORE, LSET, RSET, LDATA, RDATA, LBLOT, RBLOT;
terminal String VDASH, LAND, LOR, IMPLIES, IFF, LNOT, FORALL, EXISTS, CROSS,SPOT, HIDE, PROJECT, SEMI, PIPE;
terminal String IF, THEN, ELSE, LET, SECTION, CUP, CAP, SETMINUS, SYMDIFF;
terminal String MAPSTO, COMP, CIRC, DRES, RRES, NDRES, NRRES, OPLUS, UPTO;
terminal String LANGLE, RANGLE, CAT, EXTRACT, FILTER;
terminal String BEGINZSECT, PARENTS, ENDZSECT, BEGINAXDEF, WHERE, ENDAXDEF, BEGINSCHEMA, ENDSCHEMA;
terminal String BEGINGENDEF, ENDGENDEF, BEGINZED, ENDZED, BEGINZPAR, ENDZPAR;
terminal String LBRACE, RBRACE, NL, LSQUARE, RSQUARE, COMMA, FREEAND;
terminal String HDEF, FREEEQ, BAR, EXISTSONE, TRUE, FALSE, LBRACKET, RBRACKET, PRE, DOT;
terminal String ANTISLASH, COLON, PLUS, TIMES, MINUS, DIV, MOD, ZCOMP;
terminal String STROKE, WORD,DECLWORD, GREEK, DIGIT, NARRSECT, NARRPARA, FUNNAME, UNDERINFIXREL;
terminal String ZRELATION, ZFUNCTION, ZGENERIC, ASSOC, OPERANDLIST,PREC;
terminal  Rename_Exp;
terminal String PREPTOK, PRETOK, POSTPTOK, POSTTOK, IPTOK, ITOK, LPTOK, LTOK, ELPTOK, ELTOK;
terminal String ERPTOK, ERTOK, SRPTOK, SRTOK, EREPTOK, ERETOK, SREPTOK, SRETOK, ESTOK, SSTOK;

non terminal Spec specification;
non terminal List sections;
non terminal Sect section;
non terminal List/*<Parent>*/ opt_parents;
non terminal List/*<Para>*/ paragraphs, unboxedpars;
non terminal Para zparagraph, zeditem;
non terminal Branch branch;
non terminal List/*<Branch>*/ branchlist;
non terminal DeclName declname;
non terminal RefName refname;
non terminal String opname, prefixname, postfixname, infixname, nofixname, mixfixname, opt_arg, list_sep;
non terminal String genname, prefixgenname, postfixgenname, infixgenname, nofixgenname, seqarg;
non terminal List/*<DeclName>*/ opt_formals, formals;
non terminal List/*<RefName>*/  refnamelist;
non terminal List/*<DeclName>*/ declnamelist;
non terminal List/*<String>*/   namelist;
non terminal List opbody;
non terminal List declpart, declpart2;
non terminal Decl declelem, basicdecl;
non terminal TermA term, func_appl, inner_term, outer_term;
non terminal Pred predicate;
non terminal Expr expression;
non terminal List opt_term_list, term_list, bind_list;
non terminal SchText schematext, schematext_minus_expr;
non terminal List renamelist;
non terminal NameNamePair rename;
non terminal ConstDecl binding;
non terminal List freetypelist;
non terminal Freetype freetype;
non terminal List narrparalist;
non terminal OptempPara optemplate;
non terminal Cat fungen;
non terminal OptempPara template;
non terminal List chainrel;
non terminal List mixfix, mixfixgenname;

precedence right NARRPARA, NARRSECT;
precedence left NL, SEMI;
precedence left COMMA;
precedence right SPOT, BAR;
precedence left IFF;
precedence left IMPLIES;
precedence left LOR;
precedence left LAND;
precedence right LNOT;
precedence left LPTOK, ELPTOK, SREPTOK, EREPTOK,SRPTOK,ERPTOK;
precedence left IPTOK;
precedence left PREPTOK;
precedence left POSTTOK;
precedence right LAMBDA;
precedence right MU;
precedence right LET;
precedence right ELSE;
precedence left ZCOMP;
precedence left PIPE;
precedence left HIDE;
precedence left PROJECT;
precedence right PRE;
precedence left LTOK, ELTOK, SRETOK, ERETOK,SSTOK, ESTOK,SRTOK,ERTOK;
precedence left ITOK;
precedence left PRETOK;
precedence left POSTTOK;
precedence left MAPSTO;
precedence left UPTO;
precedence left SYMDIFF;
precedence left PLUS, MINUS, CUP, CAT, SETMINUS;
precedence left TIMES, DIV, MOD, CIRC, FILTER, CAP, COMP;
precedence left EXTRACT;
precedence left OPLUS;
precedence left RRES, NRRES;
precedence right DRES, NDRES;
precedence right CROSS, POWER;
precedence left STROKE;
precedence left Rename_Exp;
precedence left DOT;
precedence right THETA;
precedence left LSQUARE, RSQUARE;
precedence nonassoc LANGLE, RANGLE;
precedence nonassoc LBLOT;


// TODO: before starting parsing this, set up the operator tables
//     to be the standard_toolkit operators only.
specification ::=
    sections:s
        {: RESULT = createSpec(s); :}
    | 
    paragraphs:pgs
        {: ZSect sect = factory.createZSect("Specification",
                                            list(), // no parents
                                            pgs);
           RESULT = createSpec(list(sect));
        :}
    ;
 
sections ::=
    sections:ss section:s
        {: ss.add(s); RESULT=ss; :}
    | section:s
        {: RESULT = list(s); :}
    ;

section ::=
    BEGINZSECT SECTION WORD:w opt_parents:p ENDZSECT paragraphs:pgs
        {: RESULT = factory.createZSect(w, p, pgs); :}
    ;

opt_parents ::=
    PARENTS namelist:nl
        {: RESULT = list();
           // Convert the strings to Parent objects.
           Iterator i = nl.iterator();
           while (i.hasNext()) {
               RESULT.add(factory.createParent((String)i.next()));
           }
           // TODO: set up the operator tables (by importing these sections)
        :}
    |
    // empty
        {: RESULT = list();
           // TODO: set up the operator tables to be standard_toolkit only
        :}
    |
    //added by Chen Chunqing.
    //Capture when the name list is empty while the keyword "parent" presents.
    PARENTS
    {:  RESULT = list(); :}
    ;

//added by Chen Chunqing.
//move the definition of unboxed paragraphs up to the paragraphs level.
paragraphs ::=
    paragraphs:pgs zparagraph:pg
        {: pgs.add(pg); RESULT=pgs; :}
    |
    paragraphs:pgs BEGINZED unboxedpars:ubp ENDZED
    {: pgs.addAll(ubp); RESULT = pgs; :}
    |
    // empty
        {: RESULT = list(); :}
    ;
                 
//added by Chen Chunqing. To adjust the structure to the YACC grammar. 
/*
paragraph ::= zparagraph:zp
                    {: RESULT = zp; :}
                    |
                    unboxedpar:und
                    {: RESULT = und; :}
                    ;
*/                    
//added by Chen Chunqing
zparagraph ::= BEGINAXDEF schematext:st ENDAXDEF
                     {: RESULT = factory.createAxPara(list(),st,Box.AxBox); :}
                      |
                      BEGINSCHEMA opt_formals:f LBRACE WORD:n RBRACE schematext:st ENDSCHEMA
                      {:// Rule 12.2.3.1: SCH i t END  ==> AX [i==t] END
                         // Rule 12.2.3.2: SCH i [i1..in] t END  ==> AX [i1..in] [i==t] END
                         Expr e = factory.createSchExpr(st);
                         ConstDecl decl = factory.createConstDecl(declname(n),e);
                         SchText stext = factory.createSchText(list(decl),null);
                         RESULT = factory.createAxPara(f,stext,Box.SchBox);
                       :}
                       |
                       BEGINGENDEF opt_formals:f schematext:st ENDGENDEF
                       {: RESULT = factory.createAxPara(f,st,Box.AxBox); :}
                       |
                       BEGINZED opt_formals:f VDASH predicate:p ENDZED
                       {: RESULT = factory.createConjPara(f,p); :}
                       |
                       BEGINZED optemplate:ot ENDZED
                       {: RESULT = ot; :}
                       |
                       narrparalist:u
                       {: RESULT = factory.createUnparsedPara(u); :}
                       ;

//added by Chen Chunqing 
//we allow users to define several unboxed paragraphs (horizontal definitions for example)
//in one pair of "\begin{zed}" and "\end{zed}" latex command.
unboxedpars ::= unboxedpars:ubp NL  zeditem:zd 
                      {: ubp.add(zd); RESULT = ubp; :}
		      |
		      zeditem:zd
		      {: RESULT = list(zd); :}
                      ;         

//added by Chen Chunqing. mostly it is the same as zedparagraph                      
//haven't capture the "genname HDEF expr" structure since the genname undefined yet.
zeditem ::= formals:f
               {: RESULT = factory.createGivenPara(f); :}
               |   
               declname:n formals:f HDEF expression:e
               {:// Rule 12.2.3.4: i [i1..in] == e END ==> GENAX [i1..in] [i==e] END
                  ConstDecl decl = factory.createConstDecl(n,e);
                  SchText stext = factory.createSchText(list(decl),null);
                  RESULT = factory.createAxPara(f,stext,Box.OmitBox);
               :}
               |
              declname:n HDEF expression:e
              {: // Rule 12.2.3.3: i==e END ==> AX [i==e] END
                 ConstDecl decl = factory.createConstDecl(n,e);
                 SchText stext = factory.createSchText(list(decl),null);
                 RESULT = factory.createAxPara(list(),stext,Box.OmitBox);
               :}
               |               
//According to the 12.2.9. 
//The generic operator definition needs to convert into the generic horizontal definition
               genname:gn HDEF expression:e
               {: List formals = list();
                  String n2 = genName2String(gn, formals);                  
                  ConstDecl decl = factory.createConstDecl(declname(n2), e);
                  SchText stext = factory.createSchText(list(decl), null);
                  RESULT = factory.createAxPara(formals, stext, Box.OmitBox); :}
               |
               freetypelist:ftl
               {: RESULT = factory.createFreePara(ftl); :}
               ;               

narrparalist ::=
    narrparalist:l NARRPARA:u
        {: l.add(u); RESULT = l; :}
    |
    NARRPARA:u
        {: RESULT = list(u); :}
    ;
    
freetypelist ::=
    freetypelist: ftl  FREEAND freetype:ft
        {: ftl.add(ft); RESULT = ftl; :}
    |
    freetype:ft
        {: RESULT = list(ft); :}
    ;

freetype ::=
    WORD:n FREEEQ branchlist:bl
        {: RESULT = factory.createFreetype(declname(n), bl); :}
    ;

branchlist ::=
    branchlist:bl BAR branch:b
        {: bl.add(b); RESULT = bl; :}
    |
    branch:b
        {: RESULT = list(b); :}
    ;

branch ::=
    declname:n LDATA expression:e RDATA
        {: RESULT = factory.createBranch(n, e); :}
    |
    declname:n
        {: RESULT = factory.createBranch(n, null); :}
    ;        

//maybe here is a good place to analyze the operator types.    
//the intuition is to analyze the toks inside the object template "t".
optemplate  ::= fungen:fg template:t
                      {: t.setCat(fg); RESULT = t; :}
                      |
                      fungen:fg PREC:n ASSOC:ad template:t
                      {:t.setCat(fg); 
                         t.setPrec(new Integer(n)); 
                         Assoc a = (ad.equals("Left")? Assoc.Left : Assoc.Right);
                         t.setAssoc(a);
                         RESULT = t; :}
                      |
                      fungen:fg PREC:n template:t
                      {: t.setCat(fg); 
                          t.setPrec(new Integer(n));
                          RESULT = t; :}
                      ;

//modified by Chen Chunqing (18/12/2003)
//to update the global shared variable "optype" according to different value of "fungen"
//the problem is that I am not sure the optype value has been changed before analysing the 
//template.
fungen ::= ZRELATION
              {: //optype = RELTYPE;
                 RESULT = Cat.Relation; :}
              |
              ZFUNCTION
              {: //optype = FUNTYPE;
                 RESULT = Cat.Function; :}
              |
              ZGENERIC
              {: //optype = GENTYPE;
                 RESULT = Cat.Generic; :}
              ;

/**
It seems we can add the operator with its type list into the OpMap table.
Do we need to convert the operator from "word" into corresponding token?
or implement the analyse in the scanner?
*/
/**
taking the following structure as an example, we have:
o1           w               ob             o2
 -           s               null             -               => "itok" or "iptok"
 null       s               null             -               => "pretop" or "preptok"
 -           s               null            null            => "posttok" or "postptok"
 -           s           size = 2          null            => "eltok (ertok|srtok) " or "elptok (eretok | sretok)"
 -           s           size = 2           -               => "eltok (eretok|sretok)" or "elptok (ereptok | sreptok)"
 null       s           size = 2           -               => "ltok (eretok | sretok)" or "lptok (ereptok | sreptok)"
 null       s           size = 2          null            => "ltok (ertok | srtok) " or "lptok (erptok | srptok)"
 
 we notes that the size of ob must be a product of 2, i.e., 2k (k is a natural number).
 If the size of ob is more than 2, we will have "estok" and "sstok" according to the types of the 
 sequence arguments.
*/
template ::= LBRACKET opt_arg:o1 WORD:w opbody:ob opt_arg:o2 RBRACKET
                 {: Operand op = factory.createOperand();
                     List toks = list();
                     if(o1.equals("\\_") && o2.equals("\\_")){                                                                              
                          toks.add(op);
                          toks.add(w);
                          toks.addAll(ob);
                          toks.add(op);
                          RESULT = factory.createOptempPara(toks, Cat.Relation, Assoc.Left,
                                             new Integer(0));
                      }
                      else if(o1.equals("\\_")){
                           toks.add(op);
                           toks.add(w);
                           toks.addAll(ob);
                           RESULT = factory.createOptempPara(toks, Cat.Relation, Assoc.Left,
                                               new Integer(0));
                       }
                       else if(o2.equals("\\_")){
                            toks.add(w);
                            toks.addAll(ob);
                            toks.add(op);
                            RESULT = factory.createOptempPara(toks, Cat.Relation, Assoc.Left,
                                                new Integer(0));
                        }
                        else System.err.println("error occur in the template's match"); :}
                    ;

//added by Chen Chunqing (18/12/2003)
//treat the opbody as a list consists of the operators and operands.
opbody ::= opbody:ob seqarg:sa WORD:n 
               {: Operand op = factory.createOperand();
                  ob.add(op); ob.add(n);
                  RESULT = ob; :}
               |
               //empty
               {: RESULT = list(); :}
               ;

seqarg ::= UNDERSCORE
            {: RESULT = "_"; :}
            |
            OPERANDLIST 
            {: RESULT = ",,"; :}
            ;
            
opt_arg ::= UNDERSCORE:u
                {: RESULT = u; :}
                |
                //empty
                ;

//modified by Chen Chunqing. To introduce the "formals" definition.
//Question: why call declnamelist method?
opt_formals ::= formals:f
                      {: RESULT = f; :}
                      | 
                     // empty
                      {: RESULT = list(); :}
                      ;

formals ::= LSQUARE namelist:nl RSQUARE
               {: RESULT = declnamelist(nl); :}
               ;
               
// a list of WORDs, returned as Strings.
namelist ::=
    namelist:nl COMMA WORD:n
        {: nl.add(n); RESULT=nl; :}
    |
    WORD:n
        {: RESULT = list(n); :}
    ;

/* This is the same as namelist, but recognises only DECLWORD symbols.
 * This is because SmartScanner converts WORD symbols into DECLWORD
 * symbols just before the COLON of a declaration.
 * TODO: we might be able to do without SmartScanner if we
 *     adopt Ian Toyn's grammar for expressions?  Then we could
 *     simplify this to just a list of 'declname' calls.
 */
declnamelist ::=
    declnamelist:nl COMMA DECLWORD:n
        {: nl.add(declname(n)); RESULT=nl; :}
    |
    DECLWORD:n
        {: RESULT = list(declname(n)); :}
    ;

declname ::=
    WORD:w
        {: RESULT = declname(w); :}
    |
    opname:o
        {: RESULT = declname(o); :}
    ;

refnamelist ::=
    refnamelist:nl COMMA refname:n
        {: nl.add(n); RESULT=nl; :}
    |
    refname:n
        {: RESULT = list(n); :}
    ;

refname ::=
    WORD:w
        {: RESULT = refname(w); :}
    |
    LBRACKET opname:o RBRACKET
        {: RESULT = refname(o); :}
    ;

/**By Chen Chunqing
Consider opname is a string type first, and according to different types 
(prefix, postfix, infix and nofix), to generate different string that involves " ".
*/
opname ::= prefixname:pren
                {: RESULT = pren; :}
                |
                postfixname:postn
                {: RESULT = postn; :}
                |
                infixname:inn
                {: RESULT = inn; :}
                |
                nofixname: non
                {: RESULT = non; :}
                ;
/**
One possible approach is that when we 
*/                
prefixname ::= PRETOK:pre UNDERSCORE
                      {: RESULT = pre + ARG_STRING; :}
                      |
                      PREPTOK:prep UNDERSCORE
                      {: RESULT = prep + ARG_STRING; :}
                      |
                      LTOK:l mixfixname:mix UNDERSCORE ERETOK:ere UNDERSCORE
                      {: RESULT = l + mix + ARG_STRING + ere + ARG_STRING; :}
                      |
                      LTOK:l mixfixname:mix OPERANDLIST SRETOK:sre UNDERSCORE
                      {: RESULT = l +  mix + ARG_STRING + sre + ARG_STRING; :}
                      |
                      LPTOK:lp mixfixname:mix UNDERSCORE EREPTOK:erep UNDERSCORE
                      {: RESULT = lp + mix + ARG_STRING + erep + ARG_STRING; :}
                      |
                      LPTOK:lp mixfixname:mix OPERANDLIST SREPTOK:srep UNDERSCORE
                      {: RESULT = lp + mix + ARG_STRING + srep + ARG_STRING; :}
                      ;
                      
postfixname ::= UNDERSCORE POSTTOK:post
                       {: RESULT = ARG_STRING+ post; :}
                       |
                       UNDERSCORE POSTPTOK:postp
                       {: RESULT = ARG_STRING+ postp; :}
                       |
                       UNDERSCORE ELTOK:el mixfixname:mix UNDERSCORE ERTOK:er
                       {: RESULT = ARG_STRING + el  + mix + ARG_STRING+ er; :}
                       |
                       UNDERSCORE ELTOK:el mixfixname:mix OPERANDLIST SRTOK:sr
                       {: RESULT = ARG_STRING + el +  mix + ARG_STRING+ sr; :}
                       |
                       UNDERSCORE ELPTOK:elp mixfixname:mix UNDERSCORE ERPTOK:erp
                       {: RESULT = ARG_STRING + elp + mix + ARG_STRING + erp; :}
                       |
                       UNDERSCORE ELPTOK:elp mixfixname:mix OPERANDLIST SRPTOK:srp
                       {: RESULT = ARG_STRING + elp +  mix + ARG_STRING + srp; :}
                       ;
                       
infixname ::= UNDERSCORE ITOK:i UNDERSCORE
                   {: RESULT = ARG_STRING + i + ARG_STRING; :}
                   |
                   UNDERSCORE IPTOK:ip UNDERSCORE
                   {: RESULT = ARG_STRING + ip + ARG_STRING; :}
                   |
                   UNDERSCORE ELTOK:el mixfixname:mix UNDERSCORE ERETOK:ere UNDERSCORE
                   {: RESULT = ARG_STRING + el + mix + ARG_STRING + ere + ARG_STRING; :}
                   |
                   UNDERSCORE ELTOK:el mixfixname:mix OPERANDLIST SRETOK:sre UNDERSCORE
                   {: RESULT = ARG_STRING + el +  mix + ARG_STRING + sre + ARG_STRING; :}
                   |
                   UNDERSCORE ELPTOK:elp mixfixname:mix UNDERSCORE EREPTOK:erep UNDERSCORE
                   {: RESULT = ARG_STRING + elp + mix + ARG_STRING + erep + ARG_STRING; :}
                   |
                   UNDERSCORE ELPTOK:elp mixfixname:mix OPERANDLIST SREPTOK:srep UNDERSCORE
                   {: RESULT = ARG_STRING + elp + mix + ARG_STRING + srep + ARG_STRING; :}
                   ;
                   
nofixname ::= LTOK:l mixfixname:mix UNDERSCORE ERTOK:er
                    {: RESULT = l + mix + ARG_STRING + er; :}
                    |
                    LTOK:l mixfixname:mix OPERANDLIST SRTOK:sr
                    {: RESULT = l + mix + ARG_STRING + sr; :}
                    |
                    LPTOK:lp mixfixname:mix UNDERSCORE ERPTOK:erp
                    {: RESULT = lp +  mix + ARG_STRING + erp; :}
                    |
                    LPTOK:lp mixfixname:mix OPERANDLIST SRPTOK:srp
                    {: RESULT = lp +  mix + ARG_STRING + srp; :}
                    ;
                    
mixfixname ::= mixfixname:mix UNDERSCORE ESTOK:es
                      {: RESULT = mix + ARG_STRING + es; :}
                      |
                      mixfixname:mix OPERANDLIST SSTOK:ss
                      {: RESULT = mix + ARG_STRING + ss; :}
                      |
                      //empty
                      ;
                      
/**By Chen Chunqing
Because I don't know how to handle the "genname" in ZML, here I just simply treats them as 
String type, as similar as "opname", generate string based on different types.

According to the ISO Z description in p51, Syntactic transformation rules 12.2.9:
All generic names are transformed to juxtapositions of NAMEs and generic parameter lists.
This causes the generic operator definition paragraphs in which they appear to become 
GENERIC HORIZONTAL DEFINITION PARAGRAPHS.
NAME, [-tok, Formals, ]-tok, ==, Expression, END

Need to clarify with Mark:
Thus each WORD is converted into a RefExpression, and the genname type needs to change
into term type! But it will bring problem for the definition of
"unboxed_def ::= genname TDEF expr"

So a "genname" can be thought as a "name" followed by a "namelist" where the "name" is 
constructed by combining those tokens together? If so, we need to define the structure of 
GenName instead of String type.
*/
genname ::= prefixgenname:preg
                  {: RESULT = preg; :}
                  |
                  postfixgenname:postg
                  {: RESULT = postg; :}
                  |
                  infixgenname:infixg
                  {: RESULT = infixg; :}
                  |
                  nofixgenname:nofixg
                  {: RESULT = nofixg; :}
                  ;
                  
/**
pre i => pre_[i]
l i1 ess1 ... in-2 essn-2 in-1 ere in => l_ess1..._essn-2_ere [i1, ..., in-2, in-1, in]
l i1 ess1 ... in-2 essn-2 in-1 sre in => l_ess1..._essn-2_sre [i1, ..., in-2, in-1, in]
*/
prefixgenname ::= PRETOK:pre WORD:w
                        |
                        LTOK:l mixfixgenname:mix WORD:w1 ERETOK:ere WORD:w2
                        |
                        LTOK:l mixfixgenname:mix WORD:w1 SRETOK:sre WORD:w2
                        ;
                            
/**
i post => _post [i]
I1 el I2 ess2 ... In-1 essn-1 In er => _el_ess2..._essn-1_er [I1, I2, ...,In-1, In]
I1 el I2 ess2 ... In-1 essn-1 In sr => _el_ess2..._essn-1_sr [I1, I2, ...,In-1, In]
*/
postfixgenname ::= WORD:w POSTTOK:post
                         |
                         WORD:w1 ELTOK:el mixfixgenname:mix WORD:w2 ERTOK:er
                          |
                         WORD:w1 ELTOK:el mixfixgenname:mix WORD:w2 SRTOK:sr
                           ;
                           
/**
I1 in I2 => _in_ [I1, I2]
I1 el I2 ess2 ... In-2 essn-2 In-1 ere In => _el_ess2..._essn-2_ere_ [I1, I2, ..., In-2, In-1, In]
I1 el I2 ess2 ... In-2 essn-2 In-1 sre In => _el_ess2..._essn-2_sre_ [I1, I2, ..., In-2, In-1, In]
*/  
infixgenname ::= WORD:w1 ITOK:i WORD:w2
                     |
                      WORD:w1 ELTOK:el mixfixgenname:mix WORD:w2 ERETOK:ere WORD:w3
                      |
                      WORD:w1 ELTOK:el mixfixgenname:mix WORD:w2 SRETOK:sre WORD:w3
                     ;

/**
l I1 ess1 ... In-1 essn-1 In er => l_ess1..._essn-1_er [I1, ..., In-1, In]
l I1 ess1 ... In-1 essn-1 In sr => l_ess1..._essn-1_sr [I1, ..., In-1, In]
*/                          
nofixgenname ::= LTOK:l mixfixgenname:mix WORD:w ERTOK:er
                       |
                       LTOK:l mixfixgenname:mix WORD:w SRTOK:sr
                       ;
                           
mixfixgenname ::= mixfixgenname:mix WORD:w ESTOK:es
                        |
                        mixfixgenname:mix WORD:w SSTOK:ss
                        |
                        //empty
                        ;
                  
schematext ::=
    declpart:dp BAR predicate:pp
        {: RESULT = factory.createSchText(dp, pp); :}
    |
    declpart:dp WHERE predicate:pp
        {: RESULT = factory.createSchText(dp, pp); :}
    |
    declpart:dp
        {: RESULT = factory.createSchText(dp, null); :}
    ;

schematext_minus_expr ::= declpart:dp BAR predicate:pp
                                 {: RESULT = factory.createSchText(dp, pp); :}
	                 |
				 declpart:dp WHERE predicate:pp
				 {: RESULT = factory.createSchText(dp, pp); :}
				 |
				 declpart2:dl2 list_sep declelem:d
				 {: dl2.add(d); 
				     RESULT = factory.createSchText(dl2, null);:}
				  |
				  basicdecl: bd
				  {: RESULT = factory.createSchText(list(bd), null); :}
				  ;

declpart ::= declpart2:dp2
                 {: RESULT = dp2; :}
                 |
                 //empty
                 {: RESULT = list(); :}
                 ;
declpart2 ::= declpart2:dl2 list_sep declelem:de
                   {: dl2.add(de); RESULT = dl2; :}
                   |
                   declelem:de
                   {: RESULT = list(de); :}
                   ;
                   
list_sep ::= SEMI
                 |
                  NL
                  ;

declelem ::= basicdecl : bd
                  {: RESULT = bd; :}
                  |
                  expression:e
                  {: RESULT = factory.createInclDecl(e); :}
                  ;
                  
 basicdecl ::= declnamelist:nl COLON expression:e 
                   {: RESULT = factory.createVarDecl(nl,e); :}
                   |
                   declname:n HDEF expression:e
                   {: RESULT = factory.createConstDecl(n,e); :}
                   ;                

//convert the predicate into outer_term type.
predicate ::= outer_term:ot
                {: //Modified by Chen Chunqing (31/01/2004)
                   RESULT = (Pred)ot; :}
		;

/**By Chen Chunqing
Modify some of the expressions using 'create...' method.

Apply the super type "TermA" to "expression".

Treat those structures involve logical operators (and, or, not, imply, iff, 
forall, exists, exists1) as expression first, and later they can be converted into
predicate type using "Pred pred(Term t)" method when necessary.
*/
expression ::= term:t
                   {://modified by Chen Chunqing (31/01/2004) 
                     RESULT = (Expr)t; :}
                   ;          

term ::= FORALL schematext:st SPOT term:e
        {: RESULT = factory.createForallExpr(st, (Expr)e); :}
    |
    EXISTS schematext:st SPOT term:e
        {: RESULT = factory.createExistsExpr( st, (Expr)e); :}
    |
    EXISTSONE schematext:st SPOT term:e
        {: RESULT = factory.createExists1Expr(st, (Expr)e); :}
    |
    LAMBDA schematext:st SPOT term:e
        {: RESULT = factory.createLambdaExpr(st, (Expr)e); :}
    |
    MU schematext:st SPOT term:e
        {: RESULT = factory.createMuExpr(st, (Expr)e); :} %prec MU
    |
    LET schematext:st SPOT term:e
        {: RESULT = factory.createLetExpr(st, (Expr)e); :} %prec LET
    |
    term:e1 IMPLIES term:e2
        {: RESULT = factory.createImpliesExpr((Expr)e1,  (Expr)e2); :}
    |
    term:e1 IFF term:e2
        {: RESULT = factory.createIffExpr((Expr)e1, (Expr)e2); :}
    |
    term:e1 LAND term:e2
        {://modified by Chen Chunqing (31/01/2004)
          //Have to cast the "term e" into "Expr" type
          //to fit for the requirement of the method in ZFactory.
          //but is it correct?  
          RESULT = factory.createAndExpr((Expr)e1, (Expr)e2); :}
    |
    term:e1 LOR term:e2
        {: //modified by Chen Chunqing (31/01/2004)
          //Have to cast the "term e" into "Expr" type
          //to fit for the requirement of the method in ZFactory.
          //but is it correct?  
           RESULT = factory.createOrExpr((Expr)e1, (Expr)e2); :}
    |
    LNOT term:e
        {://modified by Chen Chunqing (31/01/2004)
          //Have to cast the "term e" into "Expr" type
          //to fit for the requirement of the method in ZFactory.
          //but is it correct?  
          RESULT = factory.createNegExpr((Expr)e); :}
    |
    IF predicate:p THEN term:e1 ELSE term:e2
        {://modified by Chen Chunqing (31/01/2004)
          //Have to cast the "term e" into "Expr" type
          //to fit for the requirement of the method in ZFactory.
          //but is it correct?  
          RESULT = factory.createCondExpr(p, (Expr)e1, (Expr)e2); :}
    |
    term:e1 ZCOMP term:e2
        {://modified by Chen Chunqing (31/01/2004)
          //Have to cast the "term e" into "Expr" type
          //to fit for the requirement of the method in ZFactory.
          //but is it correct?  
          RESULT = factory.createCompExpr((Expr)e1, (Expr)e2); :}
    |
    term:e HIDE LBRACKET declnamelist:nl RBRACKET
        {://modified by Chen Chunqing (31/01/2004)
          //Have to cast the "term e" into "Expr" type
          //to fit for the requirement of the method in ZFactory.
          //but is it correct?  
          RESULT = factory.createHideExpr((Expr)e, nl); :}
    |
    term:e1 PIPE term:e2
        {: //modified by Chen Chunqing (31/01/2004)
          //Have to cast the "term e" into "Expr" type
          //to fit for the requirement of the method in ZFactory.
          //but is it correct? 
           RESULT = factory.createPipeExpr((Expr)e1,  (Expr)e2); :}
    |
    term:e1 PROJECT term:e2    
        {: //modified by Chen Chunqing (31/01/2004)
          //Have to cast the "term e" into "Expr" type
          //to fit for the requirement of the method in ZFactory.
          //but is it correct? 
           RESULT = factory.createProjExpr((Expr)e1, (Expr)e2); :}
    |
    PRE term:e
        {://modified by Chen Chunqing (31/01/2004)
          //Have to cast the "term e" into "Expr" type
          //to fit for the requirement of the method in ZFactory.
          //but is it correct? 
          RESULT = factory.createPreExpr((Expr)e); :}
    |
    term:e1 CROSS term:e2
        {: RESULT = factory.createProdExpr(list(e1,e2)); :}
    |
    //concate the lptok and ereptok together to a new opname.
    //the following nine syntax structures are converted into <MemPred>  element with true value of 
    //its attribute Mixfix.
/**
The first three are translated into prefix relation, according to the syntactic transformation rules:
prep E => e \mem prep
lp E1 es1 ...En-2 esn-2 En-1 erep En => (E1, ..., En-2, En-1, En) \mem lp_es1_esn-2_erep
lp E1 es1 ... En-2 esn-2 ALn-1 srep En => (E1, ..., En-2, ALn-1, En) \mem lp_es1_esn-2_srep
Thus, the left hand side of "\mem" can be treated either a refexpr or tupleexpr,  and the right hand
side is to apply the refexpr to capture the operator.
the problem is that how to connect those operators together, via underscore " "?
*/
    LPTOK:l mixfix:mix term:t1 EREPTOK:erep term:t2
    {: List ts = list();
       String ops = "";
       for(int i = 0; i < mix.size(); i += 2){
           ts.add(mix.get(i));
           ops=ops + (String)mix.get(i+1) + " ";
       }
       ts.add(t1); ts.add(t2);
       ops = l + " " + ops + erep;
       RESULT = MakeMemPred(ops, ts); :}
    |
    LPTOK:l mixfix:mix opt_term_list:otl SREPTOK:srep term:t
    {: List ts = list();
       String ops = "";
       for(int i = 0; i < mix.size(); i += 2){
           ts.add(mix.get(i));
           ops=ops + (String)mix.get(i+1) + " ";
       }
       ts.add(otl); ts.add(t);
       ops = l + " " + ops + srep;
       RESULT = MakeMemPred(ops, ts); :}
    |
    PREPTOK:prep term:t
    {: List ts = list(t);
       String ops = prep + " ";
       RESULT = MakeMemPred(ops, ts); :}
    |
/**
The following three definitions belong to the "postfix relation", based on the syntactic 
transformation rules in ISO Z p52, we have:
E postp => E \mem postp
E1 elp E2 es2 ...En-1 esn-1 En erp => (E1, E2, ..., En-1, En) \mem _elp_es2..._esn-1_erp
E1 elp E2 es2 ...En-1 esn-1 ALn srp => (E1, E2, ...,En-1, ALn) \mem _elp_es2..._esn-1_srp
*/
    term:t1 ELPTOK:elp mixfix:mix term:t2 ERPTOK:erp
    {: List ts = list(t1);
       String ops = " " + elp;
       for(int i = 0; i < mix.size(); i += 2){
           ts.add(mix.get(i));
           ops=ops + " " + (String)mix.get(i+1) ;
       }
       ts.add(t2); 
       ops = ops + " " + erp;
       RESULT = MakeMemPred(ops, ts); :}
    |
    term:t ELPTOK:elp mixfix:mix opt_term_list:otl SRPTOK:srp
    {: List ts = list(t);
       String ops = " " + elp;
       for(int i = 0; i < mix.size(); i += 2){
            ts.add(mix.get(i));
            ops = ops + " " + (String)mix.get(i+1);
        }
        ts.add(otl);
        ops = ops + " " + srp;
        RESULT = MakeMemPred(ops, ts); :}
    |
    term:t POSTPTOK:postp
    {: List ts = list(t);
       String ops = " " + postp;
       RESULT = MakeMemPred(ops, ts); :}
    |
/**
The following three are "infix relation" type, according to the transformation rules :
E1 elp E2 es2 ... En-2 esn-2 En-1 erep En => 
                    (E1, E2, ..., En-2, En-1, En)\mem _elp_es2..._esn-2_erep_
E1 elp E2 es2 ...En-2 esn-2 ALn-1 srep En =>
                    (E1, E2, ..., En-2, ALn-1, En)\mem _elp_es2..._esn-2_srep_
E1 ip E2 => (E1, E2) \mem _ip_
???Questions: 1. How to handle the chain relation?
                      2.Since the ip above excludes the "\mem" and "=" symbol, 
                         then what we can do with those two symbols?
*/
    term:t1 ELPTOK:elp mixfix:mix term:t2 EREPTOK:erep term:t3
    {: List ts = list(t1);
       String ops = " " + elp + " ";
       for(int i = 0; i < mix.size(); i += 2){
            ts.add(mix.get(i));
            ops = ops + (String)mix.get(i+1) + " ";
        }
        ts.add(t2); ts.add(t3);
        ops = ops + erep + " ";
        RESULT = MakeMemPred(ops, ts); :}
    |
    term:t1 ELPTOK:elp mixfix:mix opt_term_list:otl SREPTOK:srep term:t2
    {: List ts = list(t1);
       String ops = " " + elp + " ";
       for(int i = 0; i < mix.size(); i += 2){
            ts.add(mix.get(i));
            ops = ops + (String)mix.get(i+1) + " ";
        }
        ts.add(otl); ts.add(t2);
        ops = ops + srep + " ";
        RESULT = MakeMemPred(ops, ts); :}
    |
/* modified by Chen Chunqing(05/01/2004)
Well, still need to clarify with Dr. Mark regarding how to tell a chain relation?
For the chain predicates, since the "IPTOK" is left association, i.e.,
given an infixrelation "e1 ip1 e2 ip2 e3 ip3 e4", 
we have "( ( e1 ip1 e2 ) ip2 e3 ) ip3 e4". 
The algorithm is:
Analyze the left term "t1" of the definition.
if t1 is MemPred type, i.e., t1 = t1left ip1 t1right, hence the "t1 ip t2" is a chain infix relation,
    we need to figure out the t1right and form it with the term "t2", convert them into another
    "MemPred", after that, return the whole predicate as an AndPred type whose OP value is
    "Chain".
else if t1 is an AndPred whose OP value is "Chain", i.e., t1 = (t11 ip11 t12) ^ (t12 ip12 t13), it 
    certainly is a chain infix relation of the term "t1 ip t2". We need to obtain the term "t13"
    and convert it with t2 into a MemPred, after that, translate the t1 with the generated 
    MemPred into a new AndPred whose OP value is still "Chain".
else nothing special.
*/
    term:t1 IPTOK:ip term:t2
    {: //modified by Chen Chunqing (31/01/2004)
       //Have to cast the two terms into 'pred' type
       if(t1 instanceof MemPred){
          Expr t1r = ((MemPred)t1).getRightExpr();
          MemPred mpnew = MakeBasicMemPred(t1r, t2, ip);
          RESULT = factory.createAndPred((Pred)t1, mpnew, Op.Chain);
       }
       else if(t1 instanceof AndPred){           
           String tempop = ((AndPred)t1).getOp().toString();
           if(tempop.equals("Chain")){
              MemPred t1r = (MemPred)((AndPred)t1).getRightPred();
              Expr t1rr = t1r.getRightExpr();
              MemPred mpnew = MakeBasicMemPred(t1rr, t2, ip);
              RESULT = factory.createAndPred((Pred)t1, mpnew, Op.Chain);
           }
       }
       else{
            RESULT = MakeBasicMemPred((Pred)t1, (Pred)t2, ip);
       }
     :}          
    |
/**
All function operator applications are transformed to annotated application expressions
That means, apply the <ApplExpr> element with "true" value of its attribute "Mixfix".

All generic operator applications are transformed to annotated generic instantiation expressions.
That means, apply the <RefExpr> element with "true" value of its attribute "Mixfix".
*/
//prefix application
    LTOK:l mixfix:mix term:t1 ERETOK:ere term:t2
    {: List ts = list();
       String ops = l + " ";
       for(int i = 0; i < mix.size(); i += 2){
           ts.add(mix.get(i));
           ops = ops + (String)mix.get(i+1) + " ";
        }
        ts.add(t1); ts.add(t2);
        ops = ops + ere + " ";
        RefName rn = refname(ops);
        if(isFunctionOp(l)) RESULT = MakeApplExpr(rn, ts); 
         else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE); 
     :}             
    |
    LTOK:l mixfix:mix opt_term_list:otl SRETOK:sre term:t
    {: List ts = list();
       String ops = l + " ";
       for(int i = 0; i < mix.size(); i += 2){
           ts.add(mix.get(i));
           ops = ops + (String)mix.get(i+1) + " ";
        }
        ts.add(otl); ts.add(t);
        ops = ops + sre + " ";
        RefName rn = refname(ops);
        if(isFunctionOp(l)) RESULT = MakeApplExpr(rn, ts); 
         else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE); 
     :}
    |
    PRETOK:pre term:t
    {: List ts = list(t);
       String ops = pre + " ";
       RefName rn = refname(ops);
       if(isFunctionOp(pre)) RESULT = MakeApplExpr(rn, ts); 
        else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE);
     :}
    |
//postfix application
    term:t1 ELTOK:el mixfix:mix term:t2 ERTOK:er
    {: List ts = list(t1);
       String ops = " " + el;
       for(int i = 0; i < mix.size(); i += 2){
            ts.add(mix.get(i));
            ops = ops + " " + (String)mix.get(i+1);
        }
        ts.add(t2);
        ops = ops + " " + er;
        RefName rn = refname(ops);
        if(isFunctionOp(el)) RESULT = MakeApplExpr(rn, ts); 
         else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE);
      :}
    |
    term:t1 ELTOK:el mixfix:mix opt_term_list:otl SRTOK:sr
    {: List ts = list(t1);
       String ops = " " + el;
       for(int i = 0; i < mix.size(); i += 2){
            ts.add(mix.get(i));
            ops = ops + " " + (String)mix.get(i+1);
        }
        ts.add(otl);
        ops = ops + " " + sr;
        RefName rn = refname(ops);
        if(isFunctionOp(el)) RESULT = MakeApplExpr(rn, ts); 
         else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE);
      :}
    |
    term:t POSTTOK:post
    {: List ts = list(t);
       String ops = " " + post;
       RefName rn = refname(ops);
       if(isFunctionOp(post)) RESULT = MakeApplExpr(rn, ts); 
        else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE); 
     :}
    |
//infix application
    term:t1 ELTOK:el mixfix:mix term:t2 ERETOK:ere term:t3
    {: List ts = list(t1);
       String ops = " " + el;
       for(int i = 0; i < mix.size(); i += 2){
            ts.add(mix.get(i));
            ops = ops + " " + (String)mix.get(i+1);
        }
        ts.add(t2); ts.add(t3);
        ops = ops + " " + ere + " ";
        RefName rn = refname(ops);
        if(isFunctionOp(el)) RESULT = MakeApplExpr(rn, ts);
        else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE);
     :}
    |
    term:t1 ELTOK:el mixfix:mix opt_term_list:otl SRETOK:sre term:t2
    {: List ts = list(t1);
       String ops = " " + el;
       for(int i = 0; i < mix.size(); i += 2){
            ts.add(mix.get(i));
            ops = ops + " " + (String)mix.get(i+1);
        }
        ts.add(otl); ts.add(t2);
        ops = ops + " " + sre + " ";
        RefName rn = refname(ops);
        if(isFunctionOp(el)) RESULT = MakeApplExpr(rn, ts);
        else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE);
     :}
    |
    term:t1 ITOK:i term:t2
    {: List ts = list(t1, t2);
       String ops = " " + i + " ";
       RefName rn = refname(ops);
       if(isFunctionOp(i)) RESULT = MakeApplExpr(rn, ts);
       else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE); 
     :}
    |
    POWER term:e    
        {://modified by Chen Chunqing (31/01/2004)
          //Have to cast the 'term e" into 'expr' type
          //due to the limits of the method in ZFactory.
          RESULT = factory.createPowerExpr((Expr)e); :}
    |
    func_appl:fa
       {: RESULT = fa; :}
    ;
    
/**By Chen Chunqing
The juxtaposition of two expresssions E1 E2 is always parsed as the application of 
function E1 to argument E2 according to ISO Z p36.
*/
func_appl ::= func_appl:fa inner_term:it
                  {://modified by Chen Chunqing (31/01/2004)
                    //Have to cast the 'func_appl:fa' and 'term it" into 'expr' type
                    //due to the limits of the method in ZFactory.
                    RESULT = factory.createApplExpr((Expr)fa, (Expr)it, Boolean.FALSE); :}
                  |
                  inner_term:it
                  {: RESULT = it; :}
                  ;

inner_term ::= LSET opt_term_list:tl RSET
                     {: RESULT = factory.createSetExpr(tl); :}
                     |
                     LSET schematext:st SPOT term:t RSET
                     {://modified by Chen Chunqing (31/01/2004)
                       //have to cast the 'term t' into 'expr' type 
                       //since createSetCompExpr method in the 'ZFactory' requires it. 
                       //but can we?                       
                       RESULT = factory.createSetCompExpr(st, (Expr)t); :}
                     |
   	     LSET schematext_minus_expr:sme RSET
	     {: RESULT = factory.createSetCompExpr(sme, null); :}
	     |
	     LBRACKET term:t COMMA term_list:tl RBRACKET
	     {: List toks = list(); 
	       toks.add(t);
	       toks.addAll(tl);
	       RESULT = factory.createTupleExpr(toks); :}
	     |
	     LBRACKET  MU schematext:st RBRACKET
	     {: RESULT = factory.createMuExpr(st, null); :}
	     |
//Nofix Relation
                     LPTOK:lp mixfix:mix term:t ERPTOK:erp
                     {: List ts = list();
                        String ops = lp + " ";
                        for(int i = 0; i < mix.size(); i += 2){
                             ts.add(mix.get(i));
                             ops = ops + (String)mix.get(i+1) + " ";
                         }
                         ts.add(t);
                         ops = ops + erp;
                         RESULT = MakeMemPred(ops, ts); :}
                     |
                     LPTOK:lp mixfix:mix opt_term_list:otl SRPTOK:srp
                     {: List ts = list();
                        String ops = lp + " ";
                        for(int i = 0; i < mix.size(); i += 2){
                             ts.add(mix.get(i));
                             ops = ops + (String)mix.get(i+1) + " ";
                         }
                         ts.add(otl);
                         ops = ops + srp;
                         RESULT = MakeMemPred(ops, ts); :}
                     |
//nofix application
                     LTOK:l mixfix:mix term:t ERTOK:er
                     {: List ts = list();
                        String ops = l + " ";
                        for(int i = 0; i < mix.size(); i += 2){
                             ts.add(mix.get(i));
                             ops = ops + (String)mix.get(i+1) + " ";
                         }
                         ts.add(t);
                         ops = ops + er;
                         RefName rn = refname(ops);
                         if(isFunctionOp(l)) RESULT = MakeApplExpr(rn, ts);
                         else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE); :}
                     |
                     LTOK:l mixfix:mix opt_term_list:otl SRTOK:sr
                     {: List ts = list();
                        String ops = l + " ";
                        for(int i = 0; i < mix.size(); i += 2){
                             ts.add(mix.get(i));
                             ops = ops + (String)mix.get(i+1) + " ";
                         }
                         ts.add(otl);
                         ops = ops + sr;
                         RefName rn = refname(ops);
                         if(isFunctionOp(l)) RESULT = MakeApplExpr(rn, ts);
                         else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE); :}
                     |                     
                     LBLOT bind_list:bl RBLOT
                     {: RESULT = factory.createBindExpr(bl); :}
                     |
                     LBLOT RBLOT
                     {: RESULT = factory.createBindExpr(); :}
                     |
                     LSQUARE RSQUARE
                     {: RESULT = factory.createSchExpr(); :}
                     |
                     inner_term:it DOT refname:rn
                     {: RESULT = factory.createBindSelExpr((Expr)it, rn); :}
                     |
                     inner_term:it DOT DIGIT:n
                     {: Integer nn = new Integer(n);
                         RESULT = factory.createTupleSelExpr((Expr)it, nn); :}
                     |
                     //STROKE is still a string type so far.
                     //modified by Chen Chunqing (31/01/2004)
                     //need to convert the stroke from string type into stroke type.
                     //Or we could change the scanner to return four different
                     //kinds of stroke tokens.
                     //For the moment, I've just converted all strokes to '.
                     inner_term:it  STROKE:s
                     {: Stroke st = factory.createNextStroke();
                        RESULT = factory.createDecorExpr((Expr)it, st); :}
                     |
                     THETA inner_term:it
                     {://modified by Chen Chunqing (31/01/2004)
                       //Have to cast the 'term it' into 'expr' type
                       //to satisfy the method declared in 'ZFactory'
                       //but can we do that?? 
                       //looks strange...need more analyze.
                       List strokes = list();                       
                       Expr ite = (Expr)it;
                         while (ite instanceof DecorExpr && CheckParenAnn(ite.getAnns())) {
                           DecorExpr e = (DecorExpr)ite;
                           strokes.add(e.getStroke());
                           ite = e.getExpr();                           
                           }
                           RESULT = factory.createThetaExpr(ite, strokes);
                     :}
                     |
                     inner_term:it LSQUARE renamelist:rl RSQUARE  
                     {: RESULT = factory.createRenameExpr((Expr)it, rl); :} %prec Rename_Exp
                     |
                     //it fits with the generic instantiation, so apply the RefExpr with false value of its attribute.
                     refname:rn LSQUARE term_list:tl RSQUARE
                     {: RESULT = factory.createRefExpr(rn, tl, Boolean.FALSE); :}
                     |
                     DIGIT:n
                     {: RESULT = factory.createNumExpr(new BigInteger(n)); :}
                     |
                     LBRACKET outer_term:ot RBRACKET
                     {: ot.getAnns().add(factory.createParenAnn()); RESULT = ot; :}
                     |
                     refname:rn
                     {: RESULT = factory.createRefExpr(rn,list(),Boolean.FALSE); :}                    
                     |
                    TRUE
                    {: RESULT = factory.createTruePred(); :}
                    |  
                    FALSE
                    {: RESULT = factory.createFalsePred(); :}
                     ;
                   
//consider the type of "mixfix" as a list of objects consists of "term" followed by "es"
//or "opt_term_list" followed by "ss".
mixfix ::= mixfix:mf term:t ESTOK:es
             {: mf.add(t); mf.add(es); RESULT = mf; :}
              |
              mixfix:mf opt_term_list:otl SSTOK:ss
              {: mf.add(otl); mf.add(ss); RESULT = mf; :}
              |
              //empty
              {: RESULT = list(); :}
              ;
                   
outer_term ::= predicate:p1 NL predicate:p2
                      {: RESULT = factory.createAndPred(p1, p2, Op.NL); :}
                      |
	    predicate:p1 SEMI predicate:p2
	    {: RESULT = factory.createAndPred(p1, p2, Op.Semi); :}
                      |
                      term:t
                      {: RESULT = t; :}
                      ;
                       
renamelist ::=  renamelist:rl COMMA rename:r
        {: rl.add(r); RESULT = rl; :}
    |
    rename:r
        {: RESULT = list(r); :}
    ;

rename ::=
    declname:n1 ANTISLASH refname:n2
        {: // Note that this takes OldName first, then NewName second.
           // TODO: check why the standard has two declnames here?
           RESULT = factory.createNameNamePair(n2, n1);
        :}
    ;
                   
          
bind_list ::= bind_list:bl COMMA binding:b
                 {: bl.add(b); RESULT = bl; :}
                 |
                 binding:b
                 {: RESULT = list(b); :}
                 ;
                 
binding ::= declname:dn HDEF expression:e
               {: RESULT = factory.createConstDecl(dn, e); :}
               ;
               
opt_term_list ::= term_list:tl
                         {: RESULT = tl; :}
                         | //Empty
                         {: RESULT = list(); :}
                         ;
                         
term_list ::= term_list:tl COMMA term:t
                  {: tl.add(t); RESULT = tl; :}
                  |
                  term:t
                  {: RESULT = list(t); :}
                  ;
                  
