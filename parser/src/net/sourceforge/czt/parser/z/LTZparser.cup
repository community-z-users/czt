/** Copyright 2003 CHEN Chunqing.  chenchun@comp.nus.edu.sg This file is part of 
the CZT project: http://czt.sourceforge.net

The CZT project contains free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

The CZT project is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with CZT; if not, write to the Free Software Foundation, Inc., 
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
package net.sourceforge.czt.parser.z;

import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import java.text.DateFormat;
import java.math.BigInteger;
import net.sourceforge.czt.base.ast.*;   // for Term
import net.sourceforge.czt.z.ast.*;   // the CZT corejava AST classes

action code
{:
  // NOTE: these are local copies of the corresponding variables
  // in the main parser object.   They are updated each time 
  // the parser starts (in the 'init with' method).
  public ZFactory factory;
  public OpMaps map;

  
  //==============================================================
  // Helper methods for creating AST nodes/subtrees.
  //
  // Usually we just call factory.createXYZ(...), but some kinds of
  // nodes require more processing, so are created by these methods.
  //==============================================================

  /** Create a list with zero elements.
   */
  protected List list() {
    return new ArrayList();
  }

  /** Create a list with one element.
   */
  protected List list(Object e1) {
    List result = new ArrayList();
    result.add(e1);
    return result;
  }

  /** Create a list with two elements.
   */
  protected List list(Object e1, Object e2) {
    List result = new ArrayList();
    result.add(e1);
    result.add(e2);
    return result;
  }

  /** This coerces an Expr/Pred term into a Pred.
   */
  protected Pred pred(Term t) {
      if (t instanceof Pred)
          return (Pred)t;
      else
          return factory.createExprPred((Expr)t);
  }

  /** This coerces an Expr/Pred term into an Expr.
   */
  protected Expr expr(Term t) {
      if (t instanceof Expr)
          return (Expr)t;
      else
          // TODO: use  parser.report_error(message,info);
          throw new RuntimeException("predicate found where expression required...");
  }

  protected Spec createSpec(List sects) {
    return factory.createSpec(sects, 
                              "1.1", // version of this ZML schema.
                              "",    // author of this spec.
                              Calendar.getInstance(),
                              parser.getSourceName() // file name of the spec.
                              );
  }

/** By Chen Chunqing:
For 'name', 'declname', and 'refname' method, we can apply one more method to test whether the
word is a 'decorword or not, well since it requires to return two variables, one is the modified name and
the other is the possible stroke character. We have to repeat the similar java code inside the three 
methods respectively.
The structure of a decroword is following the definition in chapter 7.2 of ISO Z. 
Well, some notes to be mentioned:
1. Can one strok has more than one stroke characters? e.g.,  A?? where variable A has two stroke
    characters. If it allows, what is the semantics of such expression?
2. If the input string is a decorword, when create the object name, declanme or refname, the string n
    in the "create..." method is not the original one but the updated one.
*/
// Check whether a string ends with stroke character "?", "!" or "'".
  private boolean decor1(String n){
     return n.endsWith("?") || n.endsWith("!") || n.endsWith("'");
  }
//check whether a string ends with a substript integer that between 0 and 9.
  private boolean decor2(String n){
     int nlen = n.length();
     char l1 = n.charAt(nlen-1);
     char l2 = n.charAt(nlen-2);
     char l3 = n.charAt(nlen-3);
     char l4 = n.charAt(nlen-4);
     if(l1 == '}' && l3 == '{' && l4 == '_'){
        return (l2 > '0') &&(l2 < '9');
     }
     else return false;
  }
  
  protected Name name(String n) {
    // TODO: extend this to extract the decorations from n
    int nlen = n.length();
    String temp = "";
    List toks = list();
    while(nlen >=2){
       if(decor1(n)){
            temp = n.substring(nlen -1);
            n = n.substring(0, nlen-1);
	    toks.add(0, temp);
	    nlen = n.length();
	    //to make sure the order of the toks is the same as it appears originally.
            //return factory.createName(n, list(temp));
       }
       else if(nlen >=5){
             if(decor2(n)){
                temp = n.substring(nlen-2, nlen-1);
                n = n.substring(0, nlen-4);
		toks.add(0, temp);
		nlen = n.length();
                //return factory.createName(n, list(temp));
             }
	     else break;
       }
       else break;
    }//end while
    return factory.createName(n, toks);
  }
       
  protected DeclName declname(String n) {
    // TODO: extend this to extract the decorations from n
    int nlen = n.length();
    String temp = "";
    List toks = list();
    while(nlen >=2){
       if(decor1(n)){
            temp = n.substring(nlen -1);
            n = n.substring(0, nlen-1);
	    toks.add(0, temp);
	    nlen = n.length();
            //return factory.createName(n, list(temp));
       }
       else if(nlen >=5){
             if(decor2(n)){
                temp = n.substring(nlen-2, nlen-1);
                n = n.substring(0, nlen-4);
		toks.add(0, temp);
		nlen = n.length();
                //return factory.createName(n, list(temp));
             }
	     else break;
       }
       else break;
    }//end while
    return factory.createDeclName(null, n, toks);
  }

  /** Converts a list of strings into a list of DeclName objects.
   */
  protected List declnamelist(List strings) {
    List result = list();
    Iterator i = strings.iterator();
    while (i.hasNext()) {
        result.add(declname((String)i.next()));
    }
    return result;
  }

  protected RefName refname(String n) {
    // TODO: extend this to extract the decorations from n
    int nlen = n.length();
    String temp = "";
    List toks = list();
    while(nlen >=2){
       if(decor1(n)){
            temp = n.substring(nlen -1);
            n = n.substring(0, nlen-1);
            toks.add(0, temp);
	    nlen = n.length();
            //return factory.createName(n, list(temp));
       }
       else if(nlen >=5){
             if(decor2(n)){
                temp = n.substring(nlen-2, nlen-1);
                n = n.substring(0, nlen-4);
		toks.add(0, temp);
		nlen = n.length();
                //return factory.createName(n, list(temp));
             }
	     else break;
       }
       else break;
    }//end while
    return factory.createRefName(null, n, toks);
  }


  /* TODO: update these to use RefExpr ?
  public void CheckFunName(Vector nl, ReferExpression tempe){
                if(tempe.op != null){
                   String oper = (String)tempe.op;
                   System.out.println("oper is: " + oper);
                   if(tempe.el != null){
                   if(((Vector)tempe.el).size() == 2){
                   //it is a infix operator
                        if(oper.equals("\\rel")){
                                for(int i = 0; i < nl.size(); i++){
                                        VarName tempvn = (VarName)nl.elementAt(i);
                                        String nlw = (String)tempvn.n;
                                        if(! map.inMap(nlw))
                                                map.addOp(nlw, "infixrel");
                                }
                        }
                        else{
                           for(int i = 0; i < nl.size(); i++){
                                VarName tempvn = (VarName)nl.elementAt(i);
                                String nlw = (String)tempvn.n;
                                if(! map.inMap(nlw))
                                        map.addOp(nlw, "prefixfun");
                           }
                        }

                   }
                   }
                   else if((Expression)tempe.e != null){
                   //it is a prefixgeneric operator
                        for(int i = 0; i < nl.size(); i++){
                                VarName tempvn = (VarName)nl.elementAt(i);
                                String nlw = (String)tempvn.n;
                                if(! map.inMap(nlw))
                                        map.addOp(nlw, "prefixfun");
                        }
                   }
                }
                else if((Vector)tempe.el == null){
                   VarName tempvn = (VarName)tempe.vn;
                   String nlw = (String)tempvn.n;
                   if(map.inMap(nlw)){
                        for(int i = 0; i < nl.size(); i++){
                                VarName vninnl = (VarName)nl.elementAt(i);
                                String newfun = (String)vninnl.n;
                                map.addOp(newfun, (String)map.getOp(nlw));
                        }//end for
                   }//end inner if
                }//end else if
  }//end method checkfunname with vector parameter

  public void CheckFunName(VarName vn, ReferExpression tempe){
                if(tempe.op != null){
                   String oper = (String)tempe.op;
                   if(tempe.el != null){
                   if(((Vector)tempe.el).size()==2){
                      if(oper.equals("\\rel")){
                        String nlw = (String)vn.n;
                        if(! map.inMap(nlw))
                                map.addOp(nlw, "infixrel");
                      }//end if

                      else{
                           String nlw = (String)vn.n;
                           if(! map.inMap(nlw))
                              map.addOp(nlw, "prefixfun");
                      }

                   }//end if for size == 2
                   }//end if for nonempty vector
                   else if((Expression)tempe.e != null){
                   //it is a prefixgeneric operator
                        String nlw = (String)vn.n;
                        if(! map.inMap(nlw))
                                map.addOp(nlw, "prefixfun");
                   }
                }
                else if((Vector)tempe.el == null){
                   VarName tempvn = (VarName)tempe.vn;
                   String nlw = (String)tempvn.n;
                   if(map.inMap(nlw)){
                        String newfun = (String)vn.n;
                        map.addOp(newfun, (String)map.getOp(nlw));
                   }//end inner if
                }//end else if
  }//end method checkfunname with varname parameter
*/
:};

                
parser code
{:
  protected OpMaps map = new OpMaps();

  public OpMaps getOpMap(){
    return map;
  }

  protected ZFactory factory = new net.sourceforge.czt.z.impl.ZFactoryImpl();

  /** Get the object factory used for creating AST objects.
   */
  public ZFactory getFactory(){
    return factory;
  }
    
  /** Set the object factory used for creating AST objects.
   */
  public void setFactory(ZFactory fact){
    factory = fact;
  }

  protected String sourceName = "";
  
  /** Get the source name of the file being parsed.
   */
  public String getSourceName(){
    return sourceName;
  }
    
  /** Set the source name of the file being parsed.
   *   This is put into the "source" attribute of the
   *   Spec tag in the resulting XML file.
   */
  public void setSourceName(String name) {
    sourceName = name;
  }
:};

init with
{:
  action_obj.map = map;
  action_obj.factory = factory;
:};

scan with {:            Symbol s = super.scan();
                        String svalue = (String)s.value;
                        System.out.println("Token "+s.sym+"  ("+svalue+")");

                        if(s.value != null){
                          if(s.sym == LTZsym.WORD ||s.sym == LTZsym.DECLWORD)
                            if(map.inMap(svalue)){
                              String temp = (String)map.getOp(svalue);
                              if(temp.equals("infixrel")){
                                System.out.println("in map infixrel");
                                return new Symbol(LTZsym.INFIXREL, svalue);
                              }
                              else if(temp.equals("prefixfun")){
                                System.out.println("in map a prefix function name");
                                return new Symbol(LTZsym.PREFIXFUN, svalue);
                              }
                              
                              else if(temp.equals("prefixrel")){
                                System.out.println("in map prefixrel");
                                return new Symbol(LTZsym.PREFIXREL, svalue);
                              }
                              
                              else{
                                System.out.println("not defined opertor!");
                                }
                            }
                        }
                        
                        return s; :};

terminal String THETA, LAMBDA, MU, POWER;
terminal String UNDERSCORE, LSET, RSET, LDATA, RDATA, LBLOT, RBLOT;
terminal String VDASH, LAND, LOR, IMPLIES, IFF, LNOT, FORALL, EXISTS, CROSS,SPOT, HIDE, PROJECT, SEMI, PIPE;
terminal String IF, THEN, ELSE, LET, SECTION, CUP, CAP, SETMINUS, SYMDIFF;
terminal String MAPSTO, COMP, CIRC, DRES, RRES, NDRES, NRRES, OPLUS, UPTO;
terminal String LANGLE, RANGLE, CAT, EXTRACT, FILTER;
terminal String BEGINZSECT, PARENTS, ENDZSECT, BEGINAXDEF, WHERE, ENDAXDEF, BEGINSCHEMA, ENDSCHEMA;
terminal String BEGINGENDEF, ENDGENDEF, BEGINZED, ENDZED, BEGINZPAR, ENDZPAR;
terminal String LBRACE, RBRACE, NL, LSQUARE, RSQUARE, COMMA, FREEAND;
terminal String HDEF, FREEEQ, BAR, EXISTSONE, TRUE, FALSE, LBRACKET, RBRACKET, PRE, DOT;
terminal String ANTISLASH, COLON, PLUS, TIMES, MINUS, DIV, MOD, ZCOMP;
terminal String INFIXREL, POSTFIXFUN, INFIXGENERIC, PREGENERIC, PREFIXREL, PREFIXFUN;
terminal String STROKE, WORD,DECLWORD, GREEK, NUMBER, NARRSECT, NARRPARA, FUNNAME, UNDERINFIXREL;
terminal String ZRELATION, ZFUNCTION, ZGENERIC, ASSOC, OPERANDLIST,PREC;
terminal  Rename_Exp;
terminal String PREPTOK, PRETOK, POSTPTOK, POSTTOK, IPTOK, ITOK, LPTOK, LTOK, ELPTOK, ELTOK;
terminal String ERPTOK, ERTOK, SRPTOK, SRTOK, EREPTOK, ERETOK, SREPTOK, SRETOK, ESTOK, SSTOK;

non terminal Spec specification;
non terminal List sections;
non terminal Sect section;
non terminal List/*<Parent>*/ opt_parents;
non terminal List/*<Para>*/ paragraphs, unboxedpars;
non terminal Para paragraph, zparagraph, zeditem;
non terminal Branch branch;
non terminal List/*<Branch>*/ branchlist;
non terminal DeclName declname;
non terminal RefName refname;
non terminal String opname, prefixname, postfixname, infixname, nofixname, mixfixname, opbody, opt_arg, list_sep;
non terminal String genname, prefixgenname, postfixgenname, infixgenname, nofixgenname, mixfixgenname;
non terminal List/*<DeclName>*/ opt_formals, formals;
non terminal List/*<RefName>*/  refnamelist;
non terminal List/*<DeclName>*/ declnamelist;
non terminal List/*<String>*/   namelist;
non terminal List declpart, declpart2;
non terminal Decl declelem, basicdecl;
non terminal TermA term, func_appl, inner_term, outer_term;
non terminal Pred predicate;
non terminal Expr expression;
non terminal List opt_term_list, term_list, bind_list;
non terminal SchText schematext, schematext_minus_expr;
non terminal List renamelist;
non terminal NameNamePair rename;
non terminal ConstDecl binding;
non terminal ApplExpr application;
non terminal List freetypelist;
non terminal Freetype freetype;
non terminal List narrparalist;
non terminal OptempPara optemplate;
non terminal Cat fungen;
non terminal OptempPara template;
non terminal List chainrel;
non terminal mixfix;

precedence right NARRPARA, NARRSECT;
precedence left NL, SEMI;
precedence left COMMA;
precedence right SPOT, BAR;
precedence left IFF;
precedence left IMPLIES;
precedence left LOR;
precedence left LAND;
precedence right LNOT;
precedence left LPTOK, ELPTOK, SREPTOK, EREPTOK,SRPTOK,ERPTOK;
precedence left INFIXREL,IPTOK;
precedence left PREFIXREL, PREPTOK;
precedence left POSTTOK;
precedence right LAMBDA;
precedence right MU;
precedence right LET;
precedence right ELSE;
precedence left ZCOMP;
precedence left PIPE;
precedence left HIDE;
precedence left PROJECT;
precedence right PRE;
precedence left LTOK, ELTOK, SRETOK, ERETOK,SSTOK, ESTOK,SRTOK,ERTOK;
precedence left INFIXGENERIC,ITOK;
precedence left PRETOK;
precedence left POSTTOK;
precedence left MAPSTO;
precedence left UPTO;
precedence left SYMDIFF;
precedence left PLUS, MINUS, CUP, CAT, SETMINUS;
precedence left TIMES, DIV, MOD, CIRC, FILTER, CAP, COMP;
precedence left EXTRACT;
precedence left OPLUS;
precedence left RRES, NRRES;
precedence right DRES, NDRES;
precedence right PREFIXFUN;
precedence right CROSS, POWER, PREGENERIC;
precedence left PREFIXFUN;
precedence left POSTFIXFUN;
precedence left STROKE;
precedence left Rename_Exp;
precedence left DOT;
precedence right THETA;
precedence left LSQUARE, RSQUARE;
precedence nonassoc LANGLE, RANGLE;
precedence nonassoc LBLOT;


// TODO: before starting parsing this, set up the operator tables
//     to be the standard_toolkit operators only.
specification ::=
    sections:s
        {: RESULT = createSpec(s); :}
    | 
    paragraphs:pgs
        {: ZSect sect = factory.createZSect("Specification",
                                            list(), // no parents
                                            pgs);
           RESULT = createSpec(list(sect));
        :}
    ;
 
sections ::=
    sections:ss section:s
        {: ss.add(s); RESULT=ss; :}
    | section:s
        {: RESULT = list(s); :}
    ;

section ::=
    BEGINZSECT SECTION WORD:w opt_parents:p ENDZSECT paragraphs:pgs
        {: RESULT = factory.createZSect(w, p, pgs); :}
    ;

opt_parents ::=
    PARENTS namelist:nl
        {: RESULT = list();
           // Convert the strings to Parent objects.
           Iterator i = nl.iterator();
           while (i.hasNext()) {
               RESULT.add(factory.createParent((String)i.next()));
           }
           // TODO: set up the operator tables (by importing these sections)
        :}
    |
    // empty
        {: RESULT = list();
           // TODO: set up the operator tables to be standard_toolkit only
        :}
    |
    //added by Chen Chunqing.
    //Capture when the name list is empty while the keyword "parent" presents.
    PARENTS
    {:  RESULT = list(); :}
    ;

//added by Chen Chunqing.
//move the definition of unboxed paragraphs up to the paragraphs level.
paragraphs ::=
    paragraphs:pgs zparagraph:pg
        {: pgs.add(pg); RESULT=pgs; :}
    |
    paragraphs:pgs BEGINZED unboxedpars:ubp ENDZED
    {: pgs.addAll(ubp); RESULT = pgs; :}
    |
    // empty
        {: RESULT = list(); :}
    ;
                 
//added by Chen Chunqing. To adjust the structure to the YACC grammar. 
/*
paragraph ::= zparagraph:zp
                    {: RESULT = zp; :}
                    |
                    unboxedpar:und
                    {: RESULT = und; :}
                    ;
*/                    
//added by Chen Chunqing
zparagraph ::= BEGINAXDEF schematext:st ENDAXDEF
                     {: RESULT = factory.createAxPara(list(),st,Box.AxBox); :}
                      |
                      BEGINSCHEMA opt_formals:f LBRACE WORD:n RBRACE schematext:st ENDSCHEMA
                      {:// Rule 12.2.3.1: SCH i t END  ==> AX [i==t] END
                         // Rule 12.2.3.2: SCH i [i1..in] t END  ==> AX [i1..in] [i==t] END
                         Expr e = factory.createSchExpr(st);
                         ConstDecl decl = factory.createConstDecl(declname(n),e);
                         SchText stext = factory.createSchText(list(decl),null);
                         RESULT = factory.createAxPara(f,stext,Box.SchBox);
                       :}
                       |
                       BEGINGENDEF opt_formals:f schematext:st ENDGENDEF
                       {: RESULT = factory.createAxPara(f,st,Box.AxBox); :}
                       |
                       BEGINZED opt_formals:f VDASH predicate:p ENDZED
                       {: RESULT = factory.createConjPara(f,p); :}
                       |
                       BEGINZED optemplate:ot ENDZED
                       {: RESULT = ot; :}
                       |
                       narrparalist:u
                       {: RESULT = factory.createUnparsePara(u); :}
                       ;

//added by Chen Chunqing 
//we allow users to define several unboxed paragraphs (horizontal definitions for example)
//in one pair of "\begin{zed}" and "\end{zed}" latex command.
unboxedpars ::= unboxedpars:ubp NL  zeditem:zd 
                      {: ubp.add(zd); RESULT = ubp; :}
		      |
		      zeditem:zd
		      {: RESULT = list(zd); :}
                      ;         

//added by Chen Chunqing. mostly it is the same as zedparagraph                      
//haven't capture the "genname HDEF expr" structure since the genname undefined yet.
zeditem ::= formals:f
               {: RESULT = factory.createGivenPara(f); :}
               |   
               declname:n formals:f HDEF expression:e
               {:// Rule 12.2.3.4: i [i1..in] == e END ==> GENAX [i1..in] [i==e] END
                  ConstDecl decl = factory.createConstDecl(n,e);
                  SchText stext = factory.createSchText(list(decl),null);
                  RESULT = factory.createAxPara(f,stext,Box.OmitBox);
               :}
               |
              declname:n HDEF expression:e
              {: // Rule 12.2.3.3: i==e END ==> AX [i==e] END
                 ConstDecl decl = factory.createConstDecl(n,e);
                 SchText stext = factory.createSchText(list(decl),null);
                 RESULT = factory.createAxPara(list(),stext,Box.OmitBox);
               :}
               |               
               genname:gn HDEF expression:e
	       //need to figure out tomorrow (9/12/03)
               |
               freetypelist:ftl
               {: RESULT = factory.createFreePara(ftl); :}
               ;               

narrparalist ::=
    narrparalist:l NARRPARA:u
        {: l.add(u); RESULT = l; :}
    |
    NARRPARA:u
        {: RESULT = list(u); :}
    ;
    
freetypelist ::=
    freetypelist: ftl  FREEAND freetype:ft
        {: ftl.add(ft); RESULT = ftl; :}
    |
    freetype:ft
        {: RESULT = list(ft); :}
    ;

freetype ::=
    WORD:n FREEEQ branchlist:bl
        {: RESULT = factory.createFreetype(declname(n), bl); :}
    ;

branchlist ::=
    branchlist:bl BAR branch:b
        {: bl.add(b); RESULT = bl; :}
    |
    branch:b
        {: RESULT = list(b); :}
    ;

branch ::=
    declname:n LDATA expression:e RDATA
        {: RESULT = factory.createBranch(n, e); :}
    |
    declname:n
        {: RESULT = factory.createBranch(n, null); :}
    ;        
    
optemplate  ::= fungen:fg template:t
                      {: t.setCat(fg); RESULT = t; :}
                      |
                      fungen:fg PREC:n ASSOC:ad template:t
                      {:t.setCat(fg); 
                         t.setPrec(new Integer(n)); 
                         Assoc a = (ad.equals("Left")? Assoc.Left : Assoc.Right);
                         t.setAssoc(a);
                         RESULT = t; :}
                      |
                      fungen:fg PREC:n template:t
                      {: t.setCat(fg); 
                          t.setPrec(new Integer(n));
                          RESULT = t; :}
                      ;

fungen ::= ZRELATION
              {: RESULT = Cat.Relation; :}
              |
              ZFUNCTION
              {: RESULT = Cat.Function; :}
              |
              ZGENERIC
              {: RESULt = Cat.Generic; :}
              ;

/**capture the three kinds of structure below.
     (_  word  _), (_  word), (word  _).
     We first assume the prec is 0, the association is left, and it is a relation, then when it is
     passed up, it will update its association, precedence and relation type.
*/
template ::= LBRACKET opt_arg:o1 WORD:w opbody:ob opt_arg:o2 RBRACKET
                 {: Strnig oname = w + ob; 
                     Operand op = factory.createOperand();
                     List toks = new List();
                     if(o1.equals("\\_") && o2.equals("\\_")){                                                                              
                          toks.add(op);
                          toks.add(oname);
                          toks.add(op);
                          RESULT = factory.createOptempPara(toks, Cat.Relation, Assoc.Left,
                                             new Integer(0));
                      }
                      else if(o1.equals("\\_")){
                           toks.add(op);
                           toks.add(oname);
                           RESULT = factory.createOptempPara(toks, Cat.Relation, Assoc.Left,
                                               new Integer(0));
                       }
                       else if(o2.equals("\\_")){
                            toks.add(oname);
                            toks.add(op);
                            RESULT = factory.createOptempPara(toks, Cat.Relation, Assoc.Left,
                                                new Integer(0));
                        }
                        else System.err.println("error occur in the template's match"); :}
                    ;

opbody ::= opbody:ob UNDERSCORE WORD:n 
               {: RESULT = ob + " _ " +  n; :}
               |
               //empty
               ;

opt_arg ::= UNDERSCORE:u
                {: RESULT = u; :}
                |
                //empty
                ;

//modified by Chen Chunqing. To introduce the "formals" definition.
//Question: why call declnamelist method?
opt_formals ::= formals:f
                      {: RESULT = f; :}
                      | 
                     // empty
                      {: RESULT = list(); :}
                      ;

formals ::= LSQUARE namelist:nl RSQUARE
               {: RESULT = declnamelist(nl); :}
               ;
               
// a list of WORDs, returned as Strings.
namelist ::=
    namelist:nl COMMA WORD:n
        {: nl.add(n); RESULT=nl; :}
    |
    WORD:n
        {: RESULT = list(n); :}
    ;

/* This is the same as namelist, but recognises only DECLWORD symbols.
 * This is because SmartScanner converts WORD symbols into DECLWORD
 * symbols just before the COLON of a declaration.
 * TODO: we might be able to do without SmartScanner if we
 *     adopt Ian Toyn's grammar for expressions?  Then we could
 *     simplify this to just a list of 'declname' calls.
 */
declnamelist ::=
    declnamelist:nl COMMA DECLWORD:n
        {: nl.add(declname(n)); RESULT=nl; :}
    |
    DECLWORD:n
        {: RESULT = list(declname(n)); :}
    ;

declname ::=
    WORD:w
        {: RESULT = declname(w); :}
    |
    opname:o
        {: RESULT = declname(o); :}
    ;

refnamelist ::=
    refnamelist:nl COMMA refname:n
        {: nl.add(n); RESULT=nl; :}
    |
    refname:n
        {: RESULT = list(n); :}
    ;

refname ::=
    WORD:w
        {: RESULT = refname(w); :}
    |
    LBRACKET opname:o RBRACKET
        {: RESULT = refname(o); :}
    ;

/**By Chen Chunqing
Consider opname is a string type first, and according to different types 
(prefix, postfix, infix and nofix), to generate different string that involves "_".
*/
opname ::= prefixname:pren
                {: RESULT = pren; :}
                |
                postfixname:postn
                {: RESULT = postn; :}
                |
                infixname:inn
                {: RESULT = inn; :}
                |
                nofixname: non
                {: RESULT = non; :}
                ;
                
prefixname ::= PRETOK:pre UNDERSCORE
                      {: RESULT = pre + " _"; :}
                      |
                      PREPTOK:pre UNDERSCORE
                      {: RESULT = pre + " _"; :}
                      |
                      LTOK:l mixfixname:mix UNDERSCORE ERETOK:ere UNDERSCORE
                      {: RESULT = l + " " + mix + " _ " + ere + " _"; :}
                      |
                      LTOK:l mixfixname:mix UNDERSCORE SRETOK:sre UNDERSCORE
                      {: RESULT = l + " " + mix + " _ " + sre + " _"; :}
                      |
                      LPTOK:lp mixfixname:mix UNDERSCORE EREPTOK:erep UNDERSCORE
                      {: RESULT = lp + " " + mix + " _ " + erep + " _"; :}
                      |
                      LPTOK:lp mixfixname:mix UNDERSCORE SREPTOK:srep UNDERSCORE
                      {: RESULT = lp + " " + mix + " _ " + srep + " _"; :}
                      ;
                      
postfixname ::= UNDERSCORE POSTTOK:post
                       {: RESULT = "_ "+ post; :}
                       |
                       UNDERSCORE POSTPTOK:postp
                       {: RESULT = "_ "+ postp; :}
                       |
                       UNDERSCORE ELTOK:el mixfixname:mix UNDERSCORE ERTOK:er
                       {: RESULT = "_ " + el + " " + mix + " _ "+ er; :}
                       |
                       UNDERSCORE ELTOK:el mixfixname:mix UNDERSCORE SRTOK:sr
                       {: RESULT = "_ " + el + " " + mix + " _ "+ sr; :}
                       |
                       UNDERSCORE ELPTOK:elp mixfixname:mix UNDERSCORE ERPTOK:erp
                       {: RESULT = "_ " + elp + " " + mix + " _ " + erp; :}
                       |
                       UNDERSCORE ELPTOK:elp mixfixname:mix UNDERSCORE SRPTOK:srp
                       {: RESULT = "_ " + elp + " " + mix + " _ " + srp; :}
                       ;
                       
infixname ::= UNDERSCORE ITOK:i UNDERSCORE
                   {: RESULT = "_ " + i + " _"; :}
                   |
                   UNDERSCORE IPTOK:ip UNDERSCORE
                   {: RESULT = "_ " + ip + " _"; :}
                   |
                   UNDERSCORE ELTOK:el mixfixname:mix UNDERSCORE ERETOK:ere UNDERSCORE
                   {: RESULT = "_ " + el + " " + mix + " _ " + ere + " _"; :}
                   |
                   UNDERSCORE ELTOK:el mixfixname:mix UNDERSCORE SRETOK:sre UNDERSCORE
                   {: RESULT = "_ " + el + " " + mix + " _ " + sre + " _"; :}
                   |
                   UNDERSCORE ELPTOK:elp mixfixname:mix UNDERSCORE EREPTOK:erep UNDERSCORE
                   {: RESULT = "_ " + elp + " " + mix + " _ " + erep + " _"; :}
                   |
                   UNDERSCORE ELPTOK:elp mixfixname:mix UNDERSCORE SREPTOK:srep UNDERSCORE
                   {: RESULT = "_ " + elp + " " + mix + " _ " + srep + " _"; :}
                   ;
                   
nofixname ::= LTOK:l mixfixname:mix UNDERSCORE ERTOK:er
                    {: RESULT = l + " " + mix + " _ " + er; :}
                    |
                    LTOK:l mixfixname:mix UNDERSCORE SRTOK:sr
                    {: RESULT = l + " " + mix + " _ " + sr; :}
                    |
                    LPTOK:lp mixfixname:mix UNDERSCORE ERPTOK:erp
                    {: RESULT = lp + " " + mix + " _ " + erp; :}
                    |
                    LPTOK:lp mixfixname:mix UNDERSCORE SRPTOK:srp
                    {: RESULT = lp + " " + mix + " _ " + srp; :}
                    ;
                    
mixfixname ::= mixfixname:mix UNDERSCORE ESTOK:es
                      {: RESULT = mix + " " + es; :}
                      |
                      mixfixname:mix UNDERSCORE SSTOK:ss
                      {: RESULT = mix + " " + ss; :}
                      |
                      //empty
                      ;
                      
/**By Chen Chunqing
Because I don't know how to handle the "genname" in ZML, here I just simply treats them as 
String type, as similar as "opname", generate string based on different types.
Need to clarify with Mark
*/
genname ::= prefixgenname:preg
                  {: RESULT = preg; :}
                  |
                  postfixgenname:postg
                  {: RESULT = postg; :}
                  |
                  infixgenname:infixg
                  {: RESULT = infixg; :}
                  |
                  nofixgenname:nofixg
                  {: RESULT = nofixg; :}
                  ;
                  
prefixgenname ::= PRETOK:pre WORD:w
                            |
                            LTOK:l mixfixgenname:mix WORD:w1 ERETOK:ere WORD:w2
                            |
                            LTOK:l mixfixgenname:mix WORD:w1 SRETOK:sre WORD:w2
                            ;
                            
postfixgenname ::= WORD:w POSTTOK:post
                             |
                             WORD:w1 ELTOK:el mixfixgenname:mix WORD:w2 ERTOK:er
                             |
                             WORD:w1 ELTOK:el mixfixgenname:mix WORD:w2 SRTOK:sr
                             ;
                             
infixgenname ::= WORD:w1 ITOK WORD:w2
                          |
                          WORD:w1 ELTOK:el mixfixgenname:mix WORD:w2 ERETOK:ere WORD:w3
                          |
                          WORD:w1 ELTOK:el mixfixgenname:mix WORD:w2 SRETOK:sre WORD:w3
                          ;
                          
nofixgenname ::= LTOK:l mixfixgenname:mix WORD:w ERTOK:er
                           |
                           LTOK:l mixfixgenname:mix WORD:w SRTOK:sr
                           ;
                           
mixfixgenname ::= mixfixgenname:mix WORD:w ESTOK:es
                            |
                            mixfixgenname:mix WORD:w SSTOK:ss
                            |
                            //empty
                            ;
                  
schematext ::=
    declpart:dp BAR predicate:pp
        {: RESULT = factory.createSchText(dp, pp); :}
    |
    declpart:dp WHERE predicate:pp
        {: RESULT = factory.createSchText(dp, pp); :}
    |
    declpart:dp
        {: RESULT = factory.createSchText(dp, null); :}
    ;

schematext_minus_expr ::= declpart:dp BAR predicate:pp
                                 {: RESULT = factory.createSchText(dp, pp); :}
				 |
				 declpart:dp WHERE predicate:pp
				 {: RESULT = factory.createSchText(dp, pp); :}
				 |
				 declpart2:dl2 list_sep declelem:d
				 {: dl2.add(d); 
				     RESULT = factory.createSchText(dl2, null);:}
				  |
				  basicdecl: bd
				  {: RESULT = factory.createSchText(list(bd), null); :}
				  ;

declpart ::= declpart2:dp2
                 {: RESULT = dp2; :}
                 |
                 //empty
                 {: RESULT = list(); :}
                 ;
declpart2 ::= declpart2:dl2 list_sep declelem:de
                   {: dl2.add(de), RESULT = dl2; :}
                   |
                   declelem:de
                   {: RESULT = list(de); :}
                   ;
                   
list_sep ::= SEMI
                 |
                  NL
                  ;

declelem ::= basicdecl : bd
                  {: RESULT = bd; :}
                  |
                  expression:e
                  {: RESULT = factory.createInclDecl(e); :}
                  ;
                  
 basicdecl ::= declnamelist:nl COLON expression:e 
                   {: RESULT = factory.createVarDecl(nl,e); :}
                   |
                   declname:n HDEF expression:e
                   {: RESULT = factory.createConstDecl(n,e); :}
                   ;                

//convert the predicate into outer_term type.
predicate ::= outer_term:ot
                {: RESULT = ot; :}
		;
/*
    predicate:p1 NL predicate:p2
        {: RESULT = factory.createAndPred(Op.NL, p1, p2 ); :}
    |
    predicate:p1 SEMI predicate:p2
        {: RESULT = factory.createAndPred(Op.Semi, p1, p2); :}
    |
    term:e
        {: RESULT = e; :}
    ;
*/
/**By Chen Chunqing
Modify some of the expressions using 'create...' method.

Apply the super type "TermA" to "expression".

Treat those structures involve logical operators (and, or, not, imply, iff, 
forall, exists, exists1) as expression first, and later they can be converted into
predicate type using "Pred pred(Term t)" method when necessary.
*/
expression ::= term:t
                   {: RESULT =t; :}
                   ;          

// TODO: the other kinds of expr (I've just done a few basic ones)
term ::= FORALL schematext:st SPOT term:e
        {: RESULT = factory.createForallExpr(st, e); :}
    |
    EXISTS schematext:st SPOT term:e
        {: RESULT = factory.createExistsExpr( st, e); :}
    |
    EXISTSONE schematext:st SPOT term:e
        {: RESULT = factory.createExists1Expr(st, e); :}
    |
    LAMBDA schematext:st SPOT term:e
        {: RESULT = factory.createLambdaExpr(st, e); :}
    |
    MU schematext:st SPOT term:e
        {: RESULT = factory.createMuExpr(st, e); :} %prec MU
    |
    LET schematext:st SPOT term:e
        {: RESULT = factory.createLetExpr(st, e); :} %prec LET
    |
    term:e1 IMPLIES term:e2
        {: RESULT = factory.createImpliesExpr(e1,  e2); :}
    |
    term:e1 IFF term:e2
        {: RESULT = factory.createIffExpr(e1,  e2); :}
    |
    term:e1 LAND term:e2
        {: RESULT = factory.createAndExpr(e1,  e2); :}
    |
    term:e1 LOR term:e2
        {: RESULT = factory.createOrExpr(e1,  e2); :}
    |
    LNOT term:e
        {: RESULT = factory.createNegExpr( e); :}
    |
    IF predicate:p THEN term:e1 ELSE term:e2
        {: RESULT = factory.createCondExpr(p, e1, e2); :}
    |
    term:e1 ZCOMP term:e2
        {: RESULT = factory.createCompExpr(e1, e2); :}
    |
/**By Chen Chunqing
The "schema hiding" hides the "declname" not the "refname" according to ISO Z.
    expression:e HIDE LBRACKET refnamelist:nl RBRACKET
        {: RESULT = factory.createHideExpr(nl,e); :}
    |
    expression:e HIDE LBRACKET opname:on RBRACKET
        {: RESULT = new SchemaHideExpression(e, list(on)); :}
    |
    expression:e HIDE LBRACKET opnamelist:ol RBRACKET
        {: RESULT = new SchemaHideExpression(e, ol); :}
*/
    term:e HIDE LBRACKET declnamelist:nl RBRACKET
        {: RESULT = factory.createHideExpr(nl, e); :}
    |
    term:e1 PIPE term:e2
        {: RESULT = factory.createPipeExpr(e1,  e2); :}
    |
    term:e1 PROJECT term:e2
        {: RESULT = factory.createProjExpr(e1, e2); :}
    |
    PRE term:e
        {: RESULT = factory.createPreExpr( e); :}
    |
    term:e1 CROSS term:e2
        {: RESULT = factory.createProdExpr(list(e1,e2)); :}
    |
    //concate the lptok and ereptok together to a new opname.
    //still got problem!!!
    LPTOK:l mixfix:mix term:t1 EREPTOK:erep term:t
    |
    LPTOK:l mixfix:mix opt_term_list:otl SREPTOK:srep term:t
    |
    PREPTOK:prep term:t
    |
    term:t1 ELPTOK:elp mixfix:mix term:t2 ERPTOK:erp
    |
    term:t ELPTOK:elp mixfix:mix opt_term_list:otl SRPTOK:srp
    |
    term:t POSTPTOK:postp
    |
    term:t1 ELPTOK:elp mixfix:mix term:t2 EREPTOK:erep term:t3
    |
    term:t1 ELPTOK:elp mixfix:mix opt_term_list:otl SREPTOK:srep term:t2
    |
    term:t1 IPTOK:ip term:t2
    |
    LTOK:l mixfix:mix term:t1 ERETOK:ere term:t2
    |
    LTOK:l mixfix:mix opt_term_list:otl SRETOK:sre term:t
    |
    PRETOK:pre term:t
    |
    term:t1 ELTOK:el mixfix:mix term:t2 ERTOK:er
    |
    term:t1 ELTOK:el mixfix:mix opt_term_list:otl SRTOK:sr
    |
    term:t POSTTOK:post
    |
    term:t1 ELTOK:el mixfix:mix term:t2 ERETOK:ere term:t3
    |
    term:t1 ELTOK:el mixfix:mix opt_term_list:otl SRETOK:sre term:t2
    |
    term:t1 ITOK:i term:t2
    |
    POWER term:e
        {: RESULT = factory.createPowerExpr(e); :}
    |
    func_appl:fa
       {: RESULT = fa; :}
    ;
    
/**By Chen Chunqing
How to capture the first syntax structure? Apply the "createApplExpr" method?
But we can't decide the boolean at this stage.
*/
func_appl ::= func_appl:fa inner_term:it
                  {: RESULT = factory.createApplExpr(Boolean.TRUE, fa, it); :}
                  |
                  inner_term:it
                  {: RESULT = it; :}
                  ;

inner_term ::= LBRACE opt_term_list:tl RBRACE
                     {: RESULT = factory.createSetExpr(tl); :}
                     |
                     LBRACE schematext:st SPOT term:t RBRACE
                     {: RESULT = factory.createSetCompExpr(st, t); :}
                     |
		     LBRACE schematext_minus_expr:sme RBRACE
		     {: RESULT = factory.createSetCompExpr(sme, null); :}
		     |
		     LBRACKET term:t COMMA term_list:tl RBRACKET
		     {: List toks = list(); 
		        toks.add(t);
			toks.addAll(tl);
			RESULT = factory.createTupleExpr(toks); :}
	             |
		     LBRACKET  MU schematext:st RBRACKET
		     {: RESULT = factory.createMuExpr(st, null); :}
		     |
		     //got problem here also.
                     LPTOK:lp mixfix:mix term:t ERPTOK:erp
                     |
                     LPTOK:lp mixfix:mix opt_term_list:otl SRPTOK:srp
                     |
                     LTOK:l mixfix:mix term:t ERTOK:er
                     |
                     LTOK:l mixfix:mix opt_term_list:otl SRTOK:sr
                     |                     
                     LBLOT bind_list:bl RBLOT
                     {: RESULT = factory.createBindExpr(bl); :}
                     |
                     LBLOT RBLOT
                     {: RESULT = factory.createBindExpr(); :}
                     |
                     LSQUARE RSQUARE
                     {: RESULT = factory.createSchExpr(); :}
                     |
                     inner_term:it DOT refname:rn
                     {: RESULT = factory.createBindSelExpr(rn, it); :}
                     |
                     inner_term:it DOT NUMBER:n
                     {: Integer nn = new Integer(n);
                         RESULT = factory.createTupleSelExpr(nn, it); :}
                     |
//how to represent the "Stroke" type?
                     inner_term:it  STROKE:s
                     {: RESULT = factory.createDecorExpr(s, it); :}
                     |
//which method can be used here?
                     THETA inner_term:it
                     {: List strokes = list();
                         while (it instanceof DecorExpr && it.getAnns() doesnot contain ParenAnn ) {
                           DecorExpr e = (DecorExpr)it;
                           strokes.add(e.getStroke());
                           it = e.getExpr();
                           }
                           return factory.createThetaExpr(strokes, it);
                     :}
                     |
                     inner_term:it LSQUARE renamelist:rl RSQUARE  
                     {: RESULT = factory.createRenameExpr(rl, it); :} %prec Rename_Exp
                     |
//how to decide the boolean value of the parameter of the "createRefExpr" method.
                     refname:rn LSQUARE term_list:tl RSQUARE
                     {: RESULT = factory.createRefExpr(rn, tl, Boolean.TRUE); :}
                     |
                     NUMBER:n
                     {: RESULT = factory.createNumExpr(new BigInteger(n)); :}
                     |
                     LBRACKET outer_term:ot RBRACKET
                     {: ot.getAnns().add(factory.createParenAnn()); RESULT = ot; :}
                     |
                     refname:rn
                     {: RESULT = factory.createRefExpr(rn,list(),Boolean.FALSE); :}                    
                     |
                    TRUE
                    {: RESULT = factory.createTruePred(); :}
                    |  
                    FALSE
                    {: RESULT = factory.createFalsePred(); :}
                     ;
                   
mixfix ::= mixfix term:t ESTOK:es
              |
              mixfix opt_term_list:otl SSTOK:ss
              |
              //empty
              ;
                   
outer_term ::= predicate:p1 NL predicate:p2
                      {: RESULT = factory.createAndPred(Op.NL, p1, p2); :}
                      |
		      predicate:p1 SEMI predicate:p2
		      {: RESULT = factory.createAndPred(Op.SEMI, p1, p2); :}
                      |
                      term:t
                      {: RESULT = t; :}
                      ;
                       
renamelist ::=  renamelist:rl COMMA rename:r
        {: rl.add(r); RESULT = rl; :}
    |
    rename:r
        {: RESULT = list(r); :}
    ;

rename ::=
    declname:n1 ANTISLASH refname:n2
        {: // Note that this takes OldName first, then NewName second.
           // TODO: check why the standard has two declnames here?
           RESULT = factory.createNameNamePair(n2, n1);
        :}
    ;
                   
          
bind_list ::= bind_list:bl COMMA binding:b
                 {: bl.add(b); RESULT = bl; :}
                 |
                 binding:b
                 {: RESULT = list(b); :}
                 ;
                 
binding ::= declname:dn HDEF expression:e
               {: RESULT = factory.createConstDecl(dn, e); :}
               ;
               
opt_term_list ::= term_list:tl
                         {: RESULT = tl; :}
                         | //Empty
                         {: RESULT = list(); :}
                         ;
                         
term_list ::= term_list:tl COMMA term:t
                  {: tl.add(t); RESULT = tl; :}
                  |
                  term:t
                  {: RESULT = list(t); :}
                  ;
                  

/*
application ::=
    PREFIXFUN:p expression:e
        {: RESULT = factory.createApplExpr(Boolean.FALSE, p, e); :}
    |
//  TODO: handle these by loading the standard toolkit operator templates...
    expression:e1 MAPSTO expression:e2
        {: RESULT = new InfixApp(e1, "\\mapsto", e2); :}
    |
    expression:e1 UPTO expression:e2
        {: RESULT = new InfixApp(e1, "\\upto", e2); :}
    |
    expression:e1 SYMDIFF expression:e2
        {: RESULT = new InfixApp(e1, "\\symdiff", e2); :}
    |
    expression:e1 PLUS expression:e2
        {: RESULT = new InfixApp(e1, "+", e2); :}
    |
    expression:e1 MINUS expression:e2
        {: RESULT = new InfixApp(e1, "-", e2); :}
    |
    expression:e1 TIMES expression:e2
        {: RESULT = new InfixApp(e1, "*", e2); :}
    |
    expression:e1 CUP expression:e2
        {: RESULT = new InfixApp(e1, "\\cup", e2); :}
    |
    expression:e1 SETMINUS expression:e2
        {: RESULT = new InfixApp(e1, "\\setminus", e2); :}
    |
    expression:e1 DIV expression:e2
        {: RESULT = new InfixApp(e1, "\\div", e2); :}
    |
    expression:e1 MOD expression:e2
        {: RESULT = new InfixApp(e1, "\\mod", e2); :}
    |
    expression:e1 OPLUS expression:e2
        {: RESULT = new InfixApp(e1, "\\oplus", e2); :}
    |
    expression:e1 COMP expression:e2
        {: RESULT = new InfixApp(e1, "\\comp", e2); :}
    |
    expression:e1 CIRC expression:e2
        {: RESULT = new InfixApp(e1, "\\circ", e2); :}
    |
    expression:e1 CAP expression:e2
        {: RESULT = new InfixApp(e1, "\\cap", e2); :}
    |
    expression:e1 DRES expression:e2
        {: RESULT = new InfixApp(e1, "\\dres", e2); :}
    |
    expression:e1 RRES expression:e2
        {: RESULT = new InfixApp(e1, "\\rres", e2); :}
    |
    expression:e1 NDRES expression:e2
        {: RESULT = new InfixApp(e1, "\\ndres", e2); :}
    |
    expression:e1 CAT expression:e2
        {: RESULT = new InfixApp(e1, "\\cat", e2); :}
    |
    expression:e1 EXTRACT expression:e2
        {: RESULT = new InfixApp(e1, "\\extract", e2); :}
    |
    expression:e1 FILTER expression:e2
        {: RESULT = new InfixApp(e1, "\\filter", e2); :}
    |
    expression:e1 NRRES expression:e2
        {: RESULT = new InfixApp(e1, "\\nrres", e2); :}
    |
    expression:e POSTFIXFUN:post
        {: RESULT = new PostfixApp(e, post); :}
    |
    LANGLE expressionlist:el RANGLE
        {: Vector v = new Vector();
                if(el.size()==1){
                        Expression tempe = (Expression)el.firstElement();
                        if(tempe instanceof TupleExpression){
                                TupleExpression tuplee = (TupleExpression)tempe;
                                Vector tempv = (Vector)tuplee.el;
                                for(int i = 0; i < tempv.size(); i++){
                                        Integer j = new Integer(i+1);
                                        NumberExpression ne = new NumberExpression(j.toString());
                                        Vector inv = new Vector();
                                        inv.addElement(ne);
                                        inv.addElement((Expression)tempv.elementAt(i));
                                        TupleExpression te = new TupleExpression(inv);
                                        v.addElement(te);
                                }//end for
                        }//end inner if
                        else{
                                NumberExpression ne = new NumberExpression("1");
                                Vector inv = new Vector();
                                inv.addElement(ne);
                                inv.addElement(tempe);
                                TupleExpression te = new TupleExpression(inv);
                                v.addElement(te);
                        }//end inner else
                }//end if
                else{
                        for(int i = 0; i < el.size(); i++){
                                Integer j = new Integer(i+1);
                                NumberExpression ne = new NumberExpression(j.toString());
                                Vector inv = new Vector();
                                inv.addElement(ne);
                                inv.addElement((Expression)el.elementAt(i));
                                TupleExpression te = new TupleExpression(inv);
                                v.addElement(te);
                        }//end inner for
                }//end else
               SetExpression s = new SetExpression(v);
               RESULT = new NofixApp("\\langle", "\\rangle", s); :}
    ;


equaldecllist ::=
    equaldecllist:edl COMMA equaldecl:ed
        {: edl.add(ed); RESULT = edl; :}
    |
    equaldecl:ed
        {: RESULT = list(ed); :}
    ;

equaldecl ::=
    declname:n HDEF expression:e
        {: RESULT = factory.createConstDecl(n, e); :}
    ;
*/

/*               
zedparagraph ::=
    LSQUARE namelist:nl RSQUARE
        {: RESULT = factory.createGivenPara(declnamelist(nl)); :}
    |
    |   
    WORD:n LSQUARE namelist:nl RSQUARE HDEF expression:e
        {:// Rule 12.2.3.4: i [i1..in] == e END ==> GENAX [i1..in] [i==e] END
          ConstDecl decl = factory.createConstDecl(declname(n),e);
          SchText stext = factory.createSchText(list(decl),null);
          RESULT = factory.createAxPara(declnamelist(nl),stext,Box.OmitBox);
        :}
    |
    // TODO: remove this?  It is not allowed by the Z standard grammar?
    // schematext:st
    //    {: RESULT = new ZedParagraph(st); :}
    |
    freetypelist:ftl
        {: RESULT = factory.createFreePara(ftl); :}
    |
    opt_formals:f VDASH predicate:p
        {: RESULT = factory.createConjPara(f,p); :}
    |
    operatortemp:ot
        {: RESULT = ot; :}
    ;
*/
//seems the following won't be used anymore, remove them?
/* NOT USED AT THE MOMENT
zedparagraphs ::=
    zedparagraphs:zps NL zedparagraph:zp
        {: zps.add(zp); RESULT = zps; :}
    |
    zedparagraphs:zps SEMI zedparagraph:zp
        {: zps.add(zp); RESULT = zps; :}
    |
    zedparagraph:zp
        {: RESULT = list(zp); :}
    ;
*/
/**By Chen Chunqing
According to the latest YACC grammar, move left definition into inner term.
    application:app
        {: RESULT = app; :}
    |
    PREFIXREL:p expression:e
        {: RESULT = factory.createApplExpr(Boolean.TRUE, p, e); :}
    |
    expression:e chainrel:cl
        {:  if (cl.size() == 2) {
                String op = (String)cl.firstElement();
                Expression e2 = (Expression)cl.lastElement();
                RESULT = new InfixRel(e, op, e2);
            }
            else {
                RESULT = new ChainRel(e, cl);
            }
        :}
    |
    expression:e STROKE:s
        {: RESULT = new DecorExpression(e, s); :}
    |
    expression:e LSQUARE renamelist:r RSQUARE
        {: RESULT = new ReNameExpression(e, r); :} %prec Rename_Exp
    |
    expression:e DOT refname:n
        {: RESULT = new BindSelExpression(e, n); :}
    |
    expression:e DOT NUMBER:n
        {: RESULT = new TupleSelExpression(e, n); :}
    |
    THETA expression:e
        {: RESULT = new SingleExpression("theta", e); :}
    |
    refname:n
        {: RESULT = factory.createRefExpr(n,list(),Boolean.FALSE);   :}
    |
    expression:e DOT LBRACKET opname:on RBRACKET
        {: RESULT = new BindSelExpression(e, on); :}
// TODO: generalize this so that it can be parsed as an application?
//    Then post-process it to see if it is a generic reference...
//          |
//          varname:r LSQUARE expressionlist:el RSQUARE
//          {: RESULT = new ReferExpression(r, el); :}
//
    |
    opname:on LSQUARE expressionlist:el RSQUARE
        {: RESULT = new ReferExpression(on, el); :}
    |
    expression:e1 INFIXGENERIC:ig expression:e2
        {: RESULT = new ReferExpression(ig, list(e1,e2)); :}
    |
    PREGENERIC:p expression:e
        {: RESULT = new ReferExpression(p, e); :}
    |
    NUMBER:n
        {: RESULT = factory.createNumExpr(new BigInteger(n)); :}
    |
    LSET schematext:s SPOT expression:e RSET
        {: RESULT = new SetCompExpression(s, e); :}
    |
    LSET declpart:dp BAR predicate:p RSET
        {: SchemaText st = new SchemaText(dp, p);
    RESULT = new SetCompExpression(st); :}
    |
    LSET noexpdecl:nel RSET
        {: SchemaText st = new SchemaText(nel);
           RESULT = new SetCompExpression(st);
        :}
    |
    LSET expressionlist:el RSET
        {: RESULT = factory.createSetExpr(el); :}
    |
    LSET RSET
        {: RESULT = factory.createSetExpr(list()); :}
    |
    LSQUARE declpart:dp BAR predicate:p RSQUARE
        {: SchemaText st = new SchemaText(dp, p);
           RESULT = new SchExpression(st);
        :}
    |
    LSQUARE noexpdecl:nel RSQUARE
        {: SchemaText st = new SchemaText(nel);
           RESULT = new SchExpression(st);
        :}
    |
    LBLOT equaldecllist:eql RBLOT
        {: RESULT = new BindExtendExpression(eql); :}
    |
    LBLOT RBLOT
        {: RESULT = new BindExtendExpression(); :}
    |
    LANGLE RANGLE
        {: VarName vn = new VarName("\\emptyseq");
           RESULT = new ReferExpression(vn);
        :}
    |
    LBRACKET MU schematext:st RBRACKET
        {: RESULT = new SchemaExpression("\\mu", st); :}
    |
    LBRACKET expressionlist:el RBRACKET
        {:  if (el.size() == 1) {
                RESULT = (Expr)el.get(0);
            } else {
                RESULT = factory.createTupleExpr(el);
            }
        :}
    ;
/*
/*
chainrel ::=
    chainrel:cl INFIXREL:op expression:e
        {: cl.add(op); cl.add(e); RESULT = cl; :}
    |
    INFIXREL:op expression:e
        {: RESULT = list(op,e); :}
    ;
*/
//seems it can be replaced by "term_list. So remove it.
/*
expressionlist ::=
    expressionlist:el COMMA expression:e
        {: el.add(e); RESULT = el; :}
    |
    expression:e
        {: RESULT = list(e); :}
    ;
*/
/*                   
declpart ::=
    declpart:dp NL declaration:d
        {: dp.add(d); RESULT = dp; :}
    |
    declpart:dp NL expdeclaration:ed
        {: dp.add(ed); RESULT = dp; :}
    |
    noexpdecl:nel
        {: RESULT = nel; :}
    |
    expdeclaration:ed
        {: RESULT = list(ed); :}
    ;

noexpdecl ::=
    declpart:dp SEMI declaration:d
        {: dp.add(d); RESULT = dp; :}
    |
    declaration:d
        {: RESULT = list(d); :}
    ;

declaration ::=
    declnamelist:nl COLON expression:e
    // TODO: this will be done by operator templates instead...
        {: if (e instanceof ReferExpression){
               //referexpression indicates it has functional operator.
               ReferExpression tempe = (ReferExpression)e;
               CheckFunName(nl, tempe);
           }
           RESULT = new Declaration(nl, e);
        :}
    
        {: RESULT = factory.createVarDecl(nl,e); :}
    |
    declname:n HDEF expression:e
    // TODO: this will be done by operator templates instead...
        {: if(e instanceof ReferExpression)
                CheckFunName(n, (ReferExpression)e);
           RESULT = new Declaration(n, e);
        :}
    
        {: RESULT = factory.createConstDecl(n,e); :}
*/
/*
    |
    opnamelist:ol COLON expression:e
        {: RESULT = new Declaration(ol, e); :}
    |
    opname:on COLON expression:e
        {: RESULT = new Declaration(list(on), e); :}
    |
    opname:on HDEF expression:e
        {: RESULT = new Declaration(on, e); :}
    |
    opname:on SDEF expression:e
        {: RESULT = new Declaration(on, e); :}
*/
/*    ;

expdeclaration ::=
    expression:e
        {: RESULT = factory.createInclDecl(e); :}
    ;
*/
/* comment it by Chen Chunqing                
operatortemp ::=
    ZRELATION template:t
        {: t.setCat(Cat.Relation); RESULT = t; :}
    |
    ZFUNCTION categorytemp:t
        {: t.setCat(Cat.Function); RESULT = t; :}
    |
    ZGENERIC categorytemp:t
        {: t.setCat(Cat.Generic); RESULT = t; :}
    ;
              
categorytemp ::=
    PREC:n template:t   // TODO: should be PrefixTemplate or PostfixTemplate
        {: t.setPrec(new Integer(n)); RESULT = t; :}
    |
    PREC:n ASSOC:as template:t   // TODO: should be InfixTemplate only
        {: Assoc a = (as.equals("left") ? Assoc.Left : Assoc.Right);
           t.setAssoc(a);
           t.setPrec(new Integer(n));
        :}
    |
    template:t    // TODO: should be NofixTemplate only
        {: RESULT = t; :}
    ;

// TODO: should allow all four kinds of templates
template ::=
    UNDERSCORE WORD:w UNDERSCORE    // A simple infix template
        {: Operand op = factory.createOperand();
           List toks = list();
           toks.add(op);
           toks.add(w);
           toks.add(op);
           RESULT = factory.createOptempPara(toks, Cat.Relation, Assoc.Left,
                                             new Integer(0));
        :}
    ;
*/
// TODO: generalise these to allow the full glory of opname in the Z std.
/*
opname ::=
    UNDERSCORE WORD:w UNDERSCORE
        {: RESULT = w; :}

    |
    WORD:w UNDERSCORE
        {: if(! map.inMap(w))
                map.addOp(w, "prefixfun");
           RESULT = new VarName(w);
        :}
    |
    UNDERINFIXREL WORD:w RBRACE
        {: if(!map.inMap(w))
                map.addOp(w, "infixrel");
           RESULT = new VarName(w);
        :}
    |
    UNDERSCORE WORD:w
        {: if(! map.inMap(w))
                map.addOp(w, "postfixrel");
           RESULT = new VarName(w);
        :}
    ;
*/
/* 
opnamelist ::=
    opnamelist:ol COMMA opname:on
        {: ol.add(on); RESULT = ol; :}
    |
    opname:on1 COMMA opname:on2
        {: RESULT = list(on1,on2); :}
    ;
*/
