/** Copyright 2003 CHEN Chunqing.  chenchun@comp.nus.edu.sg This file is part of 
the CZT project: http://czt.sourceforge.net

The CZT project contains free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

The CZT project is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with CZT; if not, write to the Free Software Foundation, Inc., 
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
package net.sourceforge.czt.parser.z;

import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import java.text.DateFormat;
import java.math.BigInteger;
import net.sourceforge.czt.base.ast.*;   // for Term
import net.sourceforge.czt.z.ast.*;   // the CZT corejava AST classes

action code
{:
  // NOTE: these are local copies of the corresponding variables
  // in the main parser object.   They are updated each time 
  // the parser starts (in the 'init with' method).
  public ZFactory factory;
  public OpMaps map;

  
  //==============================================================
  // Helper methods for creating AST nodes/subtrees.
  //
  // Usually we just call factory.createXYZ(...), but some kinds of
  // nodes require more processing, so are created by these methods.
  //==============================================================

  /** Create a list with zero elements.
   */
  protected List list() {
    return new ArrayList();
  }

  /** Create a list with one element.
   */
  protected List list(Object e1) {
    List result = new ArrayList();
    result.add(e1);
    return result;
  }

  /** Create a list with two elements.
   */
  protected List list(Object e1, Object e2) {
    List result = new ArrayList();
    result.add(e1);
    result.add(e2);
    return result;
  }

  /** This coerces an Expr/Pred term into a Pred.
   */
  protected Pred pred(Term t) {
      if (t instanceof Pred)
          return (Pred)t;
      else
          return factory.createExprPred((Expr)t);
  }

  /** This coerces an Expr/Pred term into an Expr.
   */
  protected Expr expr(Term t) {
      if (t instanceof Expr)
          return (Expr)t;
      else
          // TODO: use  parser.report_error(message,info);
          throw new RuntimeException("predicate found where expression required...");
  }

  protected Spec createSpec(List sects) {
    return factory.createSpec(sects, 
                              "1.1", // version of this ZML schema.
                              "",    // author of this spec.
                              Calendar.getInstance(),
                              parser.getSourceName() // file name of the spec.
                              );
  }

/** By Chen Chunqing:
For 'name', 'declname', and 'refname' method, we can apply one more method to test whether the
word is a 'decorword or not, well since it requires to return two variables, one is the modified name and
the other is the possible stroke character. We have to repeat the similar java code inside the three 
methods respectively.
The structure of a decroword is following the definition in chapter 7.2 of ISO Z. 
Well, some notes to be mentioned:
1. Can one strok has more than one stroke characters? e.g.,  A?? where variable A has two stroke
    characters. If it allows, what is the semantics of such expression?
2. If the input string is a decorword, when create the object name, declanme or refname, the string n
    in the "create..." method is not the original one but the updated one.
*/
// Check whether a string ends with stroke character "?", "!" or "'".
  private boolean decor1(String n){
     return n.endsWith("?") || n.endsWith("!") || n.endsWith("'");
  }
//check whether a string ends with a substript integer that between 0 and 9 like "name_8"
  private boolean decor2(String n){
     int nlen = n.length();
     char l1 = n.charAt(nlen-1);
     char l2 = n.charAt(nlen-2);
//     char l3 = n.charAt(nlen-3);
//     char l4 = n.charAt(nlen-4);
//     if(l1 == '}' && l3 == '{' && l4 == '_'){
     if(l2 == '_'){
        return (l1 > '0') &&(l1 < '9');
     }
     else return false;
  }
  
  protected Name name(String n) {
    // TODO: extend this to extract the decorations from n
    int nlen = n.length();
    String temp = "";
    List toks = list();
    while(nlen >=2){
       if(decor1(n)){
            temp = n.substring(nlen -1);
            n = n.substring(0, nlen-1);
	    toks.add(0, temp);
	    nlen = n.length();
	    //to make sure the order of the toks is the same as it appears originally.
            //return factory.createName(n, list(temp));
       }
       else if(nlen >=3){
             if(decor2(n)){
                temp = n.substring(nlen-2, nlen-1);
                n = n.substring(0, nlen-4);
		toks.add(0, temp);
		nlen = n.length();
                //return factory.createName(n, list(temp));
             }
	     else break;
       }
       else break;
    }//end while
    return factory.createName(n, toks);
  }
       
  protected DeclName declname(String n) {
    // TODO: extend this to extract the decorations from n
    int nlen = n.length();
    String temp = "";
    List toks = list();
    while(nlen >=2){
       if(decor1(n)){
            temp = n.substring(nlen -1);
            n = n.substring(0, nlen-1);
	    toks.add(0, temp);
	    nlen = n.length();
            //return factory.createName(n, list(temp));
       }
       else if(nlen >=3){
             if(decor2(n)){
                temp = n.substring(nlen-2, nlen-1);
                n = n.substring(0, nlen-4);
		toks.add(0, temp);
		nlen = n.length();
                //return factory.createName(n, list(temp));
             }
	     else break;
       }
       else break;
    }//end while
    return factory.createDeclName(null, n, toks);
  }

/**Added by Chen Chunqing.
To create the MemPred when dealing with all types of relation.
*/
protected MemPred MakeMemPred(String ops, List ts){
     RefName rn = refname(ops);
     TupleExpr te = factory.createTupleExpr(ts);
     RefExpr re = factory.createRefExpr(rn, list(), Boolean.FALSE);
     return factory.createMemPred(te, re, Boolean.TRUE);
}
 
/** Added by Chen Chunqing
To create an application.
*/   
protected ApplExpr MakeApplExpr(RefName rn, List ts){
      RefExpr re = factory.createRefExpr(rn, list(), Boolean.FALSE);
      TupleExpr te = factory.createTupleExpr(ts);
      return factory.createApplExpr(Boolean.TRUE, re, te); 
}
  /** Converts a list of strings into a list of DeclName objects.
   */
  protected List declnamelist(List strings) {
    List result = list();
    Iterator i = strings.iterator();
    while (i.hasNext()) {
        result.add(declname((String)i.next()));
    }
    return result;
  }

  protected RefName refname(String n) {
    // TODO: extend this to extract the decorations from n
    int nlen = n.length();
    String temp = "";
    List toks = list();
    while(nlen >=2){
       if(decor1(n)){
            temp = n.substring(nlen -1);
            n = n.substring(0, nlen-1);
            toks.add(0, temp);
	    nlen = n.length();
            //return factory.createName(n, list(temp));
       }
       else if(nlen >=3){
             if(decor2(n)){
                temp = n.substring(nlen-2, nlen-1);
                n = n.substring(0, nlen-4);
		toks.add(0, temp);
		nlen = n.length();
                //return factory.createName(n, list(temp));
             }
	     else break;
       }
       else break;
    }//end while
    return factory.createRefName(null, n, toks);
  }

//perform the checking of whether the annotations list of an object contains the ParenAnn object or not.
protected boolean CheckParenAnn(List ann){
      for(int i = 0; i < ann.size(); i++){
            if(ann.get(i) instanceof ParenAnn) return true;
      }
      return false;
}

 /**
 //possible class definition for GenName
 class GenName extends Name{
         List formals;
         DeclName dn;
         public GenName(DeclName dn, List fs){
                 this.dn = dn;
                 formals = fs;
          }
          public List getFormals(){
                 return formals;
          }
          public DeclName getDeclName(){
                 return dn;
          }
}
 */
 /**
 If the class GenName is defined in the above way, we can add a method to create a
 GenName object:
 
protected GenName createGenName(DeclName dn, List fs){
         GenName gn = new GenName(dn, fs);
         return gn;
}
 */
  /* TODO: update these to use RefExpr ?
  public void CheckFunName(Vector nl, ReferExpression tempe){
                if(tempe.op != null){
                   String oper = (String)tempe.op;
                   System.out.println("oper is: " + oper);
                   if(tempe.el != null){
                   if(((Vector)tempe.el).size() == 2){
                   //it is a infix operator
                        if(oper.equals("\\rel")){
                                for(int i = 0; i < nl.size(); i++){
                                        VarName tempvn = (VarName)nl.elementAt(i);
                                        String nlw = (String)tempvn.n;
                                        if(! map.inMap(nlw))
                                                map.addOp(nlw, "infixrel");
                                }
                        }
                        else{
                           for(int i = 0; i < nl.size(); i++){
                                VarName tempvn = (VarName)nl.elementAt(i);
                                String nlw = (String)tempvn.n;
                                if(! map.inMap(nlw))
                                        map.addOp(nlw, "prefixfun");
                           }
                        }

                   }
                   }
                   else if((Expression)tempe.e != null){
                   //it is a prefixgeneric operator
                        for(int i = 0; i < nl.size(); i++){
                                VarName tempvn = (VarName)nl.elementAt(i);
                                String nlw = (String)tempvn.n;
                                if(! map.inMap(nlw))
                                        map.addOp(nlw, "prefixfun");
                        }
                   }
                }
                else if((Vector)tempe.el == null){
                   VarName tempvn = (VarName)tempe.vn;
                   String nlw = (String)tempvn.n;
                   if(map.inMap(nlw)){
                        for(int i = 0; i < nl.size(); i++){
                                VarName vninnl = (VarName)nl.elementAt(i);
                                String newfun = (String)vninnl.n;
                                map.addOp(newfun, (String)map.getOp(nlw));
                        }//end for
                   }//end inner if
                }//end else if
  }//end method checkfunname with vector parameter

  public void CheckFunName(VarName vn, ReferExpression tempe){
                if(tempe.op != null){
                   String oper = (String)tempe.op;
                   if(tempe.el != null){
                   if(((Vector)tempe.el).size()==2){
                      if(oper.equals("\\rel")){
                        String nlw = (String)vn.n;
                        if(! map.inMap(nlw))
                                map.addOp(nlw, "infixrel");
                      }//end if

                      else{
                           String nlw = (String)vn.n;
                           if(! map.inMap(nlw))
                              map.addOp(nlw, "prefixfun");
                      }

                   }//end if for size == 2
                   }//end if for nonempty vector
                   else if((Expression)tempe.e != null){
                   //it is a prefixgeneric operator
                        String nlw = (String)vn.n;
                        if(! map.inMap(nlw))
                                map.addOp(nlw, "prefixfun");
                   }
                }
                else if((Vector)tempe.el == null){
                   VarName tempvn = (VarName)tempe.vn;
                   String nlw = (String)tempvn.n;
                   if(map.inMap(nlw)){
                        String newfun = (String)vn.n;
                        map.addOp(newfun, (String)map.getOp(nlw));
                   }//end inner if
                }//end else if
  }//end method checkfunname with varname parameter
*/
:};

                
parser code
{:
  protected OpMaps map = new OpMaps();

  public OpMaps getOpMap(){
    return map;
  }

  protected ZFactory factory = new net.sourceforge.czt.z.impl.ZFactoryImpl();

  /** Get the object factory used for creating AST objects.
   */
  public ZFactory getFactory(){
    return factory;
  }
    
  /** Set the object factory used for creating AST objects.
   */
  public void setFactory(ZFactory fact){
    factory = fact;
  }

  protected String sourceName = "";
  
  /** Get the source name of the file being parsed.
   */
  public String getSourceName(){
    return sourceName;
  }
    
  /** Set the source name of the file being parsed.
   *   This is put into the "source" attribute of the
   *   Spec tag in the resulting XML file.
   */
  public void setSourceName(String name) {
    sourceName = name;
  }
:};

init with
{:
  action_obj.map = map;
  action_obj.factory = factory;
:};

scan with {:            Symbol s = super.scan();
                        String svalue = (String)s.value;
                        System.out.println("Token "+s.sym+"  ("+svalue+")");

                        if(s.value != null){
                          if(s.sym == LTZsym.WORD ||s.sym == LTZsym.DECLWORD)
                            if(map.inMap(svalue)){
                              String temp = (String)map.getOp(svalue);
                              if(temp.equals("infixrel")){
                                System.out.println("in map infixrel");
                                return new Symbol(LTZsym.INFIXREL, svalue);
                              }
                              else if(temp.equals("prefixfun")){
                                System.out.println("in map a prefix function name");
                                return new Symbol(LTZsym.PREFIXFUN, svalue);
                              }
                              
                              else if(temp.equals("prefixrel")){
                                System.out.println("in map prefixrel");
                                return new Symbol(LTZsym.PREFIXREL, svalue);
                              }
                              
                              else{
                                System.out.println("not defined opertor!");
                                }
                            }
                        }
                        
                        return s; :};

terminal String THETA, LAMBDA, MU, POWER;
terminal String UNDERSCORE, LSET, RSET, LDATA, RDATA, LBLOT, RBLOT;
terminal String VDASH, LAND, LOR, IMPLIES, IFF, LNOT, FORALL, EXISTS, CROSS,SPOT, HIDE, PROJECT, SEMI, PIPE;
terminal String IF, THEN, ELSE, LET, SECTION, CUP, CAP, SETMINUS, SYMDIFF;
terminal String MAPSTO, COMP, CIRC, DRES, RRES, NDRES, NRRES, OPLUS, UPTO;
terminal String LANGLE, RANGLE, CAT, EXTRACT, FILTER;
terminal String BEGINZSECT, PARENTS, ENDZSECT, BEGINAXDEF, WHERE, ENDAXDEF, BEGINSCHEMA, ENDSCHEMA;
terminal String BEGINGENDEF, ENDGENDEF, BEGINZED, ENDZED, BEGINZPAR, ENDZPAR;
terminal String LBRACE, RBRACE, NL, LSQUARE, RSQUARE, COMMA, FREEAND;
terminal String HDEF, FREEEQ, BAR, EXISTSONE, TRUE, FALSE, LBRACKET, RBRACKET, PRE, DOT;
terminal String ANTISLASH, COLON, PLUS, TIMES, MINUS, DIV, MOD, ZCOMP;
terminal String INFIXREL, POSTFIXFUN, INFIXGENERIC, PREGENERIC, PREFIXREL, PREFIXFUN;
terminal String STROKE, WORD,DECLWORD, GREEK, NUMBER, NARRSECT, NARRPARA, FUNNAME, UNDERINFIXREL;
terminal String ZRELATION, ZFUNCTION, ZGENERIC, ASSOC, OPERANDLIST,PREC;
terminal  Rename_Exp;
terminal String PREPTOK, PRETOK, POSTPTOK, POSTTOK, IPTOK, ITOK, LPTOK, LTOK, ELPTOK, ELTOK;
terminal String ERPTOK, ERTOK, SRPTOK, SRTOK, EREPTOK, ERETOK, SREPTOK, SRETOK, ESTOK, SSTOK;

non terminal Spec specification;
non terminal List sections;
non terminal Sect section;
non terminal List/*<Parent>*/ opt_parents;
non terminal List/*<Para>*/ paragraphs, unboxedpars;
non terminal Para zparagraph, zeditem;
non terminal Branch branch;
non terminal List/*<Branch>*/ branchlist;
non terminal DeclName declname;
non terminal RefName refname;
non terminal String opname, prefixname, postfixname, infixname, nofixname, mixfixname, opbody, opt_arg, list_sep;
non terminal GenName genname, prefixgenname, postfixgenname, infixgenname, nofixgenname;
non terminal List/*<DeclName>*/ opt_formals, formals;
non terminal List/*<RefName>*/  refnamelist;
non terminal List/*<DeclName>*/ declnamelist;
non terminal List/*<String>*/   namelist;
non terminal List declpart, declpart2;
non terminal Decl declelem, basicdecl;
non terminal TermA term, func_appl, inner_term, outer_term;
non terminal Pred predicate;
non terminal Expr expression;
non terminal List opt_term_list, term_list, bind_list;
non terminal SchText schematext, schematext_minus_expr;
non terminal List renamelist;
non terminal NameNamePair rename;
non terminal ConstDecl binding;
non terminal List freetypelist;
non terminal Freetype freetype;
non terminal List narrparalist;
non terminal OptempPara optemplate;
non terminal Cat fungen;
non terminal OptempPara template;
non terminal List chainrel;
non terminal List mixfix, mixfixgenname;

precedence right NARRPARA, NARRSECT;
precedence left NL, SEMI;
precedence left COMMA;
precedence right SPOT, BAR;
precedence left IFF;
precedence left IMPLIES;
precedence left LOR;
precedence left LAND;
precedence right LNOT;
precedence left LPTOK, ELPTOK, SREPTOK, EREPTOK,SRPTOK,ERPTOK;
precedence left INFIXREL,IPTOK;
precedence left PREFIXREL, PREPTOK;
precedence left POSTTOK;
precedence right LAMBDA;
precedence right MU;
precedence right LET;
precedence right ELSE;
precedence left ZCOMP;
precedence left PIPE;
precedence left HIDE;
precedence left PROJECT;
precedence right PRE;
precedence left LTOK, ELTOK, SRETOK, ERETOK,SSTOK, ESTOK,SRTOK,ERTOK;
precedence left INFIXGENERIC,ITOK;
precedence left PRETOK;
precedence left POSTTOK;
precedence left MAPSTO;
precedence left UPTO;
precedence left SYMDIFF;
precedence left PLUS, MINUS, CUP, CAT, SETMINUS;
precedence left TIMES, DIV, MOD, CIRC, FILTER, CAP, COMP;
precedence left EXTRACT;
precedence left OPLUS;
precedence left RRES, NRRES;
precedence right DRES, NDRES;
precedence right PREFIXFUN;
precedence right CROSS, POWER, PREGENERIC;
precedence left PREFIXFUN;
precedence left POSTFIXFUN;
precedence left STROKE;
precedence left Rename_Exp;
precedence left DOT;
precedence right THETA;
precedence left LSQUARE, RSQUARE;
precedence nonassoc LANGLE, RANGLE;
precedence nonassoc LBLOT;


// TODO: before starting parsing this, set up the operator tables
//     to be the standard_toolkit operators only.
specification ::=
    sections:s
        {: RESULT = createSpec(s); :}
    | 
    paragraphs:pgs
        {: ZSect sect = factory.createZSect("Specification",
                                            list(), // no parents
                                            pgs);
           RESULT = createSpec(list(sect));
        :}
    ;
 
sections ::=
    sections:ss section:s
        {: ss.add(s); RESULT=ss; :}
    | section:s
        {: RESULT = list(s); :}
    ;

section ::=
    BEGINZSECT SECTION WORD:w opt_parents:p ENDZSECT paragraphs:pgs
        {: RESULT = factory.createZSect(w, p, pgs); :}
    ;

opt_parents ::=
    PARENTS namelist:nl
        {: RESULT = list();
           // Convert the strings to Parent objects.
           Iterator i = nl.iterator();
           while (i.hasNext()) {
               RESULT.add(factory.createParent((String)i.next()));
           }
           // TODO: set up the operator tables (by importing these sections)
        :}
    |
    // empty
        {: RESULT = list();
           // TODO: set up the operator tables to be standard_toolkit only
        :}
    |
    //added by Chen Chunqing.
    //Capture when the name list is empty while the keyword "parent" presents.
    PARENTS
    {:  RESULT = list(); :}
    ;

//added by Chen Chunqing.
//move the definition of unboxed paragraphs up to the paragraphs level.
paragraphs ::=
    paragraphs:pgs zparagraph:pg
        {: pgs.add(pg); RESULT=pgs; :}
    |
    paragraphs:pgs BEGINZED unboxedpars:ubp ENDZED
    {: pgs.addAll(ubp); RESULT = pgs; :}
    |
    // empty
        {: RESULT = list(); :}
    ;
                 
//added by Chen Chunqing. To adjust the structure to the YACC grammar. 
/*
paragraph ::= zparagraph:zp
                    {: RESULT = zp; :}
                    |
                    unboxedpar:und
                    {: RESULT = und; :}
                    ;
*/                    
//added by Chen Chunqing
zparagraph ::= BEGINAXDEF schematext:st ENDAXDEF
                     {: RESULT = factory.createAxPara(list(),st,Box.AxBox); :}
                      |
                      BEGINSCHEMA opt_formals:f LBRACE WORD:n RBRACE schematext:st ENDSCHEMA
                      {:// Rule 12.2.3.1: SCH i t END  ==> AX [i==t] END
                         // Rule 12.2.3.2: SCH i [i1..in] t END  ==> AX [i1..in] [i==t] END
                         Expr e = factory.createSchExpr(st);
                         ConstDecl decl = factory.createConstDecl(declname(n),e);
                         SchText stext = factory.createSchText(list(decl),null);
                         RESULT = factory.createAxPara(f,stext,Box.SchBox);
                       :}
                       |
                       BEGINGENDEF opt_formals:f schematext:st ENDGENDEF
                       {: RESULT = factory.createAxPara(f,st,Box.AxBox); :}
                       |
                       BEGINZED opt_formals:f VDASH predicate:p ENDZED
                       {: RESULT = factory.createConjPara(f,p); :}
                       |
                       BEGINZED optemplate:ot ENDZED
                       {: RESULT = ot; :}
                       |
                       narrparalist:u
                       {: RESULT = factory.createUnparsePara(u); :}
                       ;

//added by Chen Chunqing 
//we allow users to define several unboxed paragraphs (horizontal definitions for example)
//in one pair of "\begin{zed}" and "\end{zed}" latex command.
unboxedpars ::= unboxedpars:ubp NL  zeditem:zd 
                      {: ubp.add(zd); RESULT = ubp; :}
		      |
		      zeditem:zd
		      {: RESULT = list(zd); :}
                      ;         

//added by Chen Chunqing. mostly it is the same as zedparagraph                      
//haven't capture the "genname HDEF expr" structure since the genname undefined yet.
zeditem ::= formals:f
               {: RESULT = factory.createGivenPara(f); :}
               |   
               declname:n formals:f HDEF expression:e
               {:// Rule 12.2.3.4: i [i1..in] == e END ==> GENAX [i1..in] [i==e] END
                  ConstDecl decl = factory.createConstDecl(n,e);
                  SchText stext = factory.createSchText(list(decl),null);
                  RESULT = factory.createAxPara(f,stext,Box.OmitBox);
               :}
               |
              declname:n HDEF expression:e
              {: // Rule 12.2.3.3: i==e END ==> AX [i==e] END
                 ConstDecl decl = factory.createConstDecl(n,e);
                 SchText stext = factory.createSchText(list(decl),null);
                 RESULT = factory.createAxPara(list(),stext,Box.OmitBox);
               :}
               |               
//According to the 12.2.9. 
//The generic operator definition needs to convert into the generic horizontal definition
               genname:gn HDEF expression:e
               {: ConstDecl decl = factory.createConstDecl((DeclName)gn.getDeclName(), e);
                  SchText stext = factory.createSchText(list(decl); null);
                  RESULT = factory.createAxPara(gn.getFormals(), stext, Box.OmitBox); :}
               |
               freetypelist:ftl
               {: RESULT = factory.createFreePara(ftl); :}
               ;               

narrparalist ::=
    narrparalist:l NARRPARA:u
        {: l.add(u); RESULT = l; :}
    |
    NARRPARA:u
        {: RESULT = list(u); :}
    ;
    
freetypelist ::=
    freetypelist: ftl  FREEAND freetype:ft
        {: ftl.add(ft); RESULT = ftl; :}
    |
    freetype:ft
        {: RESULT = list(ft); :}
    ;

freetype ::=
    WORD:n FREEEQ branchlist:bl
        {: RESULT = factory.createFreetype(declname(n), bl); :}
    ;

branchlist ::=
    branchlist:bl BAR branch:b
        {: bl.add(b); RESULT = bl; :}
    |
    branch:b
        {: RESULT = list(b); :}
    ;

branch ::=
    declname:n LDATA expression:e RDATA
        {: RESULT = factory.createBranch(n, e); :}
    |
    declname:n
        {: RESULT = factory.createBranch(n, null); :}
    ;        
    
optemplate  ::= fungen:fg template:t
                      {: t.setCat(fg); RESULT = t; :}
                      |
                      fungen:fg PREC:n ASSOC:ad template:t
                      {:t.setCat(fg); 
                         t.setPrec(new Integer(n)); 
                         Assoc a = (ad.equals("Left")? Assoc.Left : Assoc.Right);
                         t.setAssoc(a);
                         RESULT = t; :}
                      |
                      fungen:fg PREC:n template:t
                      {: t.setCat(fg); 
                          t.setPrec(new Integer(n));
                          RESULT = t; :}
                      ;

fungen ::= ZRELATION
              {: RESULT = Cat.Relation; :}
              |
              ZFUNCTION
              {: RESULT = Cat.Function; :}
              |
              ZGENERIC
              {: RESULt = Cat.Generic; :}
              ;

/**capture the three kinds of structure below.
     (_  word  _), (_  word), (word  _).
     We first assume the prec is 0, the association is left, and it is a relation, then when it is
     passed up, it will update its association, precedence and relation type.
*/
template ::= LBRACKET opt_arg:o1 WORD:w opbody:ob opt_arg:o2 RBRACKET
                 {: Strnig oname = w + ob; 
                     Operand op = factory.createOperand();
                     List toks = new List();
                     if(o1.equals("\\_") && o2.equals("\\_")){                                                                              
                          toks.add(op);
                          toks.add(oname);
                          toks.add(op);
                          RESULT = factory.createOptempPara(toks, Cat.Relation, Assoc.Left,
                                             new Integer(0));
                      }
                      else if(o1.equals("\\_")){
                           toks.add(op);
                           toks.add(oname);
                           RESULT = factory.createOptempPara(toks, Cat.Relation, Assoc.Left,
                                               new Integer(0));
                       }
                       else if(o2.equals("\\_")){
                            toks.add(oname);
                            toks.add(op);
                            RESULT = factory.createOptempPara(toks, Cat.Relation, Assoc.Left,
                                                new Integer(0));
                        }
                        else System.err.println("error occur in the template's match"); :}
                    ;

opbody ::= opbody:ob UNDERSCORE WORD:n 
               {: RESULT = ob + " _ " +  n; :}
               |
               //empty
               ;

opt_arg ::= UNDERSCORE:u
                {: RESULT = u; :}
                |
                //empty
                ;

//modified by Chen Chunqing. To introduce the "formals" definition.
//Question: why call declnamelist method?
opt_formals ::= formals:f
                      {: RESULT = f; :}
                      | 
                     // empty
                      {: RESULT = list(); :}
                      ;

formals ::= LSQUARE namelist:nl RSQUARE
               {: RESULT = declnamelist(nl); :}
               ;
               
// a list of WORDs, returned as Strings.
namelist ::=
    namelist:nl COMMA WORD:n
        {: nl.add(n); RESULT=nl; :}
    |
    WORD:n
        {: RESULT = list(n); :}
    ;

/* This is the same as namelist, but recognises only DECLWORD symbols.
 * This is because SmartScanner converts WORD symbols into DECLWORD
 * symbols just before the COLON of a declaration.
 * TODO: we might be able to do without SmartScanner if we
 *     adopt Ian Toyn's grammar for expressions?  Then we could
 *     simplify this to just a list of 'declname' calls.
 */
declnamelist ::=
    declnamelist:nl COMMA DECLWORD:n
        {: nl.add(declname(n)); RESULT=nl; :}
    |
    DECLWORD:n
        {: RESULT = list(declname(n)); :}
    ;

declname ::=
    WORD:w
        {: RESULT = declname(w); :}
    |
    opname:o
        {: RESULT = declname(o); :}
    ;

refnamelist ::=
    refnamelist:nl COMMA refname:n
        {: nl.add(n); RESULT=nl; :}
    |
    refname:n
        {: RESULT = list(n); :}
    ;

refname ::=
    WORD:w
        {: RESULT = refname(w); :}
    |
    LBRACKET opname:o RBRACKET
        {: RESULT = refname(o); :}
    ;

/**By Chen Chunqing
Consider opname is a string type first, and according to different types 
(prefix, postfix, infix and nofix), to generate different string that involves "_".
*/
opname ::= prefixname:pren
                {: RESULT = pren; :}
                |
                postfixname:postn
                {: RESULT = postn; :}
                |
                infixname:inn
                {: RESULT = inn; :}
                |
                nofixname: non
                {: RESULT = non; :}
                ;
                
prefixname ::= PRETOK:pre UNDERSCORE
                      {: RESULT = pre + "_"; :}
                      |
                      PREPTOK:prep UNDERSCORE
                      {: RESULT = prep + "_"; :}
                      |
                      LTOK:l mixfixname:mix UNDERSCORE ERETOK:ere UNDERSCORE
                      {: RESULT = l + mix + "_" + ere + "_"; :}
                      |
                      LTOK:l mixfixname:mix UNDERSCORE SRETOK:sre UNDERSCORE
                      {: RESULT = l +  mix + "_" + sre + "_"; :}
                      |
                      LPTOK:lp mixfixname:mix UNDERSCORE EREPTOK:erep UNDERSCORE
                      {: RESULT = lp + mix + "_" + erep + "_"; :}
                      |
                      LPTOK:lp mixfixname:mix UNDERSCORE SREPTOK:srep UNDERSCORE
                      {: RESULT = lp + mix + "_" + srep + "_"; :}
                      ;
                      
postfixname ::= UNDERSCORE POSTTOK:post
                       {: RESULT = "_"+ post; :}
                       |
                       UNDERSCORE POSTPTOK:postp
                       {: RESULT = "_"+ postp; :}
                       |
                       UNDERSCORE ELTOK:el mixfixname:mix UNDERSCORE ERTOK:er
                       {: RESULT = "_" + el  + mix + "_"+ er; :}
                       |
                       UNDERSCORE ELTOK:el mixfixname:mix UNDERSCORE SRTOK:sr
                       {: RESULT = "_" + el +  mix + "_"+ sr; :}
                       |
                       UNDERSCORE ELPTOK:elp mixfixname:mix UNDERSCORE ERPTOK:erp
                       {: RESULT = "_" + elp + mix + "_" + erp; :}
                       |
                       UNDERSCORE ELPTOK:elp mixfixname:mix UNDERSCORE SRPTOK:srp
                       {: RESULT = "_" + elp +  mix + "_" + srp; :}
                       ;
                       
infixname ::= UNDERSCORE ITOK:i UNDERSCORE
                   {: RESULT = "_" + i + "_"; :}
                   |
                   UNDERSCORE IPTOK:ip UNDERSCORE
                   {: RESULT = "_" + ip + "_"; :}
                   |
                   UNDERSCORE ELTOK:el mixfixname:mix UNDERSCORE ERETOK:ere UNDERSCORE
                   {: RESULT = "_" + el + mix + "_" + ere + "_"; :}
                   |
                   UNDERSCORE ELTOK:el mixfixname:mix UNDERSCORE SRETOK:sre UNDERSCORE
                   {: RESULT = "_" + el +  mix + "_" + sre + "_"; :}
                   |
                   UNDERSCORE ELPTOK:elp mixfixname:mix UNDERSCORE EREPTOK:erep UNDERSCORE
                   {: RESULT = "_" + elp + mix + "_" + erep + "_"; :}
                   |
                   UNDERSCORE ELPTOK:elp mixfixname:mix UNDERSCORE SREPTOK:srep UNDERSCORE
                   {: RESULT = "_" + elp + mix + "_" + srep + "_"; :}
                   ;
                   
nofixname ::= LTOK:l mixfixname:mix UNDERSCORE ERTOK:er
                    {: RESULT = l + mix + "_" + er; :}
                    |
                    LTOK:l mixfixname:mix UNDERSCORE SRTOK:sr
                    {: RESULT = l + mix + "_" + sr; :}
                    |
                    LPTOK:lp mixfixname:mix UNDERSCORE ERPTOK:erp
                    {: RESULT = lp +  mix + "_" + erp; :}
                    |
                    LPTOK:lp mixfixname:mix UNDERSCORE SRPTOK:srp
                    {: RESULT = lp +  mix + "_" + srp; :}
                    ;
                    
mixfixname ::= mixfixname:mix UNDERSCORE ESTOK:es
                      {: RESULT = mix + "_" + es; :}
                      |
                      mixfixname:mix UNDERSCORE SSTOK:ss
                      {: RESULT = mix + "_" + ss; :}
                      |
                      //empty
                      ;
                      
/**By Chen Chunqing
Because I don't know how to handle the "genname" in ZML, here I just simply treats them as 
String type, as similar as "opname", generate string based on different types.

According to the ISO Z description in p51, Syntactic transformation rules 12.2.9:
All generic names are transformed to juxtapositions of NAMEs and generic parameter lists.
This causes the generic operator definition paragraphs in which they appear to become 
GENERIC HORIZONTAL DEFINITION PARAGRAPHS.
NAME, [-tok, Formals, ]-tok, ==, Expression, END

Need to clarify with Mark:
Thus each WORD is converted into a RefExpression, and the genname type needs to change
into term type! But it will bring problem for the definition of
"unboxed_def ::= genname TDEF expr"

So a "genname" can be thought as a "name" followed by a "namelist" where the "name" is 
constructed by combining those tokens together? If so, we need to define the structure of 
GenName instead of String type.
*/
genname ::= prefixgenname:preg
                  {: RESULT = preg; :}
                  |
                  postfixgenname:postg
                  {: RESULT = postg; :}
                  |
                  infixgenname:infixg
                  {: RESULT = infixg; :}
                  |
                  nofixgenname:nofixg
                  {: RESULT = nofixg; :}
                  ;
                  
/**
pre i => pre_[i]
l i1 ess1 ... in-2 essn-2 in-1 ere in => l_ess1..._essn-2_ere [i1, ..., in-2, in-1, in]
l i1 ess1 ... in-2 essn-2 in-1 sre in => l_ess1..._essn-2_sre [i1, ..., in-2, in-1, in]
*/
prefixgenname ::= PRETOK:pre WORD:w
                        {: List toks = list(w); 
                           String ops = pre + "_";
                           RESULT = createGenName(declname(ops), toks); :}
                        |
                        LTOK:l mixfixgenname:mix WORD:w1 ERETOK:ere WORD:w2
                        {: List toks = list();
                           String ops = l;
                           for(int i = 0; i < mix.size(); i + 2){
                               toks.add(mix.get(i));
                               ops = ops + "_" + (String)mix.get(i+1);
                            }
                            toks.add(w1); toks.add(w2);
                            ops = ops + "_" + ere;
                            RESULT = createGenName(declname(ops), toks); :}
                        |
                        LTOK:l mixfixgenname:mix WORD:w1 SRETOK:sre WORD:w2
                        {: List toks = list();
                           String ops = l;
                           for(int i = 0; i < mix.size(); i + 2){
                               toks.add(mix.get(i));
                               ops = ops + "_" + (String)mix.get(i+1);
                            }
                            toks.add(w1); toks.add(w2);
                            ops = ops + "_" + sre;
                            RESULT = createGenName(declname(ops), toks); :}
                        ;
                            
/**
i post => _post [i]
I1 el I2 ess2 ... In-1 essn-1 In er => _el_ess2..._essn-1_er [I1, I2, ...,In-1, In]
I1 el I2 ess2 ... In-1 essn-1 In sr => _el_ess2..._essn-1_sr [I1, I2, ...,In-1, In]
*/
postfixgenname ::= WORD:w POSTTOK:post
                         {: List toks = list(w);
                            String ops = "_" + post;
                            RESULT = createGenName(declname(ops), toks); :}
                         |
                         WORD:w1 ELTOK:el mixfixgenname:mix WORD:w2 ERTOK:er
                         {: List toks =list(w1);
                            String ops = "_" + el;
                            for(int i = 0; i < mix.size(); i+2){
                                 toks.add(mix.get(i));
                                 ops = ops + "_" + (String)mix.get(i+1);
                             }
                             toks.add(w2); 
                             ops = ops + "_" + er;
                             RESULT = createGenName(declname(ops), toks); :}
                          |
                         WORD:w1 ELTOK:el mixfixgenname:mix WORD:w2 SRTOK:sr
                         {: List toks =list(w1);
                            String ops = "_" + el;
                            for(int i = 0; i < mix.size(); i+2){
                                 toks.add(mix.get(i));
                                 ops = ops + "_" + (String)mix.get(i+1);
                             }
                             toks.add(w2); 
                             ops = ops + "_" + sr;
                             RESULT = createGenName(declname(ops), toks); :}
                           ;
                           
/**
I1 in I2 => _in_ [I1, I2]
I1 el I2 ess2 ... In-2 essn-2 In-1 ere In => _el_ess2..._essn-2_ere_ [I1, I2, ..., In-2, In-1, In]
I1 el I2 ess2 ... In-2 essn-2 In-1 sre In => _el_ess2..._essn-2_sre_ [I1, I2, ..., In-2, In-1, In]
*/  
infixgenname ::= WORD:w1 ITOK:i WORD:w2
                     {: List toks = list(w1, w2);
                        String ops = "_" + i + "_";
                        RESULT = createGenName(declname(ops), toks); :}
                     |
                      WORD:w1 ELTOK:el mixfixgenname:mix WORD:w2 ERETOK:ere WORD:w3
                      {: List toks = lsit(w1);
                         String ops = " _" + el;
                         for(int i = 0; i < mix.size(); i + 2){
                              toks.add(mix.get(i));
                              ops = ops + "_" + (String)mix.get(i+1);
                          }
                          toks.add(w2); toks.add(w3);
                          ops = ops + "_" + ere + "_";
                          RESULT = createGenName(declname(ops), toks); :}
                      |
                      WORD:w1 ELTOK:el mixfixgenname:mix WORD:w2 SRETOK:sre WORD:w3
                      {: List toks = lsit(w1);
                         String ops = " _" + el;
                         for(int i = 0; i < mix.size(); i + 2){
                              toks.add(mix.get(i));
                              ops = ops + "_" + (String)mix.get(i+1);
                          }
                          toks.add(w2); toks.add(w3);
                          ops = ops + "_" + sre + "_";
                          RESULT = createGenName(declname(ops), toks); :}
                     ;

/**
l I1 ess1 ... In-1 essn-1 In er => l_ess1..._essn-1_er [I1, ..., In-1, In]
l I1 ess1 ... In-1 essn-1 In sr => l_ess1..._essn-1_sr [I1, ..., In-1, In]
*/                          
nofixgenname ::= LTOK:l mixfixgenname:mix WORD:w ERTOK:er
                      {: List toks = list();
                         String ops = l;
                         for(int i = 0; i < mix.size(); i+2){
                              toks.add(mix.get(i));
                              ops = ops + "_" + (String)mix.get(i+1);
                          }
                          toks.add(w);
                          ops = ops + "_" + er;
                          RESULT = createGenName(declname(ops), toks); :}
                       |
                       LTOK:l mixfixgenname:mix WORD:w SRTOK:sr
                       {: List toks = list();
                         String ops = l;
                         for(int i = 0; i < mix.size(); i+2){
                              toks.add(mix.get(i));
                              ops = ops + "_" + (String)mix.get(i+1);
                          }
                          toks.add(w);
                          ops = ops + "_" + er;
                          RESULT = createGenName(declname(ops), toks); :}
                       ;
                           
mixfixgenname ::= mixfixgenname:mix WORD:w ESTOK:es
                        {: mix.add(w); mix.add(es); RESULT = mix; :}
                        |
                        mixfixgenname:mix WORD:w SSTOK:ss
                        {: mix.add(w); mix.add(ss); RESULT = mix; :}
                        |
                        //empty
                        {: RESULT = list(); :}
                        ;
                  
schematext ::=
    declpart:dp BAR predicate:pp
        {: RESULT = factory.createSchText(dp, pp); :}
    |
    declpart:dp WHERE predicate:pp
        {: RESULT = factory.createSchText(dp, pp); :}
    |
    declpart:dp
        {: RESULT = factory.createSchText(dp, null); :}
    ;

schematext_minus_expr ::= declpart:dp BAR predicate:pp
                                 {: RESULT = factory.createSchText(dp, pp); :}
	                 |
				 declpart:dp WHERE predicate:pp
				 {: RESULT = factory.createSchText(dp, pp); :}
				 |
				 declpart2:dl2 list_sep declelem:d
				 {: dl2.add(d); 
				     RESULT = factory.createSchText(dl2, null);:}
				  |
				  basicdecl: bd
				  {: RESULT = factory.createSchText(list(bd), null); :}
				  ;

declpart ::= declpart2:dp2
                 {: RESULT = dp2; :}
                 |
                 //empty
                 {: RESULT = list(); :}
                 ;
declpart2 ::= declpart2:dl2 list_sep declelem:de
                   {: dl2.add(de), RESULT = dl2; :}
                   |
                   declelem:de
                   {: RESULT = list(de); :}
                   ;
                   
list_sep ::= SEMI
                 |
                  NL
                  ;

declelem ::= basicdecl : bd
                  {: RESULT = bd; :}
                  |
                  expression:e
                  {: RESULT = factory.createInclDecl(e); :}
                  ;
                  
 basicdecl ::= declnamelist:nl COLON expression:e 
                   {: RESULT = factory.createVarDecl(nl,e); :}
                   |
                   declname:n HDEF expression:e
                   {: RESULT = factory.createConstDecl(n,e); :}
                   ;                

//convert the predicate into outer_term type.
predicate ::= outer_term:ot
                {: RESULT = ot; :}
		;

/**By Chen Chunqing
Modify some of the expressions using 'create...' method.

Apply the super type "TermA" to "expression".

Treat those structures involve logical operators (and, or, not, imply, iff, 
forall, exists, exists1) as expression first, and later they can be converted into
predicate type using "Pred pred(Term t)" method when necessary.
*/
expression ::= term:t
                   {: RESULT =t; :}
                   ;          

term ::= FORALL schematext:st SPOT term:e
        {: RESULT = factory.createForallExpr(st, e); :}
    |
    EXISTS schematext:st SPOT term:e
        {: RESULT = factory.createExistsExpr( st, e); :}
    |
    EXISTSONE schematext:st SPOT term:e
        {: RESULT = factory.createExists1Expr(st, e); :}
    |
    LAMBDA schematext:st SPOT term:e
        {: RESULT = factory.createLambdaExpr(st, e); :}
    |
    MU schematext:st SPOT term:e
        {: RESULT = factory.createMuExpr(st, e); :} %prec MU
    |
    LET schematext:st SPOT term:e
        {: RESULT = factory.createLetExpr(st, e); :} %prec LET
    |
    term:e1 IMPLIES term:e2
        {: RESULT = factory.createImpliesExpr(e1,  e2); :}
    |
    term:e1 IFF term:e2
        {: RESULT = factory.createIffExpr(e1,  e2); :}
    |
    term:e1 LAND term:e2
        {: RESULT = factory.createAndExpr(e1,  e2); :}
    |
    term:e1 LOR term:e2
        {: RESULT = factory.createOrExpr(e1,  e2); :}
    |
    LNOT term:e
        {: RESULT = factory.createNegExpr( e); :}
    |
    IF predicate:p THEN term:e1 ELSE term:e2
        {: RESULT = factory.createCondExpr(p, e1, e2); :}
    |
    term:e1 ZCOMP term:e2
        {: RESULT = factory.createCompExpr(e1, e2); :}
    |
    term:e HIDE LBRACKET declnamelist:nl RBRACKET
        {: RESULT = factory.createHideExpr(nl, e); :}
    |
    term:e1 PIPE term:e2
        {: RESULT = factory.createPipeExpr(e1,  e2); :}
    |
    term:e1 PROJECT term:e2
        {: RESULT = factory.createProjExpr(e1, e2); :}
    |
    PRE term:e
        {: RESULT = factory.createPreExpr( e); :}
    |
    term:e1 CROSS term:e2
        {: RESULT = factory.createProdExpr(list(e1,e2)); :}
    |
    //concate the lptok and ereptok together to a new opname.
    //the following nine syntax structures are converted into <MemPred>  element with true value of 
    //its attribute Mixfix.
/**
The first three are translated into prefix relation, according to the syntactic transformation rules:
prep E => e \mem prep
lp E1 es1 ...En-2 esn-2 En-1 erep En => (E1, ..., En-2, En-1, En) \mem lp_es1_esn-2_erep
lp E1 es1 ... En-2 esn-2 ALn-1 srep En => (E1, ..., En-2, ALn-1, En) \mem lp_es1_esn-2_srep
Thus, the left hand side of "\mem" can be treated either a refexpr or tupleexpr,  and the right hand
side is to apply the refexpr to capture the operator.
the problem is that how to connect those operators together, via underscore "_"?
*/
    LPTOK:l mixfix:mix term:t1 EREPTOK:erep term:t2
    {: List ts = list();
       String ops = "";
       for(int i = 0; i < mix.size(); i + 2){
           ts.add(mix.get(i));
           ops=ops + (String)mix.get(i+1) + "_";
       }
       ts.add(t1); ts.add(t2);
       ops = l + "_" + ops + erep;
       RESULT = MakeMemPred(ops, ts); :}
    |
    LPTOK:l mixfix:mix opt_term_list:otl SREPTOK:srep term:t
    {: List ts = list();
       String ops = "";
       for(int i = 0; i < mix.size(); i + 2){
           ts.add(mix.get(i));
           ops=ops + (String)mix.get(i+1) + "_";
       }
       ts.add(otl); ts.add(t);
       ops = l + "_" + ops + srep;
       RESULT = MakeMemPred(ops, ts); :}
    |
    PREPTOK:prep term:t
    {: List ts = list(t);
       String ops = prep + "_";
       RESULT = MakeMemPred(ops, ts); :}
    |
/**
The following three definitions belong to the "postfix relation", based on the syntactic 
transformation rules in ISO Z p52, we have:
E postp => E \mem postp
E1 elp E2 es2 ...En-1 esn-1 En erp => (E1, E2, ..., En-1, En) \mem _elp_es2..._esn-1_erp
E1 elp E2 es2 ...En-1 esn-1 ALn srp => (E1, E2, ...,En-1, ALn) \mem _elp_es2..._esn-1_srp
*/
    term:t1 ELPTOK:elp mixfix:mix term:t2 ERPTOK:erp
    {: List ts = list(t1);
       String ops = "_" + elp;
       for(int i = 0; i < mix.size(); i + 2){
           ts.add(mix.get(i));
           ops=ops + "_" + (String)mix.get(i+1) ;
       }
       ts.add(t2); 
       ops = ops + "_" + erp;
       RESULT = MakeMemPred(ops, ts); :}
    |
    term:t ELPTOK:elp mixfix:mix opt_term_list:otl SRPTOK:srp
    {: List ts = list(t);
       String ops = "_" + elp;
       for(int i = 0; i < mix.size(); i+2){
            ts.add(mix.get(i));
            ops = ops + "_" + (String)mix.get(i+1);
        }
        ts.add(otl);
        ops = ops + "_" + srp;
        RESULT = MakeMemPred(ops, ts); :}
    |
    term:t POSTPTOK:postp
    {: List ts = list(t);
       String ops = "_" + postp;
       RESULT = MakeMemPred(ops, ts); :}
    |
/**
The following three are "infix relation" type, according to the transformation rules :
E1 elp E2 es2 ... En-2 esn-2 En-1 erep En => 
                    (E1, E2, ..., En-2, En-1, En)\mem _elp_es2..._esn-2_erep_
E1 elp E2 es2 ...En-2 esn-2 ALn-1 srep En =>
                    (E1, E2, ..., En-2, ALn-1, En)\mem _elp_es2..._esn-2_srep_
E1 ip E2 => (E1, E2) \mem _ip_
???Questions: 1. How to handle the chain relation?
                      2.Since the ip above excludes the "\mem" and "=" symbol, 
                         then what we can do with those two symbols?
*/
    term:t1 ELPTOK:elp mixfix:mix term:t2 EREPTOK:erep term:t3
    {: List ts = list(t1);
       String ops = "_" + elp + "_";
       for(int i = 0; i < mix.size(); i + 2){
            ts.add(mix.get(i));
            ops = ops + (String)mix.get(i+1) + "_";
        }
        ts.add(t2); ts.add(t3);
        ops = ops + erep + "_";
        RESULT = MakeMemPred(ops, ts); :}
    |
    term:t1 ELPTOK:elp mixfix:mix opt_term_list:otl SREPTOK:srep term:t2
    {: List ts = list(t1);
       String ops = "_" + elp + "_";
       for(int i = 0; i < mix.size(); i + 2){
            ts.add(mix.get(i));
            ops = ops + (String)mix.get(i+1) + "_";
        }
        ts.add(otl); ts.add(t2);
        ops = ops + srep + "_";
        RESULT = MakeMemPred(ops, ts); :}
    |
    term:t1 IPTOK:ip term:t2
    {: List ts = list(t1, t2);
       String ops = "_" + ip + "_";
       RESULT = MakeMemPred(ops, ts); :}
    |
/**
All function operator applications are transformed to annotated application expressions
That means, apply the <ApplExpr> element with "true" value of its attribute "Mixfix".

All generic operator applications are transformed to annotated generic instantiation expressions.
That means, apply the <RefExpr> element with "true" value of its attribute "Mixfix".
*/
//prefix application
    LTOK:l mixfix:mix term:t1 ERETOK:ere term:t2
    {: List ts = list();
       String ops = l + "_";
       for(int i = 0; i < mix.size(); i +2){
           ts.add(mix.get(i));
           ops = ops + (String)mix.get(i+1) + "_";
        }
        ts.add(t1); ts.add(t2);
        ops = ops + ere + "_";
        RefName rn = refname(ops);
        if(l isFunctionOp) RESULT = MakeApplExpr(rn, ts); 
         else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE); 
     :}             
    |
    LTOK:l mixfix:mix opt_term_list:otl SRETOK:sre term:t
    {: List ts = list();
       String ops = l + "_";
       for(int i = 0; i < mix.size(); i +2){
           ts.add(mix.get(i));
           ops = ops + (String)mix.get(i+1) + "_";
        }
        ts.add(otl); ts.add(t);
        ops = ops + sre + "_";
        RefName rn = refname(ops);
        if(l isFunctionOp) RESULT = MakeApplExpr(rn, ts); 
         else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE); 
     :}
    |
    PRETOK:pre term:t
    {: List ts = list(t);
       String ops = pre + "_";
       RefName rn = refname(ops);
       if(pre isFunctionOp) RESULT = MakeApplExpr(rn, ts); 
        else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE);
     :}
    |
//postfix application
    term:t1 ELTOK:el mixfix:mix term:t2 ERTOK:er
    {: List ts = list(t1);
       String ops = "_" + el;
       for(int i = 0; i < mix.size(); i+2){
            ts.add(mix.get(i));
            ops = ops + "_" + (String)mix.get(i+1);
        }
        ts.add(t2);
        ops = ops + "_" + er;
        RefName rn = refname(ops);
        if(el isFunctionOp) RESULT = MakeApplExpr(rn, ts); 
         else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE);
      :}
    |
    term:t1 ELTOK:el mixfix:mix opt_term_list:otl SRTOK:sr
    {: List ts = list(t1);
       String ops = "_" + el;
       for(int i = 0; i < mix.size(); i+2){
            ts.add(mix.get(i));
            ops = ops + "_" + (String)mix.get(i+1);
        }
        ts.add(otl);
        ops = ops + "_" + sr;
        RefName rn = refname(ops);
        if(el isFunctionOp) RESULT = MakeApplExpr(rn, ts); 
         else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE);
      :}
    |
    term:t POSTTOK:post
    {: List ts = list(t);
       String ops = "_" + post;
       RefName rn = refname(ops);
       if(post isFunctionOp) RESULT = MakeApplExpr(rn, ts); 
        else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE); 
     :}
    |
//infix application
    term:t1 ELTOK:el mixfix:mix term:t2 ERETOK:ere term:t3
    {: List ts = list(t1);
       String ops = "_" + el;
       for(int i = 0; i < mix.size(); i + 2){
            ts.add(mix.get(i));
            ops = ops + "_" + (String)mix.get(i+1);
        }
        ts.add(t2); ts.add(t3);
        ops = ops + "_" + ere + "_";
        RefName rn = refname(ops);
        if(el isFunctionOp) RESULT = MakeApplExpr(rn, ts);
        else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE);
     :}
    |
    term:t1 ELTOK:el mixfix:mix opt_term_list:otl SRETOK:sre term:t2
    {: List ts = list(t1);
       String ops = "_" + el;
       for(int i = 0; i < mix.size(); i + 2){
            ts.add(mix.get(i));
            ops = ops + "_" + (String)mix.get(i+1);
        }
        ts.add(otl); ts.add(t2);
        ops = ops + "_" + sre + "_";
        RefName rn = refname(ops);
        if(el isFunctionOp) RESULT = MakeApplExpr(rn, ts);
        else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE);
     :}
    |
    term:t1 ITOK:i term:t2
    {: List ts = list(t1, t2);
       String ops = "_" + i + "_";
       RefName rn = refname(ops);
       if(i inFunctionOp) RESULT = MakeApplExpr(rn, ts);
       else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE); 
     :}
    |
    POWER term:e
        {: RESULT = factory.createPowerExpr(e); :}
    |
    func_appl:fa
       {: RESULT = fa; :}
    ;
    
/**By Chen Chunqing
The juxtaposition of two expresssions E1 E2 is always parsed as the application of 
function E1 to argument E2 according to ISO Z p36.
*/
func_appl ::= func_appl:fa inner_term:it
                  {: RESULT = factory.createApplExpr(Boolean.FALSE, fa, it); :}
                  |
                  inner_term:it
                  {: RESULT = it; :}
                  ;

inner_term ::= LBRACE opt_term_list:tl RBRACE
                     {: RESULT = factory.createSetExpr(tl); :}
                     |
                     LBRACE schematext:st SPOT term:t RBRACE
                     {: RESULT = factory.createSetCompExpr(st, t); :}
                     |
   	     LBRACE schematext_minus_expr:sme RBRACE
	     {: RESULT = factory.createSetCompExpr(sme, null); :}
	     |
	     LBRACKET term:t COMMA term_list:tl RBRACKET
	     {: List toks = list(); 
	       toks.add(t);
	       toks.addAll(tl);
	       RESULT = factory.createTupleExpr(toks); :}
	     |
	     LBRACKET  MU schematext:st RBRACKET
	     {: RESULT = factory.createMuExpr(st, null); :}
	     |
//Nofix Relation
                     LPTOK:lp mixfix:mix term:t ERPTOK:erp
                     {: List ts = list();
                        String ops = lp + "_";
                        for(int i = 0; i < mix.size(); i + 2){
                             ts.add(mix.get(i));
                             ops = ops + (String)mix.get(i+1) + "_";
                         }
                         ts.add(t);
                         ops = ops + erp;
                         RESULT = MakeMemPred(ops, ts); :}
                     |
                     LPTOK:lp mixfix:mix opt_term_list:otl SRPTOK:srp
                     {: List ts = list();
                        String ops = lp + "_";
                        for(int i = 0; i < mix.size(); i + 2){
                             ts.add(mix.get(i));
                             ops = ops + (String)mix.get(i+1) + "_";
                         }
                         ts.add(otl);
                         ops = ops + srp;
                         RESULT = MakeMemPred(ops, ts); :}
                     |
//nofix application
                     LTOK:l mixfix:mix term:t ERTOK:er
                     {: List ts = list();
                        String ops = l + "_";
                        for(int i = 0; i < mix.size(); i + 2){
                             ts.add(mix.get(i));
                             ops = ops + (String)mix.get(i+1) + "_";
                         }
                         ts.add(t);
                         ops = ops + er;
                         RefName rn = refname(ops);
                         if(l isFunctionOp) RESULT = MakeApplExpr(rn, ts);
                         else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE); :}
                     |
                     LTOK:l mixfix:mix opt_term_list:otl SRTOK:sr
                     {: List ts = list();
                        String ops = l + "_";
                        for(int i = 0; i < mix.size(); i + 2){
                             ts.add(mix.get(i));
                             ops = ops + (String)mix.get(i+1) + "_";
                         }
                         ts.add(otl);
                         ops = ops + sr;
                         RefName rn = refname(ops);
                         if(l isFunctionOp) RESULT = MakeApplExpr(rn, ts);
                         else RESULT = factory.createRefExpr(rn, ts, Boolean.TRUE); :}
                     |                     
                     LBLOT bind_list:bl RBLOT
                     {: RESULT = factory.createBindExpr(bl); :}
                     |
                     LBLOT RBLOT
                     {: RESULT = factory.createBindExpr(); :}
                     |
                     LSQUARE RSQUARE
                     {: RESULT = factory.createSchExpr(); :}
                     |
                     inner_term:it DOT refname:rn
                     {: RESULT = factory.createBindSelExpr(rn, it); :}
                     |
                     inner_term:it DOT NUMBER:n
                     {: Integer nn = new Integer(n);
                         RESULT = factory.createTupleSelExpr(nn, it); :}
                     |
                     //STROKE is still a string type so far.
                     inner_term:it  STROKE:s
                     {: RESULT = factory.createDecorExpr(s, it); :}
                     |
                     THETA inner_term:it
                     {: List strokes = list();
                         while (it instanceof DecorExpr && CheckParenAnn(it.getAnns())) {
                           DecorExpr e = (DecorExpr)it;
                           strokes.add(e.getStroke());
                           it = e.getExpr();
                           }
                           return factory.createThetaExpr(strokes, it);
                     :}
                     |
                     inner_term:it LSQUARE renamelist:rl RSQUARE  
                     {: RESULT = factory.createRenameExpr(rl, it); :} %prec Rename_Exp
                     |
                     //it fits with the generic instantiation, so apply the RefExpr with false value of its attribute.
                     refname:rn LSQUARE term_list:tl RSQUARE
                     {: RESULT = factory.createRefExpr(rn, tl, Boolean.FALSE); :}
                     |
                     NUMBER:n
                     {: RESULT = factory.createNumExpr(new BigInteger(n)); :}
                     |
                     LBRACKET outer_term:ot RBRACKET
                     {: ot.getAnns().add(factory.createParenAnn()); RESULT = ot; :}
                     |
                     refname:rn
                     {: RESULT = factory.createRefExpr(rn,list(),Boolean.FALSE); :}                    
                     |
                    TRUE
                    {: RESULT = factory.createTruePred(); :}
                    |  
                    FALSE
                    {: RESULT = factory.createFalsePred(); :}
                     ;
                   
//consider the type of "mixfix" as a list of objects consists of "term" followed by "es"
//or "opt_term_list" followed by "ss".
mixfix ::= mixfix:mf term:t ESTOK:es
             {: mf.add(t); mf.add(es); RESULT = mf; :}
              |
              mixfix:mf opt_term_list:otl SSTOK:ss
              {: mf.add(otl); mf.add(ss); RESULT = mf; :}
              |
              //empty
              {: RESULT = list(); :}
              ;
                   
outer_term ::= predicate:p1 NL predicate:p2
                      {: RESULT = factory.createAndPred(Op.NL, p1, p2); :}
                      |
	    predicate:p1 SEMI predicate:p2
	    {: RESULT = factory.createAndPred(Op.SEMI, p1, p2); :}
                      |
                      term:t
                      {: RESULT = t; :}
                      ;
                       
renamelist ::=  renamelist:rl COMMA rename:r
        {: rl.add(r); RESULT = rl; :}
    |
    rename:r
        {: RESULT = list(r); :}
    ;

rename ::=
    declname:n1 ANTISLASH refname:n2
        {: // Note that this takes OldName first, then NewName second.
           // TODO: check why the standard has two declnames here?
           RESULT = factory.createNameNamePair(n2, n1);
        :}
    ;
                   
          
bind_list ::= bind_list:bl COMMA binding:b
                 {: bl.add(b); RESULT = bl; :}
                 |
                 binding:b
                 {: RESULT = list(b); :}
                 ;
                 
binding ::= declname:dn HDEF expression:e
               {: RESULT = factory.createConstDecl(dn, e); :}
               ;
               
opt_term_list ::= term_list:tl
                         {: RESULT = tl; :}
                         | //Empty
                         {: RESULT = list(); :}
                         ;
                         
term_list ::= term_list:tl COMMA term:t
                  {: tl.add(t); RESULT = tl; :}
                  |
                  term:t
                  {: RESULT = list(t); :}
                  ;
                  
