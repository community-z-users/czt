options {
  STATIC = false;
}

PARSER_BEGIN(LatexToUnicode)
package net.sourceforge.czt.scanner;

import java.io.*;

import net.sourceforge.czt.util.ZString;

public class LatexToUnicode
{
  private int braceCount_ = 0;

  public static void main(String args[]) throws ParseException
  {
    String usage =
      "Usage : LatexToUnicode [ -in <inputfile>] [ -out <outputfile>]";
    try {
      InputStream input = System.in;
      Writer writer = new PrintWriter(System.out);
      for (int i = 0; i < args.length; i++) {
        if ("-in".equals(args[i])) {
          if (i < args.length) {
            input = new FileInputStream(args[++i]);
          } else {
            System.err.println(usage);
            return;
          }
        } else if ("-out".equals(args[i])) {
          if (i < args.length) {
            writer =
              new OutputStreamWriter(new FileOutputStream(args[++i]), "utf8");
          } else {
            System.err.println(usage);
            return;
          }
        } else {
          System.err.println(usage);
          return;
        }
      }
      LatexToUnicode parser = new LatexToUnicode(input);
      parser.Input(writer);
      writer.close();
    } catch(Exception e) {
      e.printStackTrace();
    }
  }
}

PARSER_END(LatexToUnicode)

<DEFAULT> TOKEN :
{
  <AX: "\\begin{axdef}"> : Z
| <GEN: "\\begin{gendef}"> : Z
| <SCH: "\\begin{schema}"> : Z
| <ZED: "\\begin{zed}"> : Z
| <NewLine: "\n">
| <CHAR: ~[]>
}

<Z> SKIP :
{
  <IGNORE: "\n" | "\r" | "\r\n" | " " | "\t" |
            "%" (~["\n","\r"])* ("\n"|"\r")>
}

<Z> TOKEN :
{
  <HS: "~" | "\\," | "\\:" | "\\;" | "\\ "
           | "\\tl" | "\\t2" | "\\t3" | "\\t4" | "\\t5" | "\\t6"
           | "\\t7" | "\\t8" | "\\t9">
| <NLCHAR: "\\\\" | "\\also" | "\\znewpage">
| <ENDAX: "\\end" (<IGNORE>)* "{axdef}"> : DEFAULT
| <ENDGEN: "\\end" (<IGNORE>)* "{gendef}"> : DEFAULT
| <ENDSCH: "\\end" (<IGNORE>)* "{schema}"> : DEFAULT
| <ENDZED: "\\end" (<IGNORE>)* "{zed}"> : DEFAULT
| <WHERE: "\\where">
| <SPECIAL: "\\_" | "\\{" | "\\}">
| <COMMAND: "\\" (<LETTER>)+ | "\\" ~["a"-"z", "A"-"Z"]>
| <UP: "^">
| <DOWN: "_">
| <LBRACE: "{">
| <RBRACE: "}">
| <LETTER: ["a"-"z", "A"-"Z"]>
| <DIGIT: ["0"-"9"]>
| <FUNCTION: "*" | "+" | "-" | "@" | "|">
| <PUNCTUATION: "," | ";">
| <RELATION: ":" | "<" | "=" | ">">
| <OTHER: ~[]>
}

void Input(Writer writer)
  throws java.io.IOException :
{ Token token = null; }
{
  (
    ZedSpec(writer)
    | (token=<CHAR> { writer.write(token.toString()); })
    | <NewLine>          { writer.write("\n"); writer.flush(); }
  )* <EOF>
}

void ZedSpec(Writer writer)
  throws java.io.IOException :
{}
{
   (
     <AX>         { writer.write(ZString.AX); }
     LatexFormula(writer)
     [ <WHERE>      { writer.write(" | "); }
       LatexFormula(writer) ]
     <ENDAX>      { writer.write(ZString.END); }
   )
 |
   (
     <SCH>        { writer.write(ZString.SCH); }
     <LBRACE>
     LatexFormula(writer)
     <RBRACE>     { writer.write(" "); }
     LatexFormula(writer)
     [ <WHERE>      { writer.write(" | "); }
       LatexFormula(writer) ]
     <ENDSCH>     { writer.write(ZString.END); }
   )
 | 
   (
     <GEN>        { writer.write(ZString.GENSCH); }
     LatexFormula(writer)
     [ <WHERE>      { writer.write(" | "); }
       LatexFormula(writer) ]
     <ENDGEN>     { writer.write(ZString.END); }
   )
 | 
   (
     <ZED>        { writer.write(ZString.ZED); }
     LatexFormula(writer)
     <ENDZED>     { writer.write(ZString.END); }
   )
}

void LatexFormula(Writer writer)
  throws java.io.IOException :
{
}
{
  [ Script(writer) ] ( Word(writer) ) *
}

void Word(Writer writer)
  throws java.io.IOException :
{
  Token token = null;
  boolean addWhitespace = false;
}
{
  (
    token=<SPECIAL>
                      {
                          writer.write(token.toString().substring(1));
                      }
    [ Script(writer) ]
  )
|
  (
    token=<COMMAND>
                      {
                        String command = token.toString();
                        boolean spaces = braceCount_ == 0;
                        String zed = LatexMarkup.toUnicode(command, spaces);
                        if (zed != null) {
                          if (zed.endsWith(" ")) {
                            addWhitespace = true;
                            writer.write(zed.substring(0, zed.length() - 1));
                          } else {
                            writer.write(zed);
                          }
                        } else {
                          /* Command not found.
                             Z standard specifies that this is an error;
                             but for now just return the command
                             with backslash removed and assume type INWORD
                           */
                          String message = "WARNING: Unknown latex command "
                            + command;
                          System.err.println(message);
                          if (spaces) {
                            writer.write(" ");
                          }
                          writer.write(command.substring(1));
                          if (spaces) {
                            writer.write(" ");
                          }
                        }
                      }
    [ Script(writer) ]
                      {
                         if (addWhitespace) writer.write(" ");
                      }
  )
|
  (
    token=<LETTER>     { writer.write(token.toString()); }
    [ Script(writer) ]
  )
|
  (
    token=<DIGIT>     { writer.write(token.toString()); }
    [ Script(writer) ]
  )
|
  (
    token=<FUNCTION>
                      {
                        String fun = token.toString();
                        if (braceCount_ == 0) writer.write(" ");
                        if (fun.equals("@")) {
                          writer.write(ZString.SPOT);
                        } else {
                          writer.write(fun);
                        }
                      }
    [ Script(writer) ]
                      {
                        if (braceCount_ == 0) writer.write(" ");
                      }

  )
|
  (
    token=<PUNCTUATION>
                      {
                        writer.write(token.toString());
                      }
    [ Script(writer) ]
                      {
                        if (braceCount_ == 0) writer.write(" ");
                      }

  )
|
  (
                      {
                        if (braceCount_ == 0) writer.write(" ");
                      }
    Relation(writer)
    [ Script(writer) ]
                      {
                        if (braceCount_ == 0) writer.write(" ");
                      }

  )
|
  (
    token=<OTHER>
                      {
                        writer.write(token.toString());
                      }
    [ Script(writer) ]
  )
|
  (
    <HS>              { writer.write(" "); }
    [ Script(writer) ]
  )
|
  (
    <NLCHAR>
                      {
                        writer.write(ZString.NLCHAR);
                        writer.flush();
                      }
    [ Script(writer) ]
  )
|
  (
    <LBRACE>          { braceCount_++; }
    LatexFormula(writer)
    <RBRACE>          { braceCount_--; }
    [ Script(writer) ]
  )
}

void Relation(Writer writer)
  throws java.io.IOException :
{
}
{
  (
    LOOKAHEAD(1)
    <RELATION>      { writer.write(token.toString()); }
  )+
}

void Script(Writer writer)
  throws java.io.IOException :
{
}
{
     Superscript(writer) [ Subscript(writer) ]
   | Subscript(writer) [ Superscript(writer) ]
}


void Superscript(Writer writer)
  throws java.io.IOException :
{
}
{
  <UP>                { writer.write(ZString.NE); }
  ScriptBody(writer)
                      { writer.write(ZString.SW); }
}

void Subscript(Writer writer)
  throws java.io.IOException :
{
}
{
  <DOWN>               { writer.write(ZString.SE); }
  ScriptBody(writer)
                       { writer.write(ZString.NW); }
}

void ScriptBody(Writer writer)
  throws java.io.IOException :
{
  Token token = null;
}
{
    <LBRACE> LatexFormula(writer) <RBRACE>
  | token=<SPECIAL>
                      {
                          writer.write(token.toString().substring(1));
                      }
  | token=<COMMAND>
                      {
                        String command = token.toString();
                        String zed = LatexMarkup.toUnicode(command, false);
                        if (zed != null) {
                          writer.write(zed);
                        } else {
                          /* Command not found.
                             Z standard specifies that this is an error;
                             but for now just return the command
                             with backslash removed and assume type INWORD
                           */
                          writer.write(command.substring(1));
                        }
                      }
  | token=<LETTER>     { writer.write(token.toString()); }
  | token=<DIGIT>     { writer.write(token.toString()); }
  | token=<FUNCTION>
                      {
                        String fun = token.toString();
                        if (fun.equals("@")) {
                          writer.write(ZString.SPOT);
                        } else {
                          writer.write(fun);
                        }
                      }
  | token=<PUNCTUATION> { writer.write(token.toString()); }
  | token=<RELATION>  { writer.write(token.toString()); }
  | token=<OTHER>   { writer.write(token.toString()); }
}
