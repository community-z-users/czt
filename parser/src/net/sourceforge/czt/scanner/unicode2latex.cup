/* ----------------------Preliminary Declarations Section--------------------*/

package net.sourceforge.czt.scanner;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

action code
{:
  private Map map_ = createMap();

  private Map createMap()
  {
    Map map = new HashMap();
    Set set = LatexMarkup.getUnicodeMappingEntries();
    for (Iterator iter = set.iterator(); iter.hasNext();) {
      Map.Entry entry = (Map.Entry) iter.next();
      map.put(entry.getValue(), entry.getKey());
    }
    return map;
  }

  private String begin(String string)
  {
    return "\\begin{" + string + "}";
  }

  private String end(String string)
  {
    return "\\end{" + string + "}";
  }

  static class Word
  {
    public String string;
    public Boolean needLeftTilde;
    public Boolean needRightTilde;

    public Word(String s, LatexMarkup.Type type)
    {
      string = s;
      if (type.equals(LatexMarkup.Type.NONE)) {
        needLeftTilde = Boolean.valueOf(true);
        needRightTilde = Boolean.valueOf(true);
      }
      else if (type.equals(LatexMarkup.Type.IN)) {
        needLeftTilde = Boolean.valueOf(false);
        needRightTilde = Boolean.valueOf(false);
      }
      else if (type.equals(LatexMarkup.Type.PRE)) {
        needLeftTilde = Boolean.valueOf(true);
        needRightTilde = Boolean.valueOf(false);
      }
      else {
        needLeftTilde = Boolean.valueOf(false);
        needRightTilde = Boolean.valueOf(true);
      }
    }

    public Word(String s, Boolean left, Boolean right)
    {
      string = s;
      needLeftTilde = left;
      needRightTilde = right;
    }

    public Word(String s, boolean left, boolean right)
    {
      string = s;
      needLeftTilde = Boolean.valueOf(left);
      needRightTilde = Boolean.valueOf(right);
    }

    public Word concate(Word w)
    {
      Boolean t = Boolean.valueOf(true);
      Boolean f = Boolean.valueOf(false);

      if (string.equals(""))
        return new Word(w.string, w.needLeftTilde, w.needRightTilde);

      if (w.string.equals(""))
        return new Word(string, needLeftTilde, needRightTilde);

      String s = string;
      if (needRightTilde == null || w.needLeftTilde == null)
        s += w.string;
      else if (needRightTilde.equals(f) || w.needLeftTilde.equals(f))
        s += " " + w.string;
      else s += "~" + w.string;

      return new Word(s, needLeftTilde, w.needRightTilde);
    }
  }
:}

parser code {:
  private Writer writer_ = new OutputStreamWriter(System.out);

  public Writer getWriter()
  {
    return writer_;
  }

  public void setWriter(Writer writer)
  {
    writer_ = writer;
  }

  protected void write(String s)
  {
    try {
      writer_.write(s);
    }
    catch(IOException e) {
      System.err.println("Cannot write");
    }
  }

  public void report_error(String message, Object info) {
    StringBuffer m = new StringBuffer("Error");
    if (info instanceof java_cup.runtime.Symbol) {
      java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
      if (s.left >= 0) {                
        m.append(" in line "+(s.left+1));   
        if (s.right >= 0) m.append(", column "+(s.right+1));
      }
      m.append(" (" + s.sym + "," + s.value + ")");
    }
    m.append(": " + message);
    System.err.println(m);
  }


  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new UnsupportedOperationException("Parse error.");
  }
:};


/* ------------Declaration of Terminals and Non Terminals Section----------- */
   
/* Terminals */
terminal           LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACE, RBRACE,
                   LBIND, RBIND, LDATA, RDATA, ZED, AX, SCH, GENAX, GENSCH,
                   END, NL, ELSE, FALSE, FUNCTION, GENERIC, IF,
                   LEFTASSOC, LET, POWER, PARENTS, ZPRE, RELATION,
                   RIGHTASSOC, SECTION, THEN, TRUE, COLON, DEFFREE,
                   BAR, ANDALSO, ZHIDE, SLASH, DOT, SEMICOLON, ARG,
                   LISTARG, EQUALS, CONJECTURE, ALL, SPOT, EXI, EXIONE,
                   IFF, IMP, OR, AND, NOT, MEM, ZPROJ, CROSS, LAMBDA,
                   MU, THETA, ZCOMP, COMMA, DEFEQUAL, ZPIPE;
terminal Integer   NUMERAL;
terminal String    DECORWORD, STROKE, TEXT;
   
/* Non terminals */
non terminal String     s, input, sect, para, schemaText,
                        nlSeq;
non terminal Word       token, tokenSeq, 
                        other, paren, special, decorword;


   s ::=     input
             {: parser.getWriter().flush(); :}
             ;

   input ::= input sect
             |
             sect
             |
             input para
             |
             para
             |
             input TEXT:t
             {: parser.write(t); :}
             |
             TEXT:t
             {: parser.write(t); :}
             ;

   sect ::=  ZED SECTION tokenSeq END
             ;

   para ::=  ZED schemaText:s END
             {:
                String result = begin("zed");
                result += s;
                result += end("zed");
                parser.write(result);
             :}
             |
             AX schemaText:s END
             {:
                String result = begin("axdef");
                result += s;
                result += end("axdef");
                parser.write(result);
             :}
             |
             SCH decorword:w schemaText:s END
             {:
                String result = begin("schema") + "{" + w.string + "}";
                result += s;
                result += end("schema");
                parser.write(result);
             :}
             |
             GENAX schemaText:s END
             {:
                String result = begin("gendef");
                result += s;
                result += end("gendef");
                parser.write(result);
             :}
             |
             GENSCH schemaText:s END
             {:
                String result = begin("schema");
                result += s;
                result += end("schema");
                parser.write(result);
             :}
             ;


   schemaText ::=
             nlSeq:n1 token:s1 tokenSeq:s2 BAR:b nlSeq:n2 token:s3 tokenSeq:s4
             {: RESULT =  n1;
                RESULT += s1.concate(s2).string;
                RESULT += "\\where " + n2;
                RESULT += s3.concate(s4).string; :}
             |
             BAR:b nlSeq:nl token:s1 tokenSeq:s2
             {: RESULT =  "\\where " + nl;
                RESULT += s1.concate(s2).string; :}
             |
             nlSeq:nl token:s1 tokenSeq:s2
             {: RESULT =  nl;
                RESULT += s1.concate(s2).string; :}
             |
             nlSeq:nl
             {: RESULT = nl; :}
             ;

   nlSeq    ::= nlSeq:s NL
             {: RESULT = s + "\n"; :}
             |
             {: RESULT = ""; :}
             ;

   tokenSeq ::= tokenSeq:w1 token:w2
             {: RESULT = w1.concate(w2); :}
             |
             tokenSeq:w1 special:w2
             {: RESULT = w1.concate(w2); :}
             |
             {: RESULT = new Word("", null, null); :}
             ;

   token ::= decorword:s
             {: RESULT = s; :}
             |
             STROKE:s
             {: RESULT = new Word(s, true, true); :}
             |
             NUMERAL:i
             {: RESULT = new Word(i.toString(), true, true); :}
             |
             paren:s
             {: RESULT = s; :}
             |
             other:s
             {: RESULT = s; :}
             ;

   decorword ::= DECORWORD:s
             {:
                String string = (String) map_.get(s);
                if (string != null) {
                  LatexMarkup.Type type = LatexMarkup.getType(string);
                  RESULT = new Word(string, type);
                }
                else RESULT = new Word(s, true, true);
             :}
             ;

   paren ::= LPAREN
             {: RESULT = new Word("(", null, null); :}
             |
             RPAREN
             {: RESULT = new Word(")", null, null); :}
             |
             LSQUARE
             {: RESULT = new Word("[", null, null); :}
             |
             RSQUARE
             {: RESULT = new Word("]", null, null); :}
             |
             LBRACE
             {: RESULT = new Word("\\{", null, null); :}
             |
             RBRACE
             {: RESULT = new Word("\\}", null, null); :}
             |
             LBIND
             {: RESULT = new Word("\\lblot", null, Boolean.valueOf(false)); :}
             |
             RBIND
             {: RESULT = new Word("\\rblot", null, Boolean.valueOf(false)); :}
             |
             LDATA
             {: RESULT = new Word("\\ldata", null, Boolean.valueOf(false)); :}
             |
             RDATA
             {: RESULT = new Word("\\rdata", null, Boolean.valueOf(false)); :}
             ;

  special ::= NL
             {: RESULT = new Word("\\\\\n", null, null); :}
             ;

  other ::=  ELSE
             {: String cmd = "\\ELSE";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             FALSE
             {: RESULT = new Word("false", LatexMarkup.Type.NONE); :}
             |
             FUNCTION
             {: String cmd = "\\function";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             GENERIC
             {: String cmd = "\\generic";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             IF
             {: String cmd = "\\IF";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             LEFTASSOC
             {: String cmd = "\\leftassoc";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             LET
             {: String cmd = "\\LET";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             POWER
             {: String cmd = "\\power";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             PARENTS
             {: String cmd = "\\parents";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             ZPRE
             {: String cmd = "\\pre";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             RELATION
             {: String cmd = "\\relation";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             RIGHTASSOC
             {: String cmd = "\\rightassoc";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             THEN
             {: String cmd = "\\THEN";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             TRUE
             {: RESULT = new Word("true", LatexMarkup.Type.NONE); :}
             |
             COLON
             {: RESULT = new Word(":", null, null); :}
             |
             DEFFREE
             |
             ANDALSO
             |
             ZHIDE
             {: String cmd = "\\hide";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             SLASH
             |
             DOT
             |
             SEMICOLON
             {: RESULT = new Word(";", LatexMarkup.Type.IN); :}
             |
             ARG
             {: String cmd = "\\varg";
                RESULT = new Word(cmd, null, null); :}
             |
             LISTARG
             {: String cmd = "\\listarg";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             EQUALS
             {: RESULT = new Word("=", false, false); :}
             |
             CONJECTURE
             |
             ALL
             {: String cmd = "\\forall";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             SPOT
             {: RESULT = new Word("@", LatexMarkup.Type.IN); :}
             |
             EXI
             {: String cmd = "\\exists";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             EXIONE
             {: RESULT = new Word("\\exists_{1}",
                                  LatexMarkup.getType("\\exists")); :}
             |
             IFF
             {: String cmd = "\\iff";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             IMP
             {: String cmd = "\\implies";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             OR
             {: String cmd = "\\lor";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             AND
             {: String cmd = "\\land";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             NOT
             {: String cmd = "\\lnot";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             MEM
             {: String cmd = "\\in";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             ZPROJ
             {: String cmd = "\\project";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             CROSS
             {: String cmd = "\\cross";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             LAMBDA
             {: String cmd = "\\lambda";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             MU
             {: String cmd = "\\mu";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             THETA
             {: String cmd = "\\theta";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             |
             ZCOMP
             |
             COMMA
             {: RESULT = new Word(",", null, null); :}
             |
             DEFEQUAL
             |
             ZPIPE
             {: String cmd = "\\pipe";
                RESULT = new Word(cmd, LatexMarkup.getType(cmd)); :}
             ;
