/* ----------------------Preliminary Declarations Section--------------------*/

package net.sourceforge.czt.scanner;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

import net.sourceforge.czt.util.ParseException;
import net.sourceforge.czt.z.util.ZString;
import net.sourceforge.czt.parser.util.LatexCommand;
import net.sourceforge.czt.parser.util.LatexMarkupUtils;

action code
{:
  private Map map_ = createMap();

  private Map createMap()
  {
    Map map = new HashMap();
    Set set = LatexMarkup.getUnicodeMappingEntries();
    for (Iterator iter = set.iterator(); iter.hasNext();) {
      Map.Entry entry = (Map.Entry) iter.next();
      String latex = (String) entry.getKey();
      String unicode = (String) entry.getValue();
      LatexMarkup.Type type = LatexMarkup.getType(latex);
      boolean leftSpace = type.equals(LatexMarkup.Type.IN) ||
                          type.equals(LatexMarkup.Type.POST);
      boolean rightSpace = type.equals(LatexMarkup.Type.IN) ||
                           type.equals(LatexMarkup.Type.PRE);
      LatexCommand command =
        new LatexCommand(latex, unicode, leftSpace, rightSpace);
      map.put(unicode, command);
    }
    map.put(ZString.SPOT, new LatexCommand("@", ZString.SPOT, true, true));
    map.put("+", new LatexCommand("+", "+", true, true));
    map.put("-", new LatexCommand("-", "-", true, true));
    map.put("*", new LatexCommand("*", "*", true, true));
    map.put("|", new LatexCommand("|", "|", true, true));
    map.put(";", new LatexCommand(";", ";", false, true));
    map.put(",", new LatexCommand(",", ",", false, true));
    map.put(ZString.SE, new LatexCommand("_{", ZString.SE, false, false));
    map.put(ZString.NW, new LatexCommand("}", ZString.NW, false, false));
    map.put(ZString.NE, new LatexCommand("^{", ZString.NE, false, false));
    map.put(ZString.SW, new LatexCommand("}", ZString.SW, false, false));
    map.put(ZString.LL, new LatexCommand("\\_", ZString.LL, false, false));
    return map;
  }

  private String begin(String string)
  {
    return "\\begin{" + string + "}";
  }

  private String end(String string)
  {
    return "\\end{" + string + "}";
  }

  private LatexCommand concate(LatexCommand c1, LatexCommand c2)
  {
    if (c1 == null) return c2;
    if (c2 == null) return c1;
    String latex = c1.getName();
    if (! c1.addRightSpace() && ! c2.addLeftSpace()) {
      latex += "~";
    } else {
      latex += " ";
    }
    latex += c2.getName();
    return
      new LatexCommand(latex, null, c1.addLeftSpace(), c2.addRightSpace());
  }

  private LatexCommand toLatex(String s, int line, int column)
    throws ParseException
  {
    try {
      return LatexMarkupUtils.uniwordToLatex(s, map_);
    }
    catch(ParseException e) {
      e.setLine(line);
      e.setColumn(column + e.getColumn());
      throw e;
    }
  }
:}

parser code {:
  private Writer writer_ = new OutputStreamWriter(System.out);

  public Writer getWriter()
  {
    return writer_;
  }

  public void setWriter(Writer writer)
  {
    writer_ = writer;
  }

  protected void write(String s)
  {
    try {
      writer_.write(s);
    }
    catch(IOException e) {
      System.err.println("Cannot write");
    }
  }

  public void report_error(String message, Object info) {
    StringBuffer m = new StringBuffer("Error");
    if (info instanceof java_cup.runtime.Symbol) {
      java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
      if (s.left >= 0) {                
        m.append(" in line "+(s.left+1));   
        if (s.right >= 0) m.append(", column "+(s.right+1));
      }
      m.append(" (" + s.sym + "," + s.value + ")");
    }
    m.append(": " + message);
    System.err.println(m);
  }


  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new UnsupportedOperationException("Parse error.");
  }
:};


/* ------------Declaration of Terminals and Non Terminals Section----------- */
   
/* Terminals */
terminal           LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACE, RBRACE,
                   LBIND, RBIND, LDATA, RDATA, ZED, AX, SCH, GENAX, GENSCH,
                   END, NL, ELSE, FALSE, FUNCTION, GENERIC, IF,
                   LEFTASSOC, LET, POWER, PARENTS, ZPRE, RELATION,
                   RIGHTASSOC, SECTION, THEN, TRUE, COLON, DEFFREE,
                   BAR, ANDALSO, ZHIDE, SLASH, DOT, SEMICOLON, ARG,
                   LISTARG, EQUALS, CONJECTURE, ALL, SPOT, EXI, EXIONE,
                   IFF, IMP, OR, AND, NOT, MEM, ZPROJ, CROSS, LAMBDA,
                   MU, THETA, ZCOMP, COMMA, DEFEQUAL, ZPIPE, INSTROKE,
                   OUTSTROKE, NEXTSTROKE;
terminal Integer   NUMERAL, NUMSTROKE;
terminal String    DECORWORD, TEXT;
   
/* Non terminals */
non terminal String     s, input, sect, para;
non terminal LatexCommand token, tokenSeq, other, paren, special, decorword;


   s ::=     input
             {: parser.getWriter().flush(); :}
             ;

   input ::= input sect
             |
             sect
             |
             input para
             |
             para
             |
             input TEXT:t
             {: parser.write(t); :}
             |
             TEXT:t
             {: parser.write(t); :}
             ;

   sect ::=  ZED SECTION tokenSeq END
             ;

   para ::=  ZED tokenSeq:s END
             {:
                String result = begin("zed");
                if (s != null) { result += s.getName(); }
                result += end("zed");
                parser.write(result);
             :}
             |
             AX tokenSeq:s END
             {:
                String result = begin("axdef");
                if (s != null) result += s.getName();
                result += end("axdef");
                parser.write(result);
             :}
             |
             SCH decorword:w tokenSeq:s END
             {:
                String result = begin("schema") + "{" + w.getName() + "}";
                if (s != null) result += s.getName();
                result += end("schema");
                parser.write(result);
             :}
             |
             GENAX tokenSeq:s END
             {:
                String result = begin("gendef");
                if (s != null) result += s.getName();
                result += end("gendef");
                parser.write(result);
             :}
             |
             GENSCH tokenSeq:s END
             {:
                String result = begin("schema");
                if (s != null) result += s.getName();
                result += end("schema");
                parser.write(result);
             :}
             ;

   tokenSeq ::= tokenSeq:w1 token:w2
             {: RESULT = concate(w1, w2); :}
             |
             tokenSeq:w1 special:w2
             {: RESULT = concate(w1, w2); :}
             |
             {: RESULT = null; :}
             ;

   token ::= decorword:s
             {: RESULT = s; :}
             |
             INSTROKE
             {: RESULT = new LatexCommand("?", null, false, false); :}
             |
             OUTSTROKE
             {: RESULT = new LatexCommand("!", null, false, false); :}
             |
             NEXTSTROKE
             {: RESULT = new LatexCommand("'", null, false, false); :}
             |
             NUMSTROKE:i
             {: RESULT =
                  new LatexCommand("^" + i.toString(), null, false, false); :}
             |
             NUMERAL:i
             {: RESULT = new LatexCommand(i.toString(), null, false, false); :}
             |
             paren:s
             {: RESULT = s; :}
             |
             other:s
             {: RESULT = s; :}
             ;

   decorword ::= DECORWORD:s
             {:
                RESULT = toLatex(s, sleft, sright);
                /*
                String string = (String) map_.get(s);
                if (string != null) {
                  LatexMarkup.Type type = LatexMarkup.getType(string);
                  RESULT = new Word(string, type);
                }
                else RESULT = new Word(s, true, true);
                */
             :}
             ;

   paren ::= LPAREN
             {: RESULT = new LatexCommand("(", null, true, true); :}
             |
             RPAREN
             {: RESULT = new LatexCommand(")", null, true, true); :}
             |
             LSQUARE
             {: RESULT = new LatexCommand("[", null, true, true); :}
             |
             RSQUARE
             {: RESULT = new LatexCommand("]", null, true, true); :}
             |
             LBRACE
             {: RESULT = new LatexCommand("\\{", null, true, true); :}
             |
             RBRACE
             {: RESULT = new LatexCommand("\\}", null, true, true); :}
             |
             LBIND
             {: RESULT = new LatexCommand("\\lblot", null, true, true); :}
             |
             RBIND
             {: RESULT = new LatexCommand("\\rblot", null, true, true); :}
             |
             LDATA
             {: RESULT = new LatexCommand("\\ldata", null, true, true); :}
             |
             RDATA
             {: RESULT = new LatexCommand("\\rdata", null, true, true); :}
             ;

  special ::= NL
             {: RESULT = new LatexCommand("\\\\\n", null, true, true); :}
             ;

  other ::=  BAR:t
             {: RESULT = new LatexCommand("\\where\n", null, true, true); :}
             |
             ELSE:t
             {: RESULT = toLatex("else", tleft, tright); :}
             |
             FALSE:t
             {: RESULT = toLatex("false", tleft, tright); :}
             |
             FUNCTION:t
             {: RESULT = toLatex("function", tleft, tright); :}
             |
             GENERIC:t
             {: RESULT = toLatex("generic", tleft, tright); :}
             |
             IF:t
             {: RESULT = toLatex("if", tleft, tright); :}
             |
             LEFTASSOC:t
             {: RESULT = toLatex("leftassoc", tleft, tright); :}
             |
             LET:t
             {: RESULT = toLatex("let", tleft, tright); :}
             |
             POWER:t
             {: RESULT = toLatex(ZString.POWER, tleft, tright); :}
             |
             PARENTS:t
             {: RESULT = toLatex("parents", tleft, tright); :}
             |
             ZPRE:t
             {: RESULT = toLatex("pre", tleft, tright); :}
             |
             RELATION:t
             {: RESULT = toLatex("relation", tleft, tright); :}
             |
             RIGHTASSOC:t
             {: RESULT = toLatex("rightassoc", tleft, tright); :}
             |
             THEN:t
             {: RESULT = toLatex("then", tleft, tright); :}
             |
             TRUE:t
             {: RESULT = toLatex("true", tleft, tright); :}
             |
             COLON
             {: RESULT = new LatexCommand(":", null, false, false); :}
             |
             DEFFREE:t
             {: RESULT = toLatex("::=", tleft, tright); :}
             |
             ANDALSO:t
             {: RESULT = toLatex("&", tleft, tright); :}
             |
             ZHIDE:t
             {: RESULT = toLatex(ZString.ZHIDE, tleft, tright); :}
             |
             SLASH:t
             {: RESULT = toLatex(ZString.AMP, tleft, tright); :}
             |
             DOT:t
             {: RESULT = toLatex(ZString.DOT, tleft, tright); :}
             |
             SEMICOLON:t
             {: RESULT = toLatex(ZString.SEMICOLON, tleft, tright); :}
             |
             ARG:t
             {: RESULT = toLatex("_", tleft, tright); :}
             |
             LISTARG:t
             {: RESULT = toLatex(",,", tleft, tright); :}
             |
             EQUALS:t
             {: RESULT = toLatex("=", tleft, tright); :}
             |
             CONJECTURE:t
             {: RESULT = toLatex(ZString.CONJECTURE, tleft, tright); :}
             |
             ALL:t
             {: RESULT = toLatex(ZString.ALL, tleft, tright); :}
             |
             SPOT:t
             {: RESULT = toLatex(ZString.SPOT, tleft, tright); :}
             |
             EXI:t
             {: RESULT = toLatex(ZString.EXI, tleft, tright); :}
             |
             EXIONE:t
             {: RESULT = toLatex(ZString.EXI + ZString.SUB1, tleft, tright); :}
             |
             IFF:t
             {: RESULT = toLatex(ZString.IFF, tleft, tright); :}
             |
             IMP:t
             {: RESULT = toLatex(ZString.IMP, tleft, tright); :}
             |
             OR:t
             {: RESULT = toLatex(ZString.OR, tleft, tright); :}
             |
             AND:t
             {: RESULT = toLatex(ZString.AND, tleft, tright); :}
             |
             NOT:t
             {: RESULT = toLatex(ZString.NOT, tleft, tright); :}
             |
             MEM:t
             {: RESULT = toLatex(ZString.MEM, tleft, tright); :}
             |
             ZPROJ:t
             {: RESULT = toLatex(ZString.ZPROJ, tleft, tright); :}
             |
             CROSS:t
             {: RESULT = toLatex(ZString.CROSS, tleft, tright); :}
             |
             LAMBDA:t
             {: RESULT = toLatex(ZString.LAMBDA, tleft, tright); :}
             |
             MU:t
             {: RESULT = toLatex(ZString.MU, tleft, tright); :}
             |
             THETA:t
             {: RESULT = toLatex(ZString.THETA, tleft, tright); :}
             |
             ZCOMP:t
             {: RESULT = toLatex(ZString.ZCOMP, tleft, tright); :}
             |
             COMMA:t
             {: RESULT = toLatex(ZString.COMMA, tleft, tright); :}
             |
             DEFEQUAL:t
             {: RESULT = toLatex("==", tleft, tright); :}
             |
             ZPIPE:t
             {: RESULT = toLatex(ZString.ZPIPE, tleft, tright); :}
             ;
