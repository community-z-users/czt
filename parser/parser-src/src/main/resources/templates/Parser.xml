<?xml version="1.0" encoding="utf-8"?>
<parser xmlns:add="http://czt.sourceforge.net/templates/additional">
/*
  Copyright (C) 2003, 2004, 2005 Tim Miller
  Copyright (C) 2004, 2005, 2006, 2007 Petra Malik
  Copyright (C) 2005, 2006, 2007 Leo Freitas
  This file is part of the CZT project.

  The CZT project contains free software;
  you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  The CZT project is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CZT; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package <package/>;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Properties;
import java.util.Collection;
import java.util.Collections;

import java_cup.runtime.*;

import net.sourceforge.czt.util.CztException;
import net.sourceforge.czt.util.Section;
import net.sourceforge.czt.util.CztLogger;

import net.sourceforge.czt.base.ast.*;
import net.sourceforge.czt.base.util.PerformanceSettings;

import net.sourceforge.czt.z.ast.*;
import net.sourceforge.czt.z.util.*;

import net.sourceforge.czt.session.*;

import net.sourceforge.czt.parser.util.*;

<add:circus>
import net.sourceforge.czt.parser.z.*;
import net.sourceforge.czt.circus.ast.*;
import net.sourceforge.czt.circus.util.CircusUtils;
</add:circus>
<add:circuscore>
import net.sourceforge.czt.circus.util.Factory;
</add:circuscore>

<add:circustime>
//import net.sourceforge.czt.circustime.ast.*;
//import net.sourceforge.czt.circustime.util.CircusTimeUtils;

import net.sourceforge.czt.parser.circus.CircusParseError;
import net.sourceforge.czt.parser.circus.CircusParseMessage;
</add:circustime>
<add:circustimecore>
import net.sourceforge.czt.circustime.util.Factory;
</add:circustimecore>


<add:circusconf>
import net.sourceforge.czt.parser.circus.CircusParseError;
import net.sourceforge.czt.parser.circus.CircusParseMessage;
</add:circusconf>
<add:circusconfcore>
import net.sourceforge.czt.circusconf.util.Factory;
</add:circusconfcore>


<add:oz>
import net.sourceforge.czt.oz.ast.*;
import net.sourceforge.czt.oz.util.OzString;

import net.sourceforge.czt.parser.z.*;
</add:oz>
<add:ozcore>
import net.sourceforge.czt.oz.util.Factory;
</add:ozcore>

<add:ozpattcore>
import net.sourceforge.czt.oz.util.Factory;
</add:ozpattcore>

<add:ozpatt>
import net.sourceforge.czt.parser.oz.ParserState;
import net.sourceforge.czt.parser.zpatt.JokerTable;
import net.sourceforge.czt.parser.zpatt.ZpattParseError;
import net.sourceforge.czt.parser.zpatt.ZpattParseMessage;
</add:ozpatt>

<add:tcoz>
import net.sourceforge.czt.tcoz.ast.*;
import net.sourceforge.czt.tcoz.util.Factory;

</add:tcoz>

<add:pattern>
import net.sourceforge.czt.zpatt.ast.*;

</add:pattern>
<add:zpattcore>
import net.sourceforge.czt.parser.z.*;
import net.sourceforge.czt.zpatt.util.Factory;
</add:zpattcore>

<add:zeves>
import net.sourceforge.czt.zeves.ast.*;
import net.sourceforge.czt.zeves.util.ZEvesString;
import net.sourceforge.czt.zeves.util.Factory;
import net.sourceforge.czt.zeves.util.ZEvesUtils;

import net.sourceforge.czt.parser.z.*;

import net.sourceforge.czt.parser.zeves.ProofTable;
</add:zeves>

import net.sourceforge.czt.session.Dialect;

action code
{:
<add:oz>
    /** The name of the Object-Z toolkit. */
    public final static String OZ_TOOLKIT = "oz_toolkit";
</add:oz>

    /** The symbols used to replace arguments for names in ApplExpr etc. */
    protected final static String ARG_TOK = ZString.ARG_TOK;
    protected final static String LISTARG_TOK = ZString.LISTARG_TOK;

    /** The factory for creating AST objects. */
    protected Factory factory_;

    /** The table of operators. */
    protected OpTable opTable_;
    
    /** The table of named conjectures */
    protected ThmTable thmTable_;

<add:pattern>
    /** The table of joker names. */
    protected JokerTable jokerTable_;
</add:pattern>
<add:zeves>
    /** The table of proof scripts. */
    protected ProofTable proofTable_;
</add:zeves>

    /** The source currently being parsed. */
    protected Source source_ = null;

    /**
     * The symbol returned by the last call to local_next_token().
     */
    protected Symbol previous_;

    protected ParserState parserState_;

   /** Section information (action code). */
    protected SectionInfo sectInfo_;

	protected DefaultSectionParents defaultSP_;

		/** Action code dialect */
	  protected Dialect dialect_;
	  
    /** The operator scanner. */
    protected OperatorScanner opScanner_;
    protected NewlineScanner nlScanner_;
<add:pattern>
    protected JokerScanner jokerScanner_;
</add:pattern>
<add:oz>

	
    /**
     * Create a pair of PrimaryDecl and SecondaryDecl from 2 DeclLists
     */
    protected Pair&lt;PrimaryDecl,SecondaryDecl&gt;
      statePair(DeclList pDeclList, DeclList sDeclList)
    {
      if (pDeclList == null) {
        pDeclList = factory_.createZDeclList();
      }
      if (sDeclList == null) {
        sDeclList = factory_.createZDeclList();
      }
      PrimaryDecl primaryDecl = factory_.createPrimaryDecl(pDeclList);
      SecondaryDecl secondaryDecl = factory_.createSecondaryDecl(sDeclList);
      return new Pair&lt;PrimaryDecl,SecondaryDecl&gt;(primaryDecl, secondaryDecl);
    }

    protected OpText createOpText(DeltaList del, DeclList dec, Pred p)
    {
      if (dec == null) dec = factory_.createZDeclList();
      return factory_.createOpText(del, factory_.createZSchText(dec, p));
    }
</add:oz>

		public Dialect getDialect()
		{
			return dialect_;
		}

    /**
     * Create an function application with the SchExpr formed from
     * 'st' and any additional renaming/strokes etc in 'al'.
     * 
     * @param e 
     * @param st 
     * @param al 
     * @return
     */
    private ApplExpr createSchApplExpr(Expr e, SchText st,
                                       List &lt; Object &gt; al)
    {
      Expr se = factory_.createSchExpr(st);
      for (Object a : al) {
        if (a instanceof Stroke) {
          se = factory_.createDecorExpr(se, (Stroke) a);
        }
        else if (a instanceof RenameExpr) {
          RenameExpr re = (RenameExpr) a;
          se = factory_.createRenameExpr(se, re.getRenameList());
        }
        else if (a instanceof BindSelExpr) {
          BindSelExpr bse = (BindSelExpr) a;
          se  = factory_.createBindSelExpr(se, bse.getName());
        }
        else if (a instanceof TupleSelExpr) {
          TupleSelExpr tse = (TupleSelExpr) a;
          se  = factory_.createTupleSelExpr(se, tse.getNumeral());
        }
      }
      ApplExpr result = factory_.createApplExpr(e, se, Boolean.FALSE);
      return result;
    }

    private void checkName(Decorword decorword)
    {
      ZChar unmatched = decorword.check();
      if (unmatched != null) {
        final Object[] params = { unmatched };
        parser.report_error(ZParseMessage.MSG_UNMATCHED_WORDGLUE,
                            params, decorword.getLocation());
      }
    }

    private Spec createSpec(List&lt;? extends Sect&gt; sectList)
    {
      Spec result = factory_.createSpec();
      result.setVersion(Version.ZML_VERSION);
      result.getSect().addAll(sectList);
      return result;
    }

    private ZName createZName(Decorword decorword)
    {
      checkName(decorword);
      ZName result = factory_.createZName(decorword.getWord(),
                                          decorword.getStrokes());
      addLocAnn(result, decorword.getLocation());
      return result;
    }

<add:zeves>
    // bla\$domainCheck or bla\$declaration
    private ZName createSpecialThmName(Decorword dw1, /*LocInfo dollar,*/ Decorword dw2)
    {
      checkName(dw1);
      checkName(dw2);
      // dw1 might have strokes; dw2 must not have strokes.
      ZName result = factory_.createZName(dw1.getWord() + ZEvesString.ZPROOFDOLLARCHAR + dw2.getWord(), dw1.getStrokes());
      checkSpecialThmSuffix(dw2);

      // location is the start of dw1 and end dw2
      addLocAnn(result, getLocation(dw1.getLocation(), dw2.getLocation()));
      return result;
    }

    // unamed\$n5\$domainCheck
    private ZName createSpecialThmName(Decorword dw1, Decorword dw2, Decorword dw3)
    {
      checkName(dw1);
      checkName(dw2);
      checkName(dw3);
      // dw1 might have strokes; dw2/3 must not have strokes.
      ZName result = factory_.createZName(dw1.getWord() + ZEvesString.ZPROOFDOLLARCHAR + dw2.getWord() + ZEvesString.ZPROOFDOLLARCHAR + dw3.getWord(), dw1.getStrokes());
      checkSpecialThmSuffix(dw2);
      checkSpecialThmSuffix(dw3);

      // location is the start of dw1 and end dw2
      addLocAnn(result, getLocation(dw1.getLocation(), dw3.getLocation()));
      return result;
    }

    private void checkSpecialThmSuffix(Decorword dw)
    {
      if (dw.getStrokes() != null &amp;&amp; !dw.getStrokes().isEmpty())
      {
        parser.report_error(ZEvesParseMessage.MSG_INVALID_SPECIAL_THM_SUFFIX,
                               new Object[] { dw.toString() }, dw.getLocation());
      }
      // TODO: or should we actually check for all the "allowed" names? e.g., domainCheck; thetasInSet; member; etc...
    }

    // some very peculiar circunstances (e.g., name capture; mistaken names from thm appl) might appear like "x$"
    //private ZName createSpecialName(Decorword dw)
    //{
    //  checkName(dw);
    //  ZName result = factory_.createZName(dw.getWord() + ZEvesString.ZPROOFDOLLARCHAR, dw.getStrokes());
    //  addLocAnn(result, dw.getLocation());
    //  return result;
    //}

    // x$' for x' renamed due to capture
    // second decorword MUST be DOLLAR STROKE
    //private ZName createSpecialName(Decorword dw)//, Decorword pw)
    //{
    //  checkName(dw);
    //  //checkName(pw);
    //  if ((!dw.getWord().endsWith(ZEvesString.ZPROOFDOLLARCHAR))
    //      //||
    //      //(pw == null || !(pw instanceof Proofword) || !pw.getStrokes().isEmpty())
    //      )
    //  {
    //    parser.report_error(ZEvesParseMessage.MSG_INVALID_SPECIAL_THM_SUFFIX,
    //        new Object[] { dw.toString() //+ String.valueOf(pw)
    //                     }, dw.getLocation());
    //  }
    //  ZName result = factory_.createZName(dw.getWord() + ZEvesString.TO,//pw.getWord(),
    //    dw.getStrokes());
    //  addLocAnn(result, dw.getLocation());
    //  return result;
    //}

    private void addZNote(Term term, ZEvesNote znote)
    {
      if (znote != null &amp;&amp; znote.getNote() != null &amp;&amp; !znote.getNote().isEmpty())
      {
        term.getAnns().add(znote);
      }
    }

    /**
     * Labels for unboxed paragraph are slighltly more complicated. That's because something like \begin[disabled]{zed}...\end{zed}
     * are (ability-only) labels for all paragraphs within, hence the list as a parameter. Each paragraph will have inner elements
     * within that are entitled to a label, say a GivenPara like [X,Y,Z] will have 3 labels, one for each name X, Y, Z. That is,
     * GivenPara will have 3 labels, and each name will have its own. For FreePara, each FreeType and Branch have a label, as well
     * as the top-level para, where the names are free-type names. For AxPara, it depends: if it's an abbreviation or horizontal
     * schema (e.g., OmitBox), the name is obvious; other AxPara kinds are not allowed within unboxed-para lists. For ConjPara,
     * an error is raised, since Z/EVES does not allow theorems in zed environments. OptempPara is also funny, but necessary.
     */
    private void addZEvesLabel(List&lt;Para&gt; unboxedParaList, LabelAbility ability)
    {
      for (Para p : unboxedParaList)
      {
        if (p instanceof GivenPara)
        {
          GivenPara gp = (GivenPara) p;
          if (gp.getNameList() instanceof ZNameList)
          {
            for (Name name : gp.getZNameList())
            {
              addZEvesLabel(gp, name, ability);
            }
          }
        }
        else if (p instanceof FreePara)
        {
          FreePara fp = (FreePara)p;
          if (fp.getFreetypeList() instanceof ZFreetypeList)
          {
            for (Freetype ft : ZUtils.assertZFreetypeList(fp.getFreetypeList()))
            {
              addZEvesLabel(fp, ft.getName(), ability);
              if (ft.getBranchList() instanceof ZBranchList)
              {
                for (Branch branch : ZUtils.assertZBranchList(ft.getBranchList()))
                {
                  addZEvesLabel(fp, branch.getName(), ability);
                }
              }
            }
          }
        }
        else if (p instanceof AxPara)
        {
          AxPara ap = (AxPara)p;
          if (ap.getBox().equals(Box.OmitBox))
          {
            // try if it is an abbreviation
            Name name = ZUtils.getAbbreviationName(ap);
            if (name == null)
            {
              // if not, it must be a simple schema (e.g., one that is schema display, not schema calculus, YET! TODO)
              if (!ZUtils.isSimpleSchema(ap))
              {
                parser.report_error(ZEvesParseMessage.MSG_INVALID_AXPARA_ABILITY,
                               new Object[] { ap }, getLocation(p));
              }
              else
              {
                name = ZUtils.getSchemaName(ap);
              }
            }
            assert name != null;
            addZEvesLabel(ap, name, ability);
          }
          else
          {
            parser.report_error(ZEvesParseMessage.MSG_INVALID_AXPARA_ABILITY,
                               new Object[] { ap }, getLocation(p));
          }
        }
        else if (p instanceof OptempPara)
        {
          OptempPara op = (OptempPara)p;
          for (Oper oper : op.getOper())
          {
            //if (oper instanceof Operand)
            //{
            //  ((Operand)oper).
            //}
            //else
            if (oper instanceof Operator)
            {
              addZEvesLabel(op, factory_.createZName(((Operator)oper).getWord()), ability);
            }
          }
        }
        else if (p instanceof ConjPara)
        {
          // if \vdash? is present, this is unlikely to be within Z/EVES,
          // but rather as part of a unboxedPara within ZED rather than THEOREM
          // raise a warning? or error? ERROR?
          
          // the assymetry of THEOREM is annoying: in there, we add the label. But it is still
          // parsed as if it was an unboxed para (!) So, will get here. So, only raise the error
          // if getLabel(p) doesn't have a label yet (e.g., haven't been processed as THEOREM!)
          if (ZEvesUtils.getLabel(p) == null)
          {
            parser.report_error(ZEvesParseMessage.MSG_UNBOXED_CONJPARA, new Object[] { ((ConjPara)p).getName(), p }, getLocation(p));
          }
        }
        else
        {
           parser.report_error(ZEvesParseMessage.MSG_UNKNOWNPARA_ABILITY,
                               new Object[] { p }, getLocation(p));
        }
      }
    }

    private void addZEvesLabel(Term term, Name name, LabelAbility ability)
    {
      addZEvesLabel(term, name, ability, ZEvesUtils.getDefaultUsage());
    }

    /**
     * Create ZEvesLabel with given parameters and attach it to Term, as well as Name.
     * If the term or name already contains a label, a warning is raised.
     */
    private void addZEvesLabel(Term term, Name name, LabelAbility ability, LabelUsage usage)
    {
      assert name != null;
      if (ZEvesUtils.getLabel(term) != null)
      {
         // warning: multiple labels? It does happen for GivenPara and others, though...
         // in that case, check the name. If it does have it already as well, then raise the warning
         // (E.g., the name having it at a GvienPara, is a duplication)
         if (ZEvesUtils.getLabel(name) != null)
         {
            CztLogger.getLogger(<class/>.class).warning("Duplicated ZEvesLabel for name " + name + " as " + 
            	ZEvesUtils.getLabel(name) + " for " + getDialect().toString() + " in Parser.");
            if (!ZEvesUtils.getLabel(name).equals(ZEvesUtils.getLabel(term)))
            {
              CztLogger.getLogger(<class/>.class).warning("Inconsistent ZEvesLabel for name " + name + 
              	" and term as " + ZEvesUtils.getLabel(name)
              	+ " for " + getDialect().toString() + " in Parser.");
            }
         }
      }
      ZEvesLabel label = factory_.createZEvesLabel(name, ability, usage);
      //name.getAnns().add(label); To avoid circular annotation loops in ZML
      term.getAnns().add(label);
    }

    /**
     * Creates a ZEvesLabel with default values from ZEvesUtils, and a fresh name
     * according to ParserState - this is usually the name for axioms, like axiom$1.
     * The freshly created name has the label as an annotation.
     */
    private ZEvesLabel createDefaultZEvesLabel(LabelAbility ability, LabelUsage usage)
    {
      ZName name = factory_.createZName(parserState_.freshLabelName());
      ZEvesLabel result = factory_.createZEvesLabel(name, ability, usage);
      //name.getAnns().add(result); To avoid circular annotation loops in ZML
      return result;
    }
</add:zeves>

<add:circus>
    /**
     * This solution is simpler(?) than the DEFNAME used by Object-Z to
     * disambiguate DECORWORD where a name is needed. For Circus, we
     * just use DECORWORD, which does not cause ambiguity, but check
     * that strokes are empty if not accepted.
     */
    private ZName createCircusName(Decorword decorword)
    {
      // !acceptStrokes => decorword.getStrokes().isEmpty()
      //boolean validStrokes = (acceptStrokes || decorword.getStrokes().isEmpty());
      if (!decorword.getStrokes().isEmpty())
      {
        final Object[] params = { decorword.getWord() };
        parser.report_error(CircusParseMessage.MSG_CIRCNAME_DOESNOT_ALLOW_STROKES,
                            params, decorword.getLocation());
      }
      return createZName(decorword);
    }
</add:circus>

    private Operator createOperator(Decorword decorword)
    {
      return createOperator(decorword.getName(), decorword.getLocation());
    }

    private Operator createOperator(String name, LocInfo locInfo)
    {
      final ZName dn = factory_.createZName(name);
      final StrokeList sl = dn.getStrokeList();
      if (sl instanceof List &amp;&amp; ((List&lt;?&gt;) sl).size() != 0) {
        final Object[] params = { name };
        parser.report_error(ZParseMessage.MSG_STROKE_IN_OPNAME,
                            params, locInfo);
      }
      Operator result = factory_.createOperator(dn.getWord());
      addLocAnn(result, locInfo);
      return result;
    }

    private void misusedOpName(LocString name)
    {
      final Object [] params = {name.getString()};
      parser.report_error(ZParseMessage.MSG_OPNAME_AS_DECLWORD,
                          params, name.getLocation());
    }

    private LocInfo getLocation(int line, int column)
    {
      return new LocInfoImpl(getDialect(), getLoc(), line, column);
    }

    private LocInfo getLocation(Term term)
    {
      return parser.getLocation(term);
    }

    private OperatorName createOperatorName(List&lt;String&gt; list)
      throws OperatorName.OperatorNameException
    {
      final String errorMessage = list + " is not an operator name (for dialect " + getDialect().toString() + " in Parser).";
      if (list.size() &lt;= 1) {
        throw new OperatorName.OperatorNameException(errorMessage);
      }
      StrokeList strokes = null;
      Boolean expectArgument = null;
      StringBuilder stringBuilder = new StringBuilder();
      for (String opPart : list) {
        if (opPart.equals(ZString.ARG) ||
            opPart.equals(ARG_TOK)) {
          if (Boolean.FALSE.equals(expectArgument)) {
            throw new OperatorName.OperatorNameException(errorMessage);
          }
          stringBuilder.append(ARG_TOK);
          expectArgument = Boolean.FALSE;
        }
        else if (opPart.equals(ZString.LISTARG) ||
                 opPart.equals(LISTARG_TOK)) {
          if (Boolean.FALSE.equals(expectArgument)) {
            throw new OperatorName.OperatorNameException(errorMessage);
          }
          stringBuilder.append(LISTARG_TOK);
          expectArgument = Boolean.FALSE;
        }
        else {
          if (Boolean.TRUE.equals(expectArgument)) {
            throw new OperatorName.OperatorNameException(errorMessage);
          }
          ZName declName = factory_.createZName(opPart);
          stringBuilder.append(declName.getWord());
          if (strokes == null) {
            strokes = declName.getStrokeList();
          }
          else if (! strokes.equals(declName.getStrokeList())) {
            final String message =
              "The component names of an operator must have the " +
              "same decorations (for dialect " + dialect_.toString() + " in Parser).";
            throw new OperatorName.OperatorNameException(message);
          }
          expectArgument = Boolean.TRUE;
        }
      }
      return new OperatorName(stringBuilder.toString(), strokes);
    }

    /**
     * Converts a list of String objects to a Name object.
     * 
     * @param list 
     * @param location 
     * @return
     */
    protected ZName strListToZName(List&lt;String&gt; list,
                                   LocInfo location)
    {
      try {
        OperatorName opName = createOperatorName(list);
        ZName result =
          factory_.createZName(opName.getWord(), opName.getStrokes());
        addLocAnn(result, location);
        return result;
      }
      catch (OperatorName.OperatorNameException e) {
        parser.report_error(ZParseMessage.MSG_OPNAME_ERROR,
                            new Object[] { e.getMessage() },
                            location);
        return null;
      }
    }
    
    /**
     * Converts a name list into a list of strings. This methods is called by complex operator template
     * patterns that eventually call strListToZName(List&lt;String&gt;, LocInfo). Earlier versions of 
     * parser mixed up list of names within the list of strings... This method flattens these names to strings.
     */
    protected List&lt;String&gt; extractNamesFromNameList(List&lt;Name&gt; list)
    {
    	List&lt;String&gt; result = factory_.list();
    	for(Name n : list)
    	{
    		if (n instanceof ZName)
    			result.add(ZUtils.assertZName(n).getWord());
    		<add:zpatt>
    		else if (n instanceof net.sourceforge.czt.zpatt.ast.JokerName)
    			result.add(((net.sourceforge.czt.zpatt.ast.JokerName)n).getName());
    		</add:zpatt>
    		else
    			result.add(n.toString());
    	}
    	return result;
    }
    

    protected List&lt;String&gt; toStringList(List&lt;LocString&gt; list)
    {
      List&lt;String&gt; result = new ArrayList&lt;String&gt;(list.size());
      for (LocString ls : list) {
        result.add(ls.getString());
      }
      return result;
    }

    /**
     * Converts a Term to a Pred.
     * 
     * @param t 
     * @return
     */
    protected Pred pred(Term t)
    {
      Pred result = null;

      if (t instanceof Pred) {
        result = (Pred) t;
      }
<add:oz>
      else if (t instanceof PredExpr) {
        result = ((PredExpr) t).getPred();
      }
</add:oz>
      else if (t instanceof Expr) {
        result = factory_.createExprPred((Expr) t);
        LocAnn locAnn = (LocAnn) t.getAnn(LocAnn.class);
        if (locAnn != null) result.getAnns().add(locAnn);
      }
      else {
        //I don't think that this is possible...?
        parser.report_error(ZParseMessage.MSG_PRED_EXPECTED,
                            new Object[0], getLocation(t));
      }
      return result;
    }

    /**
     * Converts an Term to an Expr.
     * 
     * @param t 
     * @return
     */
    protected Expr expr(Term t)
    {
      Expr result = null;

      if (t instanceof Expr) {
        result = (Expr) t;
      }
      else if (t instanceof ExprPred) {
        result = ((ExprPred) t).getExpr();
      }
<add:oz>
      else if (t instanceof OpPromotionExpr) {
        OpPromotionExpr ope = (OpPromotionExpr) t;
        assert ope.getExpr() != null;
        Expr e = ope.getExpr();
        Name rn = ope.getName();
        result = factory_.createBindSelExpr(ope.getExpr(), ope.getName());
        LocAnn locAnn = (LocAnn) t.getAnn(LocAnn.class);
        if (locAnn != null) result.getAnns().add(locAnn);
      }
</add:oz>
      else if (t instanceof Pred) {
<add:oz>
        result = factory_.createPredExpr((Pred) t);
        LocAnn locAnn = (LocAnn) t.getAnn(LocAnn.class);
        if (locAnn != null) result.getAnns().add(locAnn);
</add:oz>
<add:z>
        parser.report_error(ZParseMessage.MSG_EXPR_EXPECTED_FOUND_PRED,
                            new Object [0], getLocation(t));
</add:z>
<add:zeves>
        parser.report_error(ZParseMessage.MSG_EXPR_EXPECTED_FOUND_PRED,
                            new Object [0], getLocation(t));
</add:zeves>
<add:circus>
        parser.report_error(ZParseMessage.MSG_EXPR_EXPECTED_FOUND_PRED,
                            new Object [0], getLocation(t));
</add:circus>

<add:pattern>
        parser.report_error(ZParseMessage.MSG_EXPR_EXPECTED_FOUND_PRED,
                            new Object [0], getLocation(t));
</add:pattern>
      }
      else {
        parser.report_error(ZParseMessage.MSG_EXPR_EXPECTED,
                            new Object [0], getLocation(t));
      }
      return result;
    }

<add:oz>
    /**
     * Converts a Term to an OpExpr.
     */
    protected OpExpr opExpr(Term t)
    {
      if (t instanceof OpExpr) return (OpExpr) t;
      if (t instanceof RefExpr) {
        RefExpr re = (RefExpr) t;
        OpExpr result = factory_.createOpPromotionExpr(null, re.getName());
        LocAnn locAnn = (LocAnn) t.getAnn(LocAnn.class);
        if (locAnn != null) result.getAnns().add(locAnn);
        return result;
      }
      parser.report_error(ZParseMessage.MSG_OPEXPR_EXPECTED,
                          new Object[0], getLocation(t));
      return null;
    }
</add:oz>

    /**
     * Converts a Term to a Name.
     * 
     * @param t 
     * @return 
     */
    protected Name name(Term t)
    {
      if (t instanceof Name) return (Name) t;
      if (t instanceof RefExpr) {
        RefExpr re = (RefExpr) t;
        if (re.getZExprList().size() > 0) {
          parser.report_error(ZParseMessage.MSG_REFNAME_NO_PARAMS_EXPECTED,
                              new Object [0], getLocation(re));
        }
        return re.getName();
      }
      parser.report_error(ZParseMessage.MSG_REFNAME_EXPECTED,
                          new Object [0], getLocation(t));
      return null;
    }

    /**
     * Creates a member predicate from a string list and an expression list.
     * 
     * @param name 
     * @param exprs 
     * @param loc 
     * @return
     */
    protected MemPred createMemPred(List&lt;String&gt; name,
                                    ZExprList exprs,
                                    LocInfo loc)
    {
      Expr e = createTupleExpr(exprs);
      Name rn = strListToZName(name, loc);
      MemPred result = factory_.createRelOpAppl(e, rn);
      addLocAnn(result.getRightExpr(), loc);
      return result;
    }

    /**
     * Creates an application expression or reference expression
     * (depending on the type of operator: function or generic)
     * from a string list and an expression list.
     * The line,column pair are the position of the start of
     * the whole mixfix expression.
     * 
     * @param name 
     * @param exprs 
     * @param loc 
     * @return
     */
    protected Expr createMixfixExpr(List&lt;String&gt; name,
                                    ZExprList exprs,
                                    LocInfo loc)
    {
      final Name rn = strListToZName(name, loc);
      Expr result = null;

      // TODO: then do what with it? firstOperator is never used.
      //
      //get the first operator in the name list, i.e. the first
      //item that is not an ARG_TOK or LISTARG_TOK.
      //String firstOperator = null;
      //for (String next : name) {
      //  if (! next.equals(ARG_TOK) &amp;&amp; ! next.equals(LISTARG_TOK)) {
      //    firstOperator = next;
      //    break;
      //  }
      //}

      if (opTable_.lookup(name) != null &amp;&amp;
          Cat.Function.equals(opTable_.lookup(name).getCat())) {
        Expr e = createTupleExpr(exprs);
        result = factory_.createFunOpAppl(rn, e);
        addLocAnn(((ApplExpr) result).getLeftExpr(), loc);
      }
      else {
        result = factory_.createRefExpr(rn, exprs, Boolean.TRUE, Boolean.TRUE);
      }

      return result;
    }

    /**
     * If the list contains just one expression, the expression is
     * returned.  If there is more than one expression in the list, a
     * tuple expression is created and returned.
     * 
     * @param exprs 
     * @return
     */
    private Expr createTupleExpr(ZExprList exprs)
    {
      return exprs.size() == 1 ?
        exprs.get(0) : factory_.createTupleExpr(exprs);
    }

    /**
     * Returns the right hand side of the previous infix relation.
     * 
     * @param pred 
     * @return
     */
    protected Expr getPreviousRhsExpr(Pred pred)
    {
      Expr result = null;

      MemPred memPred = null;
      if (pred instanceof MemPred) {
        memPred = (MemPred) pred;
      }
      else {   //AndPred
        memPred = (MemPred) ((AndPred) pred).getRightPred();
      }

      //if the previous infix is a mem pred
      if (memPred.getMixfix().equals(Boolean.FALSE)) {
        result = memPred.getRightExpr();
      }
      //if the previous infix is an equals
      else if (memPred.getMixfix().equals(Boolean.TRUE) &amp;&amp;
               memPred.getRightExpr() instanceof SetExpr) {
        SetExpr se = (SetExpr) memPred.getRightExpr();
        result = se.getZExprList().get(0);
      }
      //if the previous infix is an IP
      else {
        TupleExpr te = (TupleExpr) memPred.getLeftExpr();
        result = te.getZExprList().get(1);
      }

      return result;
    }

    /**
     * Convert a chain relation into a series of and predicates
     * (transformation rule 12.2.10.3).
     * 
     * @param chain 
     * @param sym 
     * @param rhs 
     * @param loc 
     * @return
     */
    protected Pred transformChainRel(Pred chain, int sym, Expr rhs,
                                     LocInfo loc)
    {
      Pred result = null;

      Expr lExpr = getPreviousRhsExpr(chain);
      Expr rExpr = rhs;

      Boolean mixfix = Boolean.FALSE;
      if (sym == Sym.EQUALS) {
        ZExprList expList = factory_.createZExprList();
        expList.add(rhs);
        rExpr = factory_.createSetExpr(expList);
        addLocAnn(rExpr, loc);
        mixfix = Boolean.TRUE;
      }

      MemPred mp = factory_.createMemPred(lExpr, rExpr, mixfix);
      addLocAnn(mp, loc);
      result = factory_.createAndPred(chain, mp, And.Chain);
      return result;
    }

    protected Pred transformChainRelInfix(Pred chain, Expr rhs, String ip,
                                          LocInfo loc)
    {
      Pred result = null;

      List&lt;String&gt; opName = factory_.list(ARG_TOK);
      opName.add(ip);
      opName.add(ARG_TOK);

      Expr lExpr = getPreviousRhsExpr(chain);
      Expr rExpr = rhs;
      ZExprList exprs = factory_.createZExprList();
      exprs.add(lExpr);
      exprs.add(rExpr);
      MemPred mp = createMemPred(opName, exprs, loc);
      addLocAnn(mp, loc);
      result = factory_.createAndPred(chain, mp, And.Chain);
      return result;
    }

    /**
     * Creates a list of strings for a list returned by expSep.
     * This list will represent the name of the operator to which
     * the expressions were applied.
     * 
     * @param opName 
     * @param es
     */
    protected void addExpSepName(List&lt;String&gt; opName, List&lt;?&gt; es)
    {
      for (int i = 0; i &lt; es.size(); i += 2) {

        List&lt;?&gt; list = (List&lt;?&gt;) es.get(i);
        if (list.size() == 1) {
          opName.add(ARG_TOK);
        }
        else {
          opName.add(LISTARG_TOK);
        }
        opName.add((String) es.get(i + 1));
      }
    }

    /**
     * Returns the list of expressions returned by expSep.
     * 
     * @param expList 
     * @param es 
     */
    @SuppressWarnings({ "unchecked", "rawtypes" })
    protected void addExpSepExp(List&lt;? extends Object&gt; expList, List&lt;Object&gt; es)
    {
      for (int i = 0; i &lt; es.size(); i += 2) {
      	// exprList is always called as ZExprList; but es can have expr or strings. argh... TODO: fix types?
        expList.addAll((List) es.get(i));
      }
    }
    
    private void resetInfoTables(String section, List&lt;Parent&gt; parents,
                                 int line, int column)
      throws Exception
    {
      
      // use the cyclic manager to get valid parents avoiding cyclic recursion
      CyclicParseManager cyclicMan = CyclicParseManager.getManager(sectInfo_);
      List&lt;Parent&gt; validParents = cyclicMan.getValidParents(section, parents); 
      try
      {
        // to enable proper transaction scopes within the section manager,
        // we MUST adhere to the most natural dependency ordering between
        // any info table involved. 
        // the one we choose was: 
        //  [ProofTable] dependsOn ThmTble dependsOn [JokerTble] dependsOn OpTable
        //
        //
        // ahhh, but there is the possibility of unrecovered errors or syntax errors
        // or indeed scanning errors. In that case, we would need a catch for closing/cancelling
        // the transactions. Instead then, we decided to end the transaction with a empty
        // info table that gets filled along the way during parsing. If such errors occur,
        // then upon removing the ZSect involved, we know that the dependant tables get
        // removed as well becuase they explicitly depend on the ZSect.
        // So order here of resetXXXTable doesn't matter.

        resetOpTable(section, validParents, line, column);
        resetThmTable(section, validParents, line, column);
<add:pattern>
        resetJokerTable(section, validParents, line, column);
</add:pattern>
<add:zeves>
        resetProofTable(section, validParents, line, column);
</add:zeves>
        
      } finally {
        // mark section inactive and report cycles
        List&lt;List&lt;String&gt;&gt; cycles = cyclicMan.visitedParents(section);
        for (List&lt;String&gt; cycle : cycles) {
          // report found cycles, if any, as warnings
          reportParentCycle(cycle, parents);
        }
      }
      
    }
    
    private void reportParentCycle(List&lt;String&gt; cycle, List&lt;Parent&gt; parents)
    {
      Pair&lt;String, String&gt; render = CyclicParseManager.renderParseParentCycle(cycle);
      String cycleParent = render.getFirst();
      String cycleStr = render.getSecond();
      
      boolean found = false;
      for (Parent parent : parents) {
        if (cycleParent.equals(parent.getWord())) {
          // found the parent - report cycle with its location as a warning
          CyclicParentError.reportCyclicParent(sectInfo_, source_, cycleStr, getLocation(parent));
          found = true;
          // do not break, because several parents with the same name could be
          // listed - we need to report the same cycle for all of them
        }
      }
      
      if (!found) {
        // no applicable parent found? 
        // still report - using dummy location
        CyclicParentError.reportCyclicParent(sectInfo_, source_, cycleStr, 
            new LocInfoImpl(getDialect(), source_.getName(), 0, 0));
      }
    }
    
    /**
     * Starts a transaction for the info table. Also calculates parent info tables and returns
     * them. This means that parent info tables become implicit dependencies for this info table.
     * 
     * @param section
     * @param parents
     * @param line
     * @param column
     * @param tableKey
     * @param tableLabel
     * @return
     */
    private &lt;T&gt; List&lt;T&gt; startInfoTableTransaction(String section, List&lt;Parent&gt; parents, 
        int line, int column, Key&lt;T&gt; tableKey, String tableLabel)
    {
      /*
       * Start the transaction for the info table. Parent calculations later will start their own
       * transactions (via {@code SectionInfo.get()}), thus nesting transactions and dependencies.
       * We assume here, that the parent cycles have been resolved.
       */
      sectInfo_.startTransaction(tableKey);
  
      List&lt;T&gt; parentInfoTables = factory_.list();
      if (Section.PRELUDE.getName().equals(section)) {
        assert parents.isEmpty();
      }
      else {
        for (Parent parent : parents) {
          
          // For each parent, resolve their info table and use it to create the current one.
          // Note that if problems occur in parents, the error is reported, but parsing continues.
          try 
          {
            // will have a transaction on the inner/parent table
            T parentInfoTable = sectInfo_.get(new Key&lt;T&gt;(parent.getWord(), tableKey.getType()));
            parentInfoTables.add(parentInfoTable);
          }
          catch (CommandException e) {
            Object [] args = { tableLabel, section, e.getMessage() };
            parser.report_error(ZParseMessage.MSG_OF_PARENT_NOT_FOUND,
                                args, new LocInfoImpl(getDialect(), getLoc(), line, column));
          }
        }
      }
      
      return parentInfoTables;
    }
    
    /**
     * End the transaction for the info table calculation in the Section Manager. The transaction is
     * ended immediately after calculation of the info table. It is then populated with contents
     * during the actual parsing. This means that the info table can be empty when first put in the
     * section manager, and filled with content later. Such approach is necessary to ensure correct
     * transactions in the section manager. Otherwise, parsing of different info tables can overlap,
     * and transactions would fail.
     * &lt;p&gt;
     * To accommodate for the short-circuiting of the info table transactions, we add an explicit
     * dependency on the ZSect for the info table. This is to signal that the ZSect may contain
     * contents for the info table, e.g. operator definitions.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The same approach (end transaction after initial resolution of an object) is used for
     * LatexMarkupFunction computation. This is necessary because of a complicated parsing protocol,
     * and is a compromise to achieve transactional structure to some level. Otherwise the
     * transactions would overlap. To achieve better confidence in the dependencies, some
     * dependencies are added explicitly (e.g. that info table depends on its ZSect).
     * &lt;/p&gt;
     * 
     * @param section
     * @param tableKey
     * @param infoTable
     */
    private &lt;T&gt; void endInfoTableTransaction(String section, Key&lt;T&gt; tableKey, T infoTable)
    {
      sectInfo_.endTransaction(tableKey, infoTable,
          Collections.singleton(new Key&lt;ZSect&gt;(section, ZSect.class)));
    }
    
    /**
     * Marks the given key of the info table computation as a dependency for the parsed section. 
     * This is used to implicitly include the dependency on an info table, e.g. if it is used to
     * interpret/generate the subsequent contents of the Z section. For example, OpTable is used
     * in the operator scanner, so we mark this dependency. This should be done for all info
     * tables that have bi-directional dependency with the ZSect, e.g. OpTable, JokerTable. The
     * ThmTable, though, is not used by the parser, so it should not be a dependency for the ZSect.
     * 
     * @param section 
     * @param tableKey
     * @return 
     */
    private &lt;T&gt; T markInfoTableDependency(String section, Key&lt;T&gt; tableKey) {
      try
      {
        // mark the implicit dependency via SectionInfo.get(), 
        // because we are inside a ZSect transaction
        return sectInfo_.get(tableKey);
      }
      catch (CommandException e)
      {
        // should never happen - we have just put the table into the manager
        final String message = "Could not retrieve " + tableKey.getType().getSimpleName() 
            + " for " + section + " that has just been calculated?! (for dialect " 
            + getDialect().toString() + " in Parser).";
        throw new CztException(message, e);
      }
    }
    
    private void resetOpTable(String section, List&lt;Parent&gt; parents,
                              int line, int column)
    {
      Key&lt;OpTable&gt; optKey = new Key&lt;OpTable&gt;(section, OpTable.class);
      
      // start the transaction and collect parent tables
      List&lt;OpTable&gt; parentOpTables = startInfoTableTransaction(
          section, parents, line, column, optKey, "Operator table");
      
      OpTable opTable = new OpTable(getDialect(), section);
      try {
        opTable.addParents(parentOpTables);
      }
      catch (InfoTable.InfoTableException e) {
        parser.report_error(ZParseMessage.MSG_CANNOT_MERGE_OPTABLES, 
            new Object[]{e.getMessage()},
            getLocation(line, column));
      }
  
      // end the transaction with the non-null value
      endInfoTableTransaction(section, optKey, opTable);
      
      opTable_ = opTable;
      
      // mark the OpTable dependency for the ZSect, because it is used in the operator scanner 
      markInfoTableDependency(section, optKey);
      opScanner_.setOperatorTable(opTable_);
    }
    
    private void resetThmTable(String section, List&lt;Parent&gt; parents,
                              int line, int column)
    {
      Key&lt;ThmTable&gt; thmKey = new Key&lt;ThmTable&gt;(section, ThmTable.class);
      
      // start the transaction and collect parent tables
      List&lt;ThmTable&gt; parentThmTables = startInfoTableTransaction(
          section, parents, line, column, thmKey, "Named conjectures table");
      
      ThmTable thmTable = new ThmTable(getDialect(), section);
      try {
        thmTable.addParents(parentThmTables);
      }
      catch (InfoTable.InfoTableException e) {
        parser.report_error(ZParseMessage.MSG_CANNOT_MERGE_THMTABLES, 
            new Object[]{e.getMessage()},
            getLocation(line, column));
      }
  
      // end the transaction with the non-null value
      endInfoTableTransaction(section, thmKey, thmTable);
      
      thmTable_ = thmTable;
    }

<add:zeves>
    private void addToProofTable(ProofScript script, int nleft, int nright)
    {
       try
       {
         proofTable_.add(script);
       }
       catch (ProofTable.ProofTableException e)
       {
         //final Symbol token = new Symbol(Sym.ZED, nleft, nright);
           parser.report_error(ZEvesParseMessage.MSG_CANNOT_ADD_PROOFSCRIPT,
                               new Object[] { e.getMessage() },
                               getLocation(nleft, nright));
       }
    }
    
    private void resetProofTable(String section, List&lt;Parent&gt; parents,
                              int line, int column)
    {
      Key&lt;ProofTable&gt; proofKey = new Key&lt;ProofTable&gt;(section, ProofTable.class);
      
      // start the transaction and collect parent tables
      List&lt;ProofTable&gt; parentProofTables = startInfoTableTransaction(
          section, parents, line, column, proofKey, "Named proof scripts table");
      
      ProofTable proofTable = new ProofTable(getDialect(), section);
      try {
        proofTable.addParents(parentProofTables);
      }
      catch (InfoTable.InfoTableException e) {
        parser.report_error(ZEvesParseMessage.MSG_CANNOT_MERGE_PROOFTABLES, 
            new Object[]{e.getMessage()},
            getLocation(line, column));
      }
  
      // end the transaction with the non-null value
      endInfoTableTransaction(section, proofKey, proofTable);
      
      proofTable_ = proofTable;
    }
</add:zeves>

<add:pattern>
    private void resetJokerTable(String section, List&lt;Parent&gt; parents,
                              int line, int column)
    {
      Key&lt;JokerTable&gt; jokerKey = new Key&lt;JokerTable&gt;(section, JokerTable.class);
      
      // start the transaction and collect parent tables
      List&lt;JokerTable&gt; parentJokerTables = startInfoTableTransaction(
          section, parents, line, column, jokerKey, "Joker table");
      
      JokerTable jokerTable = new JokerTable(section);
      try {
        jokerTable.addParents(parentJokerTables);
      }
      catch (JokerTable.JokerException e) {
        parser.report_error(ZpattParseMessage.MSG_CANNOT_MERGE_JOKERTABLES, 
            new Object[]{e.getMessage()},
            getLocation(line, column));
      }
  
      // end the transaction with the non-null value
      endInfoTableTransaction(section, jokerKey, jokerTable);
      
      jokerTable_ = jokerTable;
      
      // mark the JokerTable dependency for the ZSect, because it is used in the joker scanner 
      markInfoTableDependency(section, jokerKey);
      jokerScanner_.setJokerTable(jokerTable_);
    }
</add:pattern>

    /**
     * Starts the Z section computation transaction in the Section Manager. The transaction allows to
     * capture the dependencies of the ZSect - e.g. that it depends on its OpTable, and transitively
     * on parent OpTables and ZSects.
     * &lt;p&gt;
     * The ZSect transaction must be started manually, because the parsing is done for the whole
     * specification. So the section manager can start a transaction on the Spec, however inside the
     * specification, there can be multiple Z sections. Thus transactions for each ZSect are started
     * and ended manually, during the parse process.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The start of transaction handles issues with redeclared sections as well. See
     * {@link #endZSectTransaction(ZSect, OpTable)} for more details about the ZSect transaction and
     * explicit dependencies.
     * &lt;/p&gt;
     * &lt;p&gt;
     * When the manual transaction starts, we need to ensure that any exceptions until the end of
     * transaction are caught and handled. If an exception is encountered, the ZSect transaction must
     * be cancelled. This is done in {@link Parser#parse()} method, which is the single entry point to
     * parsing.
     * &lt;/p&gt;
     * 
     * @param sectName
     * @see #endZSectTransaction(ZSect, OpTable)
     */
    private void startZSectTransaction(String sectName)
    {
      Key&lt;ZSect&gt; zsKey = new Key&lt;ZSect&gt;(sectName, ZSect.class);
       
      /*
       * There may be cases when the Z section is calculated already at the start of transaction.
       * Sometimes it can be because of the pollution of section manager (SM) from previous runs -
       * this should have been removed before running the parsing again. Polluted section managers
       * should generally be caught by other transactions, so it is not that important to be strict
       * about existing objects in SM cache here.
       *
       * However, there are cases when we can encounter this case in a single specification
       * (RedeclaredSection). The parser is required to parse such specification without errors, and
       * leave the check for the typechecker. Thus there is parsing of two identical section names
       * (and therefore keys). For this case - when we encounter the second (redeclared) section, we
       * remove the ZSect from SM if it is already cached, and start a new transaction for its
       * calculation. We will have a case when the second ZSect "overwrites" the first ZSect via
       * remove-endTransaction.
       * 
       * If we do not do such "overwriting", we would have needed to make the RedeclaredSection a
       * parsing error and stop parsing altogether (e.g. via Exception). Current solution allows us to
       * finish parsing and postpone the check to typechecker.
       */
      if (sectInfo_.isCached(zsKey))
      {
        sectInfo_.removeKey(zsKey);
      }
       
      /*
       * Force start the transaction - we cannot have it started already. The parsing could not have
       * started with a ZSect transaction, because parsing encompasses the whole Spec (even if it has
       * a single ZSect). So the outer transaction must be that of a Spec, and we should not have an
       * existing transaction on ZSect. Therefore do a strict startTransaction(), instead of
       * ensureTransaction().
       * 
       * Note if parsing is started using SectionInfo#get(ZSect), the original ZSect transaction is
       * postponed in favor of the Spec transaction (see ParseUtils for details).
       */
       
      sectInfo_.startTransaction(zsKey);
    }

    private ZSect createZSect(String name, List&lt;Parent&gt; parents)
    {
      parserState_.setCurrentSectName(name);
      ZParaList paraList = factory_.createZParaList();
      ZSect result = factory_.createZSect(name, parents, paraList);
      return result;
    }
    
    /**
     * Ends the transaction for Z section calculation in the Section Manager. The computed ZSect
     * receives final adjustments - its operators are reordered according to their precedence, and the
     * LatexMarkupFunction is added as a LatexMarkupPara to the section. The Z section transaction is
     * ended, and the section is added to the section manager.
     * 
     * @param zSect
     *          The Z section to end transaction
     * @param opTable 
     *          The operator table to determine operator precedences
     * @return The updated Z section (may be the same object)
     * @see #startZSectTransaction(String)
     */
    private ZSect endZSectTransaction(ZSect zSect, OpTable opTable)
    {
      final boolean parseError = parser.hasErrors();
      final String sectName = zSect.getName();
  
      // reorder the Z section in correct operator precedence
      final PrecedenceHandlingVisitor visitor = new PrecedenceHandlingVisitor(opTable);
      final ZSect sect = (ZSect) zSect.accept(visitor);
<add:zeves>
      if (sectName.equals("zeves_toolkit"))
      {
        // adds applies$to definitions to top of sections Z para list
        parserState_.updateZSectWithAddedPara(sect);
      }
</add:zeves>
      // Add the LatexMarkupFunction as a LatexMarkupPara to the ZSect.
      // Note, that this will add implicit dependency on LMF, if it is available
      addLatexMarkupPara(sect, sectName);
<add:circus>
      
      // Add implicit process paragraphs to the ZSect term.
      ZUtils.assertZParaList(sect.getParaList()).addAll(parserState_.getImplicitlyDeclProcPara());
//      System.out.println("Printing " + sect.getPara().size() + " paragraphs from " + 
//         sect.getName() + " for " + getDialect().toString() + " in Parser.");
//      for(Para para : sect.getPara()) {
//        System.out.println("\t" + para.toString());
//      }
//      System.out.println();
</add:circus>
      
      Key&lt;ZSect&gt; zsKey = new Key&lt;ZSect&gt;(sectName, ZSect.class);
  
      if (!parseError) {
<add:zeves>
        
        // check proof-thm table consistency
        checkProofTables();
        
</add:zeves>
        /*
         * End the ZSect transaction. The parser may carry explicit dependencies to add for the ZSect.
         * This allows indicating some dependencies that could have been missed since ZSect
         * transaction is started later in the parsing, e.g. that ZSect depends on its Source, or has
         * a bi-directional dependency with its Spec.
         * 
         * ZSect also depends on its LatexMarkupFunction, OpTable and JokerTable. Actually, dependencies 
         * with these objects are bi-directional (they also depend on the ZSect). These dependencies are
         * implicitly captured (see #resetOpTable(), addLatexMarkupPara(), etc.), so there is no need to
         * add them explicitly.
         */
        sectInfo_.endTransaction(zsKey, sect, parser.getExplicitDeps());
      }
      else {
        // in case of parsing errors, cancel the transaction
        sectInfo_.cancelTransaction(zsKey);
      }
      return sect;
    }

    /**
     * Adds the computed LatexMarkupFunction for the Z section, if available, as a LatexMarkupPara to
     * the section.
     * 
     * @param sect
     * @param sectName
     */
    private void addLatexMarkupPara(ZSect sect, String sectName)
    {
      Key&lt;LatexMarkupFunction&gt; key = new Key&lt;LatexMarkupFunction&gt;(sectName, LatexMarkupFunction.class);
      if (sectInfo_.isCached(key)) {
        try {
  
          /*
           * Note that this SectionInfo#get(LMF) call will add dependency on the LMF to the ZSect.
           * This is good, because it indicates the dependency implicitly, which may have been missed
           * since LatexMarkupParser executes before Parsing (and ZSect transaction) even starts.
           */
          LatexMarkupFunction latexMarkupFunction = sectInfo_.get(key);
  
          /*
           * During lexing, the LatexMarkupFunction for this ZSect may have been calculated, which
           * contains LaTeX markup directives within the section. These directives are added to the
           * front of the Z section as a LatexMarkupPara. If no directives exist, a LatexMarkupPara
           * with empty directives list is added.
           */
          LatexMarkupPara markupPara = latexMarkupFunction.toAst(factory_);
          ZUtils.assertZParaList(sect.getParaList()).add(0, markupPara);
  
        }
        catch (CommandException exception) {
          String message = "Error retrieving LatexMarkupFunction for section " + sectName + " and dialect " + exception.getDialect().toString() + 
          	" in Parser for " + getDialect().toString();
          CztLogger.getLogger(<class/>.class).warning(message);
        }
      }
    }
<add:zeves>

    private void checkProofTables()
    {
        proofTable_.checkAgainst(thmTable_); // just warning in case of inconsistency (e.g., more proofs than conj para).
        //proofTable_.verifyConsistency(thmTable_); -- for error
    } 
</add:zeves>

    protected String getLoc()
    {
      return parserState_.getLoc();
    }

    private void addLocAnn(Term term, LocInfo locInfo)
    {
      parserState_.addLocAnn(term, locInfo);
    }

    //private void addZStateRefInfo(Term term, Ann ozsi, Name n)
    //{
    //   if (ozsi != null)
    //   {
    //      if (ozsi instanceof ZRefinesAnn)
    //        ((ZRefinesAnn)ozsi).setConcreteName(n);
    //      term.getAnns().add(ozsi);
    //   }
    //}

    private int computeLength(LocInfo start, LocInfo end)
    {
      final int startStart = start.getStart();
      final int endStart = end.getStart();
      final int endLength = end.getLength();
      if (startStart >= 0 &amp;&amp;
          endStart >= 0 &amp;&amp;
          endLength >= 0) {
        return endStart - startStart + endLength;
      }
      return -1;
    }

    private LocInfo getLocation(LocInfo start, LocInfo end)
    {
      if (start != null &amp;&amp; end != null) {
        return new LocInfoImpl(getDialect(),
        											 start.getSource(),
                               start.getLine(),
                               start.getColumn(),
                               start.getStart(),
                               computeLength(start, end));
      }
      return null;
    }

    private LocInfo getLocation(Term start, LocInfo end)
    {
      return getLocation(getLocation(start), end);
    }

    private LocInfo getLocation(LocInfo start, Term end)
    {
      return getLocation(start, getLocation(end));
    }

    private LocInfo getLocation(Term start, Term end)
    {
      return getLocation(getLocation(start), getLocation(end));
    }

    private LocInfo getLocation(int line, int column,
                                LocInfo start, LocInfo end)
    {
      if (start != null &amp;&amp; end != null) {
        return new LocInfoImpl(getDialect(),
        											 start.getSource(),
                               line,
                               column,
                               start.getStart(),
                               computeLength(start, end));
      }
      return null;
    }

    private LocInfo getLocation(int line, int column,
                                Term start, LocInfo end)
    {
      return getLocation(line, column, getLocation(start), end);
    }

    <add:zpatt>
    private LocInfo getLocation(int line, int column,
                                LocInfo start, Term end)
    {
      return getLocation(line, column, start, getLocation(end));
    }
    </add:zpatt>
    <add:ozpatt>
    private LocInfo getLocation(int line, int column,
                                LocInfo start, Term end)
    {
      return getLocation(line, column, start, getLocation(end));
    }
    </add:ozpatt>

    private LocInfo getLocation(int line, int column,
                                Term start, Term end)
    {
      return getLocation(line, column, getLocation(start), getLocation(end));
    }

    private LocInfo getLocation(List&lt;LocString&gt; list)
    {
      if (list != null &amp;&amp; list.size() > 0) {
        if (list.size() == 1) return list.get(0).getLocation();
        return getLocation(list.get(0).getLocation(),
                           list.get(list.size() - 1).getLocation());
      }
      return null;
    }

<add:circus>
    /**
     * Creates an empty (basic) channel set expression
     */
    protected Expr createEmptyChannelSetExpr(LocInfo loc)
    {
      Expr result = factory_.createBasicChannelSetExpr(factory_.createCircusCommunicationList());
      addLocAnn(result, loc);
      return result;
    }

    /**
     * Creates an empty channel set (i.e. ChannelSet with an empty basic channel set expression).
     */
    protected ChannelSet createEmptyChannelSet(LocInfo loc)
    {
      ChannelSet result = factory_.createCircusChannelSet(factory_.createSetExpr(factory_.createZExprList()));
      addLocAnn(result, loc);
      return result;
    }

    /**
     * Creates an empty name set (i.e. NameSet with an empty set expression).
     */
    protected NameSet createEmptyNameSet(LocInfo loc) {
      NameSet result = factory_.createCircusNameSet(factory_.createSetExpr(factory_.createZExprList()));
      addLocAnn(result, loc);
      return result;
    }

    /**
     * &lt;p&gt;
     * This method characterises parameterised commands and actions according to the
     * expected (specific and disjoint) structure both have, yet they share the same
     * AST class due to their similar nature and to minimize AST numbers. This choice
     * is similar to AxPara in Z, which represents various Z boxes.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The protocol is as follows: parameterised commands MUST have a CircusCommand
     * as its inner term, and VarDecl and QualifiedDecl are allowed; whereas parameterised
     * actions have a CircusAction as its inner term, and only VarDecl is allowed.
     * &lt;/p&gt;
     */
    protected ParamAction createParamAction(CircusAction pa, DeclList cp)
    {
      // if this is not a qualified command, then check for non VarDecl elements
      if (cp instanceof ZDeclList)
      {
        int vDecls = 0;
        int qDecls = 0;
        int otherDecls = 0;
        for(Decl d : ZUtils.assertZDeclList(cp))
        {
          if (d instanceof VarDecl)
            vDecls++;
          else if (d instanceof QualifiedDecl)
            qDecls++;
          else
            otherDecls++;
        }
        // otherDecls = 0 AND (vDecls = 0 IMPlIES qDecls = 0 AND otherDecls = 0) AND
        // (qDecls = 0 IMPlIES vDecls = 0 AND otherDecls = 0) AND (vDecls+qDecls+otherDecls = cp.size())
        boolean declOk = ((otherDecls == 0 &amp;&amp; (vDecls == 0 || qDecls == 0)) &amp;&amp;
          ZUtils.assertZDeclList(cp).size() == (vDecls+qDecls+otherDecls));
        if (!declOk)
        {
          parser.report_error(CircusParseMessage.MSG_ERRORDECL_IN_PARAMACTION, new Object[0], getLocation(cp));
        }
      }
      ParamAction result = factory_.createParamAction(pa, cp);
      return result;
    }

    /**
     * Returns whether the given expression is an empty set as a reference to
     * &lt;code&gt;ZString.EMPTYSET&lt;/code&gt;.
     */
    protected boolean isEmptySetRefExpr(Expr a) {
      return ZUtils.isEmptySetRefExpr(a);
    }

    /**
     * &lt;p&gt;
     * Creates a &lt;code&gt;BasicChannelSetExpr&lt;/code&gt; based on the given list of expressions.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The code ensures that all expressions within the expression list
     * must be &lt;code&gt;RefExpr&lt;/code&gt;, as &lt;code&gt;BasicChannelSetExpr&lt;/code&gt;
     * is just a set extension with special brackets.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If something different from &lt;code&gt;RefExpr&lt;/code&gt; is found within &lt;code&gt;zrl&lt;/code&gt;,
     * the a parsing error is thrown and the result is just an empty &lt;code&gt;BasicChannelSetExpr&lt;/code&gt;.
     * &lt;/p&gt;
     */
    protected Expr createBasicChannelSetExpr(LocInfo loc, List&lt;Communication&gt; cl) {
//      //assert zrl != null &amp;&amp; !zrl.isEmpty();
//      int errorIdx = 0;
//      Iterator&lt;Expr&gt; it = zrl.iterator();
//      while(it.hasNext()) {
//        // If any item at a particular index is not a RefExpr,
//        // return the error index and stop the loop.
//        if (!(it.next() instanceof RefExpr)) {
//          break;
//        }
//        else
//          errorIdx++;
//      }
//
//      BasicChannelSetExpr result = factory_.createBasicChannelSetExpr(factory_.createZExprList());
//      if (loc != null) { addLocAnn(result, loc); }
//
//      int size = zrl.size();
//
//      if (errorIdx >= size) {
//        result.getZExprList().addAll(zrl);
//      } else {
//        boolean isEmpty = zrl.isEmpty();
//        assert errorIdx &gt;= 0 &amp;&amp; (errorIdx &lt; size || isEmpty);
//        CztLogger.getLogger(<class/>.class).warning(java.text.MessageFormat.format(
//            CircusParseMessage.MSG_REFEXPR_EXPECPTED_IN_BASICCHANNELSETEXPR_WARNING.getMessage(),
//            new Object[] { errorIdx, size-1, isEmpty ? "empty" : zrl.get(errorIdx),
//              isEmpty ? "null" : zrl.get(errorIdx).getClass().getSimpleName(), loc }) 
//							+ " for dialect " + getDialect().toString() + " in Parser.");
//      }
      BasicChannelSetExpr result = factory_.createBasicChannelSetExpr(factory_.createCircusCommunicationList(cl));
      if (loc != null) { addLocAnn(result, loc); }
      return result;
    }

    /**
     * &lt;p&gt;
     * Validates the given Z expression as a valid channel set expression.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The code returns the given expression but it ensures that &lt;code&gt;e&lt;/code&gt;
     * is neither a set extension, nor a set comprehension expression.
     * If &lt;code&gt;e&lt;/code&gt; is one of those two, then a parsing error is thrown.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Moreover, it automatically transforms a reference to the empty set expression
     * (i.e. &lt;code&gt;\emptyset&lt;/code&gt;) to become an empty &lt;code&gt;BasicChannelSetExpr&lt;/code&gt;.
     * Thus, something like &lt;code&gt;validateChannelSetExpr(RefExpr("\emptyset"))&lt;/code&gt;,
     * returns &lt;code&gt;BasicChannelSetExpr(ZExprList())&lt;/code&gt;.
     * &lt;/p&gt;
     */
    protected Expr validateChannelSetExpr(Expr e) {
      Expr result = e;
      
      // For reference empty sets transform them into basic set extension.
      if (isEmptySetRefExpr(result)) {
        result = createBasicChannelSetExpr(getLocation(e), factory_.&lt;Communication&gt;list());
      }
      // For set extensions (possibly empty) or comprehension, report an error.
      else if (result instanceof SetExpr || result instanceof SetCompExpr){
        parser.report_error(CircusParseMessage.MSG_SETDISPLAY_NOTALLOWED_FORCHANNELSET,
                            new Object[0], getLocation(result));
      }
      return result;
    }

    /**
     * Checks whether the given lists have the same size. It returns a parser error if the
     * lists are of a different size. This method is called either through channel renaming or
     * an assignment command.
     */
    protected boolean checkListSizesAreEqual(LocInfo loc,
        List&lt;?&gt; l, List&lt;?&gt; r) {
        boolean result = l.size() == r.size();
        if (!result) {
          parser.report_error(CircusParseMessage.MSG_UNBALANCED_LISTS,
              new Object[] { l.size(), l.getClass().getTypeParameters()[0].getName(),
                  r.size(), r.getClass().getTypeParameters()[0].getName() }, loc);
        }
        return result;
    }

    /**
     * Creates an &lt;code&gt;AssignmentPairs&lt;/code&gt; class containing the LHS and RHS
     * elements for each list, which must have the same size. If the lists are not of the same
     * size, the returned list is empty and a parsing error is generated.
     */
    protected AssignmentPairs createAssignmentPairs(LocInfo loc,
        ZNameList rnl, ZExprList el) {
        AssignmentPairs result = factory_.createAssignmentPairs();
        if (checkListSizesAreEqual(loc, rnl, el)) {
          result.setLHS(rnl);
          result.setRHS(el);
        }
        if (rnl.isEmpty()) {
          parser.report_error(CircusParseMessage.MSG_EMPTY_ASSIGNMENT,
              new Object[0], loc);
        }
        addLocAnn(result, loc);
        return result;
    }

    /**
     * Creates an &lt;code&gt;AssignmentPairs&lt;/code&gt; class containing the LHS and RHS
     * elements for each list, which must have the same size and must only contain &lt;code&gt;RefExpr&lt;/code&gt;.
     * If the lists are not of the same size, the returned list is empty and a parsing error
     * is generated.
     */
    protected AssignmentPairs createChannelRenamingPairs(LocInfo loc,
        ZNameList rnl, ZExprList el) {
        AssignmentPairs result = createAssignmentPairs(loc, rnl, el);
        int i = 0;
        for(Expr e : el) {
          if (!(e instanceof RefExpr)) {
            parser.report_error(CircusParseMessage.MSG_INVALID_CHANNEL_RENAMING_EXPR,
              new Object[] { rnl.get(i), i+1, e.getClass().getSimpleName() }, loc);
          }
          i++;
        }
        addLocAnn(result, loc);
        return result;
    }

    /**
     * Creates a unique name for implicitly declared actions located
     * at the given term.
     */
    protected Decorword createImplicitlyDeclActUniqueName(Term term)
    {
      LocInfo loc = getLocation(term);
      String name = parserState_.createImplicitlyDeclActUniqueName(loc);
      return new Decorword(name, loc);
    }

    /**
     * Creates a unique name for implicitly declared processes located
     * at the given term.
     */
    protected Decorword createImplicitlyDeclProcUniqueName(Term term)
    {
      LocInfo loc = getLocation(term);
      String name = parserState_.createImplicitlyDeclProcUniqueName(loc);
      return new Decorword(name, loc);
    }

    /**
     * Creates an implicit action paragraph with location annotation for the given name and action.
     */
    protected ActionPara createImplicitActionPara(Decorword an, CircusAction ca) {
        ActionPara ap = factory_.createActionPara(createCircusName(an),  ca);
        addLocAnn(ap, getLocation(an.getLocation(), ca));
        return ap;
    }

    /**
     * Creates an implicit process paragraph with location annotation for the given name and action.
     */
    protected ProcessPara createImplicitProcessPara(Decorword pn, CircusProcess pp) {
        /* On-the-fly process have no generic formals/actuals*/
        ProcessPara pa = factory_.createProcessPara(createCircusName(pn), factory_.createZNameList(), pp);
        addLocAnn(pa, getLocation(pn.getLocation(), pp));
        return pa;
    }

    protected Para createStatePara(Name n, Expr e, LocInfo loc, boolean implicitlyDeclared)
    {
       // check if the state is duplicated and raise the error
       checkForDuplicatedState((implicitlyDeclared ? "implicitly declared" : "horizontally declared"), loc);

       // create the state para.
       Para result = parserState_.createStatePara(n, e, loc, implicitlyDeclared);
       checkCircusStateAnnParaIsSchema(result);

       // set the result to the parser state
       parserState_.setStatePara(result);

       return result;
    }

    protected void setMainAction(CircusAction mainAction, LocInfo loc)
    {
       checkForDuplicatedMainAction(loc);
       parserState_.setMainAction(mainAction);
    }

    /**
     * Checks whether the given predicate is a schema.
     * If the paragraph is not a schema, an error is reported.
     */
    /* NOTE: As we now managed to accept the expression production for state
     *       schemas without trouble then this is no longer a problem.
     *       The extra check is harmless though.
     */
    protected boolean checkCircusStateAnnParaIsSchema(Para p) {
      // call the CircusUtils version of isSchema to include Schema Actions
      boolean result = parserState_.isValidStatePara(p);
      if (!result) {
         parser.report_error(CircusParseMessage.MSG_INVALID_BASICPROCESS_STATE_PARA,
               new Object[0], getLocation(p));
      }
      return result;
    }

    /**
     * Checks &lt;code&gt;BasicProcess&lt;/code&gt; paragraphs for repeated state annotations.
     * That is, if the given paragraph corresponds to a &lt;code&gt;BasicProcess&lt;/code&gt;,
     * and the user has declared more than one state schemas, an error is reported.
     * ? TODO: CHECK if deprecated now that we have a robust parserState_ for basic process' scope.
     */
    protected void checkStateDeclNotRepeated(ProcessPara pp) {
      if (pp.getCircusProcess() instanceof BasicProcess) {
        BasicProcess bp = (BasicProcess)pp.getCircusProcess();

        // Collect all paragraphs annotated with CircusStateAnn.
        ZParaList stateParaList = getCircusStateAnnPara(bp);

        // If more than one state has been declared, then raise the error.
        // The message will contain the process name and the first violating
        // state, which is the second one (of the possibly many) declared.
        if (stateParaList.size() > 1) {
          parser.report_error(CircusParseMessage.MSG_DUPLICATE_PROC_STATE_DECL,
              new Object[] { pp.getName(), CircusUtils.getSchemaName(stateParaList.get(0)),
                  stateParaList.size(), CircusUtils.getSchemaName(stateParaList.get(1)), getLocation(pp, stateParaList.get(1)) },
                  getLocation(pp, stateParaList.get(1)));
        }
        // Otherwise, it is fine, either we have one or no state declaration.
      }
    }

    protected boolean checkProcessParaScope(LocInfo loc) {
       boolean result = parserState_.getProcessPara() != null;
       if (!result) {
          parser.report_error(CircusParseMessage.MSG_INVALID_MULTIENV_BASIC_PROCESS_CIRCEND,
                new Object[] {loc} , loc);
       }
       return result;
    }

    protected boolean checkForDuplicatedState(String msg, LocInfo loc) {
      boolean result = parserState_.getStatePara() == null;
      CztLogger.getLogger(<class/>.class).fine("DUPLICATED STATE PARA (" +
            msg + ")?: " + !result + " @ " + loc.toString() + " for " + getDialect().toString() + " in Parser.");
      if (!result) {
         parser.report_error(CircusParseMessage.MSG_DUPLICATED_BASIC_PROCESS_STATE,
               new Object[] { msg, loc} , loc);
      }
      return result;
    }

    protected boolean checkForDuplicatedMainAction(LocInfo loc) {
      boolean result = parserState_.getMainAction() == null;
      CztLogger.getLogger(<class/>.class).fine("DUPLICATED MAIN ACTION? :" + 
      	!result + " @ " + loc.toString() + " for " + getDialect().toString() + " in Parser.");
      if (!result) {
         parser.report_error(CircusParseMessage.MSG_DUPLICATED_BASIC_PROCESS_MAINACTION, new Object[0], loc);
      }
      return result;
    }

    /**
     * Adds a &lt;code&gt;ParenAnn&lt;/code&gt; annotation to the given term, where the given locations
     * are for the left and right parenthesis respectively.
     */
    protected void addParenthesisAnn(LocInfo lp, Term t, LocInfo rp) {
       ParenAnn parenAnn = factory_.createParenAnn();
       addLocAnn(parenAnn, getLocation(lp, rp));
       t.getAnns().add(parenAnn);
    }

    /**
     * Flattens all paragraphs from the given list of &lt;code&gt;ZParaList&lt;/code&gt;
     * and then keep those that are annotated with &lt;code&gt;CircusStateAnn&lt;/code&gt;.
     */
    protected ZParaList getCircusStateAnnPara(ZParaList... lists) {
        // Create a list with all paragraphs from the lists.
        ZParaList result = factory_.createZParaList();
        for(ZParaList zpl : lists) {
          result.addAll(zpl);
        }

        // Search the complete list and remove all non-state para.
        for(Iterator&lt;Para&gt; it = result.iterator(); it.hasNext(); ) {
          Para p = it.next();
          // If we have an annotation, check it is valid.
          //if (p.getAnn(CircusStateAnn.class) != null) {
          //  checkCircusStateAnnParaIsSchema(p);
          //}
          // Otherwise just remove them
          //else
          if (p.getAnn(CircusStateAnn.class) == null) {
            it.remove();
          }
        }
        return result;
    }

    /**
     * Retrieves all paragraphs within the given &lt;code&gt;BasicProcess&lt;/code&gt;
     * that are annotated with &lt;code&gt;CircusStateAnn&lt;/code&gt;. This includes
     * both local declarations and on-the-fly actions.
     */
    protected ZParaList getCircusStateAnnPara(BasicProcess bp) {
      return getCircusStateAnnPara(factory_.createZParaList(bp.getLocalPara()),
          factory_.createZParaList(bp.getOnTheFlyPara()));
    }

    protected Model validateModel(Decorword dw) {
      Model result = CircusUtils.DEFAULT_REFINEMENT_MODEL;
      if (dw.toString().toUpperCase().equals(Model.Tr.toString().toUpperCase()))
        result = Model.Tr;
      else if (dw.toString().toUpperCase().equals(Model.SFl.toString().toUpperCase()))
        result = Model.SFl;
      else if (dw.toString().toUpperCase().equals(Model.FlDv.toString().toUpperCase()))
        result = Model.FlDv;
      else {
        parser.report_error(CircusParseMessage.MSG_UNKNOWN_REFINEMENT_MODEL,
              new Object[] { dw.getWord() }, dw.getLocation());
      }
      return result;
    }

    private void warnProcessScopeMismatch(String msg, String from, LocInfo l) {
        final String msg2 = java.text.MessageFormat.format(
                CircusParseMessage.MSG_INVALID_BASIC_PROCESS_SCOPE_WARNING.getMessage(),
                new Object[] { msg, from, l.toString() }) + " for " + getDialect().toString() + " in Parser.";
        CztLogger.getLogger(<class/>.class).warning(msg2);
        parserState_.addProcessScopeWarning(msg2, l);
    }

    private void warnProcessScopeMissing(String msg, String from, LocInfo l) {
        from = "(" + from + ")" + " outside basic process scope";
        final String msg2 = java.text.MessageFormat.format(
                CircusParseMessage.MSG_OUTSITE_BASIC_PROCESS_SCOPE_WARNING.getMessage() +
                CircusParseMessage.MSG_OUTSITE_BASIC_PROCESS_SCOPE_WARNING.getExplanation(),
                new Object[] { msg, from, l }) + " for " + getDialect().toString() + " in Parser.";
        CztLogger.getLogger(<class/>.class).warning(msg2);
        parserState_.addProcessScopeWarning(msg2, l);
    }

    /**
     * &lt;p&gt;
     * Checks whether there is a basic process in current scope, adding a
     * parsing warning with the given extra msg and location information in
     * case there is no process into scope.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This warning ought to be taken seriously, since type checking will
     * simply assume the inner process paragraph (declared outside a process)
     * is included into the closest enclosing basic process.
     * &lt;/p&gt;
     * The warning are collected within the parser state and are raised
     * when the parsing task terminates at specification production.
     * &lt;p&gt;
     */
    protected boolean addBasicProcessScopePostCheckFor(String msg, LocInfo l) {
        boolean result = parserState_.isWithinMultipleEnvBasicProcessScope();
        CztLogger.getLogger(<class/>.class).fine("ADDING PROCESS SCOPE POST CHECK FOR " +
            msg + "?: " + !result + " @ " + l.toString() + " for " + getDialect().toString() + " in Parser.");
        if (!result) {
            final String msg2 = "Cannot declare " + msg;
            parserState_.addProcessScopeWarning(msg2, l);
        }
        return result;
    }

    /** Adds a warning for the case where circend is missing */
    protected void addMultipleEnvBasicProcessCIRCENDWarning(Name procName, LocInfo loc) {
        CztLogger.getLogger(<class/>.class).fine(
            "ADDING PROCESS SCOPE POST CHECK FOR MULTIPLE ENV CIRCEND? : true @ "
            + loc.toString() + " for " + getDialect().toString() + " in Parser.");
        parserState_.addProcessEndWarning(procName, loc);
    }

    /** Removes warning for the case where circend is missing if procName match */
    protected void removeMultipleEnvBasicProcessCIRCENDWarning(LocInfo circEndLoc) {
        Pair&lt;Name, LocInfo&gt; pew = parserState_.getProcessEndWarning();

        // we are at multiple environment situation and found a CIRCEND
        if (pew != null) {
            assert checkProcessParaScope(pew.getSecond()) :
                "Cannot remove CIRCEND warning outside a process para scope";
            if (parserState_.getProcessPara().getName().equals(pew.getFirst())) {
                CztLogger.getLogger(<class/>.class).fine(
                    "FOUND MATCHING CIRCEND FOR " + pew.getFirst() + " @ CIRCEND-LOC " +
                    circEndLoc.toString() + " for " + getDialect().toString() + " in Parser.");
                parserState_.clearSectBasicProcessEndWarning();
            } else {
                CztLogger.getLogger(<class/>.class).warning(java.text.MessageFormat.format(
                    CircusParseMessage.MSG_PROCESS_PARA_NAME_MISMATCH_FOR_CIRCEND_WARNIING.getMessage() +
                    CircusParseMessage.MSG_PROCESS_PARA_NAME_MISMATCH_FOR_CIRCEND_WARNIING.getExplanation(),
                    new Object[] { pew.getFirst(), parserState_.getProcessPara().getName(),
                      pew.getSecond(), circEndLoc }) + " for " + getDialect().toString() + " in Parser.");
            }
        }
    }

    protected void raisePendingBasicProcessWarnings(String from) {
        raisePendingBasicProcessWarnings(from, "outside basic process scope");
    }

    protected void raisePendingBasicProcessWarnings(String from, String msg) {
        CztLogger.getLogger(<class/>.class).fine("PENDING PROCESS SCOPE WARNINGS (" + from +
            ") AFTER POST CHECK: " + parserState_.getProcessScopeWarnings().size()
            + " for " + getDialect().toString() + " in Parser.");
        for(Pair&lt;String, LocInfo&gt; p : parserState_.getProcessScopeWarnings()) {
            parser.report_error(CircusParseMessage.MSG_OUTSITE_BASIC_PROCESS_SCOPE_WARNING,
               new Object[] { p.getFirst(), msg, p.getSecond() }, p.getSecond());
        }
        parserState_.clearSectBasicProcessScopeWarnings();

        Pair&lt;Name, LocInfo&gt; pew = parserState_.getProcessEndWarning();
        CztLogger.getLogger(<class/>.class).fine("PENDING PROCESS CIRCEND WARNING (" + from +
            ") AFTER POST CHECK?: " + (pew != null) + " for " + getDialect().toString() + " in Parser.");
        if (pew != null) {
            parser.report_error(CircusParseMessage.MSG_MISSING_BASIC_PROCESS_CIRCEND,
                new Object[] { pew.getFirst(), pew.getSecond() }, pew.getSecond());
        }
        parserState_.clearSectBasicProcessEndWarning();
    }

    /** Ensures the list of collected paragraphs is the same the one into parserState_ */
    protected boolean ensureInnerProcParaListKnownInBasicProcessScope(List&lt;Para&gt; ipl, String from, LocInfo loc) {
        boolean result = parserState_.isWithinMultipleEnvBasicProcessScope() &amp;&amp;
            parserState_.isKnownPara(ipl);
        CztLogger.getLogger(<class/>.class).fine("ENSURING PARAGRAPH CONTAINMENT (" + from + ")?: " + result
            + " @ " + loc + " for " + getDialect().toString() + " in Parser.");
        if (!result) {
            parser.report_error(CircusParseMessage.MSG_FAIL_CHECK_INNER_PROC_ELEM_BASIC_PROC_SCOPE,
              new Object[] { loc }, loc);
        }
        return result;
    }

    /** Create an empty basic process and sets the parser state valure for it */
    protected BasicProcess createMockBasicProcessFor(String from, LocInfo l) {
       BasicProcess result = factory_.createBasicProcess(factory_.createZParaList());
       addLocAnn(result, l);
       CztLogger.getLogger(<class/>.class).finer("CREATING BASICPROCESS => " + from +
           " @ " + l + "\n" + result + " for " + getDialect().toString() + " in Parser.");
       parserState_.setBasicProcess(result);
       if (!parserState_.isWithinMultipleEnvBasicProcessScope()) {
            warnProcessScopeMismatch("open", from, l);
       }
       return result;
    }

    /**
     * Enters a basic process scope within the parser state, giving a parser
     * error in case of nested process scopes. It assumes the BasicProcess
     * already has location information calculated.
     */
    protected boolean enterBasicProcessScope(String from, LocInfo l) {
        boolean result = parserState_.enterBasicProcessScope(l);
        CztLogger.getLogger(<class/>.class).finer("ENTERING PROCESS SCOPE: " + result
            + " from " + from + " @ " + l + " for " + getDialect().toString() + " in Parser.");
        if (!result) {
            parser.report_error(CircusParseMessage.MSG_DUPlICATED_BASIC_PROCESS_SCOPE,
              new Object[] { from, l } , l);
        }
        return result;
    }

    /**
     * Enters a basic process scope within the parser state, giving a parser
     * error in case of nested process scopes. It assumes the BasicProcess
     * already has location information calculated.
     */
    protected boolean exitBasicProcessScope(String from, LocInfo l) {
        CztLogger.getLogger(<class/>.class).finer("EXITING PROCESS SCOPE: " +
            parserState_.isWithinMultipleEnvBasicProcessScope() +
            " from " + from + " @ " + l + "\n" + parserState_.getBasicProcess()
						+ " for " + getDialect().toString() + " in Parser.");

        // Clears: the implicitly declared actions and their name seed;
        // the current main action, the current basic process, and the
        // list of locally declared paragraphs. It also clears the process scope
        parserState_.clearBasicProcessInformation();

        boolean result = parserState_.exitBasicProcessScope();
        if (!result) {
            warnProcessScopeMismatch("closing", from, l);
        }
        return result;
    }

    protected boolean updateBasicProcessInformation(String from, LocInfo loc) {
        CztLogger.getLogger(<class/>.class).finer("BEFORE UPDATE BASIC PROCESS INFORMATION");

        ParserState.BasicProcessUpdate bpUpdate = parserState_.updateBasicProcessInformation();
        boolean result = bpUpdate.equals(ParserState.BasicProcessUpdate.BP_OK);

        CztLogger.getLogger(<class/>.class).finer("AFTER UPDATE BASIC PROCESS INFORMATION");
        CztLogger.getLogger(<class/>.class).finer("UPDATE BASIC PROCESS INFORMATION: " +
            result + " from " + from + " @ " + loc + "\n" +
            parserState_.getProcessPara() + " for " + getDialect().toString() + " in Parser.");

        if (!result) {
            warnProcessScopeMissing("update local structures " + bpUpdate + " ", from, loc);
            if (bpUpdate.equals(ParserState.BasicProcessUpdate.DUPLICATED_STATE))
            {
              parser.report_error(CircusParseMessage.MSG_DUPLICATED_BASIC_PROCESS_STATE,
                new Object[] { from, loc} , loc);
            }
            else if (bpUpdate.equals(ParserState.BasicProcessUpdate.DUPLICATED_MAIN_ACTION))
            {
              parser.report_error(CircusParseMessage.MSG_DUPLICATED_BASIC_PROCESS_MAINACTION, new Object[0], loc);
            }
        }
        return result;
    }

    /**
     * This method is called whenever the calling production result is related to
     * a list of paragraphs, where the current one is a ProcessPara. On these conditions,
     * it might be possible to have implicitly declared processes (i.e., those declared
     * on the fly by the current process para) to consider. So, we add all pending ones
     * at this point, and clear the implicitly declared process paragraph buffer.
     */
    protected void addImplicitlyDeclaredProcPara(List&lt;Para&gt; result)
    {
      if (!parserState_.getImplicitlyDeclProcPara().isEmpty())
      {
        result.addAll(parserState_.getImplicitlyDeclProcPara());
        parserState_.clearSectProcessOnTheFlyCache();
      }
    }

</add:circus>

    // could be useful for other parsers as well
    protected void logProductionResult(Object term, String from, LocInfo loc) {
        CztLogger.getLogger(<class/>.class).fine("PRODUCTION RESULT: " +
            " from " + from + " @ " + loc + "=>\n" + term
            + " for " + getDialect().toString() + " in Parser.");
    }
:}

parser code
{:
    private static final Map&lt;Object, String&gt; symbolMap_ = DebugUtils.getFieldMap(Sym.class);

    <add:circus>
    //static {
    //  System.err.println("Symbol table mapping" + " for " + getDialect().toString() + " in Parser:");
    //  java.util.Iterator it = symbolMap_.entrySet().iterator();
    //  while (it.hasNext())
    //  {
    //     Map.Entry entry = (Map.Entry)it.next();
    //     System.err.println("\t#" + entry.getKey() + " = " + entry.getValue());
    //  }
    //}
    </add:circus>

    @Override
    public Symbol parse() throws java.lang.Exception
    {
      // perform the parsing, but wrap into a try-catch, to react when problems
      // occur - we need to update the transactions in the section manager
      Symbol symbol;
      try {
      
        symbol = super.parse();
        
      } catch (Exception e) {
        /*
         * If fatal exception occurred during the parsing (usually problems are reported
         * but the parsing continues), we need to cancel the current transaction. This is 
         * required, because ZSect transactions are started manually, instead of via 
         * SectionInfo.get(). So upon exception, find out the current ZSect, and cancel
         * its transaction, then re-throw the exception.
         */
        cleanupZSectTransaction();
        
        throw e;
      }
      
      if (hasErrors())
      {
        // need to cleanup, e.g. if scanning error happens. It would be reported, but
        // parsing stops and section transaction is not closed.
        cleanupZSectTransaction();
        raiseErrors();
      }
      return symbol;
    }
    
    /**
     * Finds the current section, and cancels its transaction, if one is still active.
     * This is necessary because section transactions are started manually, and we need
     * to cleanup if unexpected error (e.g. underlying scanning error) happens. 
     */
    private void cleanupZSectTransaction() {
      String currentSect = action_obj.parserState_.getCurrentSectName();
      if (currentSect != null) {
        Key&lt;ZSect&gt; sectKey = new Key&lt;ZSect&gt;(currentSect, ZSect.class);
        // Check whether the current section transaction is still active.
        // This is needed, because sometimes the transaction has finished
        // and we are just reporting errors (and cleaning up)
        if (sectKey.equals(sectInfo_.getCurrentTransaction())) {
          sectInfo_.cancelTransaction(sectKey);
        }
      }
    }

    /** The file being parsed. */
    protected Source source_;

    /** Section information (parser code). */
    protected SectionInfo sectInfo_;

  // dialect is a final attribute determined at construction time
  // depending on the extension being used (i.e. decided at XML transformation time).
  // this is useful for fine-tuned error information. If no extension is chosen we 
  // get a compilation error (i.e. final field not assigned).
  protected final Dialect dialect_ = 
  						<add:zcore>Dialect.Z</add:zcore>
    					<add:zpattcore>Dialect.ZPATT</add:zpattcore>
    				  <add:ozcore>Dialect.OZ</add:ozcore>
    				  <add:ozpattcore>Dialect.OZPATT</add:ozpattcore>
    				  <add:zevescore>Dialect.ZEVES</add:zevescore>
    				  <add:circuspattcore>Dialect.CIRCUSPATT</add:circuspattcore>
    				  <add:circuscore>Dialect.CIRCUS</add:circuscore>
    				  <add:circusconfcore>Dialect.CIRCUSCONF</add:circusconfcore>
    				  <add:circustimecore>Dialect.CIRCUSTIME</add:circustimecore>
    				  // otherwise it will be unassigned, hence a compilation error
    				  ;

	protected DefaultSectionParents defaultSP_;

    /**
     * The list of parse errors.
     */
    protected List&lt;CztError&gt; errorList_;

    protected ParseException parseException_;

    /**
     * Contains the last token where a syntax error has occured.
     */
    private Symbol errorToken_;

    /**
     * True if and only if an error has occured during parsing.
     */
    //protected boolean error_ = false;

    private OperatorScanner opScanner_;
    private NewlineScanner nlScanner_;
<add:pattern>
    private JokerScanner jokerScanner_;
</add:pattern>

		public Dialect getDialect()
		{
			return dialect_;
		}

    protected boolean hasErrors()
    {
      for(CztError e : errorList_)
      {
        if (e.getErrorType() == ErrorType.ERROR)
          return true;

      }
      return false;
    }

    protected void raiseErrors() throws ParseException
    {
      assert hasErrors() : "no errors to be raised";
      if (parseException_ == null)
      {
        assert source_ == null;
        parseException_ = new ParseException(getDialect(), errorList_);
      }
      assert parseException_.getErrors().equals(errorList_) : "inconsistent error list";
      Iterator&lt;CztError&gt; it = errorList_.iterator();
      while (it.hasNext())
      {
        CztError e = it.next();
        if (e.getErrorType().equals(ErrorType.WARNING))
        {
          it.remove();
          // TODO: Parser should have a warning manager (!) 
          //       For now, keep warnings as just "show" at the parser level?
          CztLogger.getLogger(<class/>.class).warning(e.toString());
        }
      }
      it = null;
      // in case there are no more warnings...
      if (hasErrors())
      {
        throw parseException_;
      }
    }

    // there are more constructors created by java cup, don't put it final!
    private Set&lt;Key&lt;?&gt;&gt; explicitDeps_ = Collections.emptySet();

    Set&lt;Key&lt;?&gt;&gt; getExplicitDeps()
    {
      return Collections.unmodifiableSet(explicitDeps_);
    }

    /**
     * Creates a new parser with the given scanner, source information,
     * and section information.
     * The source information is only used for printing error messages.
     * The section information should be able to provide information of
     * type &lt;code&gt;net.sourceforge.czt.parser.util.OpTable.class&lt;/code&gt;.
     */
    public <class/>(CztScanner scanner,
                    Source source,
                    SectionInfo sectInfo,
                    Properties properties,
                    Collection&lt;? extends Key&lt;?&gt;&gt; explicitDeps)
    {
      super(scanner);
      source_ = source;
      sectInfo_ = sectInfo;
      assert scanner != null &amp;&amp; sectInfo_ != null;
      errorList_ = new ArrayList&lt;CztError&gt;(PerformanceSettings.INITIAL_ARRAY_CAPACITY);
      explicitDeps_ = new HashSet&lt;Key&lt;?&gt;&gt;(explicitDeps);
      parseException_ = null;
      defaultSP_ = null;
      if (source != null) {
        try {
          parseException_ =
            sectInfo_.get(new Key&lt;ParseException&gt;(source.getName(),
                                  ParseException.class));
          errorList_ = parseException_.getErrors();
          
          defaultSP_ =
          	sectInfo_.get(new Key&lt;DefaultSectionParents&gt;(source.getName(),
          							DefaultSectionParents.class));
        }
        catch (CommandException e) {
          e.printStackTrace();
          //TODO: check this. why not report the error?
          //report_error(e.toString(), e);
        }
      }
      else {
      	try {
          defaultSP_ =
          	sectInfo_.get(new Key&lt;DefaultSectionParents&gt;(Section.ANONYMOUS.getName(),
          							DefaultSectionParents.class));
        }
        catch (CommandException e) {
          e.printStackTrace();
          //TODO: check this. why not report the error?
          //report_error(e.toString(), e);
        } 
      }
      assert defaultSP_ != null;
      opScanner_ = new OperatorScanner(getCztScanner(), properties);
<add:pattern>
      jokerScanner_ = new JokerScanner(getCztScanner());
      opScanner_ = new OperatorScanner(jokerScanner_, properties);
</add:pattern>
      nlScanner_ = new NewlineScanner(opScanner_, properties);
      CztLogger.getLogger(<class/>.class).finer("New " + <class/>.class.getName() + 
      		" parser created for " + source_ 
      		+ " for " + getDialect().toString() + ".");
    }
    
    public CztScanner getCztScanner()
    {
    	return (CztScanner)getScanner();
    }

    /**
     * Returns the next token.
     */
    protected Symbol local_next_token() throws Exception
    {
      Symbol result = nlScanner_.next_token();
      assert result != action_obj.previous_;
<add:oz>
      //if we are parsing an OpExpr, then convert all SPOT tokens to
      //SCOPE tokens to remove a shift/reduce problem
      //this should be in the SmartScanner, but because this is not
      //able to be referenced from the parser code, we leave it here
      //for now.
      if (action_obj.previous_ !=  null &amp;&amp;
          action_obj.previous_.sym == Sym.RSQUARE) {
        action_obj.parserState_.popIsOpExpr();
      }
      else if (action_obj.previous_ !=  null &amp;&amp;
          action_obj.previous_.sym == Sym.LSQUARE) {
        action_obj.parserState_.pushIsOpExpr(false);
      }
      else if (result.sym == Sym.OPNAME) {
        action_obj.parserState_.pushIsOpExpr(true);
      }

      if (result.sym == Sym.SPOT &amp;&amp; action_obj.parserState_.isOpExpr()) {
        result.sym = Sym.SCOPE;
      }
</add:oz>
      action_obj.previous_ = result;
      String logMessage =
        "Next token is (" + symbolMap_.get(result.sym) + ", " +
            (result.sym != Sym.TEXT ? String.valueOf(result.value) + ", " +
                (result.value != null ? result.value.getClass().getName() : "null") : "...shhh...")  
                + " for " + getDialect().toString() + " in Parser).";
      CztLogger.getLogger(<class/>.class).finest(logMessage);
      return result;
    }

    /**
     * @throws ClassCastException if the object is not a CztError
     */
    public void report_error(String message, Object object)
    {
      CztError error = (CztError) object;
      errorList_.add(error);
      //error_ = true;
    }

    public void report_error(ZParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new ZParseError(sectInfo_, msg, params, locInfo));
    }

 <add:pattern>
    public void report_error(ZpattParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new ZpattParseError(sectInfo_, msg, params, locInfo));
    }

</add:pattern>
<add:zeves>
    public void report_error(ZEvesParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new ZEvesParseError(sectInfo_, msg, params, locInfo));
    }
</add:zeves>
<add:circus>
    public void report_error(CircusParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new CircusParseError(sectInfo_, msg, params, locInfo));
    }
</add:circus>

    public void syntax_error(Symbol token)
    {
      errorToken_ = token;
    }

    public void unrecovered_syntax_error(Symbol token) //throws Exception
    {
      report_error("Syntax error", createSyntaxError(token));
      done_parsing();
      CztLogger.getLogger(<class/>.class).severe("Parser error for " + getDialect().toString() + " dialect ==> token " +
      	symbolMap_.get(token.sym));
      // TODO: throw new ParseException?
      //	    throw new PrintException(dialect_, "Parser printer error: " +
	    //  String.valueOf(message) + " => " + (info instanceof Symbol ? symbolMap_.get(((Symbol)info).sym) : String.valueOf(info)));
    }

    public void report_syntax_error()
    {
      report_error("Syntax error", createSyntaxError(errorToken_));
    }

    protected CztError createSyntaxError(Symbol token)
    {
      return new ZParseError(sectInfo_, ZParseMessage.MSG_SYNTAX_ERROR,
                             new Object[] { toObject(token) },
                             getLocation(token));
    }

    public void report_syntax_error(ZParseMessage msg)
    {
      report_error(msg,
                   new Object[] { toObject(errorToken_) },
                   getLocation(errorToken_));
    }
    
<add:circus>
    protected CztError createCircusSyntaxError(CircusParseMessage syntax_msg, Symbol token)
    {
      return new CircusParseError(sectInfo_, syntax_msg,
                             new Object[] { toObject(token) },
                             getLocation(token));
    }

    public void report_syntax_error(CircusParseMessage msg)
    {
      report_error(msg,
                   new Object[] { toObject(errorToken_) },
                   getLocation(errorToken_));
    }

    public void report_syntax_error(CircusParseMessage msg,
                             Object[] params,
                             LocInfo locInfo)
    {
      report_error(null, new CircusParseError(sectInfo_, msg, params, locInfo));
    }

    /**
     * &lt;p&gt;
     * Changes the toString() method of ZFactory (within the given Factory),
     * so that is uses the toString() strategy for Circus. This essentially
     * means that the ZFactory will use Circus' version of PrintVisitor, which
     * includes Spec, ZSect, and other interesting productions of interest.
     * &lt;/p&gt;
     * &lt;p&gt;
     * They are importat in order to debug/inspect easily the rather complex
     * scoping mechanisms for basic (locally declared) processes.
     * It also shows how one could use the elegant CZT design for extension
     * surgical fine tunning!
     * &lt;/p&gt;
     */
    protected void setZFactoryToStringVisitor(Factory f) {
        ZUtils.assertZFactoryImpl(f.getZFactory()).setToStringVisitor(
            CircusUtils.assertCircusFactoryImpl(f.getCircusFactory()).getToStringVisitor());
    }

</add:circus>
    protected Object toObject(Symbol symbol)
    {
      if (symbol.value != null &amp;&amp;
          !(symbol.value instanceof LocInfo)) {
        return symbol.value;
      }
      return symbolMap_.get(symbol.sym);
    }

    protected String getLoc()
    {
      return source_.toString();
    }

    protected LocInfo getLocation(Symbol symbol)
    {
      if (symbol.value instanceof LocInfo) {
        return (LocInfo) symbol.value;
      }
      if (symbol.value instanceof LocString) {
        LocString s = (LocString) symbol.value;
        return s.getLocation();
      }
      if (symbol.value instanceof LocInt) {
        LocInt i = (LocInt) symbol.value;
        return i.getLocation();
      }
      return new LocInfoImpl(getDialect(), getLoc(), symbol.left, symbol.right);
    }

    protected LocInfo getLocation(Term term)
    {
      if (term != null) {
        return getLocation((LocAnn) term.getAnn(LocAnn.class));
      }
      return null;
    }

    protected LocInfo getLocation(LocAnn locAnn)
    {
      return new LocInfoImpl(getDialect(), locAnn);
    }

    protected ParserState createParserState(Source src)
    {
      return new ParserState(src);
    }

    protected Factory createParserFactory()
    {
      Factory result = new Factory();
      <add:circus>setZFactoryToStringVisitor(result);</add:circus>
      return result;
    }
:}

init with
{:
    //share the operator table between the action code and the parser code
    action_obj.source_ = source_;
    action_obj.sectInfo_ = sectInfo_;
    action_obj.dialect_ = dialect_;
    action_obj.defaultSP_ = defaultSP_;
    action_obj.opScanner_ = opScanner_;
    action_obj.nlScanner_ = nlScanner_;
    action_obj.parserState_ = createParserState(source_);
    action_obj.factory_ = createParserFactory();
<add:pattern>
    action_obj.jokerScanner_ = jokerScanner_;
</add:pattern>
:}

scan with {: return local_next_token(); :};

terminal LocInfo
        PARA, EXPR, PRED,
        THETA, MU, LAMBDA,
        NEXTSTROKE, OUTSTROKE, INSTROKE,
        LPAREN, RPAREN, LSQUARE, RSQUARE, LBIND, RBIND,
        LDATA, RDATA, LBRACE, RBRACE,
        BAR, ANDALSO, CONJECTURE, AND, OR, IMP, IFF, NOT,
        ALL, EXI, CROSS, POWER,
        SLASH, EQUALS, MEM, COLON, SEMICOLON, COMMA, DOT, SPOT, ZHIDE,
        ZPROJ, ZCOMP, ZPIPE, NL,
        SECTION, PARENTS, TRUE, FALSE, LET, IF, THEN, ELSE, ZPRE,
        RELATION, FUNCTION, GENERIC, LEFTASSOC, RIGHTASSOC, LISTARG, ARG,
        DEFFREE, DEFEQUAL, EXIONE,
        END, AX, SCH, GENSCH, GENAX, ZED, THEOREM,

        //ZSTATE, ZSTINIT, ZSTFIN, ZASTATE, ZASTINIT, 
        //ZCSTATE, ZCSTINIT, ZRETRIEVE, ZASTFIN, ZCSTFIN,
        //ZAINITIN, ZAFINOUT, ZCINITIN, ZCFINOUT, ZRETRIEVEIN,
        //ZRETRIEVEOUT, ZFSREFINES, ZBSREFINES,
<add:pattern>
        JOKER, RULE, RULELINE, VDASH, PROVISO,
</add:pattern>
<add:zeves>
        // Proof environment chars and specific proof words
        ZPROOF, //ZPROOFSECTION, 
        ZPROOFCOMMANDSEP, THMREPLACEMENT, QNTINSTANTIATION,
        LLABEL, RLABEL, DISABLEDTHMTAG, DISABLEDDEFTAG,
        THMRULE, THMGRULE, THMFRULE, THMAXIOM, 
        
        // LZNOTE, RZNOTE, 
        
        // PROOFWORD, // Needed for ContextFreeScanner, but given as ProofWord (Decorword)
        
        APPLY, BACK, CASES, CONJUNCTIVE, DISJUNCTIVE, EQUALITY,
        INSTANTIATE, INVOKE, NEXT, PRENEX, PROVE, REARRANGE, TRIVIAL, TRY,
        SPLIT, USE, WITH, BY, ENABLED, EXPRESSION, DISABLED, LEMMA,
        NORMALIZATION, PREDICATE, SUBSTITUTE, TO, SORRY, OOPS,

        CHECK, DECLARE, HELP, PARENT, PRINT, QUIT, READ, RESET, RETRY,
        SYNTAX, THEOREMS, UNDO, ZSECTION, ZTAGS,

        ABOUT, DECLARATION, FORMULA, HISTORY, PROOF, SCRIPT, STATUS,
        SUMMARY, THROUGH,

</add:zeves>
<add:circus>
        // Environment chars
        CIRCUS, CIRCUSACTION,

        /**
         * For CSP, we follow the precedences from FDR's user manual v.2.82 June/2005.
         */

        // Keychars
        CIRCREFINES, CIRCDEF, CIRCINDEX, CIRCSPOT, CIRCMU, CIRCTHEN, CIRCELSE, PREFIXTHEN,
        PREFIXCOLON, CIRCSEQ, CIRCINTERRUPT, INTERLEAVE, REPINTERLEAVE, REPPARALLEL, CIRCHIDING,
        EXTCHOICE, REPEXTCHOICE, INTCHOICE, REPINTCHOICE, CIRCASSIGN, CIRCSIMULATES,
        CHANNELIN, CHANNELOUT, CHANNELDOT, _CIRCGUARD, _REPSEQ,

        /* Note:
         *
         * CIRCGUARD => As there are no similar UNICODE char for &amp;, I am just
         *              using ANDALSO (from free type definition) directly.
         *              In circus_prelude, \circguard is then mapped to the same
         *              UNICODE as ANDALSO, which is 0026, and CircChar has no
         *              entry for this token!
         *              Nevertheless, I still nedd the CIRCGUARD token for
         *              handling precedences apropriately, hence _CIRCGUARD!
         *
         * REPSEQ    => Similarly, as all the UNICODE chars for big ";" I could find
         *              (relational composition COMP = U2A3E, and
         *              schema composition ZCOMP = U2A1F) are taken, we use the
         *              ZCOMP keyword. It must not be COMP, because it is just a
         *              toolkit symbol (i.e. scanned as DECORWORD), rather than a
         *              proper keyword (i.e. scanned as ZCOMP).
         *              The same idea of precedence applies, hence _REPSEQ.
         *
         *              TODO:CHECK whether REPSEQ needs precedence or not. At the moment
         *                         it is just taking the same as CIRCSEQ.
         */

        // Keywords
        CIRCFI, CIRCDO, CIRCOD, CIRCVAR, CIRCVAL,
        CIRCRES, CIRCVRES, CIRCCHAN, CIRCCHANFROM, CIRCCHANSET,
        CIRCNAMESET, CIRCPROC, CIRCBEGIN, CIRCEND, CIRCSTATE,
        CIRCSKIP, CIRCSTOP, CIRCCHAOS, _CIRCIF, CIRCASSERTREF,

        /* Note:
         *
         * CIRCIF => As I couldn't make CIRCIF different from IF by
         *           using "ifg" or "IF", I am just reusing it here
         *           like before, with the same adjustment on precedences.
         */

        // Brackets
        LCIRCCHANSET, RCIRCCHANSET, CIRCLINST, CIRCRINST,
        LPAR, RPAR, LINTER, RINTER, LCIRCGUARD, RCIRCGUARD,
        LSCHEXPRACT, RSCHEXPRACT, LCIRCRENAME, RCIRCRENAME,

        // Special bracket terminals to overhide precedence of process renaming
        // acording to how it is expected to be in CSP_M.
        // USE _RENAME :)

        
</add:circus>


 <add:circustime>
   	/* Support Circus time for Action and Process */ 
        CIRCWAIT, ATTIME, CIRCENDBY, CIRCSTARTBY, CIRCTIMEOUT, CIRCTIMEDINTERRUPT, LCIRCTIME, RCIRCTIME,
 </add:circustime>
 <add:circusconf>
   	/* Support Circus confidentiality for Action and Process */ 
        LCIRCCONF, RCIRCCONF,
 </add:circusconf>
 

<add:oz>
        DELTA, CLASS, GENCLASS, STATE, INIT, OPSCH, SDEF,
        INITWORD, POLY, CONTAINMENT, SCOPE,
        DCNJ, DGCH, // DSQC, 
        PARALLEL, ASSOPARALLEL, GCH, CLASSUNION,
</add:oz>
<add:tcoz>
        ATTIME, NEXTPRO, INTCHOICE, DIC, INTERLEAVE,
        DIL, WAITUNTIL, DEADLINE, WAIT, INTERRUPT, TIMEOUT, TIMEEND,
        DPARA, NETTOPLEFT, NETTOPRIGHT, CHAN, SENSOR, ACTUATOR,
</add:tcoz>
        //identifiers starting with a '_' are used only to force precedence
        _APPLICATION, _RENAME;

terminal LocString
<add:pattern>
        JOKERNAME, JOKERNAMELIST, JOKERRENAMELIST,
        JOKEREXPR, JOKEREXPRLIST, JOKERPRED, JOKERDECLLIST, JOKERSTROKE,
</add:pattern>
        TEXT, PREP, PRE, POSTP, POST, IP, I, LP, L, ELP, EL, ERP, ER,
        SRP, SR, EREP, ERE, SREP, SRE, ES, SS;

terminal LocInt NUMERAL, NUMSTROKE;

terminal Decorword
<add:oz>
        DEFNAME, OPNAME,
</add:oz>
<add:circus>
        CHANNELNAME, FIELDNAME, CHANNELERROR,
</add:circus>
<add:zeves>
        THMNAME, 
</add:zeves>
        DECORWORD, DECLWORD;

<add:zeves>
terminal Proofword
        PROOFWORD; // Needed for the ContextFreeScanner. Should be dealt with by SmartScanner, though. see below.

terminal LocInfo
      REDUCE, REWRITE, SIMPLIFY;
</add:zeves>

non terminal Term
    input;

non terminal Spec
    specification;

non terminal NarrSect
    narrSect;

non terminal ZSect
    section,
    emptySectionHeader,
    empty,
    sectionHeader;

non terminal List&lt;Sect&gt;
    sectionList;

non terminal List&lt;Parent&gt;
    parentList,
    parents;

non terminal ZParaList
    paragraphList;

non terminal List&lt;Para&gt;
    unboxedParagraphList,
    unboxedParagraphItemList;

non terminal Para
    boxedParagraph,
    unboxedParagraphItem,
    narrParagraph;

non terminal AxPara
    axiomaticDefinition,
    genericAxDefinition,
    abbreviationDefinition,
    schema;

//non terminal ZStateInfo
//non terminal Ann
//    optZStRefInfo;  // either ZStateAnn or ZRefinesAnn
//
////non terminal ZRefines
////    optZRefines;

non terminal ConstDecl
    letDefinition;

non terminal ZFreetypeList freeTypeList;
non terminal Freetype freeTypeDefinition;

non terminal List&lt;LocString&gt;
    narrWordList;

non terminal OptempPara 
	operatorTemplate;
	
// this list includes both operator and operands
non terminal List&lt;Oper&gt;
    template,
    prefixTemplate,
    postfixTemplate,
    infixTemplate,
    nofixTemplate,
    optWordOperandList;

non terminal Operand
    varg,
    templateTag;
non terminal Assoc assoc;
non terminal OptempPara catTemplate;

non terminal SchText
    schemaTextNoExpression,
    axiomaticSchemaText,
    schemaText;

non terminal ZDeclList letDefinitionList;

non terminal ZBranchList branchList;
non terminal Branch branch;

non terminal ZNameList
    nameList,
    declWordList;

non terminal Name
    name,
    declName;

non terminal ZName
    refName;

non terminal List&lt;ZName&gt; refNameList;

non terminal RenameList renameList;
non terminal ZRenameList zRenameList;
non terminal NewOldPair rename;

non terminal ZDeclList
    zDeclList;

non terminal DeclList
    optDeclPart,
    declPart;

non terminal VarDecl
    varDecl;
non terminal ConstDecl
    <add:zeves>bindDecl,</add:zeves>
    constDecl;
non terminal Decl
    basicDeclaration,
    declaration;

non terminal GivenPara basicTypeDefinition;
non terminal ZNameList
    formalParameters,
    optFormalParameters;

non terminal Stroke stroke;

non terminal And
    sep;

non terminal Term
    term,
    septerm,
    func_appl,
    inner_term;

non terminal List &lt; Object &gt;
    optAppendageList,
    appendageList;

non terminal Object
    appendage;

non terminal Pred
    predicate,
    relation,
    infixRel,
    infixChainRel;

non terminal MemPred
    prefixRel,
    postfixRel,
    nofixRel;

non terminal Expr
    expression;

non terminal ZDeclList
    constDeclList,
    <add:zeves>
    bindDeclList,
    </add:zeves>
    optConstDeclList;

non terminal ZExprList
    prodExpressionList,
    optExpressionList,
    expressionList;

non terminal List&lt;String&gt;
    opName,
    prefixName,
    postfixName,
    infixName,
    nofixName;

non terminal Pair&lt;Name,ZNameList&gt;
    genName,
    prefixGenName,
    postfixGenName,
    infixGenName,
    nofixGenName;

non terminal List&lt;String&gt;
    optVargEsSsList;

non terminal Pair&lt;ZNameList,ZNameList&gt;
    optNameEsSsList;

non terminal Expr
    application,
    prefixApp,
    postfixApp,
    infixApp,
    nofixApp;

non terminal List&lt;Object&gt;
    expSep;

non terminal List&lt;String&gt;
    argErepOrSrep,
    argEreOrSre,
    argErOrSr,
    argEsOrSs,
    argErpOrSrp;

non terminal LocString
    misusedOpName,
    ereOrSre,
    erOrSr,
    esOrSs;

non terminal And
    optNL;

non terminal Boolean
    conjecture;

<add:pattern>
/// Z pattern constructs ///////////////////////////////////////////////
non terminal Jokers jokerPara;
non terminal Rule rulePara;
non terminal Oracle oraclePara;

non terminal List&lt;String&gt; jokerList;

non terminal List&lt;Sequent&gt;
    sequentLHS;

non terminal SequentList
    premisses;

non terminal Sequent premiss;

non terminal Sequent conclusion;

non terminal Sequent
    sequent,
    predSequent;

non terminal Term jokerRef;

non terminal DeclList
    jokerDeclList;
</add:pattern>

<add:zeves>
non terminal ProofScript
    zProof;
    
non terminal ProofCommandList
    proofScript;

non terminal ProofCommand
    proofCommand, innerProofCommand,
    applyCommand, caseAnalysisCommand, normalizationCommand,
    quantifiersCommand, simplificationCommand, substitutionCommand,
    useCommand, withCommand,
    printProofCommands, undoingCommands, interfaceCommands, zsectionProofCommands;


non terminal LocInfo
    optPrint, optSummary, optScript;

non terminal LocInt
    optNumber;

non terminal Instantiation
    instantiation//, replacement
    ;

non terminal InstantiationList
    instantiations, replacements,
    //optReplacements,
    instantiationList;

//non terminal Expr
//    zevesRenaming;

non terminal ZExprList
    //optGenActuals,
    genericActuals;

non terminal Object[]
      innerSimplCmd;

// can include ZPROOFDOLLAR sign in these names
non terminal Name 
      applyThmName, thmName;

non terminal ZNameList
      thmNameList;

non terminal LocInfo
    proofSep;

//non terminal Boolean
//    instOrRepl;

non terminal LabelAbility
    optLabelAbility,
    optDefAbility,
    optThmAbility;

non terminal LabelUsage
    optUsage;

non terminal ZEvesLabel
    optAxLabel;

//non terminal ZEvesNote
//    optZNote;
</add:zeves>

<add:circus>
/// Circus paragraphs ///////////////////////////////////////////////
non terminal Para
    channelPara,
    channelSetPara,
    processRefPara,
    actionRefPara,
    namesetPara,
    circusProcessState,
    singleCircusParagraphItem,
    circusInnerProcPara;

non terminal ProcessPara
    processPara;

non terminal ActionPara
    actionPara;

non terminal List&lt;Para&gt;
    singleCircusParagraphItemList,
    circusMultiEnvParagraphList,
    circusInnerProcParaList;

non terminal ZExprList
    genericActuals,
    actualParameters,
    actualIndexes;

/// Circus channel definition ////////////////////////////////////////////////
non terminal List&lt;ChannelDecl&gt;
    channelFromDeclList,
    channelDeclList;

non terminal ChannelDecl
    channelDecl, channelFromDecl;

non terminal ChannelSet
    channelSet;

/// Circus channel set expression definition ////////////////////////////////

//non terminal Expr
//    cs_expression;
//
//non terminal ZDeclList
//    cs_letDefinitionList;
//
//non terminal ConstDecl
//    cs_letDefinition;
//
//non terminal Expr
//    cs_func_appl,
//    cs_inner_expression,
//    cs_nofixApp,
//    cs_application,
//    cs_prefixApp,
//    cs_postfixApp,
//    cs_infixApp;
//
//non terminal List&lt;Object&gt;
//    cs_expSep;
//
//non terminal ZExprList
//    cs_optExpressionList,
//    cs_expressionList;

/// Circus process definition ///////////////////////////////////////////////
non terminal CircusProcess
    processDesc,
    paramProcess,
    indexedProcess,
    processCall,
    parenthesisedProcess,
    //renamingProcesses,
    process;
    
non terminal BasicProcess
    circusBasicProcess;

non terminal RenameList
    nameSubstitution;

non terminal AssignmentPairs
    channelRenaming;

/// Circus parameters definition /////////////////////////////////////////////

non terminal DeclList
  circusParamDeclList,
  circusParamCommandDeclList;

non terminal ZDeclList
    circusParamZDeclList,
    circusParamCommandZDeclList;

non terminal ZNameList
    circusDeclWordList;

non terminal Decl
  circusCommandDecl;

non terminal QualifiedDecl
  qualifiedDecl;

non terminal ParamQualifier
  circusQualifier;

non terminal Transformation
  refines;

/// Circus action definition ///////////////////////////////////////////////
non terminal CircusAction
    actionDesc,
    paramAction,
    circusAction,
    actionCall,
    parenthesisedAction,
    circusBasicProcessMainAction,
    cspAction;
   
    
/// Circus guard //////////////////////////////////////////////////////////
non terminal Pred
    guard;

/// Circus communication /////////////////////////////////////////////////
//non terminal LocString anyCircusSymbol;

non terminal Communication
    chanSetComm,
    communication;

non terminal List&lt;Field&gt;
    optCommFields,
    commFields;

non terminal List&lt;Communication&gt;
    optCommunicationList,
    communicationList;

non terminal Field
    commField;

/// Circus guarded commands /////////////////////////////////////////////////
non terminal CircusCommand
    command;

non terminal List&lt;GuardedAction&gt;
    guardedCommands;

non terminal GuardedAction
    guardedCommand;

/// Circus name set definition /////////////////////////////////////////////
non terminal NameSet
    nameSet;

</add:circus>


<add:circustime>
/* Support  Circus Time for Process and Action */

//non terminal CircusAction circusTimedCSPActions;
//non terminal CircusProcess  circusTimedCSPProcess;
</add:circustime>


<add:oz>
/// Object-Z constructs ///////////////////////////////////////////////
non terminal Expr
    inheritedClass;

non terminal ClassPara
    class;

non terminal Pair&lt;Name,ZNameList&gt;
    classHeader;

non terminal State
    state;

non terminal Pair&lt;PrimaryDecl,SecondaryDecl&gt;
    stateDeclNoExpression,
    stateDecl;

non terminal ZDeclList
    primaryDeclPart,
    optPrimaryDeclPart;

non terminal DeclList
    secondaryDeclPart;

non terminal InitialState
    initialState;

// Inner para was Term because InitialState and State were Terms, but this 
// doesn't seem right given they are a "innerPara" and are treated as such
// both here and in typechecker-oz/ParaChecker.java. So changed them to Para.
non terminal Term
    innerPara;

// TODO: why not make this Para?
non terminal List&lt;Term&gt;
    innerParaList;

non terminal DeltaList
    deltaList;

non terminal VisibilityList
    visibilityList;

non terminal OpExpr
    opExpr,
    outer_opExpr,
    inner_opExpr;

non terminal ExprList
    inheritedList;

non terminal List&lt;Expr&gt;
    inheritedClassList;

non terminal OpText
    opTextWithDelta,
    opText;

non terminal Operation
    operation;

non terminal List&lt;Operation&gt;
    operationList;

</add:oz>
<add:tcoz>
non terminal VarDecl channelDeclaration;

non terminal Expr channel;

non terminal List&lt;Event&gt; eventSet;

non terminal Event
    event,
    inOutEvent;

non terminal List&lt;Connection&gt; topology;

non terminal Connection connection;

/* non terminal ChannelType chantype;*/
</add:tcoz>

// These are ordered from loosest first to tightest last.
precedence right        BAR;
precedence left         TEXT;
precedence left         <add:tcoz>LPAREN,</add:tcoz> RPAREN;
precedence left         NL, SEMICOLON;
precedence nonassoc     DEFEQUAL <add:circus>, CIRCDEF</add:circus>;
precedence left         ALL, EXI, EXIONE, SPOT <add:circus>, CIRCSPOT, CIRCINDEX </add:circus>;
<add:oz>
precedence left         DCNJ, DGCH; //, DSQC;
precedence left         ASSOPARALLEL;
<add:tcoz>
precedence left         DIC, DIL;
precedence left         WAIT;
precedence left         NEXTPRO, ATTIME;
precedence left         NETTOPLEFT, NETTOPRIGHT;
</add:tcoz>
precedence left         SCOPE;
precedence left         PARALLEL<add:tcoz>, INTERLEAVE, INTERRUPT,
TIMEOUT, TIMEEND</add:tcoz>;
precedence left         GCH <add:tcoz>, INTCHOICE </add:tcoz>;
</add:oz>
<add:circus>
/* From Z-Std(p.36): default is prefix op=rightassoc, postfix op=leftassoc */

precedence right        CIRCMU;
precedence right        CIRCVAR;
precedence nonassoc     CIRCDO, CIRCOD;
precedence nonassoc     _CIRCIF, CIRCFI, CIRCTHEN, CIRCELSE;
precedence left         CIRCHIDING;
precedence left         INTERLEAVE;//, REPINTERLEAVE;
precedence nonassoc     LINTER, RINTER;
//precedence left         REPPARALLEL;
precedence nonassoc     LPAR, RPAR;
precedence left         INTCHOICE;//, REPINTCHOICE;
precedence left         EXTCHOICE;//, REPEXTCHOICE;
precedence left         CIRCINTERRUPT;
precedence left         CIRCSEQ, _REPSEQ; //TODO:CHECK _REPSEQ placement.
precedence nonassoc     _CIRCGUARD;
precedence right        PREFIXTHEN;
//, CIRCCOMMDOT
//CIRCVAL, CIRCRES, CIRCVRES,
//CIRCCHAN, CIRCCHANFROM, CIRCCHANSET,
//CIRCNAMESET, CIRCPROC, CIRCBEGIN, CIRCEND, CIRCSTATE,
//CIRCSKIP, CIRCSTOP, CIRCCHAOS,
//LCIRCCHANSET, RCIRCCHANSET,
</add:circus>

<add:circustime>
/* Support  Circus Time for Process and Action */

precedence left  CIRCENDBY, CIRCTIMEOUT, CIRCTIMEDINTERRUPT, ATTIME;
precedence right CIRCSTARTBY;
</add:circustime>


precedence left         IFF;
precedence right        IMP;
precedence left         OR;
precedence left         AND;
precedence right        NOT;
precedence left         MEM, EQUALS, PREP, LP, IP, EREP, SREP,
                        POSTP, ELP, ERP, SRP;
precedence right        LAMBDA;
precedence right        MU;
precedence right        LET;
<add:oz>
precedence left         CLASSUNION;
</add:oz>
precedence right        ELSE;
precedence left         ZCOMP;
precedence left         ZPIPE;
precedence left         ZHIDE;
precedence left         ZPROJ;
precedence right        ZPRE;
precedence left         I, CROSS;
precedence left         EL, ERE, SRE;
precedence right        POWER, PRE, L;
<add:oz>
precedence right        POLY;
</add:oz>
precedence left         POST, ER, SR;
<add:oz>
precedence left         CONTAINMENT;
</add:oz>
<add:tcoz>
precedence left         CHAN, SENSOR, ACTUATOR;
</add:tcoz>
precedence left         _APPLICATION;
precedence left         INSTROKE, OUTSTROKE, NEXTSTROKE, NUMSTROKE;
<add:circus>
// Just like FDR, we make ?/!/. fields right associative. Since the
// smart scanner renames these tokens accordingly, we can now do it.
// So far, it seems irrelevant --- couldn't find a example where it
// made a difference yet. This is harmless.
precedence right        CHANNELIN, CHANNELOUT, CHANNELDOT;
</add:circus>
precedence left         _RENAME;
<add:pattern>
precedence left         RULELINE;
</add:pattern>
precedence left         DOT;
precedence right        THETA;
precedence left         LSQUARE, RSQUARE;
<add:circus>
/* TODO: Need to test funny cases to see whether this precedences are really useful.
 */
precedence nonassoc     LCIRCRENAME, RCIRCRENAME; // it doesn't matter if put before _RENAME
precedence nonassoc     LSCHEXPRACT, RSCHEXPRACT;
precedence nonassoc     LCIRCGUARD, RCIRCGUARD;

precedence nonassoc     CIRCLINST, CIRCRINST;
precedence nonassoc     CIRCASSIGN;
</add:circus>

 <add:circustime>
   /* Support  Circus Time for Process and Action */
precedence nonassoc  LCIRCTIME, RCIRCTIME;
precedence nonassoc     CIRCWAIT;
 </add:circustime>
 <add:circusconf>
precedence nonassoc  LCIRCCONF, RCIRCCONF;
 </add:circusconf>

<add:zeves>
precedence nonassoc     LLABEL, RLABEL; //, LZNOTE, RZNOTE;
</add:zeves>
precedence left         DECORWORD
                        <add:circus>
                          // Do we need to add these precedences for Circus?
                          // adding just for consistency wrt DECORWORD
                          , CHANNELNAME, FIELDNAME, CHANNELERROR
                        </add:circus>
                        <add:oz>, INITWORD</add:oz>;

<add:zeves>//TODO: check the need for precedence here of proof words </add:zeves>


/// specifications /////////////////////////////////////////////////////////

input ::=
        narrSect:narr specification:s
        {:
           if (narr != null) {
             s.getSect().add(0, narr);
           }
           <add:circus>
               //logProductionResult(s, "SPECIFICATION AT INPUT", getLocation(s));
           </add:circus>
           RESULT = s;
        :}
        |
        PARA boxedParagraph:p
        {: RESULT = p; :}
        |
        EXPR expression:e
        {: RESULT = e; :}
        |
        PRED predicate:p
        {: RESULT = p; :}
        ;

narrSect ::=
        //empty
        {:
           RESULT = null;
        :}
	|
	narrWordList:nwl
	{:
           RESULT = factory_.createNarrSect(toStringList(nwl));
           addLocAnn(RESULT, getLocation(nwl));
        :}
        ;

specification ::=
        // anonymous specification
        emptySectionHeader:header paragraphList:pl
        {:
           header.setParaList(pl);
           ZSect zSect = endZSectTransaction(header, opTable_);
           RESULT = createSpec(factory_.list(zSect));
           <add:circus>
               //logProductionResult(pl, "EMPTY-SECTION-HEADER", getLocation(RESULT));
               raisePendingBasicProcessWarnings("SPECIFICATION PRODUCTION");
           </add:circus>
        :}
        |
        // sectioned specification
        sectionList:sl
        {:
           RESULT = createSpec(sl);
        :}
        ;

emptySectionHeader ::=
        empty:e
        {:
           // Apply Syntactic Transformation Rule 12.2.1.1
           final String name = Section.ANONYMOUS.getName();
           startZSectTransaction(name);
           final Set&lt;String&gt; parentSet = defaultSP_.defaultParents(name);
           final List&lt;Parent&gt; parents = ZUtils.parentsAsListOfParent(parentSet);
           resetInfoTables(name, parents, eleft, eright);
           RESULT = createZSect(name, parents);
<add:circus>
           parserState_.clearAllProcessInformation();
</add:circus>
           addLocAnn(RESULT, getLocation(eleft, eright));
        :}
        ;

empty ::=
        //empty
        {:
        :}
        ;

sectionList ::=
        sectionList:sl section:s
        {:
           sl.add(s);
           RESULT = sl;
        :}
        |
        section:s
        {: RESULT = factory_.list((Sect) s); :}
        ;

section ::=
        sectionHeader:header paragraphList:pl
        {:
           <add:circus>
               //logProductionResult(pl, "PARAGRAPH LIST AT SECTION", pl.isEmpty() ? null : getLocation(pl.get(0)));
           </add:circus>
           header.setParaList(pl);
           RESULT = endZSectTransaction(header, opTable_);
           if (pl.size() > 0) {
             Para plPara = pl.get(pl.size()-1);
             //logProductionResult(plPara, "PARAGRAPH LOCATION AT SECTION", getLocation(plPara));
             LocInfo loc = getLocation(plPara);
             LocAnn locAnn = (LocAnn) RESULT.getAnn(LocAnn.class);
             if (loc.getStart() >= 0 &amp;&amp;
                 loc.getLength() >= 0  &amp;&amp;
                 locAnn.getStart() != null) {
               final int length = loc.getStart() + loc.getLength()
                                  - locAnn.getStart().intValue();
               locAnn.setLength(BigInteger.valueOf(length));
             }
           }

           <add:circus>
               logProductionResult(pl, "SECTION[" + header.getName() + "]-PL", getLocation(RESULT));
               raisePendingBasicProcessWarnings("SECTION PRODUCTION");
           </add:circus>
        :}
        ;

sectionHeader ::=
        //ZED token at the start of sections is ignored by
        //the OperatorScanner to avoid a few problems
        SECTION:s DECORWORD:dw parents:p END
        {:
           String name = dw.getName();
           checkName(dw);

			// add default parents only if given parents are empty
			// this includes explicitly given NON-PARENTS (i.e. SECTION name PARENTS _empty_ ; SECTION name).
			// in both cases we override to add default parents. 
			//
			// This is as prescribed by the Z Standard (see the Section production in Appendix C.3)
           if (p.isEmpty())
           {
			   // add to the set to avoid repetition of parents
	           //final Set&lt;String&gt; parentStrSet = defaultSP_.defaultParents(name);
	           final Set&lt;Parent&gt; parentSet = ZUtils.parentsAsSetOfParent(defaultSP_.defaultParents(name));
	           parentSet.addAll(p);
	           
	           // make it back into list of Parent cleared of duplicates
	           p.clear();
	           p.addAll(parentSet);
           }
		   
           // update the parsed section information
           startZSectTransaction(name);
           resetInfoTables(name, p, pleft, pright);
           RESULT = createZSect(name, p);
<add:circus>
           parserState_.clearAllProcessInformation();
</add:circus>
           addLocAnn(RESULT, s);
        :}
        ;

parents ::=
        //empty
        {: RESULT = factory_.list(); :}
        |
        PARENTS
        {: RESULT = factory_.list(); :}
        |
        PARENTS parentList:pl
        {: RESULT = pl; :}
        ;

parentList ::=
        parentList:pl COMMA DECORWORD:dw
        {:
           checkName(dw);
           Parent p = factory_.createParent(dw.getName());
           addLocAnn(p, dw.getLocation());
           pl.add(p);
           RESULT = pl;
        :}
        |
        DECORWORD:dw
        {:
           checkName(dw);
           Parent p = factory_.createParent(dw.getName());
           addLocAnn(p, dw.getLocation());
           RESULT = factory_.list(p);
        :}
        ;


//paragraphs are divided into boxed and unboxed paragraphs.
//Unboxed paragraphs must have a newline after their definition,
//unless they are the final paragraph within ZED ... END tokens
paragraphList ::=
        paragraphList:pl boxedParagraph:p
        {:
           if (p != null) {
             <add:circus>
             // for boxed paragraphs for basic circus process added
             // across multiple circus LaTeX environments
             if (parserState_.isWithinMultipleEnvBasicProcessScope()) {
                LocInfo loc = getLocation(p);
                if (p instanceof AxPara) {
                    NameList nl = ZUtils.getAxParaGenFormals(p);
                    boolean hasGenerics = (nl != null &amp;&amp;
                        (nl instanceof ZNameList) &amp;&amp;
                        !((ZNameList)nl).isEmpty());
                    final String msg = "a local " +
                        (hasGenerics ? "generic " : "") +
                        (ZUtils.isSimpleSchema(p) ? "schema " :
                            (((AxPara)p).getBox().equals(Box.OmitBox) ?
                                "horizontal definition " :
                                "axiomatic definition ")
                        ) +
                        "paragraph";

                    // raise a scoping warning if needed
                    addBasicProcessScopePostCheckFor("MULTIPLE ENV - " + msg, getLocation(p));
                    parserState_.addLocallyDeclPara(p);
                } else {
                    //assert ZUtils.isZPara(para);
                    parser.report_error(CircusParseMessage.MSG_INVALID_INNER_PROCESS_PARA,
                        new Object[] { p.getClass().getSimpleName(), loc }, loc);
                }
             }
             // Only add to the list when not within a basic process
             else
             </add:circus>
                pl.add(p);
           }
           RESULT = pl;
        :}
        |
        paragraphList:pl unboxedParagraphList:upl
        {:
           <add:circus>
           if (!parserState_.isWithinMultipleEnvBasicProcessScope())
           </add:circus>
              pl.addAll(upl);
           RESULT = pl;
        :}
<add:circus>
        |
        paragraphList:pl circusMultiEnvParagraphList:ucpl
        {:
           //assert ucpl.isEmpty() : "Circus paragraph list from multiple environment must be empty. " +
           //    "Its members are stored within the parserState and collected when the basic process " +
           //    "scope is closed. If they appear dangling outside a scope, relevant warnings/errors " +
           //    "are raised accordingly. For this production, this s necessary in order to allow the " +
           //    "tokens to be consumed, even if stored indirectly as in here.";
           pl.addAll(ucpl);
           RESULT = pl;
           //logProductionResult(RESULT, "MULTIPLE-CIRCUS-PARAGRAPH-LIST", null);
        :}
</add:circus>
        |
        paragraphList:pl narrParagraph:np
        {:
           <add:circus>
           // If not within a basic process keep the narr para at section level
           if (!parserState_.isWithinMultipleEnvBasicProcessScope())
           </add:circus>
              pl.add(np);
           RESULT = pl;
        :}
        |
        //empty
        {: RESULT = factory_.createZParaList(); :} %prec NL
        ;


// 6.2 Global Paragraphs //////////////////////////////////////////////////////

boxedParagraph ::=
        axiomaticDefinition:ad
        {: RESULT = ad; :}
        |
        schema:s
        {: RESULT = s; :}
        |
        genericAxDefinition:gd
        {: RESULT = gd; :}
<add:pattern>
        |
        jokerPara:jp
        {: RESULT = jp; :}
        |
        rulePara:rp
        {: RESULT = rp; :}
        |
        oraclePara:pp
        {: RESULT = pp; :}
</add:pattern>
<add:oz>
        |
        class:c
        {: RESULT = c; :}
</add:oz>
<add:zeves>
        |
        zProof:zp
        {: RESULT = zp; :}
</add:zeves>
        |
        error:e END:ed
        {:
          parser.report_syntax_error();
          <add:oz>parserState_.resetIsOpExpr();</add:oz>
        :}
        ;

narrParagraph ::=
        narrWordList:nwl
        {:
           RESULT = factory_.createNarrPara(toStringList(nwl));
           addLocAnn(RESULT, getLocation(nwl));
           <add:circus>
           // If within a basic process keep the narr para within it.
           if (parserState_.isWithinMultipleEnvBasicProcessScope()) {
              // raise a scoping warning if needed
              addBasicProcessScopePostCheckFor("narrative paragraph", getLocation(nwl));
              parserState_.addLocallyDeclPara(RESULT);
           }
           </add:circus>
        :}
        ;

unboxedParagraphList ::=
        ZED:zed
        <add:zeves>optDefAbility:ability</add:zeves>
        unboxedParagraphItemList:uil END:end
        {: if (uil.size() == 1) {
             addLocAnn(uil.get(0), getLocation(zed, end));
           }
             <add:circus>
             // for unboxed paragraphs for basic circus process added
             // across multiple circus LaTeX environments
             if (parserState_.isWithinMultipleEnvBasicProcessScope()) {
                String msg;
                LocInfo loc;
                boolean add;
                Iterator&lt;Para&gt; it = uil.iterator();
                while (it.hasNext()) {
                    Para para = it.next();
                    loc = getLocation(para);
                    add = ZUtils.isZPara(para);
                    if (para instanceof AxPara) {
                        AxPara p = (AxPara)para;
                        NameList nl = ZUtils.getAxParaGenFormals(p);
                        boolean hasGenerics = (nl != null &amp;&amp;
                            (nl instanceof ZNameList) &amp;&amp;
                            !((ZNameList)nl).isEmpty());
                        msg = "a local " +
                            (hasGenerics ? "generic " : "") +
                            (ZUtils.isSimpleSchema(p) ? "schema " :
                                (((AxPara)p).getBox().equals(Box.OmitBox) ?
                                    "horizontal definition " :
                                    "axiomatic definition ")
                            ) +
                            "paragraph";
                    } else if (para instanceof GivenPara) {
                        msg = "a local given set paragraph";
                    } else if (para instanceof FreePara) {
                        msg = "a local free type paragraph";
                    } else if (para instanceof ConjPara) {
                        msg = "a local conjecture paragraph";
                    } else if (para instanceof OptempPara) {
                        msg = "a local operator template paragraph";
                    } else {
                        msg = "an invalid local paragrph";
                        //assert parserState_.isZPara(para);
                        parser.report_error(CircusParseMessage.MSG_INVALID_INNER_PROCESS_PARA,
                            new Object[] { para.getClass().getSimpleName(), loc }, loc);
                    }
                    if (add) {
                        // raise a scoping warning if needed
                        addBasicProcessScopePostCheckFor("SINGLE ENV - " + msg, loc);
                        parserState_.addLocallyDeclPara(para);
                        it.remove();
                    }
                }
                it = null;
             }
           </add:circus>
           RESULT = uil;
           <add:zeves>addZEvesLabel(RESULT, ability);</add:zeves>
        :}
<add:circus>
        |
        ZED:zed singleCircusParagraphItemList:ppl END:end
        {:
           RESULT = factory_.list();
           parser.report_error(CircusParseMessage.MSG_INVALID_CIRCUS_PARA_IN_ZED,
              new Object[] { "process level", "CIRCUS" }, getLocation(zed, end));
        :}
        /*
        NOTE: It would be nice to have the production below with an error message as well,
              but unfortunately, it is creating conflicts. So, leave it out for now.
        |
        ZED:zed circusInnerProcParaList:ppl END:end
        {:
           RESULT = factory_.list();
           parser.report_error(CircusParseMessage.MSG_INVALID_CIRCUS_PARA_IN_ZED,
              new Object[] { "action level", "CIRCUSACTION" }, getLocation(zed, end));
        :}*/
        |
        ZED:zed circusBasicProcessMainAction:cbpma END:end
        {:
           RESULT = factory_.list();
           parser.report_error(CircusParseMessage.MSG_INVALID_CIRCUS_PARA_IN_ZED,
              new Object[] { "action level", "CIRCUSACTION" }, getLocation(zed, end));
        :}
</add:circus>
        |
        ZED:z error:e END
        {:
           parser.report_syntax_error();
           RESULT = factory_.list();
<add:oz>
           parserState_.resetIsOpExpr();
</add:oz>
        :}
        ;

unboxedParagraphItemList ::=
        unboxedParagraphItemList:uil NL unboxedParagraphItem:ui
        {:
           if (ui != null) uil.add(ui);
           RESULT = uil;
        :}
        |
        unboxedParagraphItem:ui
        {:
           RESULT = factory_.list();

           <add:circus>
           // for implicitly declared processes, add the implicit decl first
           if (ui instanceof ProcessPara)
           {
             addImplicitlyDeclaredProcPara(RESULT);
           }
           </add:circus>

           // This nullness result check is important for
           // consistency with the check above for lists.
           //
           // It is also important to avoid duplication
           // of Circus BasicPorcess declared across multiple
           // Circus environments.
           if (ui != null) RESULT.add(ui);
        :}
        ;

unboxedParagraphItem ::=
        <add:zeves>
        //optZNote:znote
        </add:zeves>
        basicTypeDefinition:btd
        {: RESULT = btd; :}
        |
        <add:zeves>
        //optZNote:znote
        </add:zeves>
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        |
        <add:zeves>
        //optZNote:znote
        </add:zeves>
        freeTypeList:ftl
        {:
           RESULT = factory_.createFreePara(ftl);
           addLocAnn(RESULT, getLocation(ftl.get(0), ftl.get(ftl.size() - 1)));
        :}
        |
        <add:zeves>optThmAbility:ability</add:zeves>
        THEOREM
        <add:zeves>optUsage:usage</add:zeves>
        name:n optNL optFormalParameters:ofp
        <add:zeves>
        //optZNote:znote
        </add:zeves>
        conjecture:c predicate:p

        // WARNING: ConjPara within ZED environment cannot accept ability (!) Only within THEOREM environment!
        {:
           // named conjectures in Unicode are a CZT extension of the Z standard.
           RESULT = factory_.createConjPara(ofp, p);
           RESULT.getAnns().add(n); // add it as an annotation for now.
           LocInfo loc = getLocation(getLocation(ofpleft, ofpright), getLocation(p));
           <add:zeves>
           if (c)
           {
            // if \vdash? is present, this is unlikely to be within Z/EVES,
            // but rather as part of a unboxedPara within ZED rather than THEOREM
            // raise a warning? or error? ERROR?
            CztLogger.getLogger(<class/>.class).warning(java.text.MessageFormat.format(
              ZEvesParseMessage.MSG_WARNING_VDASH_IN_CONJECTURE.getMessage(), n, loc)
              + " for " + getDialect().toString() + " in Parser.");
           }
           addZEvesLabel(RESULT, n, ability, usage);
           </add:zeves>
           addLocAnn(RESULT, loc);
           
           try
           {
             thmTable_.add((ConjPara)RESULT);
           }
           catch (ThmTable.ThmTableException e)
           {
             //final Symbol token = new Symbol(Sym.ZED, nleft, nright);
               parser.report_error(ZParseMessage.MSG_CANNOT_ADD_THM,
                                   new Object[] { e.getMessage() },
                                   getLocation(nleft, nright));
           }           
        :}
        |
        optFormalParameters:ofp CONJECTURE:c predicate:p
        {:
           // unnamed conjectures in Unicode, as in the Z standard.
           RESULT = factory_.createConjPara(ofp, p);
           addLocAnn(RESULT, getLocation(getLocation(ofpleft, ofpright), getLocation(p)));
        :}
        |
        operatorTemplate:ot
        {:
           try {
             opTable_.add(ot);
           }
           catch (OpTable.OperatorException e) {
             //final Symbol token = new Symbol(Sym.ZED, otleft, otright);
             parser.report_error(ZParseMessage.MSG_CANNOT_ADD_OP,
                                 new Object[] { e.getMessage() },
                                 getLocation(otleft, otright));
           }
           RESULT = ot;
        :}
<add:circus>
        /*
        |
        singleCircusParagraphItem:scpi
        {:
            RESULT = scpi;
            logProductionResult(RESULT, "CIRCUS-PARAGRAPH-ITEM-UNBOXED", getLocation(scpi));
        :}
        */
</add:circus>
        ;

conjecture ::=
        CONJECTURE:c
        {:
          RESULT = true;
        :}
        <add:zeves>
        |
        // empty is fine in Z/EVES
        {:
          RESULT = false;
        :}
        </add:zeves>
        ;

<add:zeves>
optThmAbility ::=
        DISABLEDTHMTAG
        {:
          RESULT = LabelAbility.disabled;
        :}
        |
        // empty
        {:
          RESULT = LabelAbility.none;
        :}
        ;

optDefAbility ::=
        DISABLEDDEFTAG
        {:
          RESULT = LabelAbility.disabled;
        :}
        |
        // empty
        {:
          RESULT = LabelAbility.none;
        :}
        ;

optLabelAbility ::=
        // "disabled" within \Label{ is overloaded by the "disabled" proof-keyword as well...
        DISABLED
        {:
          RESULT = LabelAbility.disabled;
        :}
        |
        // empty
        {:
          RESULT = LabelAbility.none;
        :}
        ;

optUsage ::=
        THMRULE
        {:
          RESULT = LabelUsage.rule;
        :}
        |
        THMFRULE
        {:
          RESULT = LabelUsage.frule;
        :}
        |
        THMGRULE
        {:
          RESULT = LabelUsage.grule;
        :}
        |
        THMAXIOM
        {:
          RESULT = LabelUsage.axiom;
        :}
        |
        // empty
        {:
          RESULT = LabelUsage.none;
        :}
        ;

// ZNote is generating out-of-memory errors... TODO:check later... Remove for now.
/*
optZNote ::=
        LZNOTE:lzn DECORWORD:note RZNOTE:rzn
        {:
          RESULT = factory_.createZEvesNote(note.toString());
          addLocAnn(RESULT, getLocation(lzn, rzn));
        :}
        |
        // empty
        {:
          RESULT = factory_.createZEvesNote();
        :}
        ;
*/
</add:zeves>


basicTypeDefinition ::=
        LSQUARE:lsq nameList:nl RSQUARE
        {:
           RESULT = factory_.createGivenPara(nl);
           addLocAnn(RESULT, getLocation(lsqleft, lsqright));
        :}
        ;

schema ::=
        SCH:sch
        <add:zeves>optDefAbility:ability</add:zeves>
        name:n optNL
        //optZStRefInfo:ozsi optNL
        schemaText:st END:end
        {:
           RESULT = factory_.createSchema(n, null, st);
           <add:zeves>addZEvesLabel(RESULT, n, ability);</add:zeves>
           addLocAnn(RESULT, getLocation(sch, end));
           //addZStateRefInfo(RESULT, ozsi, n);
        :}
        |
        GENSCH:gensch
        <add:zeves>optDefAbility:ability</add:zeves>
        name:n optNL 
        formalParameters:fp
        //optZStRefInfo:ozsi optNL
        schemaText:st END:end
        {:
           RESULT = factory_.createSchema(n, fp, st);
           <add:zeves>addZEvesLabel(RESULT, n, ability);</add:zeves>
           addLocAnn(RESULT, getLocation(gensch, end));
           //addZStateRefInfo(RESULT, ozsi, n);
        :}
        ;

/*
optZStRefInfo ::=
        ZSTATE
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.STATE);
        :}
        |
        ZSTINIT
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.STINIT);
        :}
        |
        ZSTFIN
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.STFIN);
        :}
        |
        ZASTATE
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.ASTATE);
        :}
        |
        ZASTINIT
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.ASTINIT);
        :}
        |
        ZCSTATE
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.CSTATE);
        :}
        |
        ZCSTINIT
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.CSTINIT);
        :}
        |
        ZASTFIN
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.ASTFIN);
        :}
        |
        ZCSTFIN
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.CSTFIN);
        :}
        |
        ZRETRIEVE
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.RETRIEVE);
        :}
        |
        ZRETRIEVEIN
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.RETRIEVEIN);
        :}
        |
        ZRETRIEVEOUT
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.RETRIEVEOUT);
        :}
        |
        ZAINITIN
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.AINITIN);
        :}
        |
        ZAFINOUT
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.AFINOUT);
        :}
        |
        ZCINITIN
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.CINITIN);
        :}
        |
        ZCFINOUT
        {:
           RESULT = factory_.createZStateAnn(ZStateInfo.CFINOUT);
        :}
        |
        ZFSREFINES name:abs
        {:
           RESULT = factory_.createZRefinesAnn(abs);
           ((ZRefinesAnn)RESULT).setRefKind(ZRefKind.FORWARD);
        :}
        |
        ZBSREFINES name:abs 
        {:
           RESULT = factory_.createZRefinesAnn(abs);
           ((ZRefinesAnn)RESULT).setRefKind(ZRefKind.BACKWARD);
        :}
        |
        // empty
        {:
           RESULT = null;
        :}
        ;
*/

<add:zeves>
zProof ::=
        ZPROOF:zp thmName:n //optNL
              proofScript:ps proofSep:zpc //optNL
              END:end
        {:
           //parserState_.addProofScript(n, RESULT);

           // resets the proof step counter at the beginning of a proof script
           factory_.getZEvesFactory().resetProofSteps();
           
           RESULT = factory_.createProofScript(n, ps);
           addLocAnn(RESULT, getLocation(zp, end));
           addToProofTable(RESULT, nleft, nright);

        :}
        |
        ZPROOF:zp thmName:n //optNL
              END:end
        {:
           RESULT = factory_.createProofScript(n, factory_.createProofCommandList());
           addLocAnn(RESULT, getLocation(zp, end));
           addToProofTable(RESULT, nleft, nright);
        :}
        ;

proofScript ::= 
        proofScript:ps proofSep:zpc proofCommand:pc
        {:
          ps.add(pc);
          RESULT = ps;
        :}
        |
        // last proof command separator just before end at top-level zProof production
        proofCommand:pc //proofSep:zpc
        {:
           RESULT = factory_.createProofCommandList(factory_.list(pc));
        :}
        ;

proofCommand ::=
        //optZNote:znote
        innerProofCommand:ipc
        {:
          RESULT = ipc;
          //addZNote(RESULT, znote);
          // LocAnn must be at the lower production (e.g., with more loc info, rather than here) - Andrius
          //addLocAnn(RESULT, getLocation(ipc));
        :}
        |
        printProofCommands:ppc
        {:
          RESULT = ppc;
        :}
        |
        undoingCommands:uc
        {:
          RESULT = uc;
        :}
        |
        interfaceCommands:ic
        {:
          RESULT = ic;
        :}
        |
        zsectionProofCommands:zpc
        {:
          RESULT = zpc;
        :}
        ;


printProofCommands ::=
        HELP name:n
        {:
        :}
        |
        PRINT DECLARATION name:n
        {:
        :}
        |
        PRINT FORMULA
        {:
        :}
        |
        PRINT HISTORY optSummary:s optNumber:n
        {:
        :}
        |
        PRINT PROOF optSummary:s
        {:
        :}
        |
        PRINT STATUS
        {:
        :}
        |
        PRINT SYNTAX name:n
        {:
        :}
        |
        optPrint:t THEOREMS ABOUT EXPRESSION expression:e
        {:
        :}
        |
        optPrint:t THEOREMS ABOUT PREDICATE predicate:p
        {:
        :}
        ;

undoingCommands ::=
        RESET
        {:
        :}
        |
        UNDO optNumber:n
        {:
        :}
        |
        UNDO BACK TO name:n
        {:
        :}
        |
        UNDO BACK THROUGH name:n
        {:
        :}
        |
        RETRY
        {:
        :}
        |
        TRY LEMMA thmName:n
        {:
        :}
        TRY predicate:p
        {:
        :}
        |
        SORRY:s
        {:
          RESULT = factory_.getZEvesFactory().createSorryCommand(false);
          addLocAnn(RESULT, getLocation(sleft, sright));
        :}
        |
        OOPS:s
        {:
          RESULT = factory_.getZEvesFactory().createSorryCommand(true);
          addLocAnn(RESULT, getLocation(sleft, sright));
        :}
        ;

interfaceCommands ::=
        CHECK DECORWORD:dw2
        {:
        :}
        |
        QUIT
        {:
        :}
        |
        READ optScript:s DECORWORD:dw2
        {:
        :}
        |
        ZTAGS thmNameList:tnl
        {:
        :}
        ;

        // or should this be thmNameList:nl?
zsectionProofCommands ::=
        DECLARE nameList:nl
        {:
        :}
        |
        DECLARE TO name:n
        {:
        :}
        |
        DECLARE THROUGH name:n
        {:
        :}
        |
        PARENT DECORWORD:dw
        {:
        :}
        |
        ZSECTION DECORWORD:path nameList:nl
        {:
        :}
        |
        // NOTE: Added this (spurious) production here to avoid the warning about
        // 	     PROOFWORD terminal, which needs to be declared, but was never used
        //		 by the Parser; it's used by the ContextFreeScanner and SmartScanner.
        PROOFWORD:dw
        {:
	        parser.report_error(ZEvesParseMessage.MSG_UNHANDLED_PROOFWORD,
                               new Object[] { dw.toString() }, dw.getLocation());
                               // error should be fatal, but that's okay. Just return NULL.
        :}
        ;
        
optScript ::=
        SCRIPT:s
        {:
          RESULT = s;
        :}
        |
        // empty
        {:
          RESULT = null;
        :}
        ;

optPrint ::=
        PRINT:p
        {:
          RESULT = p;
        :}
        |
        // empty
        {:
          RESULT = null;
        :}
        ;

optSummary ::=
        SUMMARY:s
        {:
          RESULT = s;
        :}
        |
        // empty
        {:
          RESULT = null;
        :}
        ;

optNumber ::=
        NUMERAL:n
        {:
          RESULT = n;
        :}
        |
        // empty
        {:
          RESULT = null;
        :}
        ;

innerProofCommand ::=
        applyCommand:acm 
        {:
          RESULT = acm;
        :}
        |
        caseAnalysisCommand:cam
        {:
          RESULT = cam;
        :}
        |
        normalizationCommand:nm
        {:
          RESULT = nm;
        :}
        |
        quantifiersCommand:qm
        {:
          RESULT = qm;
        :}
        |
        simplificationCommand:sm
        {:
          RESULT = sm;
        :}
        |
        substitutionCommand:tm
        {:
          RESULT = tm;
        :}
        |
        useCommand:um
        {:
          RESULT = um;
        :}
        |
        withCommand:wm
        {:
          RESULT = wm;
        :}
        ;

applyCommand ::=
        // TODO: generalise this to  "getProofStepKind(RESULT)" and have a "switch" in there for
        //       some user defined complexity rather than my own fixed?
        //
        // TODO: perhaps we can leave this THMNAME as just DECORWORD. In ContextFreeScanner I substitute
        //       the incoming DECORWORD accordingly to THMNAME, but I impose no restriction on the name
        APPLY:ap applyThmName:n TO EXPRESSION expression:e
        {:
          //checkValidTheoremName(n);
          RESULT = factory_.getZEvesFactory().createApplyToExprCommand(n, e);
          addLocAnn(RESULT, getLocation(ap, e));
          //proofScripts_.countStep(RESULT, ProofStep.COMPLEX, ProofScope.LOCAL);
        :}
        |
        APPLY:ap applyThmName:n TO PREDICATE predicate:p
        {:
          //checkValidTheoremName(n);
          RESULT = factory_.getZEvesFactory().createApplyToPredCommand(n, p);
          addLocAnn(RESULT, getLocation(ap, p));
          //proofScripts_.countStep(RESULT, ProofStep.COMPLEX, ProofScope.LOCAL);
        :}
        |
        // in ContextFreeScanner, this case isn't easy to "catch"!
        APPLY:ap applyThmName:n
        {:
          //checkValidTheoremName(n);
          RESULT = factory_.getZEvesFactory().createGlobalApplyCommand(n);
          addLocAnn(RESULT, getLocation(ap, getLocation(n)));
          //proofScripts_.countStep(RESULT, ProofStep.MEDIUM, ProofScope.GLOBAL);
        :}
        ;

caseAnalysisCommand ::=
        CASES:cam
        {:
          RESULT = factory_.getZEvesFactory().createCasesCommand();
          addLocAnn(RESULT, cam);
          //proofScripts_.countStep(RESULT, ProofStep.TRIVIAL, ProofScope.GLOBAL);
        :}
        |
        NEXT:cam
        {:
          RESULT = factory_.getZEvesFactory().createNextCommand();
          addLocAnn(RESULT, cam);
          //proofScripts_.countStep(RESULT, ProofStep.TRIVIAL, ProofScope.GLOBAL);
        :}
        |
        // split pred;
        SPLIT:cam predicate:p
        {:
          RESULT = factory_.getZEvesFactory().createSplitCommand(p);
          addLocAnn(RESULT, getLocation(cam, p));
          //proofScripts_.countStep(RESULT, ProofStep.MEDIUM, ProofScope.GLOBAL);
        :}
        ;
//              cases  : Kind=Cases and P == null
//              next   : Kind=Next  and P == null
//              split P: Kind=Split and P != null

normalizationCommand ::=
        CONJUNCTIVE:nc
        {:
          RESULT = factory_.getZEvesFactory().createConjunctiveCommand();
          addLocAnn(RESULT, nc);
          //proofScripts_.countStep(RESULT, ProofStep.UNUSUAL, ProofScope.GLOBAL);
        :}
        |
        DISJUNCTIVE:nc
        {:
          RESULT = factory_.getZEvesFactory().createDisjunctiveCommand();
          addLocAnn(RESULT, nc);
          //proofScripts_.countStep(RESULT, ProofStep.UNUSUAL, ProofScope.GLOBAL);
        :}
        |
        REARRANGE:nc
        {:
          RESULT = factory_.getZEvesFactory().createRearrangeCommand();
          addLocAnn(RESULT, nc);
          //proofScripts_.countStep(RESULT, ProofStep.SIMPLE, ProofScope.GLOBAL);
        :}
        |
        WITH:w NORMALIZATION:n innerProofCommand:ipc
        {:
          RESULT = factory_.getZEvesFactory().createWithNormalizationCommand(ipc);
          addLocAnn(RESULT, getLocation(w, ipc));
          //proofScripts_.countStep(RESULT, ProofStep.MEDIUM, getProofScope(ipc));
        :}
        ;
//            conjunctive: Kind==Conjuncture and CMD == null
//            disjunctive: Kind==Disjunctive and CMD == null
//            rearrange  : Kind==Rearranghe  and CMD == null
//            with normalization CMD: Kind==Command and CMD != null


quantifiersCommand ::=
        PRENEX:p
        {:
          RESULT = factory_.getZEvesFactory().createPrenexCommand();
          addLocAnn(RESULT, p);
          //proofScripts_.countStep(RESULT, ProofStep.TRIVIAL, ProofScope.GLOBAL);
        :}
        |
        INSTANTIATE:i instantiations:inst
        {:
          assert !inst.isEmpty();
          RESULT = factory_.getZEvesFactory().createInstantiateCommand(inst);
          addLocAnn(RESULT, getLocation(i, inst));
          //proofScripts_.countStep(RESULT, ProofStep.COMPLEX, ProofScope.GLOBAL); // or is it local? to a quantifier?
        :}
        ;
//          prenex     : InstList = null or empty
//          instantiate: InstList != null and != empty

instantiations ::=
        instantiationList:il
        {:
          RESULT = il;
          //checkInstantiationListConsistency(il);
          addLocAnn(il, getLocation(il.get(0), il.get(il.size() - 1)));
        :}
        ;

instantiationList ::=
        instantiationList:il COMMA instantiation:i
        {:
           il.add(i);
           RESULT = il;
        :}
        |
        instantiation:i
        {:
           RESULT = factory_.createInstantiationList();
           RESULT.add(i);
        :}
        ;

instantiation ::=
        // use invoke name because we could have instantiation of operator names
        // as quantified names.
        refName:n THMREPLACEMENT expression:e // instOrRepl:isQtn zevesRenaming:e
        {:
           RESULT = factory_.createInstantiation(n, e, InstantiationKind.ThmReplacement);
           addLocAnn(RESULT, getLocation(n, e));
        :} // DIDN'T SOLVE CONFLICT BELOW FOR zevesRenaming production.
           // %prec _RENAME
        |
        refName:n QNTINSTANTIATION expression:e
        {:
           RESULT = factory_.createInstantiation(n, e, InstantiationKind.Quantifier);
           addLocAnn(RESULT, getLocation(n, e));
        :}
        ;

//zevesRenaming ::=
       // expression:e
        //{:
        //  RESULT = e;
        //:}
        // CONFLICTS!  TODO: won't accepted mixed renamings for now.. (e.g., THETA S[x := 10, a/y]; use THETA S[x:= 10, y := a]).
        //|
        //DECORWORD:n
        //refName:n
        //name:n
        //????
        //{:
        //  RESULT = createRefExpr(n);
        //:}
        //;

//instOrRepl ::=
        //DEFEQUAL
        //{:
        //  RESULT = true;
        //:}
        //|
        //THMREPLACEMENT
        //{:
        //  RESULT = false;
        //:}
        //|
        // for when we have mixed renaming like: THETA S[x := 10, a/y] (both are THMREPLACEMENT kind)
        //SLASH
        //{:
        //  RESULT = false;
        //:}
        //;

simplificationCommand ::=
        PROVE:cmd BY innerSimplCmd:isc
        {:
          ProofCommand pc = null;
          switch ((RewriteKind) isc[0])
          {
            case Simplify:
            // TODO: add an error case here, actually
              pc = factory_.getZEvesFactory().createProveBySimplifyCommand();
              break;
            case Rewrite:
              pc = factory_.getZEvesFactory().createProveByRewriteCommand();
              break;
            case Reduce:
              pc = factory_.getZEvesFactory().createProveByReduceCommand();
              break;
            default:
              throw new Error("invalid proof command rewrite kind " + isc[0] +
              	 "(for dialect " + getDialect().toString() + " in Parser)."
              );
          }
          RESULT = pc;
          addLocAnn(RESULT, getLocation(cmd, (LocInfo) isc[1]));
          //proofScripts_.countStep(RESULT, ProofStep.TRIVIAL, ProofScope.GLOBAL);
        :}
        |
        TRIVIAL:cmd innerSimplCmd:isc
        {:
          ProofCommand pc = null;
          switch ((RewriteKind) isc[0])
          {
            case Simplify:
              pc = factory_.getZEvesFactory().createTrivialSimplifyCommand();
              break;
            case Rewrite:
              pc = factory_.getZEvesFactory().createTrivialRewriteCommand();
              break;
            case Reduce:
            // TODO: add an error case here, actually
              pc = factory_.getZEvesFactory().createTrivialReduceCommand();
              break;
            default:
              throw new Error("invalid proof command rewrite kind " + isc[0]+
              	 "(for dialect " + getDialect().toString() + " in Parser)."
              );
          }
          RESULT = pc;
          addLocAnn(RESULT, getLocation(cmd, (LocInfo) isc[1]));
          //proofScripts_.countStep(RESULT, ProofStep.MEDIUM, ProofScope.GLOBAL);
        :}
        |
        innerSimplCmd:isc
        {:
          ProofCommand pc = null;
          switch ((RewriteKind) isc[0])
          {
            case Simplify:
              pc = factory_.getZEvesFactory().createSimplifyCommand();
              break;
            case Rewrite:
              pc = factory_.getZEvesFactory().createRewriteCommand();
              break;
            case Reduce:
              pc = factory_.getZEvesFactory().createReduceCommand();
              break;
            default:
              throw new Error("invalid proof command rewrite kind " + isc[0]+
              	 "(for dialect " + getDialect().toString() + " in Parser)."
              );
          }
          RESULT = pc;
          addLocAnn(RESULT, (LocInfo) isc[1]);
          //proofScripts_.countStep(RESULT, ProofStep.SIMPLE, ProofScope.GLOBAL);
        :}
        |  
        // unqualified "prove" command is "by rewrite" in Z/EVES
        PROVE:cmd
        {:
          RESULT = factory_.getZEvesFactory().createProveByRewriteCommand();
          addLocAnn(RESULT, cmd);
          //proofScripts_.countStep(RESULT, ProofStep.TRIVIAL, ProofScope.GLOBAL);
        :}
        ;

innerSimplCmd ::=
        SIMPLIFY:cmd
        {:
          RESULT = new Object[] { RewriteKind.Simplify, cmd };
        :}
        |
        REWRITE:cmd
        {:
          RESULT = new Object[] { RewriteKind.Rewrite, cmd };
        :}
        |
        REDUCE:cmd
        {:
          RESULT = new Object[] { RewriteKind.Reduce, cmd };
        :}
        ;

substitutionCommand ::=
        EQUALITY:st SUBSTITUTE expression:e
        {:
          RESULT = factory_.getZEvesFactory().createEqualitySubstituteCommand(e);
          addLocAnn(RESULT, getLocation(st, e));
          //proofScripts_.countStep(RESULT, ProofStep.SIMPLE, ProofScope.LOCAL);
        :}
        |
        EQUALITY:st SUBSTITUTE:end
        {:
          RESULT = factory_.getZEvesFactory().createGlobalEqualitySubstituteCommand();
          addLocAnn(RESULT, getLocation(st, end));
          //proofScripts_.countStep(RESULT, ProofStep.SIMPLE, ProofScope.GLOBAL);
        :}
        |
        INVOKE:st PREDICATE predicate:p
        {:
          RESULT = factory_.getZEvesFactory().createInvokePredicateCommand(p);
          addLocAnn(RESULT, getLocation(st, p));
          //proofScripts_.countStep(RESULT, ProofStep.MEDIUM, ProofScope.LOCAL);
        :}
        |
        // includes both names and opNames parenthesised 
        INVOKE:st refName:n
        {:
          RESULT = factory_.getZEvesFactory().createInvokeCommand(n);
          addLocAnn(RESULT, getLocation(st, n));
          //proofScripts_.countStep(RESULT, ProofStep.SIMPLE, ProofScope.LOCAL);
        :}
        |
        INVOKE:st
        {:
          RESULT = factory_.getZEvesFactory().createGlobalInvokeCommand();
          addLocAnn(RESULT, st);
          //proofScripts_.countStep(RESULT, ProofStep.SIMPLE, ProofScope.GLOBAL);
        :}
        ;
//          equality substitute [Expr]: Pred = null and Name = null and (Expr != null or EQ)  [global eq subst]
//          invoke predicate Pred     : Expr = null and Name = null and Pred != null
//          invoke [Name]             : Expr = null and Pred = null and (Name != null or INVOKE) [global invoke]


// Keep the productions separate, otherwise, if I use optXXX there is a lookahead problem for "use name[x:=10]"
// to know whether the replacement is generic actual or not.
useCommand ::=
        // TODO: for use, should we allow the $ names? Perhaps not, given they are always rules?! No: use S\$declaration is common!
        USE:u thmName:thmN genericActuals:ga replacements:repl //optGenActuals:ga optReplacements:repl
        {:
          //checkValidTheoremName(thmN);
                                                          // if ga is not empty, then create an "explicit" RefExpr; an normal one (e.g., createRefExpr(thmN)) otherwise.
          RESULT = factory_.getZEvesFactory().createUseCommand(
                      factory_.createRefExpr(thmN, ga, Boolean.FALSE, !ga.isEmpty()), repl);
          addLocAnn(RESULT, getLocation(u, repl));
          //proofScripts_.countStep(RESULT, ProofStep.COMPLEX, ProofScope.GLOBAL);
        :}
        |
        USE:u thmName:thmN replacements:repl
        {:
          //checkValidTheoremName(thmN);
          RESULT = factory_.getZEvesFactory().createUseCommand(factory_.createRefExpr(thmN), repl);
          addLocAnn(RESULT, getLocation(u, repl));
          //proofScripts_.countStep(RESULT, ProofStep.COMPLEX, ProofScope.GLOBAL);
        :} // No need ? %  p r e c _RENAME
        |
        USE:u thmName:thmN genericActuals:ga
        {:
          //checkValidTheoremName(thmN);
          RESULT = factory_.getZEvesFactory().createUseCommand(
                      factory_.createRefExpr(thmN, ga, Boolean.FALSE, Boolean.TRUE));
          addLocAnn(RESULT, getLocation(u, ga));
          //proofScripts_.countStep(RESULT, ProofStep.COMPLEX, ProofScope.GLOBAL);
        :}
        |
        USE:u thmName:thmN
        {:
          //checkValidTheoremName(thmN);
          RESULT = factory_.getZEvesFactory().createUseCommand(factory_.createRefExpr(thmN));
          addLocAnn(RESULT, getLocation(u, thmN));
          //proofScripts_.countStep(RESULT, ProofStep.MEDIUM, ProofScope.GLOBAL);
        :}
        ;
       
genericActuals ::=
        LSQUARE:ls expressionList:el RSQUARE:rs
        {:
           RESULT = el;
           addLocAnn(RESULT, getLocation(ls, rs));
        :}
        ;


replacements ::=
        LSQUARE:ls instantiationList:rl RSQUARE:rs
        {:
          RESULT = rl;
          addLocAnn(rl, getLocation(ls, rs));
        :}
        ;

/*optGenActuals ::=
        genericActuals:ga
        {:
          RESULT = ga;
        :}
        |
        //empty
        {:
          RESULT = factory_.createZExprList();
        :}
        ;

optReplacements ::=
        replacements:r
        {:
          RESULT = r;
        :}
        |
        // empty
        {:
          RESULT = factory_.createInstantiationList();
        :}
        ;
        */

// TODO: call these something else because "with normalization" is not here?
withCommand ::=
        WITH:w EXPRESSION LPAREN expression:e RPAREN innerProofCommand:ipc
        {:
          RESULT = factory_.getZEvesFactory().createWithExpressionCommand(e, ipc);
          addLocAnn(RESULT, getLocation(w, ipc));
          //proofScripts_.countStep(RESULT, ProofStep.MEDIUM, ProofScope.LOCAL);
        :}
        |
        WITH:w PREDICATE LPAREN predicate:p RPAREN innerProofCommand:ipc
        {:
          RESULT = factory_.getZEvesFactory().createWithPredicateCommand(p, ipc);
          addLocAnn(RESULT, getLocation(w, ipc));
          //proofScripts_.countStep(RESULT, ProofStep.MEDIUM, ProofScope.LOCAL);
        :}
        |
        WITH:w ENABLED LPAREN thmNameList:nl RPAREN innerProofCommand:ipc
        {:
          RESULT = factory_.getZEvesFactory().createWithEnabledCommand(nl, ipc);
          addLocAnn(RESULT, getLocation(w, ipc));
          //proofScripts_.countStep(RESULT, ProofStep.MEDIUM, getProofScope(ipc));
        :}
        |
        WITH:w DISABLED LPAREN thmNameList:nl RPAREN innerProofCommand:ipc
        {:
          RESULT = factory_.getZEvesFactory().createWithDisabledCommand(nl, ipc);
          addLocAnn(RESULT, getLocation(w, ipc));
          //proofScripts_.countStep(RESULT, ProofStep.MEDIUM, getProofScope(ipc));
        :}
        ;
//      with expression E cmd : Expr != null and Pred = null and NameList = empty and Cmd != null
//      with predicate P cmd  : Expr  = null and Pred = null and NameList = empty and Cmd = null
//      with enabled NL cmd   : Expr  = null and Pred = null and NameLisst != empty and Cmd != null (same for disabled)

proofSep ::=
        // do nothing
        ZPROOFCOMMANDSEP:zpc //optNL
        {:
          RESULT = zpc;
        :}
        ;


applyThmName ::=
        //THMNAME:dw1 ZPROOFDOLLAR:d DECORWORD:dw2
        //{:
        //   RESULT = createSpecialThmName(dw1, dw2);
        //:}
        //|
        THMNAME:dw
        {:
           RESULT = createZName(dw);
        :}
        ;

thmName ::=
        // special name from axiomatic/schema declarations
        // the issue here is that "DECLARATION" is a reserved 
        // word ("print declaration X"), hence doesn't gets
        // tokenised as DECORWORD(!)
        // ex. f\$declaration, S\$declaration
        //DECORWORD:dw1 ZPROOFDOLLAR:d DECLARATION:dcl
        //{:
        //   RESULT = createSpecialThmName(dw1, new Decorword(ZEvesString.DECLARATION, dcl));
        //:}
        //|
        //// NAME$domainCheck
        //DECORWORD:dw1 ZPROOFDOLLAR:d DECORWORD:dw2
        //{:
        //   RESULT = createSpecialThmName(dw1, dw2);
        //:}
        //|
        //// unammed$ni$domainCheck
        //DECORWORD:dw1 ZPROOFDOLLAR DECORWORD:dw2 ZPROOFDOLLAR DECORWORD:dw3
        //{:
        //   RESULT = createSpecialThmName(dw1, dw2, dw3);
        //:}
        //|
        DECORWORD:dw
        {:
           RESULT = createZName(dw);
        :}
        |
        opName:on
        {:
           final LocInfo loc = getLocation(onleft, onright);
           RESULT = strListToZName(on, loc);
           RESULT.getAnns().add(factory_.createParenAnn());
        :}
        ;

thmNameList ::=
        thmNameList:nl COMMA thmName:n
        {:
           nl.add(n);
           RESULT = nl;
        :}
        |
        thmName:n
        {:
           RESULT = factory_.createZNameList();
           RESULT.add(n);
        :}
        ;
</add:zeves>

genericAxDefinition ::=
        GENAX:genax formalParameters:fp axiomaticSchemaText:st END:end
        {:
           RESULT = factory_.createAxPara(fp, st, Box.AxBox);
           <add:zeves>
           parserState_.clearLabelPredList();
           </add:zeves>
           addLocAnn(RESULT, getLocation(genax, end));
        :}
        ;

optFormalParameters ::=
        formalParameters:fp
        {: RESULT = fp; :}
        |
        //empty
        {: RESULT = factory_.createZNameList(); :}
        ;

formalParameters ::=
        LSQUARE nameList:nl RSQUARE optNL
        {: RESULT = nl; :}
        ;

axiomaticDefinition ::=
        AX:ax axiomaticSchemaText:st END:end
        {:
           ZNameList zdnl = factory_.createZNameList();
           RESULT = factory_.createAxPara(zdnl, st, Box.AxBox);
           <add:zeves>
           parserState_.clearLabelPredList();
           </add:zeves>
           addLocAnn(RESULT, getLocation(ax, end));
        :}
        ;

//according to the Z ISO standard, an abbreviation definition is to be
//treated as an axiomatic definition, with ConstDecl(dn,e)
abbreviationDefinition ::=
        declName:dn DEFEQUAL:equal expression:e
        {:
           ConstDecl cd = factory_.createConstDecl(dn, e);
           addLocAnn(cd, getLocation(equalleft, equalright, dn, e));
           ZDeclList decls = factory_.createZDeclList();
           decls.add(cd);
           ZSchText st = factory_.createZSchText(decls, null);
           addLocAnn(st, getLocation(dn, e));
           ZNameList zdnl = factory_.createZNameList();
           RESULT = factory_.createAxPara(zdnl, st, Box.OmitBox);
           addLocAnn(RESULT, getLocation(dn, e));
        :}
        |
        //TODO: check this. Should be name:n, but the toolkit won't parse
        //"\langle \listarg \rangle [X] == .... without this
        declName:dn formalParameters:fp DEFEQUAL:equal expression:e
        {:
           ConstDecl cd = factory_.createConstDecl(dn, e);
           addLocAnn(cd, getLocation(equalleft, equalright, dn, e));
           ZDeclList decls = factory_.createZDeclList();
           decls.add(cd);
           ZSchText st = factory_.createZSchText(decls, null);
           addLocAnn(st, getLocation(cd, e));
           RESULT = factory_.createAxPara(fp, st, Box.OmitBox);
           addLocAnn(RESULT, getLocation(dn, e));
        :}
        |
        genName:gn DEFEQUAL:equal expression:e
        {:
           Name dn = gn.getFirst();
           LocInfo dnLoc = dn != null ?
             getLocation(dn) : getLocation(gnleft, gnright);
           ZNameList fp = gn.getSecond();
           ConstDecl cd = factory_.createConstDecl(dn, e);
           LocInfo eLoc = getLocation(e);
           addLocAnn(cd, getLocation(equalleft, equalright, dnLoc, eLoc));
           ZDeclList decls = factory_.createZDeclList();
           decls.add(cd);
           ZSchText st = factory_.createZSchText(decls, null);
           addLocAnn(st, getLocation(dnLoc, eLoc));
           RESULT = factory_.createAxPara(fp, st, Box.OmitBox);
           addLocAnn(RESULT, getLocation(dnLoc, eLoc));
        :}
        ;


freeTypeList ::=
        freeTypeList:ftl ANDALSO freeTypeDefinition:ftd
        {:
           ftl.add(ftd);
           RESULT = ftl;
        :}
        |
        freeTypeDefinition:ftd
        {:
           RESULT = factory_.createZFreetypeList();
           RESULT.add(ftd); :}
        ;

freeTypeDefinition ::=
        name:n DEFFREE:deffree branchList:bl
        {:
           RESULT = factory_.createFreetype(n, bl);
           addLocAnn(RESULT, getLocation(deffreeleft, deffreeright,
                                         n, bl.get(bl.size() - 1)));
        :}
        ;

branchList ::=
        branchList:bl BAR branch:b
        {:
           bl.add(b);
           RESULT = bl;
        :}
        |
        branch:b
        {:
           RESULT = factory_.createZBranchList();
           RESULT.add(b); :}
        ;

branch ::=
        declName:dn
        {:
           RESULT = factory_.createBranch(dn, null);
           addLocAnn(RESULT, getLocation(dn));
        :}
        |
        declName:dn LDATA expression:e RDATA:rdata
        {:
           RESULT = factory_.createBranch(dn, e);
           addLocAnn(RESULT, getLocation(dn, rdata));
        :}
        ;

narrWordList ::=
        narrWordList:nwl TEXT:t
        {:
           nwl.add(t);
           RESULT = nwl;
        :}
        |
        TEXT:t
        {: RESULT = factory_.list(t); :}
        ;

// operator templates  /////////////////////////////////////////////////////

operatorTemplate ::=
        RELATION:rel template:t
        {:
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(t);
           RESULT.setCat(Cat.Relation);
           addLocAnn(RESULT, getLocation(relleft, relright));
        :}
        |
        FUNCTION:fun catTemplate:ct
        {:
           ct.setCat(Cat.Function);
           addLocAnn(ct, getLocation(funleft, funright));
           RESULT = ct;
        :}
        |
        GENERIC:g catTemplate:ct
        {:
           ct.setCat(Cat.Generic);
           addLocAnn(ct, getLocation(gleft, gright));
           RESULT = ct;
        :}
        ;

template ::=
        prefixTemplate:pt
        {: RESULT = pt; :}
        |
        postfixTemplate:pt
        {: RESULT = pt; :}
        |
        infixTemplate:it
        {: RESULT = it; :}
        |
        nofixTemplate:nt
        {: RESULT = nt; :}
        ;


catTemplate ::=
        prefixTemplate:pt
        {:
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(pt);
        :}
        |
        postfixTemplate:pt
        {:
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(pt);
        :}
        |
        NUMERAL:pr assoc:a infixTemplate:it
        {:
           RESULT = factory_.createOptempPara();
           RESULT.setPrec(pr.getValue());
           RESULT.getOper().addAll(it);
           RESULT.setAssoc(a);
        :}
        |
        nofixTemplate:nt
        {:
           RESULT = factory_.createOptempPara();
           RESULT.getOper().addAll(nt);
        :}
        ;


assoc ::=
        LEFTASSOC
        {: RESULT = Assoc.Left; :}
        |
        RIGHTASSOC
        {: RESULT = Assoc.Right; :}
        ;


prefixTemplate ::=
        LPAREN DECORWORD:n optWordOperandList:ol varg:v RPAREN
        {:
           ol.add(0, createOperator(n));
           ol.add(v);
           RESULT = ol;
        :}
	|
	LPAREN POWER:p varg:v RPAREN
	{:
           RESULT = factory_.list(createOperator(ZString.POWER, p), v);
	:}
        ;


postfixTemplate ::=
        LPAREN varg:v DECORWORD:n optWordOperandList:ol RPAREN
        {: 
           ol.add(0, createOperator(n));
           ol.add(0, v);
           RESULT = ol;
        :}
        ;


infixTemplate ::=
        LPAREN varg:v1 DECORWORD:n optWordOperandList:ol varg:v2 RPAREN
        {:
           ol.add(0, createOperator(n));
           ol.add(0, v1);
           ol.add(v2);
           RESULT = ol;
        :}
        ;


nofixTemplate ::=
        LPAREN DECORWORD:n optWordOperandList:ol RPAREN:rp
        {:
           if (ol.size() &lt; 1) {
             parser.report_error(ZParseMessage.MSG_UNEXPECTED_TOKEN,
                                 new Object[] {"RPAREN"},
                                 getLocation(rpleft, rpright));
           }
           ol.add(0, createOperator(n));
           RESULT = ol;
        :}
        ;


optWordOperandList ::=
        //empty
        {: RESULT = factory_.list(); :}
        |
        optWordOperandList:wl templateTag:t DECORWORD:n
        {:
           wl.add(t);
           wl.add(createOperator(n));
           RESULT = wl;
        :}
        ;

templateTag ::=
        varg:v
        {: RESULT = v; :}
        |
        LISTARG:listarg
        {: RESULT = factory_.createOperand(Boolean.TRUE); :}
        ;

varg ::=
        ARG:arg
        {: RESULT = factory_.createOperand(Boolean.FALSE); :}
        ;

<add:circus>

// Main entry as a Circus unboxed paragraph ////////////////////////////////

/**
 * These paragraphs encompass all Circus paragraphs across multiple
 * Circus environments, except BasicProcess.
 */
circusMultiEnvParagraphList ::=
        CIRCUS:circ singleCircusParagraphItemList:ppl END:end
        {:
           RESULT = ppl;
           //logProductionResult(RESULT, "CIRCUS-PARAGRAPH-ITEM-LIST", getLocation(circ, end));
        :}
        |
        CIRCUSACTION:circ circusInnerProcParaList:ppl END:end
        {:
           ensureInnerProcParaListKnownInBasicProcessScope(ppl, "MULTIPLE ENV", getLocation(circ, end));

           // Result here does not matter. It will be collected later via ParserState
           RESULT = factory_.list();
        :}
        |
        CIRCUSACTION:circ circusBasicProcessMainAction:cbpma END:end
        {:
            final String from = "JUST MAINACTION - MULTIPLE ENVIRONMENT";
            // If exit fails, a warning is mentioned, not an error,
            // exitBasicProcessScope(from, getLocation(circ, cbpma));

            // Result here is the current process that was on scope.
            RESULT = factory_.list();
        :}
        ;

singleCircusParagraphItemList ::=
        singleCircusParagraphItemList:cpl NL singleCircusParagraphItem:cpi
        {:
           if (cpi != null) cpl.add(cpi);
           RESULT = cpl;
        :}
        |
        singleCircusParagraphItem:cpi
        {:
           RESULT = factory_.list();

           <add:circus>
           // for implicitly declared processes, add the implicit decl first
           if (cpi instanceof ProcessPara)
           {
             addImplicitlyDeclaredProcPara(RESULT);
           }
           </add:circus>

           // This nullness result check is important for
           // consistency with the check above for lists.
           //
           // It is also important to avoid duplication
           // of Circus BasicPorcess declared across multiple
           // Circus environments.
           //
           // see unboxedParagraphItem
           if (cpi != null) {
             RESULT.add(cpi);
             logProductionResult(RESULT, "CIRCUS-PARAGRAPH-ITEM-SINGLE-ENV", getLocation(cpi));
           }
        :}
        ;

/**
 * These items represent global paragraphs (possibly within a single circus environment).
 * They are process, refinement, channel, and chennel set declarations.
 */
singleCircusParagraphItem ::=
        channelPara:cp
        {: RESULT = cp; :}
        |
        channelSetPara:csp
        {: RESULT = csp; :}
        |
        processPara:pp
        {: RESULT = pp; :}
        |
        processRefPara:rp
        {: RESULT = rp; :}
        ;

/**
 * List of inner process paragraphs for Circus.
 * As we could muliple items, NL is always needed between paragraphs.
 * For now, this excludes Z boxed paragraphs (AXDEF, GAXDEF, SCH, and GSCH).
 * That is because we need to fiddle with the Latex2Unicode scanner for that effect.
 */
circusInnerProcParaList ::=
        circusInnerProcParaList:ipl NL circusInnerProcPara:ip
        {:
           if (ip != null) ipl.add(ip);
           RESULT = ipl;
        :}
        |
        circusInnerProcPara:ip
        {: RESULT = factory_.list(ip); :}
        /*|
        // empty
        {: RESULT = factory_.list(); :}*/
        ;

/**
 * These are all the productions that can occur within a BasicProcess scope.
 *
 */
circusInnerProcPara ::=
        /* Allow these repeated unboxedParagrahItem productions here so
         * that singled circus-environment basic-processes can be defined.
         * Note that there is no room for boxedParagraph (which is fine).
         */
        basicTypeDefinition:gtd
        {:
            RESULT = gtd;
            // raise a scoping warning if needed
            addBasicProcessScopePostCheckFor("a local given set", getLocation(gtd));
            parserState_.addLocallyDeclPara(RESULT);
        :}
        |
        freeTypeList:ftl
        {:
           LocInfo loc = getLocation(ftl.get(0), ftl.get(ftl.size() - 1));
           RESULT = factory_.createFreePara(ftl);
           addLocAnn(RESULT, loc);
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("a local free type list", loc);
           parserState_.addLocallyDeclPara(RESULT);
        :}
        |
        abbreviationDefinition:ad
        {:
           RESULT = ad;
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("a local abbreviation", getLocation(ad));
           parserState_.addLocallyDeclPara(RESULT);
        :}
        |
        THEOREM name:n optNL optFormalParameters:ofp CONJECTURE:c predicate:p
        {:
           LocInfo loc = getLocation(c, p);
           RESULT = factory_.createConjPara(ofp, p);
           RESULT.getAnns().add(n); // add it as an annotation for now.
           addLocAnn(RESULT, loc);
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("a local named conjecture " + n, loc);
           parserState_.addLocallyDeclPara(RESULT);
        :}
        |
        optFormalParameters:ofp CONJECTURE:c predicate:p
        {:
           LocInfo loc = getLocation(c, p);
           RESULT = factory_.createConjPara(ofp, p);
           addLocAnn(RESULT, loc);
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("a local conjecture", loc);
           parserState_.addLocallyDeclPara(RESULT);
        :}
        /*| DO NOT ALLOW LOCAL OPERATOR TEMPLATES? UNRESOLVED ISSUE IN Circus GRAMMAR
        // TODO:DESIGN: come back here and include appropriate code for ProcessTable
        operatorTemplate:ot
        {:
           //try {
           //  opTable_.add(ot);
           //}
           //catch (OpTable.OperatorException e) {
           //  final Symbol token = new Symbol(Sym.ZED, otleft, otright);
           //  parser.report_error(ZParseMessage.MSG_CANNOT_ADD_OP,
           //                      new Object[] { e.getMessage() },
           //                      getLocation(ot));
           //}
           LocInfo loc = getLocation(ot);
           RESULT = ot;
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("a local operator template", loc);
           parserState_.addLocallyDeclPara(RESULT);

           parser.report_error(CircusParseMessage.MSG_NOT_IMPLEMENTED,
              new Object[] { "Basic process operator template" }, loc);
        :}*/
        |
        circusProcessState:cps
        {:
           RESULT = cps;
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("process state", getLocation(cps));

           // no need to add to local paragraphs, see circusProcessState
           // production: state could be a local paragraph or implicitly declared
        :}
        |
        namesetPara:np
        {:
           RESULT = np;
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("name set paragraph", getLocation(np));
           parserState_.addLocallyDeclPara(RESULT);
        :}
        |
        actionPara:ap
        {:
           RESULT = ap;
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("action paragraph", getLocation(ap));

           // check whether this is already recorded as implicitly declared
           if (!parserState_.isImplicitlyDeclaredActionPara(ap)) {
               parserState_.addLocallyDeclPara(RESULT);
           }
        :}
        |
        actionRefPara:rp
        {:
           RESULT = rp;
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("action refinement paragraph", getLocation(rp));
           parserState_.addLocallyDeclPara(RESULT);
        :}
        /*
        |
        // This production seems to never occur since paragraphList at the
        // section level always captures it first. Anyway, both places are
        // covered. Perhaps we could remove this production later.
        narrParagraph:np
        {:
           //System.out.println("KEEP-PRODUCTION-?");
           RESULT = np;
           // raise a scoping warning if needed
           addBasicProcessScopePostCheckFor("narrative paragraph @ circusInnerProcPara", getLocation(np));
           parserState_.addLocallyDeclPara(RESULT);
        :}
        */
        ;

/// Circus declaration list (no opName) ////////////////////////////////

/*
 * Used where declWordList should be used, but no operator templates are allowed,
 * such as channelDecl, circus qualified parameters, or variable declarations.
 * Also, to avoid confusion and problems with communication fields, we also do not
 * allow circusDeclWordList
 */
circusDeclWordList ::=
    circusDeclWordList:cdwl COMMA DECLWORD:dw
    {:
       ZName dn = createCircusName(dw);
       cdwl.add(dn);
       RESULT = cdwl;
    :}
    |
    DECLWORD:dw
    {:
       ZName dn = createCircusName(dw);
       RESULT = factory_.createZNameList();
       RESULT.add(dn);
    :}
    ;

/// Channel Paragraph ////////////////////////////////

channelPara ::=
        CIRCCHAN:chan channelDeclList:cdl
        {:
           RESULT = factory_.createChannelPara(factory_.createZDeclList(cdl));
           addLocAnn(RESULT, getLocation(chan, cdl.get(cdl.size()-1)));
        :}
        |
        CIRCCHANFROM:chanf channelFromDeclList:cfdl
        {:
           RESULT = factory_.createChannelPara(factory_.createZDeclList(cfdl));
           addLocAnn(RESULT, getLocation(chanf, cfdl.get(cfdl.size()-1)));
        :}
        |
        CIRCCHAN:chan error:e END
        {:
           RESULT = factory_.createChannelPara(factory_.createZDeclList());
           addLocAnn(RESULT, getLocation(eleft, eright));
           parser.report_error(CircusParseMessage.MSG_CHANDECL_ERROR,
              new Object[0], getLocation(eleft, eright));
        :}
        |
        CIRCCHANFROM:chanf error:e END
        {:
           RESULT = factory_.createChannelPara(factory_.createZDeclList());
           addLocAnn(RESULT, getLocation(eleft, eright));
           parser.report_error(CircusParseMessage.MSG_CHANFROMDECL_ERROR,
              new Object[0], getLocation(eleft, eright));
        :}
        ;

channelDeclList ::=
        channelDeclList:cdl SEMICOLON channelDecl:cd
        {:
           assert cd != null &amp;&amp; cdl != null;
           cdl.add(cd);
           RESULT = cdl;
        :}
        |
        channelDecl:cd
        {:
           assert cd != null;
           RESULT = factory_.list(cd);
        :}
        ;

channelFromDeclList ::=
        channelFromDeclList:cfdl SEMICOLON channelFromDecl:cfd
        {:
           assert cfd != null &amp;&amp; cfdl != null ;
           cfdl.add(cfd);
           RESULT = cfdl;
        :}
        |
        channelFromDecl:cfd
        {:
           assert cfd != null;
           RESULT = factory_.list(cfd);
        :}
        ;

/* Removed declWordList and use circusDeclWordList instead as we do not need
 * operator templates for channel declaration names. We cannot use nameList
 * everywhere because words in typed channel declarations are parsed as DECLWORD
 * rather than DECORWORD
 */
channelDecl ::=
        /* Generically defined typed channels */
        formalParameters:fp circusDeclWordList:cdwl COLON expression:e
        {:
           RESULT = factory_.createChannelDecl(factory_.list(fp, cdwl), e);
           addLocAnn(RESULT, getLocation(fp, e));
        :}
        |
        /* Typed channels */
        circusDeclWordList:cdwl COLON expression:e
        {:
           ZNameList znl = factory_.createZNameList();
           RESULT = factory_.createChannelDecl(factory_.list(znl, cdwl), e);
           addLocAnn(RESULT, getLocation(cdwl.get(0), e));
        :}
        |
        /* Synchronisation channels */
        /*
         * The typechecker include a type annotation but MUST NOT change
         * the expression value from null, as this information is used for
         * AST printing.
         */
        nameList:nl
	{:
           // no generics for synchronisation channels.
           ZNameList znl = factory_.createZNameList();

           assert nl != null &amp;&amp; !nl.isEmpty() : "Cannot have empty synch channel name list";
           RESULT = factory_.createChannelDecl(factory_.list(znl, nl),
              CircusUtils.SYNCH_CHANNEL_EXPR);
           addLocAnn(RESULT, getLocation(nl));
	:}
        /* Generically defined typed channels with type error */
        |
        formalParameters:fp circusDeclWordList:cdwl COLON:c error:e END
        {:
          parser.report_error(CircusParseMessage.MSG_CHANNEL_TYPE_ERROR,
                            new Object[0], getLocation(eleft, eright));
          RESULT = factory_.createChannelDecl(factory_.list(fp, cdwl), null);
          addLocAnn(RESULT, getLocation(fp, getLocation(eleft, eright)));
        :}
        |
        formalParameters:fp circusDeclWordList:cdwl error:e END
        {:
          parser.report_error(CircusParseMessage.MSG_CHANNEL_TYPE_ERROR,
                            new Object[0], getLocation(eleft, eright));
          RESULT = factory_.createChannelDecl(factory_.list(fp, cdwl), null);
          addLocAnn(RESULT, getLocation(fp, getLocation(eleft, eright)));
        :}
        |
        /* Typec channels with type error */
        circusDeclWordList:cdwl COLON:c error:e END
        {:
          parser.report_error(CircusParseMessage.MSG_CHANNEL_TYPE_ERROR,
                            new Object[0], getLocation(eleft, eright));
          ZNameList znl = factory_.createZNameList();
          RESULT = factory_.createChannelDecl(factory_.list(znl, cdwl), null);
          addLocAnn(RESULT, getLocation(cdwl.get(0), getLocation(eleft, eright)));
        :}
        |
        /* This production covers just name lists, see channel-errors.tex*/
        circusDeclWordList:cdwl error:e END
        {:
          parser.report_error(CircusParseMessage.MSG_CHANNEL_TYPE_ERROR,
                            new Object[0], getLocation(eleft, eright));
          ZNameList znl = factory_.createZNameList();
          RESULT = factory_.createChannelDecl(factory_.list(znl, cdwl), null);
          addLocAnn(RESULT, getLocation(cdwl.get(0), getLocation(eleft, eright)));
        :}
        ;

/* Channel declaration from schema inclusion MUST have the Name list EMPTY
 * and the expression MUST not be NULL, it contains the schema name (possibly
 * with generic actuals). (see Circus.xsd comments).
 */
channelFromDecl ::=
        /* Generic channels declared through generic Z schemas with generic actuals */
        optFormalParameters:ofp DECORWORD:dw genericActuals:ga
        {:
           // NOTE: channel from declarations does not allow decorated schema names!

           RefExpr re = factory_.createRefExpr(createCircusName(dw), ga, Boolean.FALSE, Boolean.TRUE);
           ZNameList znl = factory_.createZNameList();
           RESULT = factory_.createChannelDecl(factory_.list(ofp, znl), re);
           addLocAnn(RESULT, getLocation(ofp, ga));
        :}
        |
        /* Channels declared through Z schemas */
        optFormalParameters:ofp DECORWORD:dw
        {:
           RefExpr re = factory_.createRefExpr(createCircusName(dw));/*same as: FALSE, FALSE*/
           ZNameList znl = factory_.createZNameList();
           RESULT = factory_.createChannelDecl(factory_.list(ofp, znl), re);
           addLocAnn(RESULT, getLocation(ofp, dw.getLocation()));
        :}
        ;

/// Channel Set Paragraph ////////////////////////////

channelSetPara ::=
        CIRCCHANSET:ccs optFormalParameters:ofp name:n DEFEQUAL:equal channelSet:cs
        {:
           RESULT = factory_.createChannelSetPara(ofp, n, cs);
           addLocAnn(RESULT, getLocation(ccs, cs));
        :}
        |
        CIRCCHANSET:ccs optFormalParameters:ofp name:n DEFEQUAL:equal error:e END
        {:
           RESULT = factory_.createChannelSetPara(ofp, n, null);
           addLocAnn(RESULT, getLocation(ccs, n));
           parser.report_error(CircusParseMessage.MSG_CHANNELSET_EXPR_ERROR,
              new Object[0], getLocation(eleft, eright));

        :}
        |
        CIRCCHANSET:ccs optFormalParameters:ofp name:n error:e END
        {:
           RESULT = factory_.createChannelSetPara(ofp, n, null);
           addLocAnn(RESULT, getLocation(ccs, n));
           parser.report_error(CircusParseMessage.MSG_CHANNELSET_MISSING_DEFEQUAL_ERROR,
              new Object[0], getLocation(eleft, eright));
        :}
        |
        CIRCCHANSET:ccs optFormalParameters:ofp error:e END
        {:
           RESULT = factory_.createChannelSetPara(ofp, null, null);
           addLocAnn(RESULT, getLocation(ccs, ofp.get(ofp.size()-1)));
           parser.report_error(CircusParseMessage.MSG_CHANNELSET_MISSING_NAME_ERROR,
              new Object[0], getLocation(eleft, eright));
        :}
        /* TODO: maybe add this error production later (i.e. it raises a Shift/Reduce error).
                 todo that, just duplicate the productions by avoiding optFormalParameters
                 and using formalParameters instead. That is one with formalParameters and
                 one without it.
        |
        CIRCCHANSET:ccs error:e END
        {:
           RESULT = factory_.createChannelSetPara();
           addLocAnn(RESULT, getLocation(ccs));
           parser.report_error(CircusParseMessage.MSG_CHANNELSET_ERROR,
              new Object[0], getLocation(eleft, eright));
        :}
        */
        ;

// NOTE: channel sets wrap Expr tree into Para tree for Circus
channelSet ::=
        expression:e
        {:
           // NOTE: The validation below makes sure that if this is a channel set extension,
           //       set displays (SetExpr) or comprehension (SetCompExpr) are not allowed.
           Expr eValid = validateChannelSetExpr(e);
           RESULT = factory_.createCircusChannelSet(eValid);
           addLocAnn(RESULT, getLocation(e));
        :}
        ;

/// Process Paragraphs ////////////////////////////////

processPara ::=
        /* Process declaration */
        CIRCPROC:cp optFormalParameters:ofp name:n CIRCDEF processDesc:pd
        {:
           LocInfo loc = getLocation(cp, pd);
           final String from = "PROCESS PARA";
           ProcessPara pp = factory_.createProcessPara(n, ofp, pd);
           checkStateDeclNotRepeated(pp);
           addLocAnn(pp, loc);

           // If processDesc is a multiple env BasicProcess, check whether
           // it is multiple environment or single environment - ParamProcess is also basic!
           if (CircusUtils.isBasicProcess(pd)
              &amp;&amp;
              // If multiple environment, just return null. This avoids creating
              // duplicated entries into section level for process para.
              // The null entry is dealt with in unboxedParagraphItemList production
              parserState_.isWithinMultipleEnvBasicProcessScope()) {
                  RESULT = null;
                  parserState_.setProcessPara(pp);

                  // to ensure this is harmless, we add must add a
                  // post check warning in case the process is not
                  // properly closed. Such warnings are cleared whenever
                  // a process scope is properly closed.
                  addMultipleEnvBasicProcessCIRCENDWarning(n, loc);
           } else {
              // Otherwise, for either single environment basic process or
              // process paragraphs that are not basic processes, create a
              // new entry.
              RESULT = pp;
           }
           logProductionResult(pp, from + " with " +
              (RESULT == null ? "null" : "non-null"), loc);
        :}
        |
        /**
         * This production terminates the scope of a basic process declared
         * across multiple circusaction environments. It needs to be here,
         * rather than on "circusBasicProcess" production, to avoid confusion
         * between indexed processes (i.e. an indexed process could also be
         * a basic process, but it would be terminating one, which is strange,
         * as in "CIRCPROC CIRCEND").
         */
        CIRCEND:end
        {:
           final String from = "MULTIPLE ENVIRONMENT END";
           LocInfo loc = getLocation(endleft, endright);

           // if there is no scope add warning.
           addBasicProcessScopePostCheckFor(from, loc);

           //Name pn = null;
           //NameList gen = null;
           BasicProcess bp = null;

           // Updates the basic process structures with collected information
           // from previous environment
           if (updateBasicProcessInformation(from, loc)) {
                //logProductionResult(parserState_.getBasicProcess(), "PARSER STATE BP FROM " + from + " AFTER UPDATE", loc);

                //pn = parserState_.getProcessName();
                bp = parserState_.cloneBasicProcessWithAnns();
                //gen = parserState_.getProcessGenFormals();

                //logProductionResult(bp, "BP FROM " + from + " AFTER PARSER STATE UPDATE", loc);
           }
           // retrive the process from the state before clearing it up

           if (checkProcessParaScope(loc)
              &amp;&amp;
              parserState_.isWithinMultipleEnvBasicProcessScope()) {
              parserState_.updateProcessParaBasicProcess(bp);
              RESULT = parserState_.getProcessPara();

              logProductionResult(RESULT, "AFTER-PROCESS-PARA-BP-UPDATE", loc);

              // if we have a ProcessPara, the CIRCEND warning
              // should be removed provided the procName is the same
              removeMultipleEnvBasicProcessCIRCENDWarning(loc);

              // This was creating a duplicated entry into section level for processpara
              //RESULT = factory_.createProcessPara(pn, gen, bp);
           } else {
              // error was raised at this point
              RESULT = factory_.createProcessPara();
           }

           // If exit fails, a warning is mentioned, not an error, so continue regardless
           exitBasicProcessScope(from, loc);

           addLocAnn(RESULT, loc);
           checkStateDeclNotRepeated(RESULT);
           //logProductionResult(RESULT, "PROCESS PARA " + from, loc);

           // if there were any warning collected for the list of paragraphs
           // declared outside the multiple environment scope, raise then
           raisePendingBasicProcessWarnings(from);
        :}

        /* NOTE: If no processDesc catches the error, this production covers it */
        /*
        THESE ERROR PRODUCTIONS TURN OUT TO BE NOT HELPFUL
        |
        CIRCPROC:cp optFormalParameters:ofp name:n CIRCDEF error:e END
        {:
           RESULT = factory_.createProcessPara(n, ofp, factory_.createBasicProcess(factory_.createZParaList()));
           addLocAnn(RESULT, getLocation(cp, n));
           parser.report_syntax_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "process paragraph" }, getLocation(eleft, eright));
        :}
        |
        CIRCPROC:cp optFormalParameters:ofp name:n error:e END
        {:
           RESULT = factory_.createProcessPara(n, ofp, factory_.createBasicProcess(factory_.createZParaList()));
           addLocAnn(RESULT, getLocation(cp, n));
           parser.report_error(CircusParseMessage.MSG_PROCESSPARA_MISSING_CIRCDEF_ERROR,
              new Object[0], getLocation(eleft, eright));
        :}
        |
        CIRCPROC:cp optFormalParameters:ofp error:e END
        {:
           RESULT = factory_.createProcessPara(null, ofp, factory_.createBasicProcess(factory_.createZParaList()));
           addLocAnn(RESULT, getLocation(cp, ofp.get(ofp.size()-1)));
           parser.report_error(CircusParseMessage.MSG_PROCESSPARA_MISSING_NAME_ERROR,
              new Object[0], getLocation(eleft, eright));
        :}*/
        /* TODO: maybe add this error production later (i.e. it raises a Shift/Reduce error).
                 todo that, just duplicate the productions by avoiding optFormalParameters
                 and using formalParameters instead. That is one with formalParameters and
                 one without it.
        |
        CIRCPROC:cp error:e END
        {:
           RESULT = factory_.createProcessPara();
           addLocAnn(RESULT, getLocation(cp));
        :}
        */
        ;

processDesc ::=
        DECORWORD:dw channelRenaming:cr
        {:
          //System.out.println("OXENTE");
          RESULT = factory_.createRenameProcess(
              factory_.createCallProcess(factory_.createRefExpr(createCircusName(dw)),
                factory_.createZExprList(), CallUsage.Parameterised), cr);
            addLocAnn(RESULT, getLocation(dw.getLocation(), getLocation(cr)));
        :} %prec _RENAME
        |
        DECORWORD:dw genericActuals:ga channelRenaming:cr
        {:
            RESULT = factory_.createRenameProcess(
              factory_.createCallProcess(factory_.createRefExpr(
                createCircusName(dw), ga, Boolean.FALSE, Boolean.TRUE),
                factory_.createZExprList(), CallUsage.Parameterised), cr);
            addLocAnn(RESULT, getLocation(dw.getLocation(), getLocation(cr)));
        :} %prec _RENAME
        |
        paramProcess:pp
        {:
            RESULT = pp;
        :}
        |
        indexedProcess:ip
        {:
            RESULT = ip;
        :}
        |
        process:p
        {:
           RESULT = p;
        :}
	;

// DESIGN:
/* Moved replicated productions out of process because they are not
 * compatible with parenthesised processes. That is, we cannot have
 * "\circprocess P \circdef (\Interleave i: \nat @ B)", because it would
 * make no sense in "(\Interleave i: \nat @ B) \extchoice C". This also
 * normalises on-the-fly replicated/parameterised process calls, which gets
 * quite confusing if replicated processes were to be in process.
 */
//DESIGN: We MUST NOT allow processDesc here in the place of process
//        that is to avoid actions like P \circdef (i: \power \nat @ (i: \nat @ Q)),
//        which would have a funny signature of (non-unifiable yet valid(?)) formal
//        parameters. Note that on-the-fly nested parameters are fine, as in
//        P \circdef (i: \power~\nat @ (i: \nat @ Q)(0)), because the process of P
//        is just a call, hence the formal parameters signature of P is i: \power~\arithmos.
//
//        One consequence of this is that one cannot have explicit nesting parameterised process
//        declarations, or in fact any explicit nesting among parameterised, replicated and indexed
//        processes.
//
// The SVN revision prior to this change is 6684 - channel renaming for non-parenthesised calls
paramProcess ::=
        /* Parameterised process */
        circusParamDeclList:dp CIRCSPOT:sp processDesc:p
        {:
            RESULT = factory_.createParamProcess(p, dp);
            addLocAnn(RESULT, getLocation(getLocation(dpleft, dpright), getLocation(p)));
        :}
        |
        /* Replicated processes productions in precedence order */
        REPINTERLEAVE:ri circusParamDeclList:dp CIRCSPOT:sp processDesc:p
        {:
            RESULT = factory_.createInterleaveProcessIte(p, dp);
            addLocAnn(RESULT, getLocation(ri, p));
        :}
        |
        REPPARALLEL:rp circusParamDeclList:dp LPAR channelSet:cs RPAR CIRCSPOT:sp processDesc:p
        {:
            RESULT = factory_.createParallelProcessIte(p, dp, cs);
            addLocAnn(RESULT, getLocation(rp, p));
        :}
        |
        REPINTCHOICE:ri circusParamDeclList:dp CIRCSPOT:sp processDesc:p
        {:
            RESULT = factory_.createIntChoiceProcessIte(p, dp);
            addLocAnn(RESULT, getLocation(ri, p));
        :}
        |
        REPEXTCHOICE:re circusParamDeclList:dp CIRCSPOT:sp processDesc:p
        {:
            RESULT = factory_.createExtChoiceProcessIte(p, dp);
            addLocAnn(RESULT, getLocation(re, p));
        :}
        |
        ZCOMP:rs circusParamDeclList:dp CIRCSPOT:sp processDesc:p
        {:
            RESULT = factory_.createSeqProcessIte(p, dp);
            addLocAnn(RESULT, getLocation(rs, p));
        :}  %prec _REPSEQ
        /*
         * Error productions for processDesc in paramProcess.
         * These are productions for topmost errors. That is, if no
         * other more detailed inner production matches (or if the
         * error_count threshold).
         */
        |
        circusParamDeclList:dp CIRCSPOT:sp error:e END
        {:
            RESULT = factory_.createParamProcess(null, dp);
            addLocAnn(RESULT, getLocation(eleft, eright));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "parameterised process" }, getLocation(eleft, eright));
        :}
        |
        REPINTERLEAVE:ri circusParamDeclList:dp CIRCSPOT:sp error:e END
        {:
            RESULT = factory_.createInterleaveProcessIte(null, dp);
            addLocAnn(RESULT, getLocation(ri, sp));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated parameterised interleave process" },
                getLocation(eleft, eright));
        :}
        |
        REPPARALLEL:rp circusParamDeclList:dp LPAR channelSet:cs RPAR CIRCSPOT:sp error:e END
        {:
            RESULT = factory_.createParallelProcessIte(null, dp, cs);
            addLocAnn(RESULT, getLocation(rp, cs));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated parameterised parallel process" },
                getLocation(eleft, eright));
        :}
        |
        REPINTCHOICE:ri circusParamDeclList:dp CIRCSPOT:sp error:e END
        {:
            RESULT = factory_.createIntChoiceProcessIte(null, dp);
            addLocAnn(RESULT, getLocation(ri, sp));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated parameterised internal choice process" },
                getLocation(eleft, eright));

        :}
        |
        REPEXTCHOICE:re circusParamDeclList:dp CIRCSPOT:sp error:e END
        {:
            RESULT = factory_.createExtChoiceProcessIte(null, dp);
            addLocAnn(RESULT, getLocation(re, sp));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated parameterised external choice process" },
                getLocation(eleft, eright));
        :}
        |
        ZCOMP:rs circusParamDeclList:dp CIRCSPOT:sp error:e END
        {:
            RESULT = factory_.createSeqProcessIte(null, dp);
            addLocAnn(RESULT, getLocation(rs, sp));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated parameterised sequential composition process" },
                getLocation(eleft, eright));
        :}  %prec _REPSEQ
        /* Note: Add further error productions here if needed. */
        ;

/* Moved replicated indexed productions out of process because they are not
 * compatible with parenthesised processes. That is, we cannot have
 * "\circprocess P \circdef (\Interleave i: \nat \circindex B)", because it would
 * make no sense in "(\Interleave i: \nat \circindex B) \extchoice C". This also
 * normalises on-the-fly (replicated) indexed process calls, which gets quite
 * confusing if replicated indexed processes were to be in process.
 */
indexedProcess ::=
        circusParamDeclList:dp CIRCINDEX:ci processDesc:p
        {:
            RESULT = factory_.createIndexedProcess(p, dp);
            addLocAnn(RESULT, getLocation(getLocation(dpleft, dpright), getLocation(p)));
        :}
        /* Indexed processes productions in precedence order */
        |
        REPINTERLEAVE:ri circusParamDeclList:dp CIRCINDEX:ci processDesc:p
        {:
            RESULT = factory_.createInterleaveProcessIdx(p, dp);
            addLocAnn(RESULT, getLocation(ri, p));
        :}
        |
        REPPARALLEL:rp circusParamDeclList:dp LPAR channelSet:cs RPAR CIRCINDEX:ci processDesc:p
        {:
            RESULT = factory_.createParallelProcessIdx(p, dp, cs);
            addLocAnn(RESULT, getLocation(rp, p));
        :}
        |
        REPINTCHOICE:ri circusParamDeclList:dp CIRCINDEX:ci processDesc:p
        {:
            RESULT = factory_.createIntChoiceProcessIdx(p, dp);
            addLocAnn(RESULT, getLocation(ri, p));
        :}
        |
        REPEXTCHOICE:re circusParamDeclList:dp CIRCINDEX:ci processDesc:p
        {:
            RESULT = factory_.createExtChoiceProcessIdx(p, dp);
            addLocAnn(RESULT, getLocation(re, p));
        :}
        |
        ZCOMP:rs circusParamDeclList:dp CIRCINDEX:ci processDesc:p
        {:
            RESULT = factory_.createSeqProcessIdx(p, dp);
            addLocAnn(RESULT, getLocation(rs, p));
        :} %prec _REPSEQ
        /*
         * Error productions for processDesc in indexedProcess.
         * These are productions for topmost errors. That is, if no
         * other more detailed inner production matches (or if the
         * error_count threshold).
         */
        |
        circusParamDeclList:dp CIRCINDEX:ci error:e END
        {:
            RESULT = factory_.createIndexedProcess(null, dp);
            addLocAnn(RESULT, getLocation(eleft, eright));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "parameterised indexed process" }, getLocation(eleft, eright));
        :}
        |
        REPINTERLEAVE:ri circusParamDeclList:dp CIRCINDEX:ci error:e END
        {:
            RESULT = factory_.createInterleaveProcessIdx(null, dp);
            addLocAnn(RESULT, getLocation(ri, ci));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated indexed parameterised interleave process" },
                getLocation(eleft, eright));
        :}
        |
        REPPARALLEL:rp circusParamDeclList:dp LPAR channelSet:cs RPAR CIRCINDEX:ci error:e END
        {:
            RESULT = factory_.createParallelProcessIdx(null, dp, cs);
            addLocAnn(RESULT, getLocation(rp, cs));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated indexed parameterised parallel process" },
                getLocation(eleft, eright));
        :}
        |
        REPINTCHOICE:ri circusParamDeclList:dp CIRCINDEX:ci error:e END
        {:
            RESULT = factory_.createIntChoiceProcessIdx(null, dp);
            addLocAnn(RESULT, getLocation(ri, ci));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated indexed parameterised internal choice process" },
                getLocation(eleft, eright));
        :}
        |
        REPEXTCHOICE:re circusParamDeclList:dp CIRCINDEX:ci error:e END
        {:
            RESULT = factory_.createExtChoiceProcessIdx(null, dp);
            addLocAnn(RESULT, getLocation(re, ci));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated indexed parameterised external choice process" },
                getLocation(eleft, eright));
        :}
        |
        ZCOMP:rs circusParamDeclList:dp CIRCINDEX:ci error:e END
        {:
            RESULT = factory_.createSeqProcessIdx(null, dp);
            addLocAnn(RESULT, getLocation(rs, ci));
            parser.report_error(CircusParseMessage.MSG_PROCESSPARA_DESC_ERROR,
              new Object[] { "replicated indexed parameterised sequential composition process" },
                getLocation(eleft, eright));
        :} %prec _REPSEQ
        /* Note: Add further error productions here if needed. */
        ;

process ::=
        circusBasicProcess:bp
        {: RESULT = bp; :}
        |
        /* Processes operator productions in precedence order */
        process:p CIRCHIDING:h channelSet:cs
        {:
           RESULT = factory_.createHideProcess(p, cs);
           addLocAnn(RESULT, getLocation(hleft, hright, p, cs));
        :}
        <add:circustime>
        |
        process:pl CIRCENDBY LCIRCTIME expression:e RCIRCTIME
        {:
	    RESULT = factory_.createTimeEndByProcess(pl, e);
	    addLocAnn(RESULT, getLocation(pl,e));
        :}
		|
        LCIRCTIME expression:e RCIRCTIME CIRCSTARTBY process:pr
        {:
		    RESULT = factory_.createTimeStartByProcess(pr, e);
		    addLocAnn(RESULT, getLocation(pr,e));
        :}
        </add:circustime>
        <add:circusconf>
		|
		LCIRCCONF:lc process:p RCIRCCONF:rc
		{:
            RESULT = factory_.createConfidentialityProcess(p);
            addLocAnn(RESULT, getLocation(lc, rc));			
		:}
		</add:circusconf>
        |
        process:pl INTERLEAVE:in process:pr
        {:
            RESULT = factory_.createInterleaveProcess(factory_.list(pl, pr));
            addLocAnn(RESULT, getLocation(inleft, inright, pl, pr));
        :}
        |
        process:pl LPAR:lp channelSet:cs RPAR:rp process:pr
        {:
            RESULT = factory_.createParallelProcess(factory_.list(pl, pr), cs);
            addLocAnn(RESULT, getLocation(rpleft, rpright, pl, pr));
        :}
        |
        process:pl INTCHOICE:ic process:pr
        {:
            RESULT = factory_.createIntChoiceProcess(factory_.list(pl, pr));
            addLocAnn(RESULT, getLocation(icleft, icright, pl, pr));
        :}
        |
        process:pl EXTCHOICE:cs process:pr
        {:
            RESULT = factory_.createExtChoiceProcess(factory_.list(pl, pr));
            addLocAnn(RESULT, getLocation(csleft, csright, pl, pr));
        :}
        |
        process:pl CIRCSEQ:cs process:pr
        {:
            RESULT = factory_.createSeqProcess(factory_.list(pl, pr));
            addLocAnn(RESULT, getLocation(csleft, csright, pl, pr));
        :}
        <add:circustime>
		|
        process:pl CIRCTIMEOUT  LCIRCTIME expression:e RCIRCTIME  process:pr
        {:
		    RESULT = factory_.createTimeoutProcess(factory_.list(pl, pr), e);
		    addLocAnn(RESULT, getLocation(pl, pr));
        :}
		|
        process:pl CIRCTIMEDINTERRUPT:ti  LCIRCTIME expression:e RCIRCTIME  process:pr
        {:
		    RESULT = factory_.createTimedinterruptProcess(factory_.list(pl, pr),e);
		    addLocAnn(RESULT, getLocation(pl, pr));
		:}
        </add:circustime>
		|
        /* Process calls */
        processCall:pc
        {:
            RESULT = pc;
        :}
        |
        /* Parenthesised processes */
        parenthesisedProcess:pp
        {:
           RESULT = pp;
        :}
        ;

processCall ::=
        /* Nongenertic parameterised process call with instantiations */
        DECORWORD:dw actualParameters:ap
        {:
            /* The CallUsage is Parameterised and the generic actuals are empty */
            /* RefExpr: mixfix = false, explicit = false */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(dw)), ap, CallUsage.Parameterised);
            addLocAnn(RESULT, dw.getLocation());
        :}
        |
        /* Genertic parameterised process call with instantiations */
        DECORWORD:dw genericActuals:ga actualParameters:ap
        {:
            /* The CallUsage is Parameterised and both generic actuals and indexes are not null */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(
              createCircusName(dw), ga, Boolean.FALSE, Boolean.TRUE), ap, CallUsage.Parameterised);
            addLocAnn(RESULT, dw.getLocation());
        :}
        |
        /* Nongeneric indexed process call with instantiations */
        DECORWORD:dw actualIndexes:ai
        {:
            /* The CallUsage is Indexed and the generic actuals are empty */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(dw)), ai, CallUsage.Indexed);
            addLocAnn(RESULT, dw.getLocation());
        :}
        |
        /* Generic indexed process call with instantiations */
        DECORWORD:dw genericActuals:ga actualIndexes:ai
        {:
            /* The CallUsage is Indexed and both generic actuals and indexes are not null */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(
              createCircusName(dw), ga, Boolean.FALSE, Boolean.TRUE), ai, CallUsage.Indexed);
            addLocAnn(RESULT, dw.getLocation());
        :}
        /**
        If we try renaming of calls without parenthesis, the other parenthesisedProcess:pp
        production is always given preference, regardless of our careful choice of precedences :-((

        So, instead, I added the production to the root of processDesc, which gives the  intended result.
        Nevertheless, there still some unwanted glitches - see test/circus/process_renaming.tex
        |
        DECORWORD:dw channelRenaming:cr
        {:
          //System.out.println("OXENTE");
          RESULT = factory_.createRenameProcess(
              factory_.createCallProcess(factory_.createRefExpr(createCircusName(dw)),
                factory_.createZExprList(), CallUsage.Parameterised), cr);
            addLocAnn(RESULT, getLocation(dw.getLocation(), getLocation(cr)));
        :} %prec _RENAME
        |
        DECORWORD:dw genericActuals:ga channelRenaming:cr
        {:
            RESULT = factory_.createRenameProcess(
              factory_.createCallProcess(factory_.createRefExpr(
                createCircusName(dw), ga, Boolean.FALSE, Boolean.TRUE),
                factory_.createZExprList(), CallUsage.Parameterised), cr);
            addLocAnn(RESULT, getLocation(dw.getLocation(), getLocation(cr)));
        :} %prec _RENAME
        */
        |
        /* Generic parameterless process call with instantiation */
        DECORWORD:dw genericActuals:ga
        {:
            /* The CallUsage is irrelevant and the parameters are empty */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(
              createCircusName(dw), ga, Boolean.FALSE, Boolean.TRUE),
              factory_.createZExprList(), CallUsage.Parameterised);
            addLocAnn(RESULT, dw.getLocation());
        :}
        |
        /* Nongeneric parameterless process call */
        DECORWORD:dw
        {:
            /* The CallUsage is irrelevant and both generic actuals and parameters are empty */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(dw)),
                factory_.createZExprList(), CallUsage.Parameterised);
            addLocAnn(RESULT, dw.getLocation());
        :}
        ;

/* Parenthesised processes represent on-the-fly process calls and
 * normal processes between parenthesis. This production is symetric
 * to processCall, apart from P[X,Y], which is uncessary because (P)[X,Y]
 * is implicitly because process can be a processCall ;)
 *
 * Ideally, we should just use processDesc, but it is not the case due
 * to the structural differences between the possibilities, hence we
 * define each case individually.
 */
parenthesisedProcess ::=
        /* Parenthesised processes */
        LPAREN:lp process:p RPAREN:rp
        {:
           addParenthesisAnn(lp, p, rp);
           RESULT = p;
        :}
        |
        LPAREN:lp paramProcess:pp RPAREN:rp
        {:
           addParenthesisAnn(lp, pp, rp);
           RESULT = pp;
        :}
        |
        /* Non-generic on-the-fly parameterised process call */
        LPAREN:lp1 paramProcess:pp RPAREN:rp1 actualParameters:ap
        {:
            addParenthesisAnn(lp1, pp, rp1);
            Decorword pn = createImplicitlyDeclProcUniqueName(pp);
            ProcessPara pa = createImplicitProcessPara(pn, pp);
            parserState_.addImplicitlyDeclProcessPara(pa);
            /* The CallUsage is Parameterised and the generic actuals are the same as the  */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(pn)), ap, CallUsage.Parameterised);
            addLocAnn(RESULT, getLocation(lp1, ap.get(ap.size()-1)));
        :}
        |
        /* Generic on-the-fly parematerised process call */
        formalParameters:fp LPAREN:lp1 paramProcess:pp RPAREN:rp1 genericActuals:ga actualParameters:ap
        {:
            addParenthesisAnn(lp1, pp, rp1);
            Decorword pn = createImplicitlyDeclProcUniqueName(pp);
            ProcessPara pa = createImplicitProcessPara(pn, pp);
            parserState_.addImplicitlyDeclProcessPara(pa);
            /* The CallUsage is Parameterised and the generic actuals are the same as the  */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(pn),
                ga, Boolean.FALSE, Boolean.TRUE), ap, CallUsage.Parameterised);
            addLocAnn(RESULT, getLocation(lp1, ap.get(ap.size()-1)));
        :}
        |
        LPAREN:lp indexedProcess:ip RPAREN:rp
        {:
           addParenthesisAnn(lp, ip, rp);
           RESULT = ip;
        :}
        |
        /* Non-generic on-the-fly indexed process call */
        LPAREN:lp indexedProcess:ip RPAREN:rp actualIndexes:ai
        {:
            addParenthesisAnn(lp, ip, rp);
            Decorword pn = createImplicitlyDeclProcUniqueName(ip);
            ProcessPara pa = createImplicitProcessPara(pn, ip);
            parserState_.addImplicitlyDeclProcessPara(pa);
            /* The CallUsage is Parameterised and the generic actuals are empty */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(pn)), ai, CallUsage.Indexed);
            addLocAnn(RESULT, getLocation(lp, ai.get(ai.size()-1)));
        :}
        |
        /* Generic on-the-fly indexed process call */
        formalParameters:fp LPAREN:lp indexedProcess:ip RPAREN:rp genericActuals:ga actualIndexes:ai
        {:
            addParenthesisAnn(lp, ip, rp);
            Decorword pn = createImplicitlyDeclProcUniqueName(ip);
            ProcessPara pa = createImplicitProcessPara(pn, ip);
            parserState_.addImplicitlyDeclProcessPara(pa);
            /* The CallUsage is Parameterised and the generic actuals are empty */
            RESULT = factory_.createCallProcess(factory_.createRefExpr(createCircusName(pn),
                ga, Boolean.FALSE, Boolean.TRUE), ai, CallUsage.Indexed);
            addLocAnn(RESULT, getLocation(lp, ai.get(ai.size()-1)));
        :}
        |
        /* NOTE:
         * The reason why we have introduced the special renaming bracket is because it makes
         * debugging the parsing trees easier, as LSQUARE or RSQUARE appears in many places in
         * the Z and Circus grammar. Anyway, it is nice to give them a distinctive bracket to
         * avoid confusion.
         * Note that for parameterised and indexed processes, we enforce the parenthesis around.
         */
        /* Process channel renaming */
        LPAREN:lp process:pp RPAREN:rp channelRenaming:cr
        {:
            //System.out.println("VIXE");
            addParenthesisAnn(lp, pp, rp);
            RESULT = factory_.createRenameProcess(pp, cr);
            addLocAnn(RESULT, getLocation(lp, rp));
        :} %prec _RENAME
        |
        /* Parameterised process channel renaming */
        LPAREN:lp paramProcess:pp RPAREN:rp channelRenaming:cr
        {:
            addParenthesisAnn(lp, pp, rp);
            RESULT = factory_.createRenameProcess(pp, cr);
            addLocAnn(RESULT, getLocation(lp, rp));
        :} %prec _RENAME
        |
        /* Indexed process channel renaming */
        LPAREN:lp indexedProcess:ip RPAREN:rp channelRenaming:cr
        {:
            addParenthesisAnn(lp, ip, rp);
            RESULT = factory_.createRenameProcess(ip, cr);
            addLocAnn(RESULT, getLocation(lp, rp));
        :} %prec _RENAME
        ;

/* This production leads to a loop in the grammar
 * if directly put on parenthesisedProces :-(
renamingProcesses ::=
        process:p
        {: RESULT = p; :}
        |
        paramProcess:pp
        {: RESULT = pp; :}
        |
        indexedProcess:idx
        {: RESULT = idx; :}
        ;
*/

/// Circus parameters declaration ////////////////////////////////

/* Just follows the rules for declPart but restricted to VarDecl */
circusParamDeclList ::=
        circusParamZDeclList:zdl
        {:
           RESULT = zdl;
           addLocAnn(zdl, getLocation(getLocation(zdl.get(0)),
                                      getLocation(zdl.get(zdl.size() - 1))));
        :}
        ;

circusParamZDeclList ::=
        varDecl:vd
        {: RESULT = factory_.createZDeclList(factory_.list(vd)); :}
        |
        circusParamZDeclList:zdl sep varDecl:vd
        {:
           zdl.add(vd);
           RESULT = zdl;
        :}
        ;

/* Just follows the rules for circusParamDeclList but extended to QualifiedDecl */
circusCommandDecl ::=
        varDecl:vd
        {: RESULT = vd; :}
        |
        qualifiedDecl:cd
        {: RESULT = cd; :}
        ;

circusParamCommandDeclList ::=
        circusParamCommandZDeclList:cdl
        {: RESULT = cdl; :}
        ;

circusParamCommandZDeclList ::=
        circusCommandDecl:cd
        {: RESULT = factory_.createZDeclList(factory_.list(cd)); :}
        |
        circusParamCommandZDeclList:cdl SEMICOLON circusCommandDecl:cd
        {:
           cdl.add(cd);
           RESULT = cdl;
        :}
        ;

/* We cannot use nameList here because of the COLON.
 * The smart scanner will interpret the names as DECLNAME,
 * but nameList produces DECORWORD. We don't want declWordList
 * either because formal parameters cannot be operators.
 */
qualifiedDecl ::=
        circusQualifier:cq circusDeclWordList:cdwl COLON:colon expression:e
        {:
           RESULT = factory_.createQualifiedDecl(cdwl, e, cq);
           addLocAnn(RESULT, getLocation(cdwl.get(0), getLocation(e)));
        :}
        ;

circusQualifier ::=
        CIRCVAL
        {: RESULT = ParamQualifier.Value; :}
        |
        CIRCRES
        {: RESULT = ParamQualifier.Result; :}
        |
        CIRCVRES
        {: RESULT = ParamQualifier.ValueResult; :}
        ;

/// Circus BasicProcess paragraphs ////////////////////////////////

circusBasicProcess ::=
        /* Represents basic circus processes across multiple circus environments.
         * That means, we REQUIRE that "\circprocess P \circdef \circbegin"
         * After this lonely begin, the parser will match the enclosing \end{circus}
         *
         * Then, after that, the user MUST switch to \begin{circusaction} \end{circusaction}
         * environment in order to allow next paragraphs to be add.
         */
        CIRCBEGIN:begin
        {:
           final String from = "MULTIPLE ENVIRONMENT BEGIN";
           LocInfo loc = getLocation(beginleft, beginright);

           // sets the basic process scope flag
           enterBasicProcessScope(from, loc);

           // create an empty BasicProcess with empty (rather than null) lists
           // it adds location annotation to the result and set it into the parser state
           RESULT = createMockBasicProcessFor(from, loc);

        :}
        |
        /* Represents basic processes without paragraphs, but just the main action
         * declared within a single \begin{circus} \end{circus}.
         */
        CIRCBEGIN:cb circusBasicProcessMainAction:ca CIRCEND:ce
        {:
           final String from = "JUST MAINACTION - SINGLE ENVIRONMENT";
           LocInfo loc = getLocation(cb, ce);

           // sets the basic process scope flag.
           // it is important to check mainAction's scope
           // (i.e. main action declared outside basic process scope)
           boolean shouldContinue = enterBasicProcessScope(from, loc);

           // create an empty BasicProcess with empty (rather than null) lists
           // it adds location annotation to the result and set it into the parser state
           // Can only call createMockBasicProcessFor after entering process scope
           RESULT = createMockBasicProcessFor(from, loc);

           if (shouldContinue){
               //logProductionResult(parserState_.getBasicProcess(), "BP FROM " + from + " BEFORE UPDATE", loc);

               // Updates the basic process structures with collected
               // information (i.e. main action)
               if (updateBasicProcessInformation(from, loc)) {
                    //logProductionResult(parserState_.getBasicProcess(), "BP FROM " + from + " AFTER UPDATE", loc);
                    RESULT = parserState_.cloneBasicProcessWithAnns();

                    //logProductionResult(RESULT, "RESULT-VAR FROM " + from + " AFTER PARSER STATE UPDATE", loc);
               }
               // If exit fails, a warning is mentioned, not an error, so continue regardless
               exitBasicProcessScope(from, loc);
            }
            //logProductionResult(RESULT, "RESULT-VAR FROM " + from + " AFTER PARSER SCOPE EXIT", loc);

            // if there were any warning collected for the list of paragraphs
            // declared outside the multiple environment scope, raise then.
            // there should be none, since this is already just a main action.
            raisePendingBasicProcessWarnings(from);
        :}
        |
        CIRCBEGIN:cb circusInnerProcParaList:ipl circusBasicProcessMainAction:ca CIRCEND:ce
        {:
           final String from = "SINGLE ENVIRONMENT";
           LocInfo loc = getLocation(cb, ce);

           boolean shouldContinue = enterBasicProcessScope(from, loc);
           RESULT = createMockBasicProcessFor(from, loc);
           if (shouldContinue) {
               //logProductionResult(factory_.createZParaList(ipl), "IPL FROM " + from, loc);
               //logProductionResult(factory_.createZParaList(parserState_.getLocallyDeclPara()),
               //     "STATE-LOCAL-PARA-LIST FROM " + from, loc);

               // In here we have a tricky situation...

               // Ensure the list collected in "ipl" is the same the one into RESULT
               if (ensureInnerProcParaListKnownInBasicProcessScope(ipl, from, loc)) {
                  // if ensureInnerProcParaListKnownInBasicProcessScope, then the
                  // warnings can be cleared, since they were properly included.
                  parserState_.clearSectBasicProcessScopeWarnings();
               }

               // logProductionResult(parserState_.getBasicProcess(), "BP FROM " + from + " BEFORE UPDATE", loc);

               // Updates the basic process structures with collected
               // information (i.e. ipl, state para, on the fly, main action, etc.)
               if (updateBasicProcessInformation(from, loc)) {
                    logProductionResult(parserState_.getBasicProcess(), "BP FROM " + from + " AFTER UPDATE", loc);

                    RESULT = parserState_.cloneBasicProcessWithAnns();

                    logProductionResult(RESULT, "RESULT-VAR FROM " + from + " AFTER PARSER STATE UPDATE", loc);
               }
               // If exit fails, a warning is mentioned, not an error, so continue regardless
               exitBasicProcessScope(from, loc);
           }
           // logProductionResult(RESULT, "RESULT-VAR FROM " + from + " AFTER PARSER SCOPE EXIT", loc);

           // if there were any warning collected for the list of paragraphs
           // declared outside the multiple environment scope, raise then.
           raisePendingBasicProcessWarnings(from);
        :}
        ;

circusBasicProcessMainAction ::=
        CIRCSPOT:s circusAction:ca
        {:
           final String from = "CIRCUS BP MAIN ACTION";
           LocInfo loc = getLocation(s, ca);
           RESULT = ca;

           // sets the main action into the parserState_
           setMainAction(RESULT, loc);
           addLocAnn(RESULT, loc);

           // Create an on-the-fly paragraph for the main action named "$$mainAction".
           String maName = parserState_.createUniqueMainActionName(loc);
           ActionPara mainActPara = factory_.createActionPara(
              factory_.createZName(maName), RESULT);
           addLocAnn(mainActPara, loc);
           parserState_.addImplicitlyDeclActionPara(mainActPara);

           //logProductionResult(RESULT, from, loc);
           //logProductionResult(parserState_.getMainAction(), "BP FROM STATE AFTER MA", loc);
        :}
        ;

/* Circus basic processes state can only be an expression or
 * an abbreviation (without generic parameters). Thus, we have copied
 * the appropriate production from abbreviationDefinition terminal.
 * For a schema we need a boxed basic process paragraph.
 */
circusProcessState ::=
        /* explicit schema definition is a horizontal box */
        CIRCSTATE:cs name:n DEFEQUAL:equal expression:e
        {:
           RESULT = createStatePara(n, e, getLocation(n, e), false /* not implicit */);
        :}
        |
        /* On-the-fly state schema is a horizontal box with special name */
        CIRCSTATE:cs expression:e
        {:
           LocInfo loc = getLocation(e);
           Name dn = parserState_.createDefaultProcessStateName(loc);
           RESULT = createStatePara(dn, e, loc, true /* implicit */);
        :}
        ;

/// Special productions for process paragraphs ////////////////////////////////

genericActuals ::=
        LSQUARE:ls expressionList:el RSQUARE:rs
        {:
           RESULT = el;
           addLocAnn(RESULT, getLocation(ls, rs));
        :}
        ;

actualParameters ::=
        LPAREN:lp expressionList:el RPAREN:rp
        {:
            RESULT = el;
            addLocAnn(RESULT, getLocation(lp, rp));
        :}
        ;

actualIndexes ::=
        CIRCLINST:cli expressionList:idx CIRCRINST:cri
        {:
            RESULT = idx;
            addLocAnn(RESULT, getLocation(cli, cri));
        :}
        ;

channelRenaming ::=
        LCIRCRENAME:lsq refNameList:rnl CIRCASSIGN expressionList:el RCIRCRENAME:rsq
        {:
            /* Must ensure that: 1) sizes of lists are equal; 2) second list contains only RefExpr.
             * RefExpr are possible in the case of generically defined channels.
             */
            RESULT = createChannelRenamingPairs(getLocation(rnlleft, rnlright),
              factory_.createZNameList(rnl), el);
            addLocAnn(RESULT, getLocation(lsq, rsq));
        :}
        ;

/// Nameset paragraphs withing Process paragraphs ////////////////////////////////

namesetPara ::=
        CIRCNAMESET:cns name:n DEFEQUAL:equal nameSet:ns
        {:
           RESULT = factory_.createNameSetPara(n, ns);
           addLocAnn(RESULT, getLocation(cns, ns));
        :}
        ;

nameSet ::=
        expression:e
        {:
           RESULT = factory_.createCircusNameSet(e);
           addLocAnn(RESULT, getLocation(e));
        :}
        ;


/// Action paragraphs withing Process paragraphs ////////////////////////////////

actionPara ::=
        name:n CIRCDEF actionDesc:pa
        {:
           RESULT = factory_.createActionPara(n, pa);
           addLocAnn(RESULT, getLocation(n, pa));
        :}
        ;

/* Normalisation of productions to be similar to processDesc.
 * That is, as we do not have indexed actions, we could have
 * left the last two productions inside of paraAction directly,
 * but we have chosen to be similar to processDesc.
 */
actionDesc ::=
        DECORWORD:dw channelRenaming:cr
        {:                  
          RESULT = factory_.createRenameAction(factory_.createCallAction(
          createCircusName(dw), factory_.createZExprList()), cr);
          addLocAnn(RESULT, getLocation(dw.getLocation(), getLocation(cr)));
        :} %prec _RENAME        
        |
        paramAction:pa
        {: RESULT = pa; :}
        |
        circusAction:ca
        {: RESULT = ca; :}
        ;

// DESIGN:
/* Moved replicated productions out of cspAction because they are not
 * compatible with parenthesised actions. That is, we cannot have
 * "A \circdef (i: \nat @ B)", because it would make no sense in
 * "(i: \nat @ B) \extchoice C". This also normalises on-the-fly
 * (replicated) parameterised action calls, which gets quite confusing if
 * replicated actions were to be a cspAction.
 */
//DESIGN: We MUST NOT allow actionDesc here in the place of circusAction.
//        that is to avoid actions like A \circdef (i: \power \nat @ (i: \nat @ B)),
//        which would have a funny signature of (non-unifiable yet valid(?)) formal
//        parameters. Note that on-the-fly nested parameters are fine, as in
//        A \circdef (i: \power~\nat @ (i: \nat @ B)(0)), because the action of A
//        is just a call, hence the formal parameters signature of A is i: \power~\arithmos.
//
//        One consequence of this is that one cannot have explicit nesting parameterised action
//        declarations, or in fact any explicit nesting among parameterised or replicated actions,
//        or parameterised commands.
//
// The SVN revision prior to this (6694) change is 6684 - channel renaming for non-parenthesised calls
//
//DESIGN: There are some tricky linguistic issues with this decision
//        that we are leaving for the Typechecker. Originally, we were
//        not supporting nested parameters to avoid higher order calls.
//        On the other hand, there is the case between process parameters
//        and indexes to decide. Leave it open in the parser. i.e., go back to actionDesc.
paramAction ::=
        /* Parameterised actions and commands */
        circusParamCommandDeclList:cp CIRCSPOT:sp circusAction:ca
        {:
            // NOTE: ParamAction covers both parameterised actions and commands
            //       the parser allows both here, whereas the type checker
            //       guarantees the consistency among declarations and inner action/command.
            RESULT = createParamAction(ca, cp);
            addLocAnn(RESULT, getLocation(getLocation(cpleft, cpright), getLocation(ca)));
        :}
        |
        /* Replicated action productions in precedence order */
        REPINTERLEAVE:ri circusParamDeclList:dp LINTER nameSet:ns RINTER CIRCSPOT:sp circusAction:ca
        {:
            RESULT = factory_.createInterleaveActionIte(ca, dp, ns);
            addLocAnn(RESULT, getLocation(ri, ca));
        :}
        |
        REPINTERLEAVE:ri circusParamDeclList:dp CIRCSPOT:sp circusAction:ca
        {:
            RESULT = factory_.createInterleaveActionIte(ca, dp, createEmptyNameSet(ri));
            addLocAnn(RESULT, getLocation(ri, ca));
        :}
        // CONFLICT ON paramAction:ca; ok with circusAction:ca
        |
        LPAR:lp channelSet:cs RPAR circusParamDeclList:dp CIRCSPOT:sp LPAR nameSet:ns RPAR circusAction:ca
        {:
            // Namesets first because of common parent for parallel actions,
            // and interleave has no channel set but has a name set.
            RESULT = factory_.createParallelActionIte(ca, dp, ns, cs);
            addLocAnn(RESULT, getLocation(lp, ca));
        :}
        |
        LPAR:lp channelSet:cs RPAR:rp circusParamDeclList:dp CIRCSPOT:sp circusAction:ca
        {:
            // Namesets first because of common parent for parallel actions,
            // and interleave has no channel set but has a name set.
            RESULT = factory_.createParallelActionIte(ca, dp, createEmptyNameSet(rp), cs);
            addLocAnn(RESULT, getLocation(lp, ca));
        :}
        |
        REPINTCHOICE:ri circusParamDeclList:dp CIRCSPOT:sp circusAction:ca
        {:
            RESULT = factory_.createIntChoiceActionIte(ca, dp);
            addLocAnn(RESULT, getLocation(ri, ca));
        :}
        |
        REPEXTCHOICE:re circusParamDeclList:dp CIRCSPOT:sp circusAction:ca
        {:
            RESULT = factory_.createExtChoiceActionIte(ca, dp);
            addLocAnn(RESULT, getLocation(re, ca));
        :}
        |
        ZCOMP:rs circusParamDeclList:dp CIRCSPOT:sp circusAction:ca
        {:
            RESULT = factory_.createSeqActionIte(ca, dp);
            addLocAnn(RESULT, getLocation(rs, ca));
        :} %prec _REPSEQ
        /* nested paramAction is not allowed */
        |
        // REMOVED FOR NOW FROM PARSER - leave it for typechecker
        circusParamCommandDeclList:cp CIRCSPOT:sp circusParamCommandDeclList:cp2 CIRCSPOT:sp2 circusAction:pa
        {:
            LocInfo loc = getLocation(getLocation(cpleft, cpright), getLocation(cp2left, cp2right));
            // as we don't have the action, just use skip
            RESULT = createParamAction(pa, cp);
            addLocAnn(RESULT, loc);
            parser.report_error(CircusParseMessage.MSG_NESTED_PARAMACTION,
                          new Object[0], loc);
        :}
        ;

circusAction ::=
        /* CSP related actions */
        cspAction:ca
        {: RESULT = ca; :}
        |
        /* Circus guarded commands */
        command:c
        {: RESULT = c; :}
        |
        /* Schema expression action */
        LSCHEXPRACT:la expression:e RSCHEXPRACT:ra
        {:
            RESULT = factory_.createSchExprAction(e);
            addLocAnn(RESULT, getLocation(la, ra));
        :}
        |
        /* Parenthesised actions */
        parenthesisedAction:pa
        {: RESULT = pa; :}
        ;

cspAction ::=
        CIRCSKIP:sk
        {:
          RESULT = factory_.createSkipAction();
          addLocAnn(RESULT, sk);
        :}
        |
        CIRCSTOP:sp
        {:
          RESULT = factory_.createStopAction();
          addLocAnn(RESULT, sp);
        :}
        |
        CIRCCHAOS:cc
        {:
          RESULT = factory_.createChaosAction();
          addLocAnn(RESULT, cc);
        :}
        |
        CIRCMU:cm name:n CIRCSPOT circusAction:ca
        {:
            RESULT = factory_.createMuAction(ca, n);
            addLocAnn(RESULT, getLocation(cm, ca));
        :}
        |
        /* Action operator productions in precedence order */
        circusAction:ca CIRCHIDING:h channelSet:cs
        {:
           RESULT = factory_.createHideAction(ca, cs);
           addLocAnn(RESULT, getLocation(ca, cs));
        :}
        <add:circustime>
		|
		/* Support for Circus Time; TODO: check if precedences are right here */
        CIRCWAIT:cw expression:e
        {:
            RESULT = factory_.getCircusTimeFactory().createWaitAction(e);
            addLocAnn(RESULT, getLocation(cw, e));
        :}
		|
		// you cannot use a refName here, as it expects a DECORWORD.
		// the presence of "COLON" here makes this a DECLWORD instead.
		// so you really need is either a bindDecl or just DECLWORD.
		// given bindDecl also allows opName, I am leaving just DECLWORD here (Leo to Neeraj)
		//CIRCWAIT refName:na COLON expression:e CIRCSPOT circusAction:ac
		CIRCWAIT DECLWORD:dw COLON expression:e CIRCSPOT circusAction:ac
		{:
			ZName zn = createZName(dw);
		    RESULT = factory_.createWaitExprAction(ac, e, zn);
		    addLocAnn(RESULT, getLocation(zn, ac));
		:}
		</add:circustime>
		<add:circusconf>
		|
		LCIRCCONF:lc circusAction:ca RCIRCCONF:rc
		{:
            RESULT = factory_.createConfidentialityAction(ca);
            addLocAnn(RESULT, getLocation(lc, rc));			
		:}
		</add:circusconf>
        |
        circusAction:cal LINTER:li nameSet:nsl BAR nameSet:nsr RINTER:ri circusAction:car
        {:
            RESULT = factory_.createInterleaveAction(factory_.list(cal, car), factory_.list(nsl, nsr));
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal INTERLEAVE:il circusAction:car
        {:
            RESULT = factory_.createInterleaveAction(factory_.list(cal, car),
              factory_.list(createEmptyNameSet(getLocation(cal, il)), createEmptyNameSet(getLocation(il, car))));
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal LPAR:lp nameSet:nsl BAR channelSet:cs BAR nameSet:nsr RPAR:rp circusAction:car
        {:
            RESULT = factory_.createParallelAction(factory_.list(cal, car), factory_.list(nsl, nsr), cs);
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal LPAR:lp BAR:bl channelSet:cs BAR:br RPAR:rp circusAction:car
        {:
            RESULT = factory_.createParallelAction(factory_.list(cal, car),
              factory_.list(createEmptyNameSet(getLocation(lp, bl)), createEmptyNameSet(getLocation(br, rp))), cs);
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal LSQUARE:lp nameSet:nsl BAR channelSet:csl BAR BAR channelSet:csr BAR nameSet:nsr RSQUARE:rp circusAction:car
        {:
            RESULT = factory_.createAlphabetisedParallelAction(factory_.list(cal, car),
              factory_.list(nsl, nsr), factory_.list(csl, csr));
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal LSQUARE:lp BAR:bl channelSet:csl BAR BAR channelSet:csr BAR:br RSQUARE:rp circusAction:car
        {:
            RESULT = factory_.createAlphabetisedParallelAction(factory_.list(cal, car),
              factory_.list(createEmptyNameSet(getLocation(lp, bl)), createEmptyNameSet(getLocation(br, rp))),
              factory_.list(csl, csr));
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal INTCHOICE:ic circusAction:car
        {:
            RESULT = factory_.createIntChoiceAction(factory_.list(cal, car));
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal EXTCHOICE:cs circusAction:car
        {:
            RESULT = factory_.createExtChoiceAction(factory_.list(cal, car));
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal CIRCINTERRUPT:cs circusAction:car
        {:
            RESULT = factory_.createInterruptAction(factory_.list(cal, car));
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        |
        circusAction:cal CIRCSEQ:cs circusAction:car
        {:
            RESULT = factory_.createSeqAction(factory_.list(cal, car));
            addLocAnn(RESULT, getLocation(cal, car));
        :}
        <add:circustime>
        |
        circusAction:ca CIRCENDBY LCIRCTIME expression:e RCIRCTIME
        {:
		    RESULT = factory_.createTimeEndByAction(ca, e);
		    addLocAnn(RESULT, getLocation(ca,e));
        :}
		|
        LCIRCTIME expression:e RCIRCTIME CIRCSTARTBY circusAction:ca
        {:
		    RESULT = factory_.createTimeStartByAction(ca, e);
		    addLocAnn(RESULT, getLocation(ca,e));
        :}
		|
        circusAction:al CIRCTIMEOUT LCIRCTIME expression:e RCIRCTIME  circusAction:ar
        {:
		    RESULT = factory_.createTimeoutAction(factory_.list(al, ar), e);
		    addLocAnn(RESULT, getLocation(al, ar));
        :}
		|
        circusAction:al CIRCTIMEDINTERRUPT:ti LCIRCTIME expression:e RCIRCTIME circusAction:ar
        {:
		    RESULT = factory_.createTimedinterruptAction(factory_.list(al, ar),e);
		    addLocAnn(RESULT, getLocation(al, ar));
		:}
		</add:circustime>
        |
        /* Due to a series of reasonable conflicts (listed below), we see that
         * the best choice is to introduce suitable notation (guard brackets,
         * AKA toirtoise angle brackets) for guarded actions.
         *
         * The alternative without the guard brackets would be to perform
         * smart scanning (i.e. look --- far --- ahead) on a series of
         * tokens (i.e. DECORWORD, LPAREN, RPAREN, etc.) in order to
         * disambiguate the grammar.
         *
         * Ambiguities:
         *      -> Name: action call, communication fields, input field restriction, predicate
         *                  refNameList from Assignment, Spec. Stmt., Schema hiding
         *      -> LPAREN : on-the-fly action call, parenthesised action, input field restriction, predicate
         * These unfolded even more problems with the expression and predicate
         * productions. In total, without the guard brackets, we had 34 conflicts
         * of which 10 were Reduce/Reduce and 24 were Shift/Reduce, for states
         * #606, #677, and #728 of Parser.xml version 1.263 (on commit; 1.262 before commit).
         * (see file transition.table.before.guardbrackets.txt on CZT_HOME/parser/tests/circus).
         */
        LCIRCGUARD:lg guard:g RCIRCGUARD:rg ANDALSO:cg circusAction:ca
        {:
            RESULT = factory_.createGuardedAction(ca, g);
            addLocAnn(RESULT, getLocation(g, ca));
        :} %prec _CIRCGUARD
        |
        communication:comm PREFIXTHEN:pt circusAction:ca
        {:
            RESULT = factory_.createPrefixingAction(ca, comm);
            addLocAnn(RESULT, getLocation(comm, ca));
        :}
        <add:circustime>
        |
		communication:comm PREFIXTHEN:pt LCIRCTIME expression:e RCIRCTIME circusAction:ac
        {:
		    RESULT = factory_.getCircusTimeFactory().createPrefixingExprAction(ac,comm,e);
		    addLocAnn(RESULT, getLocation(comm, ac));	    
        :}
		|
		communication:comm ATTIME:at  refName:na  PREFIXTHEN:pt  circusAction:ac
        {:
		    RESULT = factory_.getCircusTimeFactory().createAtPrefixingAction(ac,comm,na);
		    addLocAnn(RESULT, getLocation(comm, ac));
        :}
		|
		communication:comm ATTIME refName:na PREFIXTHEN:pt LCIRCTIME expression:e LCIRCTIME circusAction:ac
        {:
		    RESULT = factory_.getCircusTimeFactory().createAtPrefixingExprAction(ac,comm,na,e);
		    addLocAnn(RESULT, getLocation(comm, ac));
		:}
        </add:circustime>
        |
        actionCall:ac
        {:
            RESULT = ac;
        :}
        |
        circusAction:ca nameSubstitution:ns
        {:
            RESULT = factory_.createSubstitutionAction(ca, ns);
            addLocAnn(RESULT, getLocation(ca));
        :} %prec _RENAME
        /* tHIS ERROR production is innocous :-(
        |
        communication:comm error:e END
        {:
            LocInfo loc = getLocation(comm);
            RESULT = factory_.createPrefixingAction(factory_.createSkipAction(), comm);
            addLocAnn(RESULT, loc);
            parser.report_error(CircusParseMessage.MSG_MISSING_PREFIXTHEN_PREFIXACTION,
                          new Object[0], loc);
        :}*/
        ;

actionCall ::=
        /* Parameterised action call */
        DECORWORD:dw actualParameters:ap
        {:
            RESULT = factory_.createCallAction(createCircusName(dw), ap);
            addLocAnn(RESULT, dw.getLocation());
        :}
        |
        /* Action call */
        DECORWORD:dw
        {:
            RESULT = factory_.createCallAction(createCircusName(dw), factory_.createZExprList());
            addLocAnn(RESULT, dw.getLocation());
        :}
        ;

parenthesisedAction ::=
        /* Parenthesised action */
        LPAREN:lp circusAction:ca RPAREN:rp
        {:
           addParenthesisAnn(lp, ca, rp);
           RESULT = ca;
        :}
        |
        /* Parenthesised parameterised action or command */
        LPAREN:lp paramAction:pa RPAREN:rp
        {:
           addParenthesisAnn(lp, pa, rp);
           RESULT = pa;
        :}
        |
        /* On-the-fly parameterised action/command call */
        LPAREN:lp1 paramAction:pa RPAREN:rp1 actualParameters:el
        {:
            addParenthesisAnn(lp1, pa, rp1);
            Decorword an = createImplicitlyDeclActUniqueName(pa);
            ActionPara ap = createImplicitActionPara(an, pa);
            parserState_.addImplicitlyDeclActionPara(ap);
            RESULT = factory_.createCallAction(createCircusName(an), el);
            addLocAnn(RESULT, getLocation(lp1, el.get(el.size()-1)));
        :}
        |
        /* On-the-fly parameterised mu action call */
        LPAREN:lp1 CIRCMU:cm name:n CIRCSPOT paramAction:pa RPAREN:rp1 actualParameters:el
        {:
            MuAction mu = factory_.createMuAction(pa, n);
            addLocAnn(mu, getLocation(cm, pa));
            addParenthesisAnn(lp1, mu, rp1);

            Decorword an = createImplicitlyDeclActUniqueName(mu);
            ActionPara ap = createImplicitActionPara(an, mu);
            parserState_.addImplicitlyDeclActionPara(ap);
            RESULT = factory_.createCallAction(createCircusName(an), el);
            addLocAnn(RESULT, getLocation(lp1, el.get(el.size()-1)));
        :}
        |
        /* Action channel renaming */
        LPAREN:lp circusAction:ca RPAREN:rp channelRenaming:cr
        {:            
            addParenthesisAnn(lp, ca, rp);
            RESULT = factory_.createRenameAction(ca, cr);
            addLocAnn(RESULT, getLocation(lp, rp));
        :} %prec _RENAME         
        ;

guard ::=
       predicate:p
       {: RESULT = p; :}
       ;

communication ::=
        /* Synchronisation or communication without generic parameters */
        CHANNELNAME:dw optCommFields:ocf
        {:
            /* RefExpr: mixfix=false, explicit=false */
            RESULT = factory_.createCommunication(
                factory_.createRefExpr(createCircusName(dw)),  // channel name
                factory_.createCircusFieldList(ocf),      // communication fields
                CommUsage.Normal,                         // channel communication usage
                CircusUtils.retrieveCommPattern(ocf),     // communication pattern
                CircusUtils.DEFAULT_MULTISYNCH,           // default multi synch
                false                                     // not implicit
            );
            addLocAnn(RESULT, dw.getLocation());
        :}
        |
        /* Generic channels cannot be through synchronisation, hence commFields cannot be optional */
        CHANNELNAME:dw LSQUARE expressionList:el RSQUARE commFields:cf
        {:
            /* RefExpr: mixfix=false, explicit=true */
            RESULT = factory_.createCommunication(
              factory_.createRefExpr(createCircusName(dw),     // channel name with generic parameters
                  el, Boolean.FALSE, Boolean.TRUE),
                factory_.createCircusFieldList(cf),       // communication fields
                CommUsage.Generic,                // channel communication usage
                CircusUtils.retrieveCommPattern(cf),      // communication pattern
                CircusUtils.DEFAULT_MULTISYNCH,           // default multi synch
                false                                     // not implicit
            );
            addLocAnn(RESULT, dw.getLocation());
        :}
        |
        /*
         * The channel error token is converted from DECORWORD by the smart scanner.
         * And that happens only when a PREFIXTHEN has been found ahead, but the field
         * names does not match the number of strokes. So, we can rely on PREFIXTHEN
         * appearing after the error token. This is different from most places where
         * error appear, in which case NL is mostly used as the lookahead token.
         */
        CHANNELERROR:ce error:e PREFIXTHEN
        {:
           LocInfo loc = ce.getLocation();
           RESULT = factory_.createCommunication(
                factory_.createRefExpr(createCircusName(ce)),  // channel name
                factory_.createCircusFieldList(),         // empty communication fields
                CommUsage.Normal,                         // channel communication usage
                CommPattern.Mixed,                        // assume mixed
                CircusUtils.DEFAULT_MULTISYNCH,           // default multi synch
                false                                     // not implicit
            );
            addLocAnn(RESULT, loc);
            Pair&lt;Integer, Integer&gt; counters = ce.getExtraInfo();
            if (counters == null)
            {
              counters = new Pair&lt;Integer, Integer&gt;(-1, -1);
            }
            final Object[] params = { ce.getWord(), counters.getFirst(), counters.getSecond() };
            parser.report_error(CircusParseMessage.MSG_WRONG_NUMBER_FIELD_STROKES,
                                params, loc);
        :}
        /*
         * This error production, with anyCircusSymbol or END, does not work as
         * expected. Instead, the CUP lr_parser keeps looking ahead until EOF.
         * So, remove it for now, and fix it latter.
        |
        DECORWORD:dw error:e anyCircusSymbol
        {:
           RESULT = factory_.createCommunication(
                factory_.createRefExpr(createCircusName(dw)),  // channel name
                factory_.createCircusFieldList(),         // empty communication fields
                CommUsage.Normal,                         // channel communication usage
                CommPattern.Mixed,                        // assume mixed
                CircusUtils.DEFAULT_MULTISYNCH,           // default multi synch
                false                                     // not implicit
            );
            addLocAnn(RESULT, dw.getLocation());
            final Object[] params = { dw.getWord() };
            parser.report_error(CircusParseMessage.MSG_COMMPATTERN_NOT_RECOGNISED,
                                params, dw.getLocation());
        :}
        */
        ;

//anyCircusSymbol ::=
//        CIRCTHEN | CIRCSKIP | CIRCSTOP | CIRCSTATE | END | NL | PREFIXTHEN
//        ;

optCommFields ::=
        commFields:cf
        {: RESULT = cf; :}
        |
        /* Synchronisation has empty communication fields */
        {: RESULT = factory_.&lt;Field&gt;list(); :}
        ;

commFields ::=
        commFields:cfs commField:cf
        {:
            assert cfs != null;
            cfs.add(cf);
            RESULT = cfs;
        :}
        |
        commField:cf
        {:
            RESULT = factory_.list(cf);
        :}
        ;

// Strangelly enough, this productions for FDR allows quite funny
// rules, such as c?expr, or lamda and if terms within a communication pattern.
// We decided to leave then out as they seem to be uncessary - they fall into an
// ambigous part of the grammar that is allowed by the parser but catched by the
// CSP_m compiler.
//
// With further analysis, and the FM08 paper of M.Leushel, it became clearer
// that the FDR way of handling CSP_m is very tricky indeed. There are many
// irregular and awkward cases. We have normalise them here.
commField ::=
        /**
         * We perform smart scanning on communication (i.e., lookahead for
         * PREFIXTHEN and PREFIXCOLON) to see how to treat the DECORWORDs.
         * If they have strokes, we add the strokes to the token stack, then
         * clear the strokes from the DECORWORD. The parser will then tokenise
         * the token stream and raise the right errors, it any.
         *
         * That means, CHANNELNAME and FIELDNAME (the lookahead DECORWORDs)
         * DO NOT HAVE any strokes. This solution is needed to cope with
         * awkward cases in the combination of Z and CSP.
         * ex: c??x!!.y!?z  --- (c?) ? (x!!) . (y!) ? (z)
         *
         * The initial solution was to keep it as close to CSP and Z as possible
         * and we needed to have special hard spaces at various places. But this
         * did not solved the problem that output/dot fields were being confused
         * with binding/tuple selection expressions, and only the type checker
         * could distinguish what is what. That lead to the more sophisticated
         * solution with no stroked names and smart scanning.
        /* Input communicatio as in: c?x */
        CHANNELIN:in FIELDNAME:dw
        {:
            RESULT = factory_.createInputField(createCircusName(dw), factory_.createTruePred());
            addLocAnn(RESULT, getLocation(in, dw.getLocation()));
        :}
        |
        /* Input communicatio as in: c?x : P */
        CHANNELIN:in FIELDNAME:dw PREFIXCOLON LPAREN predicate:p RPAREN
        {:
            RESULT = factory_.createInputField(createCircusName(dw), p);
            addLocAnn(RESULT, getLocation(in, dw.getLocation()));
        :}
        |
        /* Output communicatio as in: c!e */
        CHANNELOUT:out expression:e
        {:
            RESULT = factory_.getCircusFactory().createOutputField(e);
            addLocAnn(RESULT, getLocation(out, e));
        :}
        |
        // Differently from FDR, we allow expressions to appear at dot fields as well.
        /* Output communicaion as in: c.e */
        CHANNELDOT:dt expression:e
        {:
            RESULT = factory_.createDotField(e);
            addLocAnn(RESULT, getLocation(dt, e));
        :}
        |
        /*
         * This production catches the case where parenthesis around the predicate
         * were missing. The same is not possible for OUTSTROKE/CHANNELDOT because
         * there isn't any special symbol before the production - and we don't want
         * to mess around with the very complex 'expression' production.
         *
         * See the SmartScanner.pushCommPatternList for more details on this.
         */
        CHANNELIN:in FIELDNAME:dw PREFIXCOLON error:e END
        {:
            RESULT = factory_.createInputField(createCircusName(dw), factory_.createTruePred());
            addLocAnn(RESULT, getLocation(in, dw.getLocation()));
            final Object[] params = { dw.getWord() };
            parser.report_error(CircusParseMessage.MSG_COMMPATTERN_PREFIXCOLON_NOT_RECOGNISED,
                                params, dw.getLocation());
        :}
        |
        CHANNELIN:in DECORWORD:dw error:e END
        {:
            RESULT = factory_.createInputField(createCircusName(dw), factory_.createTruePred());
            addLocAnn(RESULT, getLocation(in, dw.getLocation()));
            final Object[] params = { dw.getWord() };
            parser.report_error(CircusParseMessage.MSG_COMMPATTERN_NOT_RECOGNISED,
                                params, dw.getLocation());
        :}
        |
        CHANNELDOT:in DECORWORD:dw error:e END
        {:
            RESULT = factory_.getCircusFactory().createDotField(
              factory_.createRefExpr(createCircusName(dw)));
            addLocAnn(RESULT, getLocation(in, dw.getLocation()));
            final Object[] params = { dw.getWord() };
            parser.report_error(CircusParseMessage.MSG_COMMPATTERN_NOT_RECOGNISED,
                                params, dw.getLocation());
        :}
        |
        CHANNELOUT:in DECORWORD:dw error:e END
        {:
            RESULT = factory_.getCircusFactory().createOutputField(
              factory_.createRefExpr(createCircusName(dw)));
            addLocAnn(RESULT, getLocation(in, dw.getLocation()));
            final Object[] params = { dw.getWord() };
            parser.report_error(CircusParseMessage.MSG_COMMPATTERN_NOT_RECOGNISED,
                                params, dw.getLocation());
        :}
        ;

/// Command (Action) paragraphs (as part of Process paragraph) ////////////////////////////////

command ::=
        /* Assignment */
        refNameList:rnl CIRCASSIGN:ca expressionList:el
        {:
            RESULT = factory_.createAssignmentCommand(
              createAssignmentPairs(ca, factory_.createZNameList(rnl), el));
            addLocAnn(RESULT, getLocation(rnlleft, rnlright, rnl.get(0), el));
        :}
        |
        /* Alternative */
        IF:cif guardedCommands:gcs CIRCFI:cfi
        {:
            RESULT = factory_.createIfGuardedCommand(factory_.createCircusActionList(gcs));
            addLocAnn(RESULT, getLocation(cif, cfi));
        :} %prec _CIRCIF
        |
        /* Iteration */
        CIRCDO:cdo guardedCommands:gcs CIRCOD:cod
        {:
            RESULT = factory_.createDoGuardedCommand(factory_.createCircusActionList(gcs));
            addLocAnn(RESULT, getLocation(cdo, cod));
        :}
        |
        /* Variable declaration */
        CIRCVAR:cv circusParamZDeclList:dp CIRCSPOT circusAction:ca
        {:
            // DESIGN: we do not allow schema inclusion. only variable declaration.

            // NOTE: Variable names with decorations should not be allowed here,
            //       as they mess up their interpretation when added to the state
            //       (e.g., for var x: \nat TC includes x, x', x?, x! , if we allow
            //       var x?: \nat TC will include x?, x?', x??, x!?). Also it makes
            //       prefixing very confusing too (e.g., in "c?x??!x!?z", what should
            //       be the communication pattern? "c ? (x??) ! (x!) ? z"? The smart
            //       scanner makes sure, by differentiating DECORWORD into CHANNELNAME
            //       and FIELDNAME by ensuring no decorated names are allowed as either
            //       terminal. So, the above tokenises as "c ? (x) ??! (x) !? z", which
            //       then is clearly a parsing error.
            RESULT = factory_.createVarDeclCommand(dp, ca);
            addLocAnn(RESULT, getLocation(cv, ca));
        :}
        |
        /* Specification statement */
        refNameList:rnl PREFIXCOLON LSQUARE predicate:pre COMMA predicate:post RSQUARE
        {:
            RESULT = factory_.createSpecStmtCommand(factory_.createZNameList(rnl),
              factory_.list(pre, post));
            addLocAnn(RESULT, getLocation(getLocation(rnlleft, rnlright), getLocation(post)));
        :}
        |
        /* Specification statement with empty frame*/
        PREFIXCOLON:c LSQUARE predicate:pre COMMA predicate:post RSQUARE:rsq
        {:
            RESULT = factory_.createSpecStmtCommand(factory_.createZNameList(),
              factory_.list(pre, post));
            addLocAnn(RESULT, getLocation(c, rsq));
        :}
        /* Assumption */
        |
        LBRACE:lb predicate:pre RBRACE:rb
        {:
            RESULT = factory_.createSpecStmtCommand(factory_.createZNameList(),
              factory_.list(pre, factory_.createTruePred()));
            addLocAnn(RESULT, getLocation(getLocation(lbleft, lbright), getLocation(rbleft, rbright)));
        :}
        /* Coercion */
        |
        LSQUARE:ls predicate:post RSQUARE:rs
        {:
            RESULT = factory_.createSpecStmtCommand(factory_.createZNameList(),
              factory_.list(factory_.createTruePred(), post));
            addLocAnn(RESULT, getLocation(getLocation(lsleft, lsright), getLocation(rsleft, rsright)));
        :}
        ;

guardedCommands ::=
        guardedCommands:gcs CIRCELSE guardedCommand:g
        {:
           gcs.add(g);
           RESULT = gcs;
        :}
        |
        guardedCommand:g
        {:
           RESULT = factory_.list(g);
        :}
        ;

guardedCommand ::=
        guard:g CIRCTHEN circusAction:ca
        {:
            RESULT = factory_.createGuardedAction(ca, g);
            addLocAnn(RESULT, getLocation(g, ca));
        :}
        ;

nameSubstitution ::=
        LSQUARE:ls renameList:rnl RSQUARE:rs
        {:
            RESULT = rnl;
            addLocAnn(RESULT, getLocation(ls, rs));
        :}
        ;

// TODO: CHECK Shall it allow basic process here? i.e. shall "process" not contain "circusBasicProc"
//       and this production should then go to processDesc? (Seems ok - 07/Mar/2008).
processRefPara ::=
        name:n CIRCASSERTREF process:spec refines:r process:impl
        {:
           RESULT = factory_.createTransformerPara(n,
                factory_.createProcessTransformerPred(null, r, parserState_.getRefinementModel(),
                factory_.list(spec, impl)));
           addLocAnn(RESULT, getLocation(getLocation(spec), getLocation(impl)));
           parserState_.clearRefinementModel();
        :}
        ;

actionRefPara ::=
        name:n CIRCASSERTREF circusAction:spec refines:r circusAction:impl
        {:
           RESULT = factory_.createTransformerPara(n,
                factory_.createActionTransformerPred(null, r,
                parserState_.getRefinementModel(), factory_.list(spec, impl)));
           addLocAnn(RESULT, getLocation(getLocation(spec), getLocation(impl)));
           parserState_.clearRefinementModel();

        :}
        ;

refines ::=
        CIRCSIMULATES
        {: RESULT = Transformation.Simulation; :}
        |
        EQUALS
        {: RESULT = Transformation.Equivalence; :}
        |
        CIRCREFINES
        {:
           RESULT = Transformation.Refinement;
           parserState_.setRefinementModel(CircusUtils.DEFAULT_REFINEMENT_MODEL);
        :}
        |
        CIRCREFINES DECORWORD:dw
        {:
           RESULT = Transformation.Refinement;
           parserState_.setRefinementModel(validateModel(dw));
        :}
        ;
</add:circus>

/// schema text ///////////////////////////////////////////

schemaText ::=
        optDeclPart:odp BAR predicate:p
        {:
           RESULT = factory_.createZSchText(odp, p);
           <add:zeves>
           parserState_.clearLabelAssociations(p);
           </add:zeves>
           addLocAnn(RESULT, getLocation(getLocation(odp),
                                         getLocation(p)));
        :}
        |
        optDeclPart:odp
        {:
           RESULT = factory_.createZSchText(odp, null);
           addLocAnn(RESULT, getLocation(odp));
        :}
        ;

axiomaticSchemaText ::=
        optDeclPart:odp BAR predicate:p
        {:
           RESULT = factory_.createZSchText(odp, p);
           <add:zeves>
           parserState_.associateLabelsToPreds(p);
           </add:zeves>
           addLocAnn(RESULT, getLocation(getLocation(odp),
                                         getLocation(p)));
        :}
        |
        optDeclPart:odp
        {:
           RESULT = factory_.createZSchText(odp, null);
           addLocAnn(RESULT, getLocation(odp));
        :}
        ;

<add:zeves>
optAxLabel ::=
        LLABEL:l optLabelAbility:ability optUsage:usage thmName:n RLABEL:r
        {:
          RESULT = factory_.createZEvesLabel(n, ability, usage);
          //n.getAnns().add(RESULT); To avoid circular annotation loops in ZML
          addLocAnn(RESULT, getLocation(l, r));
        :}
        |
        // empty
        {:
          // create a label as an axiom
          RESULT = createDefaultZEvesLabel(LabelAbility.none, LabelUsage.none);
        :}
        ;
</add:zeves>

optDeclPart ::=
        //empty
        {: RESULT = factory_.createZDeclList(); :}
        |
        declPart:dp
        {: RESULT = dp; :}
        ;

declPart ::=
        zDeclList:zdl
        {:
           RESULT = zdl;
           addLocAnn(zdl, getLocation(getLocation(zdl.get(0)),
                                      getLocation(zdl.get(zdl.size() - 1))));
        :}
<add:pattern>
        | jokerDeclList:jdl
        {: RESULT = jdl; :}
        ;

jokerDeclList ::=
        zDeclList:zdl sep:s JOKERDECLLIST:j
        {: RESULT = factory_.createHeadDeclList(zdl,
             factory_.createJokerDeclList(j.getString(), null)); :}
        |
        JOKERDECLLIST:j
        {:
           RESULT = factory_.createJokerDeclList(j.getString(), null);
        :}
</add:pattern>
        ;

zDeclList ::=
        declaration:d
        {: RESULT = factory_.createZDeclList(factory_.list(d)); :}
        |
        zDeclList:zdl sep declaration:d
        {:
           zdl.add(d);
           RESULT = zdl;
        :}
        ;

declaration ::=
        basicDeclaration:bd
        {: RESULT = bd; :}
        |
        expression:e
        {: RESULT = factory_.createInclDecl(e); :}
        ;

schemaTextNoExpression ::=
        optDeclPart:dp BAR predicate:p
        {:
           RESULT = factory_.createZSchText(dp, p);
        :}
        |
        zDeclList:zdl sep declaration:d
	{:
           zdl.add(d);
           RESULT = factory_.createZSchText(zdl, null);
	:}
	|
	basicDeclaration:bd
	{:
           ZDeclList zdl = factory_.createZDeclList(factory_.list(bd));
           RESULT = factory_.createZSchText(zdl, null);
        :}
        ;

basicDeclaration ::=
        varDecl:vd
        {: RESULT = vd; :}
        |
        constDecl:cd
        {: RESULT = cd; :}
        ;

varDecl ::=
        declWordList:dwl COLON:colon expression:e
        {:
           RESULT = factory_.createVarDecl(dwl, e);
           if (dwl.size() > 0) {
             LocInfo loc = getLocation(colonleft, colonright, dwl.get(0), e);
             addLocAnn(RESULT, loc);
           }
           else {
             addLocAnn(RESULT, getLocation(colon, e));
           }
        :}
        |
        declWordList:dwl COLON:colon error:e
        {:
           ZParseMessage msg = ZParseMessage.MSG_SYNTAX_ERROR_IN_VARDECL;
           parser.report_syntax_error(msg);
        :}
<add:pattern>
        |
        JOKERNAME:jn COLON expression:e
        {:
           Name dn = factory_.createJokerName(jn.getString(), null);
           ZNameList zdnl = factory_.createZNameList();
           zdnl.add(dn);
           RESULT = factory_.createVarDecl(zdnl, e);
           addLocAnn(RESULT, getLocation(jn.getLocation(), e));
        :}
</add:pattern>
        ;

constDecl ::=
        declName:dn DEFEQUAL:defequal expression:e
        {:
           RESULT = factory_.createConstDecl(dn, e);
           addLocAnn(RESULT, getLocation(defequalleft, defequalright, dn, e));
        :}
<add:pattern>
        |
        JOKERNAME:jn DEFEQUAL:defequal expression:e
        {:
           Name dn = factory_.createJokerName(jn.getString(), null);
           RESULT = factory_.createConstDecl(dn, e);
           LocInfo jnLoc = jn.getLocation();
           LocInfo loc = getLocation(defequalleft, defequalright, jnLoc, e);
           addLocAnn(RESULT, loc);
        :}
</add:pattern>
        ;

sep ::=
        SEMICOLON
        {: RESULT = And.Semi; :}
        |
        NL
        {: RESULT = And.NL; :}
        ;

/// word, declName, and refName lists ////////////////////////////////////

nameList ::=
        nameList:nl COMMA DECORWORD:dw
        {:
           Name dn = createZName(dw);
           nl.add(dn);
           RESULT = nl;
        :}
        |
        DECORWORD:dw
        {:
           Name dn = createZName(dw);
           RESULT = factory_.createZNameList();
           RESULT.add(dn);
        :}
        ;

name ::=
        DECORWORD:dw
        {:
           RESULT = createZName(dw);
        :}
<add:oz>
        |
        DEFNAME:dfn
        {:
           RESULT = createZName(dfn);
        :}
</add:oz>
<add:zeves>
        //|
        //DECORWORD:dw TO
        //{:
        //   RESULT = createSpecialName(dw);
        //   //System.out.println("name ::= " + RESULT);
        //:}
        //|
        //// for cases like x$ and x$'  (e.g., renamed captured names)
        //DECORWORD:dw ZPROOFDOLLAR:d
        //{:
        //  RESULT = createSpecialName(dw);
        //:}
        //|
        //DECORWORD:dw ZPROOFDOLLARSTROKE:d
        //{:
        //  RESULT = createSpecialName(dw, d);
        //:}
</add:zeves>
        ;

declWordList ::=
        declWordList:dwl COMMA DECLWORD:dw
        {:
           Name dn = createZName(dw);
           dwl.add(dn);
           RESULT = dwl;
        :}
        |
        declWordList:dwl COMMA opName:on
        {:
           LocInfo loc = getLocation(onleft, onright);
           Name dn = strListToZName(on, loc);
           if (dn != null) {
             addLocAnn(dn, loc);
             dwl.add(dn);
           }
           RESULT = dwl;
        :}
        |
        declWordList:dwl COMMA misusedOpName:mon
        {:
           misusedOpName(mon);
           RESULT = factory_.createZNameList();
        :}
        |
        opName:on
        {:
           LocInfo loc = getLocation(onleft, onright);
           Name dn = strListToZName(on, loc);
           if (dn != null) {
             addLocAnn(dn, loc);
           }
           RESULT = factory_.createZNameList();
           RESULT.add(dn);
        :}
        |
        DECLWORD:dw
        {:
           Name dn = createZName(dw);
           RESULT = factory_.createZNameList();
           RESULT.add(dn);
        :}
        |
        misusedOpName:mon
        {:
           misusedOpName(mon);
           RESULT = factory_.createZNameList();
        :}
        ;

misusedOpName ::=
        PREP:p
        {: RESULT = p; :}
        |
        PRE:p
        {: RESULT = p; :}
        |
        POSTP:p
        {: RESULT = p; :}
        |
        POST:p
        {: RESULT = p; :}
        |
        IP:ip
        {: RESULT = ip; :}
        |
        I:i
        {: RESULT = i; :}
        |
        LP:lp
        {: RESULT = lp; :}
        |
        L:l
        {: RESULT = l; :}
        |
        ELP:elp
        {: RESULT = elp; :}
        |
        EL:el
        {: RESULT = el; :}
        |
        ERP:erp
        {: RESULT = erp; :}
        |
        ER:er
        {: RESULT = er; :}
        |
        SRP:srp
        {: RESULT = srp; :}
        |
        SR:sr
        {: RESULT = sr; :}
        |
        EREP:erep
        {: RESULT = erep; :}
        |
        ERE:ere
        {: RESULT = ere; :}
        |
        SREP:srep
        {: RESULT = srep; :}
        |
        SRE:sre
        {: RESULT = sre; :}
        |
        ES:es
        {: RESULT = es; :}
        |
        SS:ss
        {: RESULT = ss; :}
        ;

declName ::=
        name:n
        {: RESULT = n; :}
        |
        opName:on
        {:
           LocInfo loc = getLocation(onleft, onright);
           RESULT = strListToZName(on, loc);
           addLocAnn(RESULT, loc);
        :}
        ;

refNameList ::=
        refNameList:rnl COMMA DECORWORD:dw
        {:
           ZName rn = createZName(dw);
           rnl.add(rn);
           RESULT = rnl;
        :}
        <add:oz>
        |
        refNameList:rnl COMMA INITWORD:iw
        {:
           ZName rn = factory_.createZName(OzString.INITWORD);
           addLocAnn(rn, getLocation(iwleft, iwright));
           rnl.add(rn);
           RESULT = rnl;
        :}
        </add:oz>
        |
        DECORWORD:dw
        {:
           ZName rn = createZName(dw);
           RESULT = factory_.list(rn);
        :}
        <add:oz>
        |
        INITWORD:iw
        {:
           ZName rn = factory_.createZName(OzString.INITWORD);
           addLocAnn(rn, getLocation(iwleft, iwright));
           RESULT = factory_.list(rn);
        :}
        </add:oz>
        ;

refName ::=
        DECORWORD:dw
        {:
           RESULT = createZName(dw);
        :}
        <add:oz>
        |
        INITWORD:iw
        {:
           RESULT = factory_.createZName(OzString.INITWORD);
           addLocAnn(RESULT, getLocation(iwleft, iwright));
        :}
        </add:oz>
        <add:circus>
        |
        /* a field name can be an expression */
        FIELDNAME:dw
        {:
           RESULT = createCircusName(dw);
        :}
        </add:circus>
        |
        LPAREN:lparen opName:on RPAREN:rparen
        {:
           final LocInfo loc = getLocation(lparen, rparen);
           RESULT = strListToZName(on, loc);
           RESULT.getAnns().add(factory_.createParenAnn());
        :}
        ;

opName ::=
        prefixName:pn
        {: RESULT = pn; :}
        |
        postfixName:pn
        {: RESULT = pn; :}
        |
        infixName:in
        {: RESULT = in; :}
        |
        nofixName:nn
        {: RESULT = nn; :}
        ;

prefixName ::=
        PRE:p varg
        {: RESULT = factory_.list(p.getString(), ARG_TOK); :}
        |
        PREP:p varg
        {: RESULT = factory_.list(p.getString(), ARG_TOK); :}
        |
        L:l optVargEsSsList:ouesl argEreOrSre:aeos varg
        {:
           RESULT = factory_.list(l.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        :}
        |
        LP:lp optVargEsSsList:ouesl argErepOrSrep:aeos varg
        {:
           RESULT = factory_.list(lp.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        :}
        ;

postfixName ::=
        varg POST:p
        {: RESULT = factory_.list(ARG_TOK, p.getString()); :}
        |
        varg POSTP:p
        {: RESULT = factory_.list(ARG_TOK, p.getString()); :}
        |
        varg EL:el optVargEsSsList:ouesl argErOrSr:aeos
        {:
           RESULT = factory_.list(ARG_TOK);
           RESULT.add(el.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        :}
        |
        varg ELP:elp optVargEsSsList:ouesl argErpOrSrp:aeos
        {:
           RESULT = factory_.list(ARG_TOK);
           RESULT.add(elp.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        :}
        ;


infixName ::=
        varg I:i varg
        {:
           RESULT = factory_.list(ARG_TOK);
           RESULT.add(i.getString());
           RESULT.add(ARG_TOK);
        :}
        |
        varg IP:ip varg
        {:
           RESULT = factory_.list(ARG_TOK);
           RESULT.add(ip.getString());
           RESULT.add(ARG_TOK);
        :}
        |
        varg EL:el optVargEsSsList:ouesl argEreOrSre:aeos varg
        {:
           RESULT = factory_.list(ARG_TOK);
           RESULT.add(el.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        :}
        |
        varg ELP:elp optVargEsSsList:ouesl argErepOrSrep:aeos varg
        {:
           RESULT = factory_.list(ARG_TOK);
           RESULT.add(elp.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
           RESULT.add(ARG_TOK);
        :}
        ;

nofixName ::=
        L:l optVargEsSsList:ouesl argErOrSr:aeos
        {:
           RESULT = factory_.list(l.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        :}
        |
        LP:lp optVargEsSsList:ouesl argErpOrSrp:aeos
        {:
           RESULT = factory_.list(lp.getString());
           RESULT.addAll(ouesl);
           RESULT.addAll(aeos);
        :}
        ;

optVargEsSsList ::=
        //empty
        {: RESULT = factory_.list(); :}
        |
        optVargEsSsList:ouesl argEsOrSs:aeos
        {:
           ouesl.addAll(aeos);
           RESULT = ouesl;
        :}
        ;

argEsOrSs ::=
        ARG ES:es
        {: RESULT = factory_.list(ARG_TOK, es.getString()); :}
        |
        LISTARG SS:ss
        {: RESULT = factory_.list(LISTARG_TOK, ss.getString()); :}
        ;

argEreOrSre ::=
        ARG ERE:ere
        {: RESULT = factory_.list(ARG_TOK, ere.getString()); :}
        |
        LISTARG SRE:sre
        {: RESULT = factory_.list(LISTARG_TOK, sre.getString()); :}
        ;

argErepOrSrep ::=
        ARG EREP:erep
        {: RESULT = factory_.list(ARG_TOK, erep.getString()); :}
        |
        LISTARG SREP:srep
        {: RESULT = factory_.list(LISTARG_TOK, srep.getString()); :}
        ;

argErOrSr ::=
        ARG ER:er
        {: RESULT = factory_.list(ARG_TOK, er.getString()); :}
        |
        LISTARG SR:sr
        {: RESULT = factory_.list(LISTARG_TOK, sr.getString()); :}
        ;

argErpOrSrp ::=
        ARG ERP:erp
        {: RESULT = factory_.list(ARG_TOK, erp.getString()); :}
        |
        LISTARG SRP:srp
        {: RESULT = factory_.list(LISTARG_TOK, srp.getString()); :}
        ;

//a genName is returned as a pair, with the first item being the name,
//and the second being a list of generic parameters
genName ::=
        prefixGenName:pgn
        {: RESULT = pgn; :}
        |
        postfixGenName:pgn
        {: RESULT = pgn; :}
        |
        infixGenName:ign
        {: RESULT = ign; :}
        |
        nofixGenName:ngn
        {: RESULT = ngn; :}
        ;

prefixGenName ::=
        PRE:pre name:formalParameter
        {:
           List&lt;String&gt; name = factory_.list(pre.getString(), ARG_TOK);
           ZNameList decls = factory_.createZNameList();
           decls.add(formalParameter);
           LocInfo loc = getLocation(formalParameterleft,
                                     formalParameterright);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair&lt;Name, ZNameList&gt;(declName, decls);
        :}
        |
        L:l optNameEsSsList:onesl name:fpn1
             ereOrSre:eos name:fpn2
        {:
           //construct the name
           List&lt;String&gt; name = factory_.list(l.getString());
           
           // BUGFIX:
           // NOTE: This template is for rather complex (i.e. ternary etc) generic operator template.
           //		Surprisingly, there are non in the standard toolkit, and the standard itself is
           //		rather vague about examples of such complex operators. We tried but couldn't create
           //		an example to "test" this production, but at least now the types are right.
           //name.addAll((List) onesl.getSecond());
           name.addAll(extractNamesFromNameList(onesl.getSecond()));
           name.add(ARG_TOK);
           name.add(eos.getString());
           name.add(ARG_TOK);

           //construct the parameter list
           ZNameList fps = onesl.getFirst();
           fps.add(fpn1);
           fps.add(fpn2);
           LocInfo loc = getLocation(fpn2left, fpn2right);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair&lt;Name, ZNameList&gt;(declName, fps);
        :}
        ;

postfixGenName ::=
        name:fpn POST:p
        {:
           List&lt;String&gt; name = factory_.list(ARG_TOK, p.getString());
           ZNameList decls = factory_.createZNameList();
           decls.add(fpn);
           LocInfo loc = getLocation(pleft, pright);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair&lt;Name, ZNameList&gt;(declName, decls);
        :}
        |
        name:fpn1 EL:el optNameEsSsList:onesl name:fpn2 erOrSr:eos
        {:
           //construct the name
           List&lt;String&gt; name = factory_.list(ARG_TOK);
           name.add(el.getString());

           // BUGFIX:
           // NOTE: This template is for rather complex (i.e. ternary etc) generic operator template.
           //		Surprisingly, there are non in the standard toolkit, and the standard itself is
           //		rather vague about examples of such complex operators. We tried but couldn't create
           //		an example to "test" this production, but at least now the types are right.
           //name.addAll((List) onesl.getSecond());
           name.addAll(extractNamesFromNameList(onesl.getSecond()));

           name.add(ARG_TOK);
           name.add(eos.getString());

           //construct the parameter list
           ZNameList fps = factory_.createZNameList();
           fps.add(fpn1);
           fps.addAll(onesl.getFirst());
           fps.add(fpn2);
           LocInfo loc = getLocation(eosleft, eosright);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair&lt;Name, ZNameList&gt;(declName, fps);
         :}
        ;

infixGenName ::=
        name:fpn1 I:i name:fpn2
        {:
           //construct the name
           List&lt;String&gt; name = factory_.list(ARG_TOK);
           name.add(i.getString());
           name.add(ARG_TOK);

           //construct the parameter list
           ZNameList fps = factory_.createZNameList();
           fps.add(fpn1);
           fps.add(fpn2);
           LocInfo loc = getLocation(fpn2left, fpn2right);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair&lt;Name, ZNameList&gt;(declName, fps);
        :}
        |
        name:fpn1 EL:el optNameEsSsList:onesl name:fpn2 ereOrSre:eos name:fpn3
        {:
           //construct the name
           List&lt;String&gt; name = factory_.list(ARG_TOK);
           name.add(el.getString());

           // BUGFIX:
           // NOTE: This template is for rather complex (i.e. ternary etc) generic operator template.
           //		Surprisingly, there are non in the standard toolkit, and the standard itself is
           //		rather vague about examples of such complex operators. We tried but couldn't create
           //		an example to "test" this production, but at least now the types are right.
           //name.addAll((List) onesl.getSecond());
           name.addAll(extractNamesFromNameList(onesl.getSecond()));

           name.add(ARG_TOK);
           name.add(eos.getString());
           name.add(ARG_TOK);
           //construct the parameter list
           ZNameList fps = factory_.createZNameList();
           fps.add(fpn1);
           fps.addAll(onesl.getFirst());
           fps.add(fpn2);
           fps.add(fpn3);
           LocInfo loc = getLocation(fpn3left, fpn3right);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair&lt;Name, ZNameList&gt;(declName, fps);
        :}
        ;

nofixGenName ::=
        L:l optNameEsSsList:onesl name:fpn erOrSr:eos
        {:
           //construct the name
           List&lt;String&gt; name = factory_.list(l.getString());
           
           // BUGFIX:
           // NOTE: This template is for rather complex (i.e. ternary etc) generic operator template.
           //		Surprisingly, there are non in the standard toolkit, and the standard itself is
           //		rather vague about examples of such complex operators. We tried but couldn't create
           //		an example to "test" this production, but at least now the types are right.
           //name.addAll((List) onesl.getSecond());
           name.addAll(extractNamesFromNameList(onesl.getSecond()));
           
           name.add(ARG_TOK);
           name.add(eos.getString());

           //construct the parameter list
           ZNameList fps = onesl.getFirst();
           fps.add(fpn);
           LocInfo loc = getLocation(eosleft, eosright);
           Name declName = strListToZName(name, loc);
           RESULT = new Pair&lt;Name, ZNameList&gt;(declName, fps);
        :}
        ;

//an optNameEsSsList is returned as a pair, with the first item
//being a list comprising generic parameters, and the second being a
//list comprising the name
optNameEsSsList ::=
        //empty
        {: RESULT = new Pair&lt;ZNameList, ZNameList&gt;(factory_.createZNameList(),
                             factory_.createZNameList()); :}
        |
        optNameEsSsList:ouesl name:fpn esOrSs:eos
        {:
           ZNameList gens = ouesl.getFirst();
           gens.add(fpn);
           List&lt;ZNameList&gt; name = factory_.list(ouesl.getSecond());
           // BUG?/TODO: This can't be right. The result is a list of ZNameLists and
           //			 the code just adds two strings to the list?
           //
           // NOTE: This template is for rather complex (i.e. ternary etc) generic operator template.
           //		Surprisingly, there are non in the standard toolkit, and the standard itself is
           //		rather vague about examples of such complex operators. We tried but couldn't create
           //		an example to "test" this production, but at least now the types are right.
           //name.add(ARG_TOK);
           //name.add(eos.getString());
           name.add(factory_.createZNameList(
 		  		factory_.list(factory_.createZName(ARG_TOK), 
   					  factory_.createZName(eos.getString()))));
           RESULT = ouesl;
        :}
        ;

// these results are LocString
esOrSs ::=
        ES:es
        {: RESULT = es; :}
        |
        SS:ss
        {: RESULT = ss; :}
        ;

ereOrSre ::=
        ERE:ere
        {: RESULT = ere; :}
        |
        SRE:sre
        {: RESULT = sre; :}
        ;

erOrSr ::=
        ER:er
        {: RESULT = er; :}
        |
        SR:sr
        {: RESULT = sr; :}
        ;

/// predicates and expressions ///////////////////////////////////////////////

// This is for terms which MUST be predicates, so MIGHT contain NL/SEMI.
predicate ::=
        predicate:lhs sep:s <add:zeves>optAxLabel:label</add:zeves> term:rhs
        {:
           Pred rhsp = pred(rhs);
           <add:zeves>
           parserState_.storeZEvesLabelFor(rhsp, label);
           </add:zeves>
           RESULT = factory_.createAndPred(lhs, rhsp, s);
           addLocAnn(RESULT, getLocation(sleft, sright, lhs, rhs));
        :}
        |
        <add:zeves>optAxLabel:label</add:zeves> term:p
        {:
            RESULT = pred(p);
            <add:zeves>
            parserState_.storeZEvesLabelFor(RESULT, label);  
            </add:zeves>
        :}
        ;

expression ::=
        term:t
        {: RESULT = expr(t); :}
        ;

// This is for terms (which may be expr or pred) which MIGHT contain
// NL/SEMI.  If they do contain NL/SEMI, they must be predicates!
septerm ::=
        septerm:lhs sep:s term:rhs
        {:
           RESULT = factory_.createAndPred(pred(lhs), pred(rhs), s);
           addLocAnn(RESULT, getLocation(sleft, sright, lhs, rhs));
        :}
	|
	term:t
	{: RESULT = t; :}
	;

term ::=
        /* conditional */
        IF:i predicate:p THEN term:te ELSE term:fe
        {:
           RESULT = factory_.createCondExpr(p, expr(te), expr(fe));
           addLocAnn(RESULT, getLocation(i, fe));
        :}
        |
        /* (schema) universal quantification */
        ALL:all schemaText:st SPOT term:t
        {:
           if (t instanceof Expr) {
             RESULT = factory_.createForallExpr(st, expr(t));
           }
           else {
             RESULT = factory_.createForallPred(st, pred(t));
           }
           addLocAnn(RESULT, getLocation(all, t));
        :}
        |
        /* (schema) existential quantification */
        EXI:exi schemaText:st SPOT term:t
        {:
           if (t instanceof Expr) {
             RESULT = factory_.createExistsExpr(st, expr(t));
           }
           else {
             RESULT = factory_.createExistsPred(st, pred(t));
           }
           addLocAnn(RESULT, getLocation(exi, t));
        :}
        |
        /* (schema) unique existential quantification */
        EXIONE:exione schemaText:st SPOT term:t
        {:
           if (t instanceof Expr) {
             RESULT = factory_.createExists1Expr(st, expr(t));
           }
           else {
             RESULT = factory_.createExists1Pred(st, pred(t));
           }
           addLocAnn(RESULT, getLocation(exione, t));
        :}
        |
        /* function construction */
        LAMBDA:lambda schemaText:st SPOT term:t
        {:
           RESULT = factory_.createLambdaExpr(st, expr(t));
           addLocAnn(RESULT, getLocation(lambda, t));
        :} %prec LAMBDA
        |
        /* definite description */
        MU:mu schemaText:st SPOT term:t
        {:
           RESULT = factory_.createMuExpr(st, expr(t));
           addLocAnn(RESULT, getLocation(mu, t));
        :} %prec MU
        |
        /* substitution expression */
        LET:let letDefinitionList:ldl SPOT term:t
        {:
           ZSchText st = factory_.createZSchText(ldl, null);
           RESULT = factory_.createLetExpr(st, expr(t));
           addLocAnn(RESULT, getLocation(let, t));
        :} %prec LET
        |
        /* (schema) equivalence */
        term:lhs IFF:iff term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createIffExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createIffPred(pred(lhs), pred(rhs));
          }
          addLocAnn(RESULT, getLocation(iffleft, iffright, lhs, rhs));
        :}
        |
        /* (schema) implication */
        term:lhs IMP:imp term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createImpliesExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createImpliesPred(pred(lhs), pred(rhs));
          }
          addLocAnn(RESULT, getLocation(impleft, impright, lhs, rhs));
        :}
        |
        /* (schema) disjunction */
        term:lhs OR:or term:rhs
        {:
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createOrExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createOrPred(pred(lhs), pred(rhs));
          }
          addLocAnn(RESULT, getLocation(orleft, orright, lhs, rhs));
        :}
        |
        /* (schema) conjunction */
        term:lhs AND:and term:rhs
        {:
<add:oz>
          if (parserState_.isOpExpr()) {
             RESULT = factory_.createConjOpExpr(factory_.list(opExpr(lhs), opExpr(rhs)));
          }
          else
</add:oz>
          if (lhs instanceof Expr &amp;&amp; rhs instanceof Expr) {
            RESULT = factory_.createAndExpr(expr(lhs), expr(rhs));
          }
          else {
            RESULT = factory_.createAndPred(pred(lhs), pred(rhs), And.Wedge);
          }
          addLocAnn(RESULT, getLocation(andleft, andright, lhs, rhs));
        :}
        |
        /* (schema) negation */
        NOT:not term:t
        {:
          if (t instanceof Expr) {
            RESULT = factory_.createNegExpr(expr(t));
          }
          else {
            RESULT = factory_.createNegPred(pred(t));
          }
          addLocAnn(RESULT, getLocation(not, t));
        :}
        |
        /* schema composition */
        term:lhs ZCOMP:comp term:rhs
        {:
<add:oz>
           if (parserState_.isOpExpr()) {
             RESULT = factory_.createSeqOpExpr(factory_.list(opExpr(lhs), opExpr(rhs)));
           }
           else {
</add:oz>
             RESULT = factory_.createCompExpr(expr(lhs), expr(rhs));
<add:oz>
           }
</add:oz>
           addLocAnn(RESULT, getLocation(compleft, compright, lhs, rhs));
        :}
        |
        /* schema piping */
        term:lhs ZPIPE:pipe term:rhs
        {:
           RESULT = factory_.createPipeExpr(expr(lhs), expr(rhs));
           addLocAnn(RESULT, getLocation(pipeleft, piperight, lhs, rhs));
        :}
        |
        /* schema hiding */
        term:t ZHIDE:hide LPAREN refNameList:rnl RPAREN:rparen
        {:
           ZNameList zNameList = factory_.createZNameList(rnl);
<add:oz>
           if (parserState_.isOpExpr()) {
             RESULT = factory_.createHideOpExpr(opExpr(t), zNameList);
           }
           else {
</add:oz>
             RESULT = factory_.createHideExpr(expr(t), zNameList);
<add:oz>
           }
</add:oz>
           addLocAnn(RESULT, getLocation(hideleft, hideright, t, rparen));
        :}
        |
<add:pattern>
        /* schema hiding */
        term:t ZHIDE:hide LPAREN JOKERNAMELIST:jnl RPAREN:rparen
        {:
           NameList nl = factory_.createJokerNameList(jnl.getString(), null);
           RESULT = factory_.createHideExpr(expr(t), nl);
           addLocAnn(RESULT, getLocation(hideleft, hideright, t, rparen));
        :}
        |
</add:pattern>
        /* schema projection */
        term:lhs ZPROJ:proj term:rhs
        {:
           RESULT = factory_.createProjExpr(expr(lhs), expr(rhs));
           addLocAnn(RESULT, getLocation(projleft, projright, lhs, rhs));
        :}
        |
        /* schema precondition */
        ZPRE:pre term:t
        {:
           RESULT = factory_.createPreExpr(expr(t));
           addLocAnn(RESULT, getLocation(pre, t));
        :}
        |
        /* powerset */
        POWER:power term:t
        {:
           RESULT = factory_.createPowerExpr(expr(t));
           addLocAnn(RESULT, getLocation(power, t));
        :}
        |
        /* Cartesian product */
        prodExpressionList:pel
        {:
           RESULT = factory_.createProdExpr(pel);
           LocInfo loc =
             getLocation(pelleft, pelright, pel.get(0), pel.get(pel.size()-1));
           addLocAnn(RESULT, loc);
        :}
        |
        /* relation operator application */
        relation:rel
        {: RESULT = rel; :}
        |
        /* application of operator function */
        application:a
        {: RESULT = a; :}
        |
        /* application of non-operator function */
        func_appl:fa
        {: RESULT = fa; :}
<add:oz>
        |
        /* class union */
        term:lhs CLASSUNION:classunion term:rhs
        {:
           RESULT = factory_.createClassUnionExpr(factory_.list(expr(lhs),
                                                                expr(rhs)));
           addLocAnn(RESULT, getLocation(lhs, rhs));
        :}
        |
        /* polymorphism expression */
        POLY:poly term:t
        {:
           RESULT = factory_.createPolyExpr(expr(t));
           addLocAnn(RESULT, getLocation(poly, t));
        :}
        |
        /* object containment */
        term:t CONTAINMENT:containment
        {:
           RESULT = factory_.createContainmentExpr(expr(t));
           addLocAnn(RESULT, getLocation(t, containment));
        :}
        |
        outer_opExpr:ooe
        {: RESULT = ooe; :}
</add:oz>
<add:circus>
        |
        /* channel set extension */
        // NOTE: It must be an optExpressionList because of generic actuals on channel names.
        LCIRCCHANSET:lc communicationList:ocl RCIRCCHANSET:rc
        {:
           CztLogger.getLogger(<class/>.class).fine("BASIC-CHANSET-EXPR: " + ocl + " for " + getDialect().toString() + " in Parser.");
           RESULT = createBasicChannelSetExpr(getLocation(lc, rc), ocl);
           addLocAnn(RESULT, getLocation(lc, rc));
        :}
        |
        LCIRCCHANSET:lc  RCIRCCHANSET:rc
        {:
           CztLogger.getLogger(<class/>.class).fine("BASIC-CHANSET-EXPR: empty for " + getDialect().toString() + " in Parser.");
           RESULT = createBasicChannelSetExpr(getLocation(lc, rc), factory_.&lt;Communication&gt;list());
           addLocAnn(RESULT, getLocation(lc, rc));
        :}
        
        /* 
        |
        // NOTE: No, take Communication to be an expression and have \lchanset c?x?y \rchanset to be the same as c. Don't allow partial instantiation (type checker)
        
        // channel set comprehension : always must have characteristic expression to make binding variables into a channel 
        // NOTE: that is, \lchanset m, n: \nat | m > n @ c.m.n \rchanset is okay, whereas \lchanset m, n: \nat \rchanset isn't
        LCIRCCHANSET:lc schemaText:st SPOT communication:c RCIRCCHANSET:rc
        {:
           RESULT = factory_.createSetCompExpr(st, e);
           addLocAnn(RESULT, getLocation(lbrace, rbrace));
        :}
        */
</add:circus>
        ;

<add:circus>
communicationList ::=
        communicationList:cl COMMA communication:c
        {:
           // NOTE: Typechecker takes this pattern into account to know what's implictly given in fields.
           //		Because communication:c appears earlier in 7390, the below might/won't match?
           c.setCommPattern(CommPattern.ChannelSet);
           cl.add(c);
           RESULT = cl;
        :}
        |
        communication:c
        {:
        	// NOTE: Typechecker takes this pattern into account to know what's implictly given in fields.
           c.setCommPattern(CommPattern.ChannelSet);
           RESULT = factory_.list(c);
        :}
        ;

/*   NOTE: now we allow communicaiton as whole, and because BasicChannelSetExpr already allows for CommunicationList,
				 we can enable communication listing within \lchanset\rchanset, where the communication patterns language
				 will enable comprehension as needed. This is the simplest change in AS/Parser/TypeChecker
chanSetComm ::=
		    DECORWORD:dw LSQUARE expressionList:el RSQUARE
        {:
            RESULT = factory_.createCommunication(
              factory_.createRefExpr(createCircusName(dw),     // channel name with generic parameters
                  el, Boolean.FALSE, Boolean.TRUE),
                factory_.createCircusFieldList(),         // communication fields
                CommUsage.Generic,                // channel communication usage
                CommPattern.ChannelSet,                   // communication pattern
                CircusUtils.DEFAULT_MULTISYNCH,           // default multi synch
                false                                     // not implicit
            );
            addLocAnn(RESULT, dw.getLocation());
        :}
        |
        DECORWORD:dw
        {:
            // RefExpr: mixfix=false, explicit=false 
            RESULT = factory_.createCommunication(
                factory_.createRefExpr(createCircusName(dw)),  // channel name
                factory_.createCircusFieldList(),      // communication fields
                CommUsage.Normal,                         // channel communication usage
                CommPattern.ChannelSet,                   // communication pattern,
                CircusUtils.DEFAULT_MULTISYNCH,           // default multi synch
                false                                     // not implicit
            );
            addLocAnn(RESULT, dw.getLocation());
        :}
        |
        communication:c 
        {:
        	RESULT = c;
        :}
        ;
        */
</add:circus>

func_appl ::=
        func_appl:fa inner_term:it
        {:
           RESULT = factory_.createApplExpr(expr(fa), expr(it), Boolean.FALSE);
           addLocAnn(RESULT, getLocation(fa, it));
        :} %prec _APPLICATION
        |
        inner_term:it
        {: RESULT = it; :} %prec _APPLICATION
        ;

inner_term ::=
        /* set extension */
        LBRACE:lbrace optExpressionList:oel RBRACE:rbrace
        {:
           RESULT = factory_.createSetExpr(oel);
           addLocAnn(RESULT, getLocation(lbrace, rbrace));
        :}
        |
        /* set comprehension */
        LBRACE:lbrace schemaText:st SPOT expression:e RBRACE:rbrace
        {:
           RESULT = factory_.createSetCompExpr(st, e);
           addLocAnn(RESULT, getLocation(lbrace, rbrace));
        :}
        |
        /*  characteristic set comprehension */
        LBRACE:lbrace schemaTextNoExpression:stne RBRACE:rbrace
        {:
           RESULT = factory_.createSetCompExpr(stne, null);
           addLocAnn(RESULT, getLocation(lbrace, rbrace));
        :}
        |
        /* tuple extension */
        LPAREN:lparen expressionList:el COMMA expression:e RPAREN:rparen
        {:
           el.add(e);
           RESULT = factory_.createTupleExpr(el);
           addLocAnn(RESULT, getLocation(lparen, rparen));
        :}
        |
        /* characteristic definite description */
        LPAREN:lparen MU:mu schemaText:st RPAREN:rparen
        {:
           RESULT = factory_.createMuExpr(st, null);
           addLocAnn(RESULT, getLocation(muleft, muright, lparen, rparen));
           RESULT.getAnns().add(factory_.createParenAnn());
        :}
        |
        nofixRel:nfr
        {: RESULT = nfr; :} %prec ERP
        |
        nofixApp:nfa
        {: RESULT = nfa; :} %prec _APPLICATION
        |
        /* binding extension */
        LBIND:lbind optConstDeclList:cdl RBIND:rbind
        {:
           RESULT = factory_.createBindExpr(cdl);
           addLocAnn(RESULT, getLocation(lbind, rbind));
        :}
        |
<add:zeves>
        LBIND:lbind bindDeclList:bdl RBIND:rbind
        {:
           RESULT = factory_.createBindExpr(bdl);
           addLocAnn(RESULT, getLocation(lbind, rbind));
        :}
        |
</add:zeves>
        /* empty schema construction */
        LSQUARE:lsq RSQUARE:rsq
        {:
           DeclList dl = factory_.createZDeclList();
           SchText st = factory_.createZSchText(dl, null);
<add:oz>
           if (parserState_.isOpExpr()) {
             OpText ot = factory_.createOpText(null, st);
             RESULT = factory_.createAnonOpExpr(ot);
           }
           else {
</add:oz>
             RESULT = factory_.createSchExpr(st);
<add:oz>
           }
</add:oz>
           addLocAnn(RESULT, getLocation(lsq, rsq));
        :}
        |
        /* schema construction */
        /* push 'false' onto the isOpExpr stack, because both schema
         * exprs and operations contain only expressions
         */
        LSQUARE:lsq
          //<add:oz> {: pushIsOpExpr(false); :} </add:oz>
          schemaTextNoExpression:stne
          /* pop the stack now the expr has been parsed */
          // <add:oz> {: popIsOpExpr(); :} </add:oz>
        RSQUARE:rsq
        {:
<add:oz>
           if (parserState_.isOpExpr()) {
             OpText ot = factory_.createOpText(null, stne);
             RESULT = factory_.createAnonOpExpr(ot);
           }
           else {
</add:oz>
           RESULT = factory_.createSchExpr(stne);
<add:oz>
           }
</add:oz>
           addLocAnn(RESULT, getLocation(lsq, rsq));
        :}
        |
        /* binding selection */
        inner_term:it DOT:dot refName:rn
        {:
<add:oz>
           if (parserState_.isOpExpr()) {
             RESULT = factory_.createOpPromotionExpr(expr(it), rn);
           }
           else {
</add:oz>
             RESULT = factory_.createBindSelExpr(expr(it), rn);
<add:oz>
           }
</add:oz>
           addLocAnn(RESULT, getLocation(dotleft, dotright, it, rn));
        :}
        |
        /* tuple selection */
        inner_term:it DOT:dot NUMERAL:n
        {:
           ZNumeral numeral = factory_.createZNumeral(n.getValue());
           addLocAnn(numeral, n.getLocation());
           RESULT = factory_.createTupleSelExpr(expr(it), numeral);
           LocInfo loc = getLocation(dotleft, dotright, it, n.getLocation());
           addLocAnn(RESULT, loc);
        :}
        |
        /* schema decoration */
        inner_term:it stroke:s
        {:
           //if the inner term is a theta expr, add the stroke to the
           //theta expr instead, which has a tighter binding.
           Object pAnn = it.getAnn(ParenAnn.class);
           if (it instanceof ThetaExpr &amp;&amp; pAnn == null) {
             ThetaExpr te = (ThetaExpr) it;
	     te.getZStrokeList().add(s);
	     addLocAnn(te, getLocation(te, s));
	     RESULT = te;
           }
           else {
             RESULT = factory_.createDecorExpr(expr(it), s);
           }
           addLocAnn(RESULT, getLocation(it, s));
        :}
<add:pattern>
        |
        /* schema decoration */
        inner_term:it JOKERSTROKE:js
        {:
           Stroke s = factory_.createJokerStroke(js.getString(), null);
           //if the inner term is a theta expr, add the stroke to the
           //theta expr instead, which has a tighter binding.
           Object pAnn = it.getAnn(ParenAnn.class);
           if (it instanceof ThetaExpr &amp;&amp; pAnn == null) {
             ThetaExpr te = (ThetaExpr) it;
	     te.getZStrokeList().add(s);
	     addLocAnn(te, getLocation(te, s));
	     RESULT = te;
           }
           else {
             RESULT = factory_.createDecorExpr(expr(it), s);
           }
           addLocAnn(RESULT, getLocation(it, s));
        :}
</add:pattern>
        |
        /* binding construction */
        THETA:theta inner_term:it
        {:
           //System.out.println("REACHED THETA FOR " + it.toString());
           ZStrokeList sl = factory_.createZStrokeList();
           RESULT = factory_.createThetaExpr(expr(it), sl);
           addLocAnn(RESULT, getLocation(theta, it));
        :}
        |
        /* function application with schema expr as argument */
        inner_term:it LSQUARE schemaTextNoExpression:st RSQUARE:rsquare
           optAppendageList:oal
        {:
           RESULT = createSchApplExpr(expr(it), st, oal);
           addLocAnn(RESULT, getLocation(it, rsquare));
        :}
        |
        /* generic instantiation */
        /* If inner_term is changed to refName
           (as in the grammar given in the Z Standard),
           rename expressions fail to parse. */
        inner_term:it LSQUARE expressionList:el RSQUARE:rsquare
        {:
           RESULT = factory_.createRefExpr(name(it), el, Boolean.FALSE, Boolean.TRUE);
           addLocAnn(RESULT, getLocation(it, rsquare));
        :}
<add:pattern>
        |
        inner_term:it LSQUARE JOKEREXPRLIST:elj RSQUARE:rsquare
        {:
           ExprList el = factory_.createJokerExprList(elj.getString(), null);
           RESULT = factory_.createRefExpr(name(it), el, Boolean.FALSE, Boolean.TRUE);
           addLocAnn(RESULT, getLocation(it, rsquare));
        :}
</add:pattern>
        |
        /* schema renaming */
        inner_term:it LSQUARE renameList:rnl RSQUARE:rsquare
        {:
<add:oz>
           if (parserState_.isOpExpr()) {
             RESULT = factory_.createRenameOpExpr(opExpr(it), rnl);
           }
           else {
</add:oz>
             RESULT = factory_.createRenameExpr(expr(it), rnl);
<add:oz>
           }
</add:oz>
           //System.out.println("REACHED RENAMING = " + rnl.toString());
           addLocAnn(RESULT, getLocation(it, rsquare));
        :} %prec _RENAME
        |
        /* number literal */
        NUMERAL:n
        {:
           ZNumeral numeral = factory_.createZNumeral(n.getValue());
           addLocAnn(numeral, n.getLocation());
           RESULT = factory_.createNumExpr(numeral);
           addLocAnn(RESULT, n.getLocation());
        :}
        |
        /* parenthesized expression/predicate */
        LPAREN:lparen septerm:t RPAREN:rparen
        {:
           ParenAnn parenAnn = factory_.createParenAnn();
           addLocAnn(parenAnn, getLocation(lparen, rparen));
           t.getAnns().add(parenAnn);
           RESULT = t;
        :}
        |
        /* reference */
        refName:rn
        {:
           RESULT = factory_.createRefExpr(rn);
           addLocAnn(RESULT, getLocation(rn));
        :}
        |
        /* truth */
        TRUE:t
        {:
           RESULT = factory_.createTruePred();
           addLocAnn(RESULT, t);
        :}
        |
        /* falsity */
        FALSE:f
        {:
           RESULT = factory_.createFalsePred();
           addLocAnn(RESULT, f);
        :}
<add:oz>
        |
        inner_opExpr:ioe
        {: RESULT = ioe; :}
</add:oz>
<add:pattern>
        |
        jokerRef:jr
        {:
           RESULT = jr;
           addLocAnn(RESULT, getLocation(jrleft, jrright));
        :}
</add:pattern>
        ;

optAppendageList ::=
       appendageList:al
       {: RESULT = al; :}
       |
       //empty
       {: RESULT = factory_.list(); :}
       ;

//a list of possible constructs that come after inner_term LSQUARE
//schemaTextNoExpression RSQUARE
appendageList ::=
       appendageList:al appendage:a
       {:
          al.add(a);
          RESULT = al;
       :}
       |
       appendage:a
       {: RESULT = factory_.list(a); :}
       ;

appendage ::=
        stroke:s
        {: RESULT = s; :}
        |
        LSQUARE:lsq renameList:rnl RSQUARE
        {: RESULT = factory_.createRenameExpr(null, rnl); :}
        |
        DOT refName:rn
        {: RESULT = factory_.createBindSelExpr(null, rn); :}
        |
        DOT NUMERAL:n
        {:
           ZNumeral numeral = factory_.createZNumeral(n.getValue());
           addLocAnn(numeral, n.getLocation());
           RESULT = factory_.createTupleSelExpr(null, numeral);
        :}
        ;

prodExpressionList ::=
        term:t1 CROSS term:t2
        {:
           RESULT = factory_.createZExprList();
           RESULT.add(expr(t1));
           RESULT.add(expr(t2));
        :}
        |
        prodExpressionList:pel CROSS term:t
        {:
           pel.add(expr(t));
           RESULT = pel;
        :}
        ;

optExpressionList ::=
        //empty
        {: RESULT = factory_.createZExprList(); :}
        |
        expressionList:el
        {: RESULT = el; :}
        ;

expressionList ::=
        expressionList:el COMMA expression:e
        {:
           el.add(e);
           RESULT = el;
        :}
        |
        expression:e
        {:
           RESULT = factory_.createZExprList();
           RESULT.add(e);
        :}
        ;


optConstDeclList ::=
        //empty
        {: RESULT = factory_.createZDeclList(); :}
        |
        constDeclList:cdl
        {: RESULT = cdl; :}
        ;

constDeclList ::=
        constDeclList:cdl COMMA constDecl:cd
        {:
           cdl.getDecl().add(cd);
           RESULT = cdl;
        :}
        |
        constDecl:cd
        {: RESULT = factory_.createZDeclList(factory_.list(cd)); :}
        ;

<add:zeves>
bindDeclList ::=
        bindDeclList:bdl SEMICOLON bindDecl:bd
        {:
           bdl.getDecl().add(bd);
           RESULT = bdl;
        :}
        |
        bindDecl:bd
        {: RESULT = factory_.createZDeclList(factory_.list(bd)); :}
        ;

bindDecl ::=
        // because of COLON, this will be a DECLWORD
        DECLWORD:dn COLON:c expression:e
        {:
           ZName zn = createZName(dn);
           RESULT = factory_.createConstDecl(zn, e);
           addLocAnn(RESULT, getLocation(cleft, cright, zn, e));
        :}
        |
        // this is an odd one: an operator name as part of the schema declarations...?
        opName:on COLON:c expression:e
        {:
           final LocInfo loc = getLocation(onleft, onright);
           ZName dn = strListToZName(on, loc);
           dn.getAnns().add(factory_.createParenAnn()); //add?
           RESULT = factory_.createConstDecl(dn, e);
           addLocAnn(RESULT, getLocation(cleft, cright, dn, e));
        :}
        ;

</add:zeves>

letDefinitionList ::=
        letDefinitionList:ldl SEMICOLON letDefinition:ld
        {:
           ldl.getDecl().add(ld);
           RESULT = ldl;
        :}
        |
        letDefinition:ld
        {: RESULT = factory_.createZDeclList(factory_.list(ld)); :}
        ;

letDefinition ::=
        declName:n DEFEQUAL:defequal expression:e
        {:
           RESULT = factory_.createConstDecl(n,e);
           addLocAnn(RESULT, getLocation(defequalleft, defequalright, n, e));
        :}
        ;

stroke ::=
        INSTROKE:is
        {:
           RESULT = factory_.createInStroke();
           addLocAnn(RESULT, is);
        :}
        |
        OUTSTROKE:os
        {:
           RESULT = factory_.createOutStroke();
           addLocAnn(RESULT, os);
        :}
        |
        NEXTSTROKE:ns
        {:
           RESULT = factory_.createNextStroke();
           addLocAnn(RESULT, ns);
        :}
        |
        NUMSTROKE:ns
        {:
           RESULT = factory_.createNumStroke(ns.getIntValue());
           addLocAnn(RESULT, ns.getLocation());
        :}
        ;

renameList ::=
<add:zeves>
        // appear first so that THMREPLACEMENT takes precedence over SLASH in ZEves' case
        instantiations:inst
        {:
          RESULT = inst;
        :}
        |
</add:zeves>
        zRenameList:zrnl
        {: RESULT = zrnl; :}
<add:pattern>
        |
	JOKERRENAMELIST:jrl
        {: RESULT = factory_.createJokerRenameList(jrl.getString(), null); :}
</add:pattern>
        ;

zRenameList ::=
        zRenameList:rnl COMMA rename:rn
        {:
           rnl.getNewOldPair().add(rn);
           RESULT = rnl;
        :}
        |
        rename:rn
        {: RESULT = factory_.createZRenameList(factory_.list(rn)); :}
        ;

rename ::=
        declName:lhs SLASH refName:rhs
        {:
           RESULT = factory_.createNewOldPair(lhs, rhs);
           addLocAnn(RESULT, getLocation(lhs, rhs));
        :}
        ;


//nofix relation is not included here because it has a different precedence
//than the other types of relation
relation ::=
        prefixRel:pr
        {: RESULT = pr; :}
        |
        postfixRel:pr
        {: RESULT = pr; :}
        |
        infixRel:ir
        {: RESULT = ir; :}
        ;

//according to the ISO standard, op e1 is equivalent to
//e mem op
prefixRel ::=
        PREP:p term:t
        {:
           List&lt;String&gt; opName = factory_.list(p.getString());
           opName.add(ARG_TOK);
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(t));
           RESULT = createMemPred(opName, exprs, p.getLocation());
           addLocAnn(RESULT, getLocation(p.getLocation(), t));
        :}
        |
        LP:lp expSep:es term:t1 EREP:erep term:t2
        {:
           List&lt;String&gt; opName = factory_.list(lp.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erep.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t1));
           expList.add(expr(t2));
           LocInfo lpLoc = lp.getLocation();
           LocInfo loc = getLocation(lpLoc, erep.getLocation());
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lpLoc, t2));
        :}
        |
        LP:lp expSep:es optExpressionList:oel SREP:srep term:t
        {:
           List&lt;String&gt; opName = factory_.list(lp.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srep.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo lpLoc = lp.getLocation();
           LocInfo loc = getLocation(lpLoc, srep.getLocation());
           addLocAnn(seq, loc);
           expList.add(seq);
           expList.add(expr(t));
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lpLoc, t));
        :}
        ;

postfixRel ::=
        term:t POSTP:p
        {:
           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t));
           LocInfo pLoc = p.getLocation();
           RESULT = createMemPred(factory_.list(p.getString()), expList, pLoc);
           addLocAnn(RESULT, getLocation(t, pLoc));
        :}
        |
        term:t1 ELP:elp expSep:es term:t2 ERP:erp
        {:
           List&lt;String&gt; opName = factory_.list(ARG_TOK);
           opName.add(elp.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erp.getString());

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           LocInfo erpLoc = erp.getLocation();
           LocInfo loc = getLocation(elp.getLocation(), erpLoc);
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, erpLoc));
        :}
        |
        term:t ELP:elp expSep:es optExpressionList:oel SRP:srp
        {:
           List&lt;String&gt; opName = factory_.list(ARG_TOK);
           opName.add(elp.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srp.getString());

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo srpLoc = srp.getLocation();
           addLocAnn(seq, getLocation(elp.getLocation(), srpLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           LocInfo loc = getLocation(elp.getLocation(), srpLoc);
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t, srpLoc));
        :}
        ;

infixRel ::=
        infixChainRel:icr
        {: RESULT = icr; :}
        |
        term:t1 ELP:elp expSep:es term:t2 EREP:erep term:t3
        {:
           List&lt;String&gt; opName = factory_.list(ARG_TOK);
           opName.add(elp.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erep.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           expList.add(expr(t3));
           LocInfo loc = getLocation(elp.getLocation(), erep.getLocation());
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, t3));
        :}
        |
        term:t1 ELP:elp expSep:es optExpressionList:oel SREP:erep term:t2
        {:
           List&lt;String&gt; opName = factory_.list(ARG_TOK);
           opName.add(elp.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(erep.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, getLocation(oelleft, oelright));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           expList.add(expr(t2));
           LocInfo loc = getLocation(elp.getLocation(), erep.getLocation());
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, t2));
        :}
        ;

infixChainRel ::=
        term:lhs MEM:m term:rhs
        {:
           RESULT =
             factory_.createMemPred(expr(lhs), expr(rhs), Boolean.FALSE);
           addLocAnn(RESULT, getLocation(mleft, mright, lhs, rhs));
        :}
        |
        term:lhs EQUALS:equals term:rhs
        {:
           RESULT = factory_.createEquality(expr(lhs), expr(rhs));
           addLocAnn(RESULT, getLocation(equalsleft, equalsright, lhs, rhs));
        :}
        |
        term:lhs IP:ip term:rhs
        {:
           List&lt;String&gt; opName = factory_.list(ARG_TOK);
           opName.add(ip.getString());
           opName.add(ARG_TOK);
           ZExprList expList = factory_.createZExprList();
           expList.add(expr(lhs));
           expList.add(expr(rhs));
           RESULT = createMemPred(opName, expList, ip.getLocation());
           addLocAnn(RESULT, getLocation(lhs, rhs));
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr MEM term:rhs
        {:
           RESULT =
             transformChainRel(icr, Sym.MEM, expr(rhs), getLocation(icr));
           addLocAnn(RESULT, getLocation(icr, rhs));
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr EQUALS term:rhs
        {:
           RESULT = transformChainRel(icr, Sym.EQUALS, expr(rhs),
                                      getLocation(icrleft, icrright));
           addLocAnn(RESULT, getLocation(icrleft, icrright));
        :}
        |
        //apply syntactic transformation rule 12.2.10.3
        infixChainRel:icr IP:ip term:rhs
        {:
           RESULT = transformChainRelInfix(icr, expr(rhs), ip.getString(),
                                           getLocation(icrleft, icrright));
           addLocAnn(RESULT, getLocation(icrleft, icrright));
        :}
        ;

nofixRel ::=
        LP:lp expSep:es term:t ERP:erp
        {:
           List&lt;String&gt; opName = factory_.list(ARG_TOK);
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(erp.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t));
           LocInfo erpLoc = erp.getLocation();
           LocInfo loc = getLocation(lp.getLocation(), erpLoc);
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lp.getLocation(), erpLoc));
        :}
        |
        LP:lp expSep:es optExpressionList:oel SRP:srp
        {:
           List&lt;String&gt; opName = factory_.list(ARG_TOK);
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(srp.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo srpLoc =  srp.getLocation();
           LocInfo lpLoc = lp.getLocation();
           addLocAnn(seq, getLocation(lpLoc, srpLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           LocInfo loc = getLocation(lpLoc, srpLoc);
           RESULT = createMemPred(opName, expList, loc);
           addLocAnn(RESULT, loc);
        :}
        ;


//nofix application is not included here because it has a different
//precedence to the other types of application
application ::=
        prefixApp:pa
        {: RESULT = pa; :}
        |
        postfixApp:pa
        {: RESULT = pa; :}
        |
        infixApp:ia
        {: RESULT = ia; :}
        ;

prefixApp ::=
        PRE:pre term:t
        {:
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(t));
           LocInfo loc = pre.getLocation();
           RESULT =
             createMixfixExpr(factory_.list(pre.getString(), ARG_TOK), exprs, loc);
           addLocAnn(RESULT, getLocation(pre.getLocation(), t));
        :}
        |
        L:l expSep:es term:t1 ERE:ere term:t2
        {:
           List&lt;String&gt; opName = factory_.list(l.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(ere.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t1));
           expList.add(expr(t2));
           LocInfo lloc = l.getLocation();
           LocInfo loc = getLocation(lloc, ere.getLocation());
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lloc, t2));
        :}
        |
        L:l expSep:es optExpressionList:oel SRE:sre term:t
        {:
           List&lt;String&gt; opName = factory_.list(l.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sre.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo sreLoc = sre.getLocation();
           LocInfo lLoc = l.getLocation();
           addLocAnn(seq, getLocation(lLoc, sreLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           expList.add(expr(t));
           LocInfo loc = getLocation(lLoc, sreLoc);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(lLoc, t));
        :}
        ;

postfixApp ::=
        term:t POST:post
        {:
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(t));
           LocInfo loc = post.getLocation();
           RESULT =
             createMixfixExpr(factory_.list(ARG_TOK, post.getString()), exprs, loc);
           addLocAnn(RESULT, getLocation(t, post.getLocation()));
        :}
        |
        term:t1 EL:el expSep:es term:t2 ER:er
        {:
           List&lt;String&gt; opName = factory_.list(ARG_TOK);
           opName.add(el.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(er.getString());

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           LocInfo erLoc = er.getLocation();
           LocInfo elLoc = el.getLocation();
           LocInfo loc = getLocation(elLoc, erLoc);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, erLoc));
        :}
        |
        term:t EL:el expSep:es optExpressionList:oel SR:sr
        {:
           List&lt;String&gt; opName = factory_.list(ARG_TOK);
           opName.add(el.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sr.getString());

           LocInfo srLoc = sr.getLocation();
           LocInfo elLoc = el.getLocation();
           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           addLocAnn(seq, getLocation(el.getLocation(), srLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           LocInfo loc = getLocation(elLoc, srLoc);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t, srLoc));
        :}
        ;

infixApp ::=
        term:lhs I:i term:rhs
        {:
           List&lt;String&gt; opName = factory_.list(ARG_TOK);
           opName.add(i.getString());
           opName.add(ARG_TOK);
           ZExprList exprs = factory_.createZExprList();
           exprs.add(expr(lhs));
           exprs.add(expr(rhs));
           RESULT = createMixfixExpr(opName, exprs, i.getLocation());
           addLocAnn(RESULT, getLocation(ileft, iright, lhs, rhs));
        :}
        |
        term:t1 EL:el expSep:es term:t2 ERE:ere term:t3
        {:
           List&lt;String&gt; opName = factory_.list(ARG_TOK);
           opName.add(el.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(ere.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           expList.add(expr(t2));
           expList.add(expr(t3));
           LocInfo loc = getLocation(el.getLocation(), ere.getLocation());
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(t1, t3));
        :}
        |
        term:t1 EL:el expSep:es optExpressionList:oel SRE:sre term:t2
        {:
           List&lt;String&gt; opName = factory_.list(ARG_TOK);
           opName.add(el.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sre.getString());
           opName.add(ARG_TOK);

           ZExprList expList = factory_.createZExprList();
           expList.add(expr(t1));
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo sreLoc = sre.getLocation();
           addLocAnn(seq, getLocation(el.getLocation(), sreLoc));
           expList.add(seq);
           //expList.add(factory_.createSequence(oel));
           expList.add(expr(t2));
           LocInfo loc = getLocation(el.getLocation(), sreLoc);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, getLocation(elleft, elright, t1, t2));
        :}
        ;

nofixApp ::=
        L:l expSep:es term:t ER:er
        {:
           List&lt;String&gt; opName = factory_.list(l.getString());
           addExpSepName(opName, es);
           opName.add(ARG_TOK);
           opName.add(er.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           expList.add(expr(t));
           LocInfo loc = getLocation(l.getLocation(), er.getLocation());
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, loc);
        :}
        |
        L:l expSep:es optExpressionList:oel SR:sr
        {:
           List&lt;String&gt; opName = factory_.list(l.getString());
           addExpSepName(opName, es);
           opName.add(LISTARG_TOK);
           opName.add(sr.getString());

           ZExprList expList = factory_.createZExprList();
           addExpSepExp(expList, es);
           Expr seq = factory_.createSequence(oel);
           LocInfo loc = getLocation(l.getLocation(), sr.getLocation());
           addLocAnn(seq, loc);
           expList.add(seq);
           RESULT = createMixfixExpr(opName, expList, loc);
           addLocAnn(RESULT, loc);
        :}
        ;

expSep ::=
        //empty
        {: RESULT = factory_.list(); :} %prec I
        |
        expSep:exs term:t ES:es
        {:
           exs.add(factory_.list(expr(t)));
           exs.add(es.getString());
           RESULT = exs;
        :}
        |
        expSep:exs expressionList:exprList SS:ss
        {:
           exs.add(exprList);
           exs.add(ss.getString());
           RESULT = exs;
        :}
        ;

optNL ::=
        //empty
        |
        NL
        ;

<add:pattern>
/// Z pattern constructs ///////////////////////////////////////////////
jokerPara ::=
        JOKER:j DECORWORD:dw jokerList:jl END:end
        {:
           JokerType type = JokerType.Expr;
           try {
             type = JokerType.valueOf(dw.getName());
           }
           catch (IllegalArgumentException e) {
             parser.report_error(ZpattParseMessage.MSG_UNKNOWN_JOKER_TYPE,
                          new Object[] { dw },
                          getLocation(dwleft, dwright));
           }
           RESULT = factory_.createJokers(jl, type);
           addLocAnn(RESULT, getLocation(j, end));
           try {
             jokerTable_.add(RESULT);
           }
           catch (JokerTable.JokerException e) {
             parser.report_error(ZpattParseMessage.MSG_CANNOT_ADD_JOKER,
                                 new Object[] { e.getMessage() },
                                 getLocation(jleft, jright));
           }
        :}
        ;

rulePara ::=
        RULE:r DECORWORD:dw premisses:a RULELINE conclusion:c END:end
        {:
           RESULT = factory_.createRule(c, dw.getName(), a);
           addLocAnn(RESULT, getLocation(r, end));
        :}
        |
        RULE:r DECORWORD:dw conclusion:c END:end
        {:
           SequentList premisses = factory_.createSequentList();
           RESULT = factory_.createRule(c, dw.getName(), premisses);
           addLocAnn(RESULT, getLocation(r, end));
        :}
        ;

oraclePara ::=
        PROVISO:p DECORWORD:dw sequent:s END:end
        {:
           RESULT = factory_.createOracle(s, dw.getName());
           addLocAnn(RESULT, getLocation(p, end));
        :}
        ;

jokerList ::=
       jokerList:jl COMMA DECORWORD:dw
       {:
          jl.add(dw.getName());
          RESULT = jl;
       :}
       |
       DECORWORD:dw
       {: RESULT = factory_.list(dw.getName()); :}
       ;

premisses ::=
        sequent:s
        {:
           RESULT = factory_.createSequentList();
           RESULT.add(s);
        :}
        |
        premisses:a NL sequent:s
        {:
           a.add(s);
           RESULT = a;
        :}
        ;

conclusion ::=
        term:t
        {:
           //czt.todo: What is the context?
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createSequent(sc, pred(t));
           addLocAnn(RESULT, getLocation(t));
        :}
        ;

sequent ::=
        predSequent:ps
        {: RESULT = ps; :}
        ;

predSequent ::=
        sequentLHS:slhs VDASH term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createSequent(sc , pred(t));
           addLocAnn(RESULT, getLocation(slhs.get(0), t));
        :}
        |
        term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createSequent(sc, pred(t));
           addLocAnn(RESULT, getLocation(t));
        :}
        ;

sequentLHS ::=
        sequentLHS:slhs COMMA premiss:a
        {:
           slhs.add(a);
           RESULT = slhs;
        :}
        |
        premiss:a
        {:
           RESULT = factory_.list(a);
        :}
        ;

premiss ::=
        term:t
        {:
           SequentContext sc = factory_.createSequentContext();
           RESULT = factory_.createSequent(sc, pred(t));
           addLocAnn(RESULT, getLocation(t));
        :}
        ;

jokerRef ::=
        JOKEREXPR:je
        {:
           RESULT = factory_.createJokerExpr(je.getString(), null);
           addLocAnn(RESULT, je.getLocation());
        :}
        |
        JOKERPRED:jp
        {:
           RESULT = factory_.createJokerPred(jp.getString(), null);
           addLocAnn(RESULT, jp.getLocation());
        :}
        |
        JOKERNAME:jn
        {:
           final LocInfo loc = jn.getLocation();
           Name rn = factory_.createJokerName(jn.getString(), null);
           addLocAnn(rn, loc);
           RESULT = factory_.createRefExpr(rn);
           addLocAnn(RESULT, loc);
        :}
        ;

</add:pattern>

<add:oz>
/// Object-Z constructs ///////////////////////////////////////////////
class ::=
        classHeader:ch optNL
            visibilityList:vl
            inheritedList:il
            innerParaList:ipl
            operationList:ol
        END:end
        {:
           //local definitions, states, and initial states are all
           //parsed as innerPara, because upon a LSQUARE of a
           //horizontal state schema, javacup will shift to
           //a basicTypeDefinition
           State s = null;
           InitialState is = null;
           // after making InitialState/State a PARA! (Leo)
           for (Iterator&lt;Term&gt; iter = ipl.iterator(); iter.hasNext(); ) {
             Term next = iter.next();
             if (next instanceof State) {
               if (s != null) {
                 parser.report_error(ZParseMessage.MSG_DUPLICATE_STATE,
                                     new Object[] { next },
                                     getLocation(chleft, chright));
               }
               s = (State) next;
               iter.remove();
             }
             else if (next instanceof InitialState) {
               if (is != null) {
                 parser.report_error(ZParseMessage.MSG_DUPLICATE_INIT,
                                     new Object[] { next },
                                     getLocation(chleft, chright));
               }
               is = (InitialState) next;
               iter.remove();
             }
           }
           ZParaList zpl = factory_.createZParaList();
           for (Term t : ipl)
           {
           	  if (t instanceof Para) zpl.add((Para)t);
           }
           assert ipl.size() == zpl.size();
           Name dn = ch.getFirst();
           ZNameList ofp = ch.getSecond();
           RESULT = factory_.createClassPara(dn, ofp, vl, il, zpl, s, is, ol);
           addLocAnn(RESULT, getLocation(ch.getFirst(), end));
           assert parserState_.isOpExpr() == false;
        :}
        ;

classHeader ::=
        CLASS name:n
        {:
           ZNameList decls = factory_.createZNameList();
           RESULT = new Pair&lt;Name, ZNameList&gt;(n, decls);
        :}
        |
        GENCLASS name:n formalParameters:fp
        {: RESULT = new Pair&lt;Name, ZNameList&gt;(n, fp); :}
        ;

operationList ::=
        //empty
        {: RESULT = factory_.list(); :}
        |
        operationList:ol optNL operation:o
        {:
           ol.add(o);
           RESULT = ol;
        :}
        ;

/// class paragraphs ///////////////////////////////////////////////

visibilityList ::=
        //no list
        {: RESULT = null; :}
        |
        ZPROJ LPAREN RPAREN optNL //an empty list
        {: RESULT = factory_.createVisibilityList(); :}
        |
        ZPROJ LPAREN refNameList:rnl RPAREN optNL
        {: RESULT = factory_.createVisibilityList(rnl); :}
        ;

inheritedList ::=
        //empty
        {:
           RESULT = factory_.createZExprList();
        :}
        |
        inheritedClassList:icl optNL
        {: RESULT = factory_.createZExprList(icl); :}
        ;

inheritedClassList ::=
        inheritedClassList:icl NL inheritedClass:ic
        {:
           icl.add(0, ic);
           RESULT = icl;
        :}
        |
        inheritedClass:ic
        {: RESULT = factory_.list(ic); :}
        ;

inheritedClass ::=
        DECORWORD:dw
        {:
           ZName rn = createZName(dw);
           RESULT = factory_.createRefExpr(rn);
           addLocAnn(RESULT, dw.getLocation());
        :}
        |
        inheritedClass:ic LSQUARE expressionList:el RSQUARE:rsq
        {:
           Name rn = name(ic);
           addLocAnn(rn, getLocation(icleft, icright));
           RESULT =
             factory_.createRefExpr(rn, el, Boolean.FALSE, Boolean.TRUE);
           addLocAnn(RESULT, getLocation(ic, rsq));
        :}
        |
        inheritedClass:ic LSQUARE renameList:rnl RSQUARE:rsq
        {:
           RESULT = factory_.createRenameExpr(ic, rnl);
           addLocAnn(RESULT, getLocation(ic, rsq));
        :} %prec _RENAME
        ;

innerParaList ::=
        innerPara:ip optNL innerParaList:ipl
        {:
           ipl.add(0, ip);
           RESULT = ipl;
        :}
        |
        //empty
        {: RESULT = factory_.list(); :}
        ;

// TODO: check why aren't these subclass of Para? This messes up the type later on for innerParaList.
//		 shouldn't state/initialState also be para?
innerPara ::=
        axiomaticDefinition:ad
        {: RESULT = ad; :}
        |
        genericAxDefinition:gad
        {: RESULT = gad; :}
        |
        schema:s
        {: RESULT = s; :}
        |
        basicTypeDefinition:gtd
        {: RESULT = gtd; :}
        |
        freeTypeList:ftl
        {:
           RESULT = factory_.createFreePara(ftl);
           addLocAnn(RESULT, getLocation(ftl.get(0), ftl.get(ftl.size() - 1)));
        :}
        |
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        |
        state:s
        {: RESULT = s; :}
        |
        initialState:is
        {: RESULT = is; :}
        ;

state ::=
        STATE:s stateDecl:sd BAR predicate:p END:end
        {:
           PrimaryDecl pd = sd.getFirst();
           SecondaryDecl scd = sd.getSecond();
           RESULT = factory_.createState(pd, scd, p, Box.SchBox);
           addLocAnn(RESULT, getLocation(s, end));
        :}
        |
        STATE:s stateDecl:sd END:end
        {:
           PrimaryDecl pd = sd.getFirst();
           SecondaryDecl scd = sd.getSecond();
           RESULT = factory_.createState(pd, scd, null, Box.SchBox);
           addLocAnn(RESULT, getLocation(s, end));
        :}
        |
        LSQUARE:lsq stateDecl:sd BAR predicate:p RSQUARE:rsq
        {:
           PrimaryDecl pd = sd.getFirst();
           SecondaryDecl scd = sd.getSecond();
           RESULT = factory_.createState(pd, scd, p, Box.OmitBox);
           addLocAnn(RESULT, getLocation(lsq, rsq));
        :}
        |
        LSQUARE:lsq stateDeclNoExpression:sdne RSQUARE:rsq
        {:
           PrimaryDecl pd = sdne.getFirst();
           SecondaryDecl scd = sdne.getSecond();
           RESULT = factory_.createState(pd, scd, null, Box.OmitBox);
           addLocAnn(RESULT, getLocation(rsq, rsq));
        :}
        ;

//return a pair containing the primary and secondary decls
stateDecl ::=
        optPrimaryDeclPart:opdp
        {: RESULT = statePair(opdp, null); :}
        |
        secondaryDeclPart:sdp
        {: RESULT = statePair(null, sdp); :}
        |
        primaryDeclPart:pdp sep secondaryDeclPart:sdp
        {: RESULT = statePair(pdp, sdp); :}
        ;

stateDeclNoExpression ::=
        //empty
        {: RESULT = statePair(null, null); :}
        |
        secondaryDeclPart:sdp
        {: RESULT = statePair(null, sdp); :}
        |
        primaryDeclPart:pdp sep declaration:d
        {: RESULT = statePair(pdp, null); :}
        |
        basicDeclaration:bd
        {:
           ZDeclList zdl = factory_.createZDeclList(factory_.list(bd));
           RESULT = statePair(zdl, null);
        :}
        |
        primaryDeclPart:pdp sep secondaryDeclPart:sdp
        {: RESULT = statePair(pdp, sdp); :}
        ;

optPrimaryDeclPart ::=
        //empty
        {: RESULT = factory_.createZDeclList(); :}
        |
        primaryDeclPart:pdp
        {: RESULT = pdp; :}
        ;

primaryDeclPart ::=
        declaration:d
        {:
           RESULT = factory_.createZDeclList(factory_.list(d));
           addLocAnn(RESULT, getLocation(dleft, dright));
        :}
<add:tcoz>
        |
        channelDeclaration:cd
        {:
           RESULT = factory_.createZDeclList(factory_.list(cd));
           addLocAnn(RESULT, getLocation(cdleft, cdright));
        :}
</add:tcoz>
        |
        primaryDeclPart:pdp sep declaration:d
        {:
           pdp.getDecl().add(d);
           RESULT = pdp;
        :}
<add:tcoz>
        |
        primaryDeclPart:pdp sep channelDeclaration:cd
        {:
           pdp.getDecl().add(cd);
           RESULT = pdp;
        :}
</add:tcoz>
        ;

<add:tcoz>
channelDeclaration ::=
        declWordList:dwl COLON:colon channel:ch
        {:
           RESULT = factory_.createVarDecl(dwl, ch);
           addLocAnn(RESULT, getLocation(colonleft, colonright));
        :}
        ;

channel ::=
        CHAN:c
        {:
           RESULT = factory_.createChannelExpr();
           addLocAnn(RESULT, c);
        :}
        |
        term:t SENSOR:sensor
        {:
           RESULT = factory_.createSensorExpr(expr(t));
           addLocAnn(RESULT, getLocation(t, sensor));
        :}
        |
        term:t ACTUATOR:actuator
        {:
           RESULT = factory_.createActuatorExpr(expr(t));
           addLocAnn(RESULT, getLocation(t, actuator));
        :}
        ;
</add:tcoz>

secondaryDeclPart ::=
        DELTA sep declPart:dp
        {: RESULT = dp; :}
        ;

initialState ::=
        INIT:i predicate:p END:end
        {:
           RESULT = factory_.createInitialState(p, Box.SchBox);
           addLocAnn(RESULT, getLocation(i, end));
        :}
        |
        INITWORD:iw SDEF LSQUARE predicate:p RSQUARE:rsquare
        {:
           RESULT = factory_.createInitialState(p, Box.OmitBox);
           addLocAnn(RESULT, getLocation(iw, rsquare));
        :}
        ;

operation ::=
        OPSCH:osch name:n optNL opText:ot END:end
        {:
           OpExpr opExpr = factory_.createAnonOpExpr(ot);
           RESULT = factory_.createOperation(n, opExpr, Box.SchBox);
           addLocAnn(RESULT, getLocation(osch, end));
        :}
        |
        /* push true onto the stack now that this is an op expr */
        OPNAME:on /*{: pushIsOpExpr(true); :}*/ SDEF opExpr:oe
        {:
           //the op expr has finished parsing, so pop the stack.
           parserState_.popIsOpExpr();
           ZName dn = factory_.createZName(on.getName());
           addLocAnn(dn, on.getLocation());
           RESULT = factory_.createOperation(dn, oe, Box.OmitBox);
           addLocAnn(RESULT, getLocation(on.getLocation(), oe));
        :}
        ;

opText ::=
        opTextWithDelta:otwd
        {: RESULT = otwd; :}
        |
        optDeclPart:dp BAR predicate:p
        {: RESULT = createOpText(null, dp, p); :}
        |
        optDeclPart:dp
        {: RESULT = createOpText(null, dp, null); :}
        ;

opTextWithDelta ::=
        deltaList:dl sep:s declPart:dp BAR predicate:p
        {: RESULT = createOpText(dl, dp, p); :}
        |
        deltaList:dl sep:s declPart:dp
        {: RESULT = createOpText(dl, dp, null); :}
        |
        deltaList:dl BAR predicate:p
        {: RESULT = createOpText(dl, null, p); :}
        |
        deltaList:dl
        {: RESULT = createOpText(dl, null, null); :}
        ;

opExpr ::=
        //all operation expressions that have a syntactic
        //counterpart Z expression.
        term:t
        {: RESULT = opExpr(t); :}
        ;

//operations that do not have a syntactic counterpart Z
//expression. We push false onto the isOpExpr stack because we parse
//the schemaText, but count the @ as a SPOT token to remove an ambiguity
outer_opExpr ::=
        DCNJ:dcnj {: parserState_.pushIsOpExpr(false); :} schemaText:st
             SPOT {: parserState_.pushIsOpExpr(true); :} term:t
        {:
           RESULT = factory_.createDistConjOpExpr(st, opExpr(t));
           addLocAnn(RESULT, getLocation(dcnj, t));
        :}
        |
        DGCH:dgch {: parserState_.pushIsOpExpr(false); :} schemaText:st
             SPOT {: parserState_.pushIsOpExpr(true); :} term:t
        {:
           RESULT = factory_.createDistChoiceOpExpr(st, opExpr(t));
           addLocAnn(RESULT, getLocation(dgch, t));
        :}
        |
        /* We need a unicode character for this. */
        /*DSQC*/ ZCOMP:dsqc {: parserState_.pushIsOpExpr(false); :} schemaText:st
             SPOT {: parserState_.pushIsOpExpr(true); :} term:t
        {:
           RESULT = factory_.createDistSeqOpExpr(st, opExpr(t));
           addLocAnn(RESULT, getLocation(dsqc, t));
        :}
        |
        /* scope enrichment */
        term:lhs SCOPE:s term:rhs
        {:
           RESULT =
             factory_.createScopeEnrichOpExpr(factory_.list(opExpr(lhs), opExpr(rhs)));
           addLocAnn(RESULT, getLocation(sleft, sright, lhs, rhs));
        :}
<add:tcoz>
        |
        DIC:dic {: parserState_.pushIsOpExpr(false); :} schemaText:st
           SPOT {: parserState_.pushIsOpExpr(true); :} term:t
        {:
           RESULT = factory_.createDistInChoiceProExpr(st, opExpr(t));
           addLocAnn(RESULT, getLocation(dic, t));
        :}
        |
        DIL:dil {: parserState_.pushIsOpExpr(false); :} schemaText:st
           SPOT {: parserState_.pushIsOpExpr(true); :} term:t
        {:
           RESULT = factory_.createDistInterleaveProExpr(st, opExpr(t));
           addLocAnn(RESULT, getLocation(dil, t));
        :}
        |
        PARALLEL:dpara LPAREN topology:nt RPAREN:rparen
        {:
           RESULT = factory_.createTopologyProExpr(nt);
           addLocAnn(RESULT, getLocation(dpara, rparen));
        :}
</add:tcoz>
        ;

inner_opExpr ::=
        /* a horizontal operation expression with a delta list */
        LSQUARE opTextWithDelta:ot RSQUARE
        {: RESULT = factory_.createAnonOpExpr(ot); :}
        |
        /*  a horizontal operation expression with just a predicate */
        LSQUARE:l term:t RSQUARE:r
        {:
           ZDeclList dl = factory_.createZDeclList();
           OpText ot = createOpText(null, dl, pred(t));
           RESULT = factory_.createAnonOpExpr(ot);
           addLocAnn(RESULT, getLocation(l, r));
        :}
        |
        /* parallel conjuntion */
        inner_term:lhs PARALLEL:p inner_term:rhs
        {:
           RESULT =
             factory_.createParallelOpExpr(factory_.list(opExpr(lhs), opExpr(rhs)));
           addLocAnn(RESULT, getLocation(pleft, pright, lhs, rhs));
        :}
        |
        /* associative parallel conjunction */
        inner_term:lhs ASSOPARALLEL:ap inner_term:rhs
        {:
           RESULT =
             factory_.createAssoParallelOpExpr(factory_.list(opExpr(lhs), opExpr(rhs)));
           addLocAnn(RESULT, getLocation(apleft, apright, lhs, rhs));
        :}
        |
        /* angelic choice */
        inner_term:lhs GCH:gch inner_term:rhs
        {:
           RESULT =
             factory_.createExChoiceOpExpr(factory_.list(opExpr(lhs), opExpr(rhs)));
           addLocAnn(RESULT, getLocation(gchleft, gchright, lhs, rhs));
        :}
/*
<add:tcoz>
        |
        inner_term:lhs INTCHOICE inner_term:rhs
        {:
           RESULT = factory_.createInChoiceProExpr(opExpr(lhs), opExpr(rhs));
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        inner_term:lhs INTERLEAVE inner_term:rhs
        {:
           RESULT = factory_.createInterleaveProExpr(opExpr(lhs), opExpr(rhs));
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
 //ambiguity here with opExpr || [opText], where opText has inclDecl
 //although this renders as opExpr |[ eventSet |] opExpr
 //Needs to be taken care of in the scanner - this could prove difficult
        inner_term:lhs PARALLEL LSQUARE eventSet:ets RSQUARE inner_term:rhs
        {:
           EventSet es = factory_.createEventSet(ets);
           RESULT = factory_.createSynPllProExpr(lhs, rhs, es);
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
*/
/*
        inner_term:lhs TIMEOUT LSQUARE expression:e RSQUARE inner_term:rhs
        {:
           RESULT =
             factory_.createTimeoutStartProExpr(opExpr(lhs), e, opExpr(rhs));
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        inner_term:lhs TIMEEND LBRACE expression:e RBRACE inner_term:rhs
        {:
           RESULT =
             factory_.createTimeoutEndProExpr(opExpr(lhs), e, opExpr(rhs));
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        inner_term:lhs INTERRUPT LBRACE expression:e RBRACE inner_term:rhs
        {:
           RESULT =
            factory_.createInterruptProExpr(opExpr(lhs), e, opExpr(rhs));
           addLocAnn(RESULT, lhsleft, lhsright);
        :}
        |
        inner_term:t SCOPE DEADLINE expression:e
        {:
           RESULT = factory_.createDeadlineProExpr(opExpr(t), e);
           addLocAnn(RESULT, tleft, tright);
        :}
        |
        inner_term:t SCOPE WAITUNTIL expression:e
        {:
           RESULT = factory_.createWaitUntilProExpr(opExpr(t), e);
           addLocAnn(RESULT, tleft, tright);
         :}
        |
        WAIT:wait expression:e
        {:
           RESULT = factory_.createWaitProExpr(e);
           addLocAnn(RESULT, waitleft, waitright);
        :}
        |
        inOutEvent:et NEXTPRO inner_term:t
        {:
           RESULT = factory_.createAtProExpr(et, null, opExpr(t));
           addLocAnn(RESULT, etleft, etright);
        :}
        |
*/
/*
        inner_inner_term:it NEXTPRO inner_opExpr:t
        {:
           Event et = factory_.createEvent(name(oplhs), expr(it));
           RESULT = factory_.createAtProExpr(et, null, oe);
           addLocAnn(RESULT, oplhsleft, oplhsright);
        :}
        |
*/
/*
        refName:rn NEXTPRO inner_term:t
        {:
           Event et = factory_.createEvent(rn, null);
           RESULT = factory_.createAtProExpr(et, null, opExpr(t));
           addLocAnn(RESULT, rnleft, rnright);
        :}
        |
        inOutEvent:et ATTIME expression:e NEXTPRO inner_term:t
        {:
           RESULT = factory_.createAtProExpr(et, e, opExpr(t));
           addLocAnn(RESULT, etleft, etright);
        :}
        |
        opPromotionLhs:oplhs DOT inner_term:it
           ATTIME expression:e NEXTPRO inner_term:t
        {:
           Event et = factory_.createEvent(name(oplhs), expr(it));
           RESULT = factory_.createAtProExpr(et, e, oe);
           addLocAnn(RESULT, oplhsleft, oplhsright);
        :}
        |
        refName:rn ATTIME expression:e NEXTPRO inner_term:t
        {:
           Event et = factory_.createEvent(rn, null);
           RESULT = factory_.createAtProExpr(et, e, opExpr(t));
           addLocAnn(RESULT, rnleft, rnright);
        :}
        |
        MU:mu refName:rn SCOPE inner_term:t
        {:
           RESULT = factory_.createRecProExpr(rn, opExpr(t));
           addLocAnn(RESULT, muleft, muright);
        :}
</add:tcoz>
*/
        ;

<add:tcoz>
topology ::=
        topology:tp SEMICOLON connection:cn
        {:
           tp.add(cn);
           RESULT = tp;
        :}
        |
        connection:cn
        {: RESULT = factory_.list(cn); :}
        ;

connection ::=
        refNameList:lrnl NETTOPLEFT refNameList:crnl
           NETTOPRIGHT refNameList:rrnl
        {:
           RESULT = factory_.createConnection(lrnl, rrnl, crnl);
           addLocAnn(RESULT, getLocation(lrnlleft, lrnlright));
        :}
        ;

eventSet ::=
        eventSet:el COMMA event:e
        {:
           el.add(e);
           RESULT = el;
        :}
        |
        event:e
        {: RESULT = factory_.list(e); :}
        ;

event ::=
        inOutEvent:ioet
        {: RESULT = ioet; :}
        |
        refName:rn DOT inner_term:it
        {:
           RESULT = factory_.createEvent(rn, expr(it));
           addLocAnn(RESULT, getLocation(rn, it));
        :}
        |
        refName:rn
        {:
           RESULT = factory_.createEvent(rn, null);
           addLocAnn(RESULT, getLocation(rn));
        :}
        ;

inOutEvent ::=
        refName:rn INSTROKE inner_term:it
        {:
           rn.getZStrokeList().add(factory_.createInStroke());
           RESULT = factory_.createEvent(rn, expr(it));
           addLocAnn(RESULT, getLocation(rn, it));
        :}
        |
        refName:rn OUTSTROKE inner_term:it
        {:
           rn.getZStrokeList().add(factory_.createOutStroke());
           RESULT = factory_.createEvent(rn, expr(it));
           addLocAnn(RESULT, getLocation(rn, it));
        :}
        ;
</add:tcoz>

deltaList ::=
        DELTA:d LPAREN refNameList:rnl RPAREN:rparen
        {:
           RESULT = factory_.createDeltaList(rnl);
           addLocAnn(RESULT, getLocation(d, rparen));
        :}
        |
        DELTA:d LPAREN RPAREN:lparen
        {:
           List&lt;Name&gt; refNameList = factory_.list();
           RESULT = factory_.createDeltaList(refNameList);
           addLocAnn(RESULT, getLocation(d, lparen));
        :}
        ;
</add:oz>

</parser>
