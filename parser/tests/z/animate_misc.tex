\documentclass{article}
\usepackage{oz}
\newcommand{\negate}{-}
\parindent 0pt
\parskip 1ex plus 3pt

\title{CZT Tests for Basic Set Operations}
\author{Mark Utting \\ \texttt{marku@cs.waikato.ac.nz}}
\begin{document}
\maketitle

Each conjecture should evaluate to True.
However, those conjectures whose right-hand-size contains
the constant undefnum should have an undefined left-hand-side.

\begin{axdef}
  undefnum : \num
\end{axdef}

\section{Testing miscellaneous operators...}


\section{Testing IF-THEN-ELSE expressions}

 STATEGY: Equivalence Partitioning based on boolean inputs

 1. test true if statement (comparison)
\begin{zed} \vdash? (\IF 3 < 4 \THEN 1 \ELSE 2) = 1 \end{zed}
 2. test false if statement (comparison)
\begin{zed} \vdash? (\IF 3 > 4 \THEN 1 \ELSE 2) = 2 \end{zed}

 3. test true if statement (explicit boolean)
\begin{zed} \vdash? (\IF true \THEN 1 \ELSE 2) = 1 \end{zed}
 4. test false if statement (explicit boolean)
\begin{zed} \vdash? (\IF (false) \THEN 1 \ELSE 2) = 2 \end{zed}

 5. test true if statement (set membership)
\begin{zed} \vdash? (\IF 3 \in \nat \THEN 1 \ELSE 2) = 1 \end{zed}
 6. test false if statement (set membership)
\begin{zed} \vdash? (\IF (3 \notin \nat) \THEN 1 \ELSE 2) = 2 \end{zed}

 7. test true if statement (compound)
\begin{zed} \vdash? (\IF (3 < 4 \land 3 \in \nat) \THEN 1 \ELSE 2) = 1 \end{zed}
 8. test false if statement (compound)
\begin{zed} \vdash? (\IF \lnot (3 < 4 \land 3 \in \nat) \THEN 1 \ELSE 2) = 2 \end{zed}

 9. nested true-true if statement (compound)
\begin{zed} \vdash? (\IF 3 < 4 \THEN (\IF (3 < 4 \land 3 \in \nat) \THEN 1 \ELSE 2) \ELSE (\IF (3 < 4 \land 3 \in \nat)\THEN 3 \ELSE 4)) = 1 \end{zed}
 10. nested false-true if statement (compound)
\begin{zed} \vdash? (\IF 3 > 4 \THEN (\IF (3 < 4 \land 3 \in \nat) \THEN 1 \ELSE 2) \ELSE (\IF (3 < 4 \land 3 \in \nat)\THEN 3 \ELSE 4)) = 3 \end{zed}
 11. nested true-false if statement (compound)
\begin{zed} \vdash? (\IF 3 < 4 \THEN (\IF (3 < 4 \land 3 \notin \nat) \THEN 1 \ELSE 2) \ELSE (\IF (3 < 4 \land 3 \in \nat)\THEN 3 \ELSE 4)) = 2 \end{zed}
 12. nested false-false if statement (compound)
\begin{zed} \vdash? (\IF 3 > 4 \THEN (\IF (3 < 4 \land 3 \in \nat) \THEN 1 \ELSE 2) \ELSE (\IF (3 < 4 \land 3 \notin \nat)\THEN 3 \ELSE 4)) = 4 \end{zed}


\section{Testing \mu expressions}
\begin{zed} \vdash?  (\mu x,y:1 \upto 4|x=3=y) = (3,3) \end{zed}
\begin{zed} \vdash?  (\mu x,y:1 \upto 4|x<2=y) = (1,2) \end{zed}
\begin{zed} \vdash?  (\mu x,y:1 \upto 4|x<2=y @ x-y) = \negate 1 \end{zed}
\begin{zed} \vdash?  (\mu x,y:1 \upto 4|x<3=y).1 = undefnum \end{zed}


\section{Testing logical operators}
\begin{zed} \vdash?  \lnot false \end{zed}
\begin{zed} \vdash?  \lnot \lnot true \end{zed}
\begin{zed} \vdash?  \lnot true \iff false \end{zed}

\begin{zed} \vdash?  true \lor true \end{zed}
\begin{zed} \vdash?  true \lor false \end{zed}
\begin{zed} \vdash?  false \lor true \end{zed}
\begin{zed} \vdash?  \lnot(false \lor false) \end{zed}

\begin{zed} \vdash?  true \land true \end{zed}
\begin{zed} \vdash?  \lnot(true \land false) \end{zed}
\begin{zed} \vdash?  \lnot(false \land true) \end{zed}
\begin{zed} \vdash?  \lnot(false \land false) \end{zed}

\begin{zed} \vdash?  true \implies true \end{zed}
\begin{zed} \vdash?  \lnot(true \implies false) \end{zed}
\begin{zed} \vdash?  false \implies true \end{zed}
\begin{zed} \vdash?  false \implies false \end{zed}

\begin{zed} \vdash?  true \iff true \end{zed}
\begin{zed} \vdash?  \lnot(true \iff false) \end{zed}
\begin{zed} \vdash?  \lnot(false \iff true) \end{zed}
\begin{zed} \vdash?  false \iff false \end{zed}


\section{Testing logical quantifiers}
\begin{zed} \vdash? \forall x:0 \upto 4 | x \neq 4 @ x \in 0 \upto 3 \end{zed}
\begin{zed} \vdash?  \lnot \forall x:0 \upto 4 | x \neq 2 @ x < 4 \end{zed}
\begin{zed} \vdash?  \lnot \forall x:0 \upto 4 | x \neq 2 @ x > 0 \end{zed}
\begin{zed} \vdash?  \lnot \forall x:0 \upto 4 @ x \neq 2 \end{zed}

\begin{zed} \vdash? \exists x:0 \upto 4 | x \neq 4 @ x \in 1 \upto 2 \end{zed}
\begin{zed} \vdash? \exists x:0 \upto 4 | x \neq 2 @ x < 4 \end{zed}
\begin{zed} \vdash? \exists x:0 \upto 4 | x \neq 2 @ x > 0 \end{zed}
\begin{zed} \vdash? \exists x:0 \upto 4 @ x \neq 2 \end{zed}
\begin{zed} \vdash? \lnot \exists x:0 \upto 4 @ \lnot x \in 0 \upto 4 \end{zed}

\begin{zed} \vdash? \lnot \exists_1 x:0 \upto 4 | x \neq 4 @ x \in 1 \upto 2 \end{zed}
\begin{zed} \vdash? \exists_1 x:0 \upto 4 | x \neq 2 @ x \leq 0 \end{zed}
\begin{zed} \vdash? \exists_1 x:0 \upto 4 | x \neq 2 @ x \geq 4 \end{zed}
\begin{zed} \vdash? \exists_1 x:0 \upto 4 | x \neq 2 @ x \in 1 \upto 2\end{zed}
\begin{zed} \vdash? \exists_1 x:0 \upto 4 | x \neq 2 @ x \in 2 \upto 3\end{zed}
\begin{zed} \vdash? \lnot \exists_1 x:0 \upto 4 | x \neq 2 @ x \in 1 \upto 3\end{zed}
\begin{zed} \vdash? \lnot \exists_1 x:0 \upto 4 | x \neq 2 @ \lnot x \in 1 \upto 3\end{zed}

TODO: it would be nice to have some way of testing that a predicate is 
      undefined (that is, its truth value is unknown according to the Z 
      standard semantics), but this would be an extension of standard Z syntax.
\end{document}