\documentclass{article}

\usepackage{vmargin}
\usepackage{circus}

\setpapersize{A4}
%\setmarginsrb{leftmargin}{topmargin}{rightmargin}{bottommargin}{headheight}{headsep}{footheight}{footskip}
%\setmarginsrb{20mm}{10mm}{20mm}{10mm}{12pt}{11mm}{0pt}{11mm}
%\setmarginsrb{25mm}{20mm}{25mm}{20mm}{12pt}{11mm}{0pt}{10mm}
\setmarginsrb{40mm}{20mm}{40mm}{20mm}{12pt}{11mm}{0pt}{10mm}

\begin{document}

\title{\Circus\ Grammar Explained --- Channels}
\author{Leonardo Freitas}
\date{March 2006}

\maketitle

\begin{abstract}
    \noindent This article documents the various ways one can declare \Circus\ channels and channel sets
    using \LaTeX\ markup.  It also documents the open issues of the language related to these two syntactic
    categories.
\end{abstract}

\section{Introduction}

In this file, we explain the various aspect of \Circus\ related to channel
declarations. At each section relevant to the grammar, we include its
corresponding CUP rule, as ``Section name --- \texttt{grammarRule}''.

\Circus\ productions must be included within the \textsf{circus} \LaTeX\
environment in order to be recognised by the parser. Therefore, to use \Circus\
one needs to have the current version of the \textsf{circus.sty} \LaTeX\ style
file.

Amongst other commands, it contains all \Circus\ keywords, and some useful
environments.

\begin{issue}[creating \texttt{circus.sty} and \texttt{circus.dtx}]
   Make a suitable \texttt{circus.dtx} with nice and up-to-date \Circus\
   typesetting commands, as well as embedded documentation.

   Join version of \texttt{circus.sty} and add literate documentation.
   Also, gather the information for solving the spacing problem of the
   \code{circus} environment.
\end{issue}

\section{\Circus\ channel paragraphs --- \grammar{channelPara}}

In \Circus\ channels are global paragraphs at section level. Other global
paragraphs are channel sets, processes, and all other Z paragraphs. Firstly, we
need to create a new section containing the \textsf{circus\_toolkit} as a
parent.

\begin{zsection}
  \SECTION\ circus\_channels \parents\ circus\_toolkit
\end{zsection}
%
% TODO: Why is this happening?
%
% Funny, if I leave the \begin{zsection}...\end{zsection} within the
% verbatim environment, the parser is recognising it! It does not
% happen with the \begin{circus}...\end{circus} environment though.
%
\begin{verbatim}
   begin{zsection}
      \SECTION\ circus\_channels \parents\ circus\_toolkit
   end{zsection}
\end{verbatim}
%
We include with each typeset text the corresponded \LaTeX\ code.


\subsection{Common channels --- \grammar{channelDecl}}

Channels are declared in \Circus\ to specify synchronisation points. Channel
types are any Z expression, and they define the communication patterns to
synchronise.

Untyped channels are also allowed. They represent synchronisation points with
the given type $Synch$. Thus, declaring a untyped channel has the same effect
as declaring the channel with type $Synch$, as defined in the
\textsf{circus\_toolkit.tex} file.

Channels are declared within the \textsf{circus} \LaTeX\ environment, which are
typeset as Z unboxed items like in the \textsf{zed} \LaTeX\ environment. As the
Z standard, various unboxed \Circus\ items can be declared within the same
environment, as long as they are separated by a \grammar{NL} (new-line) token.

\subsubsection{Typed channels}

Let us define some typed channels,
%
\begin{circus}
  \circchannel\ a, b: \nat
\end{circus}%
%
\begin{verbatim}
     begin{circus}
        \circchannel\ a, b: \nat
     end{circus}%
\end{verbatim}
%
as well as typed channels with strokes.
%
\begin{circus}
  \circchannel\ x_1~, r, q'~, y_2: \num
\end{circus}%
%
\begin{verbatim}
     begin{circus}
        \circchannel\ x_1~, r, q'~, y_2: \num
     end{circus}%
\end{verbatim}
%
Note that due to the Z standard idiosyncrasy regarding name lists with strokes
and commas (\textit{i.e.}, \grammar{DECORWORD} or \grammar{DECLWORD} in CZT),
we \textbf{*must*} include a hard space to separate these names (see Z Standard
section 7.3). This is needed, for instance, to allow distinction between set
extensions and a list of variable names in a declaration. The soft space
through \verb'\ ' is optional, though.

\subsubsection{Generic channels}

Generic channels can also be declared, where generic formal parameters given
are right after the $\circchannel$ keyword.
%
\begin{circus}
   \circchannel\ [X, Y]\ g, h_1~, i: (X \rel Y)
\end{circus}%
%
\begin{verbatim}
     begin{circus}
        \circchannel\ [X, Y]\ g, h_1~, i: (X \rel Y)
     end{circus}%
\end{verbatim}
%
As before, names with decorations must have hard spaces before hitting a
\texttt{COMMA} token, as shown above.

\begin{issue}[type inference on generic channels usage]
    In practice, how should generic actuals be instantiated for channels?
    The implications are clear at parallel composition and implementation of
    ``generically defined'' communications.

    For example, in:

    \[
        \circchannel\ [X] c, d: X \\

        \vdots \\

        c?x \then d!x \then Skip \lpar \lchanset c, d \rchanset \rpar c.v \then d?x \then Skip
    \]

    Could the typechecker infer the types of both $c$ and $d$ to be the
    type of $v$? In a multisychronisation scenario, however, this would
    become a typechecking nightmare!

    The suggestion is then to enforce generic actuals instantiation on
    generically defined channels, so that no type inference is needed,
    as in:

    \[
       c[\nat]?x \then d[\nat]!x \then Skip \lpar \lchanset[\nat], d[\nat] \rchanset \rpar c[\nat].v \then d[\nat]?x \then Skip
    \]

    This involves a clumsy and too verbose specification, but simpler
    typechecking. What would be the compromise? Just leave it out for the
    moment?!
\end{issue}

\subsubsection{Synchronisation channels}

Synchronisation channels are defined without a type expression. The parser
introduces a $Synch$ \code{RefExpr} for it automatically, as it is necessary
for translation to and from ZML. This name is defined as a given set in the
\textsf{circus\_toolkit.tex} file.
%
\begin{circus}
   \circchannel\ c, d \\
   \circchannel\ z_2~, w_3
\end{circus}%
%
\begin{verbatim}
     begin{circus}
        \circchannel\ c, d \\
        \circchannel\ z_2~, w_3
     end{circus}%
\end{verbatim}
%
This time, we left two declarations within the same Z box, but separated by a
\grammar{NL} (new-line) token.

% SOLVED: Discussion in an e-mail with Tim and Mark (CZT), 20,21/03/2006
%         (subject: Exception thrown while marshiling ZML with null Expr in VarDecl)
%
\begin{issue}[technicality about representation of $Synch$]
    Perhaps we shall remove the $Synch$ type from \texttt{circus\_toolkit} and
    set it as a reserved word that the typechecker does not allow anyone else to
    use.

    If that is the path to choose, we can to do this by extending the
    directives of the parser to have something like \code{\%\%Zreserved}.
\end{issue}

\subsection{Channels through schemas --- \grammar{channelFromDecl}}

Another way of declaring typed channels is through schema references. Let us
define a schema named $S$ with two channels $a$ and $b$
%
\begin{schema}{S}
   a, b: \nat
\where
   a > b \land b \neq 0
\end{schema}
%
\begin{verbatim}
     begin{schema}{S}
         a, b: \nat
     \where
         a > b \land b \neq 0
     end{schema}
\end{verbatim}
%
With the $\circchannelfrom$ keyword, we can declare these channels in various
ways, depending on the chosen decoration.
%
\begin{circus}
   \circchannelfrom\ S \\
   \circchannelfrom\ S_1
\end{circus}%
%
\begin{verbatim}
     begin{circus}
        \circchannelfrom\ S \\
        \circchannelfrom\ S_1
     end{circus}%
\end{verbatim}
%
These declarations include four channels of type $\nat$, namely:~$a$, $b$,
$a_1$, and $b_1$.

% SOLVED: Invariants of schemas are ignored on channelFrom - Jim
%
\begin{issue}[invariant of schemas in channelFrom]
  What happen with the invariant of $S$?
  Should it be enforced on the communication patterns or just be ignored?
\end{issue}

% SOLVED: Restricted to RefExpr only - Jim
%
\begin{issue}[channelFrom with any expression]
What about this kind of declaration?
%
\[
   \circchannelfrom\ S \cross S
\]

At the moment the grammar does allow it. The option is to restrict it to
\code{RefExpr} only (\textit{i.e.}, reference expressions that could carry
generic actuals).
\end{issue}

Another option is to have schemas with generic types.
%
\begin{schema}{T}[X]
   x, y: \power~X
\where
   x \subseteq y
\end{schema}
%
\begin{verbatim}
     begin{schema}{T}[X]
         x, y: \power~X
     \where
         x \subseteq y
     end{schema}
\end{verbatim}
%
In this case, one can define the channels from the schema via
either:~(i)~declaring the schema name with corresponding number of generic
actuals;~(ii)~leaving the original generic formal parameters (possibly renaming
them);~(iii)~letting the typechecker decide;~or (iii)~redefining the generic
formal parameters of channel types in terms of a new pattern of formal
parameters for the schema generic actuals.
%
\begin{circus}
    \circchannelfrom\ T[\nat] \\
    \circchannelfrom\ [Y]\ T_1[Y] \\
    \circchannelfrom\ T_2 \\  % Ana says this should be a type error!
    \circchannelfrom\ [A, B]\ T_3[A \cross B]
\end{circus}%
%
\begin{verbatim}
     begin{circus}
         \circchannelfrom\ T[\nat] \\
         \circchannelfrom\ [Y]\ T_1[Y] \\
         \circchannelfrom\ T_2 \\
         \circchannelfrom\ [A, B]\ T_3[A \cross B]
     end{circus}%
\end{verbatim}
%
It is the task of the typechecker to guarantee that either the instantiation or
(re)definitions are type-correct. For each case we would have:
%
\begin{itemize}
    \item[i] $\circchannel\ x, y: \power~\nat$
    \item[ii] $\circchannel\ [Y]\ x_1~, y_1: \power~Y$
    \item[iii] $\circchannel\ x_2~, y_2: \power~X$
    \item[iv] $\circchannel\ [A, B]\ x_3~, y_3: \power~(A \cross B)$
\end{itemize}
%
Thus, $\circchannelfrom$ is just syntactic sugar for a corresponding
$\circchannel$ declaration.

% SOLVED: Allow ``layered'' generics. Typechecker needs to sort it out
%         and adjust the AST appropriately - Jim
%
\begin{issue}[desugaring $\circchannelfrom$ into $\circchannel$]
   The AST allows room for quite powerful use of generic types within channel
   declaration from generic schemas via the two set of generic types on each
   production (\textit{i.e.}, \code{AxPara} and \code{ChannelDecl}).

   The burden is given to the typechecker to infer the appropriate generic
   formals/actuals, as well as to match/update the lists of generic names (and
   their corresponding type expressions).

   Anyway, the possibly tricky business comes if we decide to restrict the
   communication patterns with the corresponding schema invariant. As it
   stands, it is left for the typechecker to solve.

   \textbf{By the way, Ana says $T_2$ should be a type error because the generic actuals
   are not being given to the schema. Check with Manuela.}
\end{issue}

\section{\Circus\ channel set paragraphs --- \grammar{channelSetPara}}

Channel sets defines an expression to represent a particular set of channels.
They are normally used as reference names for other \Circus\ operators that
have channel references as parts of their AST, such as the parallel and the
hiding operators.

Channel sets are given as a name and a corresponding expression.
%
\begin{circus}
    \circchannelset\ C == \emptyset \\
    \circchannelset\ C0 == \lchanset \rchanset \\
    \circchannelset\ C1 == \lchanset a, b, c, d \rchanset \\
    \circchannelset\ C2 == \lchanset x, y, x_1~, y_1 \rchanset \\
    \circchannelset\ [A, B] C3 == \lchanset x_2[A \cross B]~, y_2[A \fun B], x_1[A], y_1[B] \rchanset \\
    \circchannelset\ C4 == C1 \cup C2 \cap C3 \setminus (C0 \cup C1 \cup C)
\end{circus}%

\begin{verbatim}
    begin{circus}
        \circchannelset\ C == \emptyset \\
        \circchannelset\ C0 == \lchanset \rchanset %\\
        \circchannelset\ C1 == \lchanset a, b, c, d \rchanset \\
        \circchannelset\ C2 == \lchanset x, y, x_1~, y_1 \rchanset \\
        \circchannelset\ [A, B] C3 == \lchanset x_2[A \cross B]~, y_2[A \fun B], x_1[A], y_1[B] \rchanset \\
        \circchannelset\ C4 == C1 \cup C2 \cap C3 \setminus (C0 \cup C1 \cup C)
    end{circus}
\end{verbatim}
%
The channel set expressions mostly used are: set union, intersection and
difference expressions;~set extension expressions;~reference expressions;~and
application expressions.

% SOLVED: Generalise channel set expressions to allow any Z expression - Jim
%         Should it simplify typechecking in a great extent?
%
\begin{issue}[generalising channel set expressions]
  The restricted form of channel sets complicate the grammar in a great
  extent because it demands filtering through the (very complex) expression
  subtree, which also mixes with the predicate subtree.

  If application expressions were not to be considered, the limitation would be
  rather simple, as the other channel set expressions are easy to (hard) code. Nevertheless,
  as one might like (or even require) to define particular functions for
  channel sets to be used over replicated operators, application expressions may not (or cannot) be
  avoided.

  For example, this scenario might appear as a requirement when one needs to perform
  synchronisation between disjoint set of channels amongst more than two processes,
  in order to avoid multisynchronisation complexities.

  Therefore, because of application expression, we need to include channel sets with mostly
  all expressibility power of Z expressions. The best choice seems to reuse the
  Z grammar for abbreviations, and encoded as an AST of \code{ChannelSet}
  encapsulating a \code{ConstDecl}. This is useful for simplifying typechecking
  (and perhaps other purposes).

  This choice will also normalise the language with respect to generically
  defined channels, as Z abbreviations already take care of generic formal and
  actual parameters. \textbf{This would simplify the parser grammar as well as the AST structure in a grater
  extend.} Furthermore, a nice side effect is the ability to have generic
  operators as possible channel set functions!

  On the other hand, if one wants to keep the restrictions, one possible
  approach would be to leave the parser with Z abbreviations, but restrict
  its use through the type checking of channel sets.
\end{issue}

%2) Como estao as regras de tipos pra referencias a channel sets?
%
%Isso eh, channel sets references podem ter generic actuals?
%
%\circchannel\ [X] c, d: X \\
%\circchannel\ [Y] e, f: Y \\
%
%\circchanset\ CS1 = \lchanset c, d \rchanset \\
%\circchanset\ CS2 = \lchanset e, f \rchanset \\
%\circchanset\ CS3 = CS1[\nat] \cup CS2[\power~\num]
%
%Essa eh apenas uma duvida com relacao a typechecking que nao afeta o parser,
%pois CS3 esta usando RefExpr que ja contem generic actuals.
%
%Ou mais generalisado ainda, como ocorre com declaracao de canais via schemas
%onde temos possivelmente os generics do channel + generics do schema, poderiam
%channel sets ter generic formals?
%
%\circchanset\ [A, B] CS4 = CS1[\nat \cross A] \cup CS2[A \cross B]
%
%Se essa opcao for desejavel/prevista, a AST pra ChannelSet precisa ser
%modificada pra incluir uma lista de nomes pra os generic formals.

% o que ocorre se tiver decoration em ChannelSets? decora os canais tambem?
%
% ex: CS1_0  =>  \lchanset c_0, d_0 \rchanset ?

+ Add problematic tests to check the creation of various kinds of BasicChannelSetExpr!

\end{document}
