\begin{zsection}
  \SECTION sequence\_toolkit \parents function\_toolkit, number\_toolkit
\end{zsection}

\begin{zed}
  \function 20 \leftassoc (\varg \upto \varg)
\end{zed}

\begin{axdef}
  \varg \upto \varg : \arithmos \cross \arithmos \pfun \power \arithmos
\where
  (\num \cross \num) \dres (\varg \upto \varg) \in \num \cross \num \fun \power \num\\
  \forall i,j : \num @ i \upto j = \{ k : \num | i \leq k \leq j \}
\end{axdef}

\begin{gendef}[X]
  iter : \nat \fun (X \rel X) \fun (X \rel X)
\where
  \forall r : X \rel X @ iter 0 r = id X\\
  \forall r : X \rel X; n : \nat @ iter(n + 1) r = r \comp (iter n r)
\end{gendef}

%cannot parse this due to word glue problem in scanner
%TODO: fix the scanner! ;)
/*
\begin{zed}
  \function 90 ( \varg ^{ \varg } )
\end{zed}

\begin{gendef}[X]
  \varg ^{\varg} : (X \rel X) \fun \num \fun (X \rel X)
\where
  \forall r : X \rel X; n : \nat @ r^{n} = iter n r
\end{gendef}
*/

\begin{gendef}[X]
  \# : \finset X \fun \nat
\where
  \forall a : \finset X @ \# a = 
     (\mu~ n : \nat | (\exists f : 1 \upto n \mapsto a @ \ran f = a))
\end{gendef}

\begin{axdef}
  min : \power \arithmos \pfun \arithmos\\
  max : \power \arithmos \pfun \arithmos
\where
  \power \num \dres min = \{a : \power \num ; m : \num | m \in a \land
     (\forall n : a @ m \leq n) @ a \mapsto m \}\\
  \power \num \dres max = \{a : \power \num ; m : \num | m \in a \land
     (\forall n : a @ n \leq m) @ a \mapsto m \}
\end{axdef}


\begin{gendef}[L,X]
  items : (L \ffun X) \fun X \pfun \nat_1
\where
  \forall f : L \ffun X @
     items f = \{ x : \ran f @ x \mapsto \#(f \rres \{x\}) \}
\end{gendef}

%Need \seq_1 declared in a template first?
\begin{zed}
  \generic 80 ( \seq \varg )\\
  \generic 80 ( \seq_1 \varg )\\
  \generic 80 ( \iseq \varg )
\end{zed}

\begin{zed}
  \seq X == \{ f : \nat \ffun X | \dom f = 1 \upto \# f \}\\
  \seq_1 X == \seq X \setminus \{ \emptyset \}\\
  \iseq X == \seq X \cap (\nat \pinj X)
\end{zed}

\begin{zed}
  \function ( \langle \listarg \rangle )\\
%TODO: this does not seem to correspond to the ISO grammar
  \langle \listarg \rangle [X] == \lambda s : \seq X @ s
\end{zed}

\begin{zed}
  \function 30 \leftassoc ( \varg \cat \varg )
\end{zed}

\begin{gendef}[X]
  \varg \cat \varg : \seq X \cross \seq X \fun \seq X\\
  rev : \seq X \fun \seq X
\where
  \forall s, t : \seq X @ s \cat t = s \cup \{n : \dom t @ n + \# s \mapsto t n \}\\
  \forall s : \seq X @ rev s = (\lambda~ n : \dom s @ s(\# s - n + 1))
\end{gendef}

\begin{gendef}[X]
  head, last, tail, front : \seq_1 X \fun X
\where
  \forall s : \seq_1 X @
     head s = s 1 \land
     last s = s(\# s) \land
     tail s = (\lambda~ n : 1 \upto (\# s - 1) @ s(n + 1)) \land
     front s = \{ \# s \} \ndres s
\end{gendef}

\begin{gendef}[X]
  squash : (\num \ffun X) \fun \seq X
\where
  \forall f : \num \ffun X @
     squash f = \{p : f @ \# \{i : \dom f | i \leq p.1 \} \mapsto p.2 \}
\end{gendef}

\begin{zed}
  \function 41 \rightassoc (\varg \extract \varg)\\
  \function 40 \rightassoc (\varg \filter \varg)
\end{zed}

\begin{gendef}[X]
  \varg \extract \varg : \power \num \cross \seq X \fun \seq X\\
  \varg \filter \varg : \seq X \cross \power X fun \seq X
\where
  \forall a : \power \num ; s : \seq X @ a \extract s = squash(a \dres s)\\
  \forall s : \seq X; a : \power X @ s \filter a = squash(s \rres a)
\end{gendef}

\begin{zed}
  \relation ( \varg \prefix \varg )\\
  \relation ( \varg \suffix \varg )\\
  \relation ( \varg \infix \varg )
\end{zed}

\begin{gendef}[X]
  \varg \prefix \varg ,  \varg \suffix \varg , \varg \infix \varg : \seq X \rel \seq X
\where
  \forall s, t : \seq X @
     s \prefix t \iff s \subseteq t \land
     s \suffix t \iff (\exists u : \seq X @ u \cat s = t) \land
     s \infix t \iff (\exists u,w : \seq X @ u \cat s \cat v = t)
\end{gendef}

\begin{gendef}[X]
  \dcat : \seq \seq X \fun \seq X
\where
  \dcat \langle \rangle = \langle \rangle\\
  \forall s : \seq X @ \dcat \langle s \rangle = s\\
  \forall q,r : \seq \seq X @ \dcat(q \cat r) = (\dcat q) \cat (\dcat r)
\end{gendef}
