/**
Copyright 2003 Tim Miller
This file is part of the CZT project.

The CZT project contains free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

The CZT project is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with CZT; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
package net.sourceforge.czt.parser.oz;

import java.util.*;
import java.io.*;
import java.math.BigInteger;

import java_cup.runtime.*;

import net.sourceforge.czt.base.ast.*;
import net.sourceforge.czt.z.ast.*;
import net.sourceforge.czt.oz.ast.*;
import net.sourceforge.czt.oz.impl.OzFactoryImpl;

action code
{:
    /** The symbol used to replace arguments for names in ApplExpr etc. */
    public final static String USCORE_TOK = "_";

    /** The factory for creating AST objects. */
    protected OzFactory ozFactory_ = new OzFactoryImpl();

    /** The table of operators. */
    protected OperatorTable table_;

    /** The "fix" of the current operator being parsed. */
    protected int fix_ = -1;

    /**
     * Create an empty list
     */
    protected List list()
    {
        return new ArrayList();
    }

    /**
     * Create a list containing one element
     */
    protected List list(Object o)
    {
        List result = new ArrayList();
        result.add(o);
        return result;
    }

    /**
     * Create a list containing two elements
     */
    protected List list(Object o1, Object o2)
    {
        List result = new ArrayList();
        result.add(o1);
        result.add(o2);
        return result;
    }


    /**
     * Converts a list of strings into one long string with spaces between
     * each token
     */
    protected String strListToString(List list)
    {
        String name = new String();

        for (Iterator iter = list.iterator(); iter.hasNext(); ) {
            String next = (String) iter.next();
            name += next + " ";
        }
        return name;        
    }

    /**
     * Converts a list of String objects to a DeclName object
     */
    protected DeclName strListToDeclName(List list)
    {
        return ozFactory_.createDeclName(strListToString(list), list(), null);
    }

    /**
     * Converts a list of String objects to a RefName object
     */
    protected RefName strListToRefName(List list)
    {
        return ozFactory_.createRefName(strListToString(list), list(), null);
    }


    /**
     * Creates a member predicate from a string list and an expression list
     */
    protected MemPred localCreateMemPred(List name, List exprList)
    {
        TupleExpr te = ozFactory_.createTupleExpr(exprList);
        RefName rn = strListToRefName(name);
        RefExpr re = ozFactory_.createRefExpr(rn, list(), Boolean.FALSE);
        MemPred result = ozFactory_.createMemPred(te, re, Boolean.TRUE);
        return result;
    }

    /**
     * Creates an application expression from string string list and an 
     * expression list
     */
    protected ApplExpr localCreateApplExpr(List name, List exprList)
    {
        TupleExpr te = ozFactory_.createTupleExpr(exprList);
        RefName rn = strListToRefName(name);
        RefExpr re = ozFactory_.createRefExpr(rn, list(), Boolean.FALSE);
        ApplExpr result = ozFactory_.createApplExpr(te, re, Boolean.TRUE);
        return result;
    }

    /**
     * Extracts a number from a number stroke.
     * Perhaps this should be done in the scanner
     */
    protected Integer extractNum(String numStroke)
    {
        Integer result = null;

        if (numStroke.startsWith("_{")) {
            result = new Integer(numStroke.substring(2, 3));
        }
        else {
            result = new Integer(numStroke.substring(1, 2));
        }
        return result;
    }

    protected void addExpSepName(List opName, List es)
    {
        if (es.size() > 1) {
            opName.add(USCORE_TOK);
            opName.add((String)es.get(1));
        }
    }

    protected void addExpSepExp(List expList, List es)
    {
        if (es.size() > 1) {
            expList.addAll((List)es.get(0));
        }
    }
:}

parser code
{:

    /** The table of operators */
    protected OperatorTable table_;

    /**
     * The constructor that receives the operator table
     */
    public LatexParser(Scanner scanner, OperatorTable table)
    {
        super(scanner);
        this.table_ = table;
    }

    /**
     * Return the next token, returning the operator symbol if it is a 
     * user defined operator
     */
    protected Symbol local_next_token() throws Exception
    {
        Symbol symbol = null;
        Symbol result = null;

        symbol = getScanner().next_token();

        if (symbol.sym == LatexSym.NAME || symbol.sym == LatexSym.DECLWORD) {

            int type = table_.lookup((String)symbol.value);
            result = (type == -1) ? symbol : new Symbol(type, symbol.value);
        }
        else {
            result = symbol;
        }
        return result;
    }
:}

init with
{:
    //share the operator table between the action code and the parser code
    action_obj.table_ = table_;
:}

scan with {: return local_next_token(); :};

terminal String
        DELTA, THETA, MU, LAMBDA, POWER, NARRWORD,
        NEXTSTROKE, OUTSTROKE, INSTROKE, NUMSTROKE, USCORE, LBRACE, RBRACE,
        LPAREN, RPAREN, LSQBRACE, RSQBRACE, LBLOT, RBLOT, LDATA, RDATA, LSET, RSET,
        CBAR, AMPERSAND, VDASH, LAND, LOR, IMP, IFF, LNOT, FORALL, EXISTS, CROSS,
        FSLASH, EQUALS, MEM, COLON, SEMI,COMMA, PERIOD, DOT, ZHIDE, 
        ZPROJECT, ZCMP, ZPIPE, NL,
        SECTION, PARENTS, TRUE, FALSE, LET, IF, THEN, ELSE, PRECONDITION,
        RELATION, FUNCTION, GENERIC, LEFTASSOC, RIGHTASSOC, LISTARG,
        DDEF, DEFS, EXISTS1,
        END, AX, SCHEMA, GENAX, WHERE, ZED, CLASS, STATE, INIT, INITWORD, OPSCHEMA, 
        VISIBILITY, INHERITS, LOCALDEF,
        DCNJ, DGCH, DSQC, PARALLEL, ASSOCPARALLEL, GCH,
        CLASSCOM, ENDCLASSCOM, CLASSCOMWORD,
        STROKE, NAME, DECLWORD,
        PREP, PRE, POSTP, POST, IP, I, LP, L, ELP, EL, ERP, ER,
        SRP, SR, EREP, ERE, SREP, SRE, ES, SS,
        _ZNOT, _OP_PROMOTION_PERIOD, _APPLICATION;

terminal Integer NUMBER;

non terminal Spec
    specification;

non terminal List /*<ZSect>*/ sectionList;
non terminal ZSect section;
non terminal List /*<Parent>*/ parentList;
non terminal String sectionName;

non terminal List /*<Para>*/ 
    paragraphList,
    unboxedParagraphList,
    unboxedParagraphItemList;

non terminal Para 
    boxedParagraph,
    unboxedParagraphItem;

non terminal NarrPara narrParagraph;

non terminal List /*<String>*/
    optParents;

non terminal AxPara
    axiomaticDefinition,
    genericAxDefinition,
    abbreviationDefinition,
    schema;

non terminal ConstDecl
    letDefinition;

non terminal List /*<Freetype>*/ freeTypeList;
non terminal Freetype freeTypeDefinition;

non terminal List /*<String>*/ narrWordList;

non terminal OptempPara operatorTemplate;
non terminal List /*<StringAndOperand?>*/ 
    template,
    prefixTemplate,
    postfixTemplate,
    infixTemplate,
    nofixTemplate,
    optWordOperandList;

non terminal Operand 
    uscore,
    templateTag;
non terminal Assoc assoc;
non terminal OptempPara catTemplate;

non terminal SchText 
    basicSchemaText,
    schemaText;

non terminal List /*<ConstDecl>*/ letDefinitionList;

non terminal ClassPara
    class;

non terminal List /*<InheritedClass>*/ 
    inheritedList,
    inheritedClassList;
non terminal InheritedClass inheritedClass;
non terminal ActualParameters optActualParameters;
non terminal RenameExpr optRenameExpression;

non terminal RefNameList 
    deltaList,
    visibilityList;
                        
non terminal FormalParameters classFormalParameters;

non terminal List /*<Branch>*/ branchList;
non terminal Branch branch;

non terminal List /*<Operation>*/ operationList;

non terminal List /*<Para>*/ localDefinitionList;
non terminal Para localDefinition;

non terminal LocalDef
    localDefinitionBlock;

non terminal List /*<DeclName>*/ 
    nameList,
    declWordList,
    declNameList;
non terminal DeclName
    name,
    declName;

non terminal List /*<RefName>*/ refNameList;
non terminal RefName refName;

non terminal List /*<NameNamePair>*/ renameList;
non terminal NameNamePair rename;
    
non terminal List /*<Decl>*/ 
    basicDeclPart,
    expressionDeclPart,
    optDeclPart,
    declPart;
non terminal Decl 
    basicDeclaration,
    declaration;

non terminal GivenPara basicTypeDefinition;

non terminal State state;
non terminal SecondaryAttributes secondaryDecl;

non terminal InitialState initialState;

non terminal List /*<DeclName*/
    formalParameters,
    optFormalParameters;

non terminal List /*<Stroke>*/ optStrokeList;
non terminal Stroke stroke;

non terminal Op 
    sep,
    optNL;

non terminal Pred
    predicate,
    predicate1;

non terminal MemPred
    prefixRel,
    postfixRel,
    nofixRel;

non terminal Pred
    relation,
    infixRel,
    infixChainRel;

non terminal Expr 
    expression;

non terminal List /*<NameExprPair*/
    optNameExprPairList,
    nameExprPairList;

non terminal NameExprPair nameExprPair;

non terminal List /*<Expr>*/ prodExpressionList;

non terminal List /*<Expr>*/ 
    optExpressionList,
    expressionList;

non terminal Operation operation;

non terminal OperationBox operationBox;
non terminal OperationExpr
    operationExpression,
    operationExpression1;

non terminal MainOpExpr mainOpExpression;

non terminal List /*<String>*/ 
    opName,
    prefixName,
    postfixName,
    infixName,
    nofixName,
    genName,
    prefixGenName,
    postfixGenName,
    infixGenName,
    nofixGenName;

non terminal List /*<String>*/
    optUscoreEsSsList,
    optNameEsSsList;

non terminal ApplExpr
    application,
    prefixApp,
    postfixApp,
    infixApp,
    nofixApp;

non terminal List /*<Object>*/
    expSep;

non terminal String
    erepOrSrep,
    ereOrSre,
    erOrSr,
    esOrSs,
    erpOrSrp;

non terminal String
    visibility,
    predDot,
    opPromotionPeriod,
    znot;

precedence nonassoc     CBAR;
precedence left         NARRWORD;
precedence left         RPAREN;
precedence left         NL, SEMI;
precedence left         FORALL, EXISTS, EXISTS1;
precedence left         IFF;
precedence right        IMP;
precedence left         LOR;
precedence left         LAND;
precedence right        LNOT;
precedence nonassoc     PREP, LP, EREP, SREP, POSTP, ELP, ERP, SRP, MEM, EQUALS, IP;
precedence left         DOT;
precedence left         LAMBDA;
precedence left         LET;
precedence left         MU;
precedence left         ASSOCPARALLEL;
precedence left         PARALLEL;
precedence left         GCH;
precedence right        _ZNOT;
precedence right        ELSE;
precedence left         ZCMP;
precedence left         ZPIPE;
precedence left         ZHIDE;
precedence left         ZPROJECT;
precedence nonassoc     PRECONDITION;
precedence left         CROSS, POWER, PRE, L, ERE, SRE, POST, EL, ER, SR, I, ES, SS;
precedence left         _APPLICATION;
precedence left         INSTROKE, OUTSTROKE, NEXTSTROKE, NUMSTROKE;
precedence left         LSQBRACE, RSQBRACE;
precedence left         _OP_PROMOTION_PERIOD;
precedence left         PERIOD;
precedence right        THETA;


/// specifications /////////////////////////////////////////////////////////

specification ::=
        paragraphList:pl
        {:
           //TODO: use factory to create Spec instance
           ZSect sect = ozFactory_.createZSect(null, list(), pl);
           Spec spec = ozFactory_.createSpec();
           spec.getSect().add(pl);
           RESULT = spec;
        :}
        |
        sectionList:sl
        {:
           Spec spec = ozFactory_.createSpec();
           spec.getSect().addAll(sl);
           RESULT = spec;
        :}
        ;

sectionList ::= 
        sectionList:sl section:s
        {: 
           sl.add(s);
           RESULT = sl;
        :}
        |
        section:s
        {: RESULT = list(s); :}
        ;

section ::=
        SECTION sectionName:n optParents:ops NL paragraphList:pl
        {: RESULT = ozFactory_.createZSect(n, ops, pl); :}
        ;

//reduce this separately so we can set the current section
//in the operator table
sectionName ::=
        NAME:n
        {:
           table_.setSection(n);
           RESULT = n;
        :}
        ;

optParents ::=
        //empty
        {: RESULT = list(); :}
        |
        PARENTS parentList:pl
        {: RESULT = pl; :}
        |
        PARENTS
        {: RESULT = list(); :}
        ;

parentList ::=
        parentList:pl COMMA NAME:n
        {: 
           table_.addParent(n);
           Parent p = ozFactory_.createParent(n);
           pl.add(p);
           RESULT = pl;
        :}
        |
        NAME:n
        {: 
           table_.addParent(n);
           Parent p = ozFactory_.createParent(n);
           RESULT = list(p);
        :}
        ;


//paragraphs are divided into boxed and unboxed paragraphs. Unboxed paragraphs
//must have a newline after their definition
paragraphList ::= 
        paragraphList:pl boxedParagraph:p 
        {: 
           pl.add(p);
           RESULT = pl;
        :}
        |
        paragraphList:pl unboxedParagraphList:upl 
        {:
           pl.addAll(upl);
           RESULT = pl;
        :}
        |
        paragraphList:pl narrParagraph:np
        {:
           pl.add(np);
           RESULT = pl;
        :}
        |
        //empty
        {: RESULT = list(); :}
        ;


// 6.2 Global Paragraphs //////////////////////////////////////////////////////

boxedParagraph ::=
        axiomaticDefinition:ad
        {: RESULT = ad; :}
        |
        schema:s
        {: RESULT = s; :}
        |
        genericAxDefinition:gd
        {: RESULT = gd; :}
        |
        class:c
        {: RESULT = c; :}
        ;


narrParagraph ::=
        narrWordList:nwl
        {: RESULT = ozFactory_.createNarrPara(nwl); :}
        ;

unboxedParagraphList ::=
        ZED unboxedParagraphItemList:uil END
        {: RESULT = uil; :}
        ;

unboxedParagraphItemList ::=
        unboxedParagraphItemList:uil NL unboxedParagraphItem:ui
        {:
           uil.add(ui);
           RESULT = uil;
        :}
        |
        unboxedParagraphItem:ui
        {: RESULT = list(ui); :}
        ;

unboxedParagraphItem ::=
        basicTypeDefinition:btd
        {: RESULT = btd; :}
        |
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        |
        freeTypeList:ftl
        {: RESULT = ozFactory_.createFreePara(ftl); :}
        |
        optFormalParameters:ofp VDASH predicate1:p1
        {: RESULT = ozFactory_.createConjPara(ofp, p1); :}
        |
        operatorTemplate:ot
        {:
           table_.add(fix_, ot);
           fix_ = -1;
           RESULT = ot;
        :}
        ;

basicTypeDefinition ::= 
        LSQBRACE nameList:nl RSQBRACE
        {: RESULT = ozFactory_.createGivenPara(nl); :}
        ;

//according to the Z ISO, a schema is an axiomatic definition with
//ConstDecl(n, st) as the declaration
schema ::=
        SCHEMA LBRACE name:n RBRACE optFormalParameters:ofp schemaText:st END
        {: 
           //according to the Z ISO, a schema is an axiomatic definition with
           //ConstDecl(n, st) as the declaration
           SchExpr se = ozFactory_.createSchExpr(st);
           ConstDecl cd = ozFactory_.createConstDecl(n, se);
           SchText stC = ozFactory_.createSchText(list(cd), null);
           RESULT = ozFactory_.createAxPara(ofp, stC, Box.SchBox);
        :}
        ;       

genericAxDefinition ::= 
        GENAX formalParameters:fp schemaText:st END
        {: RESULT = ozFactory_.createAxPara(fp, st, Box.AxBox); :}
        ;

optFormalParameters ::=
        formalParameters:fp
        {: RESULT = fp; :}
        |
        //empty
        {: RESULT = list(); :}
        ;

formalParameters ::= 
        LSQBRACE nameList:nl RSQBRACE
        {: RESULT = nl; :}
        ;

axiomaticDefinition ::= 
        AX schemaText:st END
        {: RESULT = ozFactory_.createAxPara(list(), st, Box.AxBox); :}
        ;

//according to the Z ISO standard, an abbreviation definition is to be
//treated as an axiomatic definition, with ConstDecl(dn,e)
abbreviationDefinition ::=
        declName:dn DEFS expression:e
        {:
           ConstDecl cd = ozFactory_.createConstDecl(dn, e);
           SchText st = ozFactory_.createSchText(list(cd), null);
           RESULT = ozFactory_.createAxPara(list(), st, Box.OmitBox);      
        :}
        |
        //TODO: check this. Should be name:n, but the toolkit won't parse
        //"\langle \_ \rangle [X] == .... without this
        declName:n formalParameters:fp DEFS expression:e
        {:
           ConstDecl cd = ozFactory_.createConstDecl(n, e);
           SchText st = ozFactory_.createSchText(list(cd), null);
           RESULT = ozFactory_.createAxPara(fp, st, Box.OmitBox);
        :}
        | 
        genName:gn DEFS expression:e
        {:
           ConstDecl cd = ozFactory_.createConstDecl(strListToDeclName(gn), e);
           SchText st = ozFactory_.createSchText(list(cd), null);
           RESULT = ozFactory_.createAxPara(list(), st, Box.OmitBox);
        :}
        ;


freeTypeList ::=
        freeTypeList:ftl AMPERSAND freeTypeDefinition:ftd
        {: 
           ftl.add(ftd);
           RESULT = ftl;
        :}
        |
        freeTypeDefinition:ftd
        {: RESULT = list(ftd); :}
        ;


freeTypeDefinition ::=
        name:n DDEF branchList:bl
        {: RESULT = ozFactory_.createFreetype(n, bl); :}
        ;


branchList ::=
        branchList:bl CBAR branch:b
        {:
           bl.add(b);
           RESULT = bl;
        :}
        |
        branch:b 
        {: RESULT = list(b); :}
        ;

branch ::=
        declName:dn
        {: RESULT = ozFactory_.createBranch(dn, null); :}
        |
        declName:dn LDATA expression:e RDATA
        {: RESULT = ozFactory_.createBranch(dn, e); :}
        ;

narrWordList ::=
        narrWordList:nwl NARRWORD:nw
        {:
           nwl.add(nw);
           RESULT = nwl;
        :}
        |
        NARRWORD:nw
        {: RESULT = list(nw); :}
        ;

// operator templates  /////////////////////////////////////////////////////

operatorTemplate ::=
        RELATION template:t
        {:
           OptempPara otp =
             ozFactory_.createOptempPara(t, Cat.Relation, null, null);
           RESULT = otp;
        :}
        |
        FUNCTION catTemplate:ct
        {:
           ct.setCat(Cat.Function);
           RESULT = ct;
        :}
        |
        GENERIC catTemplate:ct
        {:
           ct.setCat(Cat.Generic);
           RESULT = ct;
        :}
        ;

template ::=
        prefixTemplate:pt
        {: RESULT = pt; :}
        |
        postfixTemplate:pt
        {: RESULT = pt; :}
        |
        infixTemplate:it
        {: RESULT = it; :}
        |
        nofixTemplate:nt
        {: RESULT = nt; :}
        ;


catTemplate ::=
        NUMBER:pr prefixTemplate:pt
        {: 
           OptempPara otp = ozFactory_.createOptempPara();
           otp.setPrec(pr);
           otp.getWordOrOperand().addAll(pt);
           RESULT = otp;
        :}
        |
        NUMBER:pr postfixTemplate:pt
        {: 
           OptempPara otp = ozFactory_.createOptempPara();
           otp.setPrec(pr);
           otp.getWordOrOperand().addAll(pt);
           RESULT = otp;
        :}
        |
        NUMBER:pr assoc:a infixTemplate:it
        {:
           OptempPara otp = ozFactory_.createOptempPara();
           otp.setPrec(pr);
           otp.getWordOrOperand().addAll(it);
           otp.setAssoc(a);
           RESULT = otp;
        :}
        |
        nofixTemplate:nt
        {:
           OptempPara otp = ozFactory_.createOptempPara();
           otp.getWordOrOperand().addAll(nt);
           RESULT = otp;
        :}
        ;


assoc ::=
        LEFTASSOC
        {: RESULT = Assoc.Left; :}
        |
        RIGHTASSOC
        {: RESULT = Assoc.Right; :}
        ;


prefixTemplate ::=
        LPAREN name:n optWordOperandList:ol uscore:u RPAREN
        {: 
           List l = list(n);
           l.addAll(ol);
           l.add(u);
           fix_ = OperatorTable.PREFIX;
           RESULT = l; 
        :}
        ;


postfixTemplate ::=
        LPAREN uscore:u name:n optWordOperandList:ol RPAREN
        {: 
           List l = list(u);
           l.add(n);
           l.addAll(ol);
           fix_ = OperatorTable.POSTFIX;
           RESULT = l; 
        :}
        ;


infixTemplate ::=
        LPAREN uscore:u1 name:n optWordOperandList:ol uscore:u2 RPAREN
        {: 
           List l = list(u1);
           l.add(n);
           l.addAll(ol);
           l.add(u2);
           fix_ = OperatorTable.INFIX;
           RESULT = l; 
        :}
        ;


nofixTemplate ::=
        LPAREN name:n optWordOperandList:ol RPAREN
        {: 
           List l = list(n);
           l.addAll(ol);
           fix_ = OperatorTable.NOFIX;
           RESULT = l;
        :}
        ;


optWordOperandList ::=
        //empty
        {: RESULT = list(); :}
        |
        optWordOperandList:wl templateTag:t name:n 
        {:
           wl.add(t);
           wl.add(n);
           RESULT = wl;
        :}
        ;

templateTag ::=
        uscore:u
        {: RESULT = u; :}
        |
        LISTARG:ol
        {: RESULT = ozFactory_.createOperand(Boolean.TRUE); :}
        ;

uscore ::=
        USCORE:u
        {: RESULT = ozFactory_.createOperand(Boolean.FALSE); :}
        ;

/// classes ///////////////////////////////////////////////

class ::= 
        CLASS LBRACE name:n RBRACE
            classFormalParameters:fp
            visibilityList:vl
            inheritedList:il
            localDefinitionBlock:ldb
            state:s
            initialState:is
            operationList:ol
        END
        {: 
          RESULT = ozFactory_.createClassPara(n, fp, vl, il, ldb, s, is, ol);
        :}
        ;

classFormalParameters ::=
        optFormalParameters:fp
        {: RESULT = ozFactory_.createFormalParameters(fp); :}
        ;


operationList ::=
        //empty
        {: RESULT = list(); :}
        |
        operationList:ol optNL operation:o
        {: 
           ol.add(o); 
           RESULT = ol;
        :}
        ;


/// class paragraphs ///////////////////////////////////////////////

visibilityList ::=
        //empty
        {: RESULT = null; :}
        |
        visibility LPAREN refNameList:rnl RPAREN optNL
        {: RESULT = ozFactory_.createRefNameList(rnl); :}
        ;

visibility ::=
        VISIBILITY
        |
        ZPROJECT %prec VISIBILITY
        ;

inheritedList ::=
        //empty
        {: RESULT = list(); :}
        |
        INHERITS inheritedClassList:icl optNL
        {: RESULT = icl; :}
        ;

inheritedClassList ::=
        inheritedClassList:icl COMMA inheritedClass:ic
        {:
           icl.add(ic);
           RESULT = icl;
        :}
        |
        inheritedClass:ic
        {: RESULT = list(ic); :}
        ;

inheritedClass ::=
        refName:rn optActualParameters:oap optRenameExpression:ore
        {: RESULT = ozFactory_.createInheritedClass(rn, oap, ore); :}
        ;

optActualParameters ::=
        //empty
        {: RESULT = null; :}
        |
        LSQBRACE expressionList:el RSQBRACE
        {: RESULT = ozFactory_.createActualParameters(el); :}
        ;

optRenameExpression ::=
        //empty
        {: RESULT = null; :}
        |
        LSQBRACE renameList:rnl  RSQBRACE
        {: ozFactory_.createRenameExpr(null, rnl); :}
        ;

localDefinitionBlock ::=
        // empty
        {: RESULT = null; :}
        |
        LOCALDEF localDefinitionList:ldl END
        {:
           //get the list of definitions and put them in lists depending on
           //their type...
           List axParaList = new ArrayList();
           List freeTypeList = new ArrayList();
           List basicTypeList = new ArrayList();

           for (Iterator it = ldl.iterator(); it.hasNext(); ) {
               Object item = it.next();

               if (item instanceof AxPara) {
                   axParaList.add(item);
               }
               else if (item instanceof Freetype) {
                   freeTypeList.add(item);
               }
               else if (item instanceof GivenPara) {
                   basicTypeList.add(item);
               }
           }
           RESULT = ozFactory_.createLocalDef(basicTypeList, axParaList, freeTypeList);
        :}
        ;


localDefinitionList ::=
        localDefinition:ld sep localDefinitionList:ldl
        {:
           ldl.add(ld);
           RESULT = ldl;
        :}
        |
        localDefinition:ld
        {: RESULT = list(ld); :}
        ;


localDefinition ::=
        basicTypeDefinition:gtd
        {: RESULT = gtd; :}
        |
        freeTypeList:ftl
        {: RESULT = ozFactory_.createFreePara(ftl); :}
        |
        axiomaticDefinition:ad
        {: RESULT = ad; :}
        |
        abbreviationDefinition:ad
        {: RESULT = ad; :}
        ;


state ::=
        // empty
        {: RESULT = ozFactory_.createState(); :}
        |
        STATE declPart:dp secondaryDecl:sd WHERE predicate:p END
        {: RESULT = ozFactory_.createState(dp, sd, list(p)); :}
        |
        STATE declPart:dp secondaryDecl:sd END
        {: RESULT = ozFactory_.createState(dp, sd, list()); :}
        | 
        LSQBRACE declPart:dp secondaryDecl:sd CBAR predicate:p RSQBRACE
        {: RESULT = ozFactory_.createState(dp, sd, list(p)); :}
        |
        LSQBRACE declPart:dp secondaryDecl:sd RSQBRACE
        {: RESULT = ozFactory_.createState(dp, sd, list()); :}
        ;

secondaryDecl ::=
        //empty
        {: RESULT = null; :}
        |
        DELTA declPart:dp
        {: RESULT = ozFactory_.createSecondaryAttributes(dp); :}
        ;

initialState ::=
        // empty
        {: RESULT = ozFactory_.createInitialState(); :}
        |
        INIT predicate:p END
        {: RESULT = ozFactory_.createInitialState(list(p)); :}
        |
        INITWORD DEFS LSQBRACE predicate:p RSQBRACE
        {: RESULT = ozFactory_.createInitialState(list(p)); :}
        ;

operation ::=
        SCHEMA LBRACE name:n RBRACE operationBox:ob END
        {: RESULT = ozFactory_.createOperation(n, ob); :}
        |
        OPSCHEMA LBRACE name:n RBRACE operationBox:ob END
        {: RESULT = ozFactory_.createOperation(n, ob); :}
        |
        declName:dn DEFS operationExpression:oe
        {: RESULT = ozFactory_.createOperation(dn, oe); :}
        ;

operationBox ::=
        deltaList:dl sep:s declPart:dp WHERE predicate:p
        {: RESULT = ozFactory_.createOperationBox(dl, dp, list(p)); :}
        | 
        deltaList:dl sep:s declPart:dp
        {: RESULT = ozFactory_.createOperationBox(dl, dp, list()); :}
        |        
        deltaList:dl WHERE predicate:p  
        {: RESULT = ozFactory_.createOperationBox(dl, list(), list(p)); :}
        | 
        deltaList:dl
        {: RESULT = ozFactory_.createOperationBox(dl, list(), list()); :}
        | 
        declPart:dp WHERE predicate:p
        {: RESULT = ozFactory_.createOperationBox(null, dp, list(p)); :}
        | 
        declPart:dp
        {: RESULT = ozFactory_.createOperationBox(null, dp, list()); :}
        ;


operationExpression ::=
        DCNJ mainOpExpression:moe
        {: RESULT = ozFactory_.createDistConjOpExpr(moe); :}
        |
        DGCH mainOpExpression:moe
        {: RESULT = ozFactory_.createDistChoiceOpExpr(moe); :}
        |
        DSQC mainOpExpression:moe
        {: RESULT = ozFactory_.createDistSeqOpExpr(moe); :}
        |
        operationExpression1:oe1
        {: RESULT = oe1; :}
        ;

mainOpExpression ::=
        schemaText:st DOT operationExpression:oe
        {: RESULT = ozFactory_.createMainOpExpr(st, oe); :}
        ;

operationExpression1 ::=
        LSQBRACE deltaList:dl sep schemaText:st RSQBRACE
        {: RESULT = ozFactory_.createBasicOpExpr(dl, st); :}
        |
        //TODO: what about [x, y : X]?
        LSQBRACE deltaList:dl CBAR schemaText:st RSQBRACE
        {: RESULT = ozFactory_.createBasicOpExpr(dl, st); :}
        |
        expression:e opPromotionPeriod refName:rn
        {:
           RESULT = ozFactory_.createOpPromotionExpr(e, rn);
        :} %prec _OP_PROMOTION_PERIOD
        |
        /** FIX THIS - reduce/reduce with refName in expression */
        /*
        refName:rn
        {: RESULT = ozFactory_.createOpPromotionExpr(null, rn); :}
        |*/
        operationExpression1:oe1 LSQBRACE renameList:rnl RSQBRACE
        {: RESULT = ozFactory_.createRenameOpExpr(oe1, rnl); :}
        |
        operationExpression1:oe1 ZHIDE LPAREN declNameList:onl RPAREN
        {: RESULT = ozFactory_.createHideOpExpr(oe1, onl);:}
        |
        operationExpression1:lhs LAND operationExpression1:rhs
        {: RESULT = ozFactory_.createConjOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs PARALLEL operationExpression1:rhs
        {: RESULT = ozFactory_.createParallelOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs ASSOCPARALLEL operationExpression1:rhs
        {: RESULT = ozFactory_.createAssoParallelOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs GCH operationExpression1:rhs
        {: RESULT = ozFactory_.createExChoiceOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs ZCMP operationExpression1:rhs
        {: RESULT = ozFactory_.createSeqOpExpr(lhs, rhs); :}
        |
        operationExpression1:lhs DOT operationExpression1:rhs
        {: RESULT = ozFactory_.createScopeEnrichOpExpr(lhs, rhs); :}
        |
        LPAREN operationExpression:oe RPAREN
        /** FIX THIS - What the hell is a ParenOpExpr? */
        {: RESULT = oe; :}
        ;

deltaList ::=
        //empty
        {: RESULT = null; :}
        |
        DELTA LPAREN refNameList:rnl RPAREN
        {:  RESULT = ozFactory_.createRefNameList(rnl); :}
        ;

opPromotionPeriod ::=
        PERIOD %prec _OP_PROMOTION_PERIOD
        ;

/// schema text ///////////////////////////////////////////

schemaText ::= 
        optDeclPart:odp CBAR predicate:p
        {: RESULT = ozFactory_.createSchText(odp, p); :}
        |
        optDeclPart:odp WHERE predicate:p
        {: RESULT = ozFactory_.createSchText(odp, p); :}
        |
        optDeclPart:odp
        {: RESULT = ozFactory_.createSchText(odp, null); :}
        ;

optDeclPart ::=
        //empty
        {: RESULT = list(); :}
        |
        declPart:dp
        {: RESULT = dp; :}
        ;

declPart ::=
        declaration:d
        {: RESULT = list(d); :}
        |
        declPart:dp sep:s declaration:d
        {:
           dp.add(d);
           RESULT = dp;
        :}
        ;

declaration ::=
        basicDeclaration:bd
        {: RESULT = bd; :}
        |
        expression:e
        {: RESULT = ozFactory_.createInclDecl(e); :}
        ;

basicSchemaText ::=
        basicDeclPart:bdp CBAR predicate1:p1
        {: RESULT = ozFactory_.createSchText(bdp, p1); :}
        |
        basicDeclPart:bdp
        {: RESULT = ozFactory_.createSchText(bdp, null); :}
        |
        CBAR predicate1:p1
        {: RESULT = ozFactory_.createSchText(list(), p1); :}
        ;

basicDeclPart ::=
        basicDeclaration:bd
        {: RESULT = list(bd); :}
        |
        basicDeclPart:bdp sep:s basicDeclaration:bd
        {:
           bdp.add(bd);
           RESULT = bdp;
        :}
        ;

basicDeclaration ::=
        declWordList:dwl COLON expression:e
        {: RESULT = ozFactory_.createVarDecl(dwl, e); :}
        |
        declName:dn DEFS expression:e
        {: RESULT = ozFactory_.createConstDecl(dn, e); :}
        ;       

expressionDeclPart ::=
        expressionDeclPart:edl sep:s expression:e
        {:
           edl.add(e);
           RESULT = edl;
        :}
        ;

sep ::=
        SEMI
        {: RESULT = Op.Semi; :}
        |
        NL
        {: RESULT = Op.NL; :}
        ;

optNL ::=
        //empty
        |
        NL
        ;

/// word, declName, and refName lists ////////////////////////////////////

nameList ::=
        nameList:nl COMMA NAME:n
        {: 
           DeclName dn = ozFactory_.createDeclName(n, list(), null);
           nl.add(dn);
           RESULT = nl;
        :}
        |
        NAME:n
        {: 
           DeclName dn = ozFactory_.createDeclName(n, list(), null);
           RESULT = list(dn);
        :}
        ;

name ::=
        NAME:n
        {: RESULT = ozFactory_.createDeclName(n, list(), null); :}
        ;

declWordList ::=
        declWordList:dwl COMMA DECLWORD:dw
        {: 
           DeclName dn = ozFactory_.createDeclName(dw, list(), null);
           dwl.add(dn); 
           RESULT = dwl;
        :}
        |
        declWordList:dwl COMMA opName:on
        {: 
           dwl.add(strListToDeclName(on)); 
           RESULT = dwl;
        :}
        |
        opName:on
        {: RESULT = list(strListToDeclName(on)); :}
        |
        DECLWORD:dw
        {: /** FIX THIS: what is the 'String id' param in createDeclName?*/
           DeclName dn = ozFactory_.createDeclName(dw, list(), null);
           RESULT = list(dn); 
        :}
        ;


declNameList ::=
        declNameList:dnl COMMA declName:dn
        {:
           dnl.add(dn);
           RESULT = dnl;
        :}
        |
        declName:dn
        {: RESULT = list(dn); :}
        ;

declName ::=
        /** FIX THIS: what is the 'String id' param in createDeclName?*/
        NAME:n
        {: RESULT = ozFactory_.createDeclName(n, list(), null); :}
        |
        opName:on
        {:
           //because we return opNames as RefName instances, we must convert
           //to a DeclName
           RESULT = strListToDeclName(on);
        :}
        ;

refNameList ::=
        refNameList:rnl COMMA NAME:n
        {:
           RefName rn = ozFactory_.createRefName(n, list(), null);
           rnl.add(n);
        :}
        |
        NAME:n
        {:
           RefName rn = ozFactory_.createRefName(n, list(), null); 
           RESULT = list(rn);
        :}
        ;

refName ::=
        NAME:n
        {: RESULT = ozFactory_.createRefName(n, list(), null); :}
        |
        LPAREN opName:on RPAREN
        {: 
           RESULT = ozFactory_.createRefName(strListToDeclName(on).getWord(),
                                          strListToDeclName(on).getStroke(),
                                          null); 
        :}
        ;


opName ::=
        prefixName:pn
        {: RESULT = pn; :}
        |
        postfixName:pn
        {: RESULT = pn; :}
        |
        infixName:in
        {: RESULT = in; :}
        |
        nofixName:nn
        {: RESULT = nn; :}
        ;

prefixName ::=
        PRE:p uscore
        {: RESULT = list(p, USCORE_TOK); :}
        |
        PREP:p uscore
        {: RESULT = list(p, USCORE_TOK); :}
        |
        L:l optUscoreEsSsList:ouesl uscore ereOrSre:eos uscore
        {: 
           List pName = list(l);
           pName.addAll(ouesl);
           pName.add(USCORE_TOK);
           pName.add(eos);
           pName.add(USCORE_TOK);
           RESULT = pName;
        :}
        |
        LP:lp optUscoreEsSsList:ouesl uscore erepOrSrep:eos uscore
        {: 
           List pName = list(lp);
           pName.addAll(ouesl);
           pName.add(USCORE_TOK);
           pName.add(eos);
           pName.add(USCORE_TOK);
           RESULT = pName;
        :}
        ;

postfixName ::=
        uscore POST:p
        {: RESULT = list(USCORE_TOK, p); :}
        |
        uscore POSTP:p
        {: RESULT = list(USCORE_TOK, p); :}
        |
        uscore EL:el optUscoreEsSsList:ouesl uscore erOrSr:eos
        {:
           List pName = list(USCORE_TOK);
           pName.add(el);
           pName.addAll(ouesl);
           pName.add(USCORE_TOK);
           pName.add(eos);
           RESULT = pName;
        :}
        |
        uscore ELP:elp optUscoreEsSsList:ouesl uscore erpOrSrp:eos
        {:
           List pName = list(USCORE_TOK);
           pName.add(elp);
           pName.addAll(ouesl);
           pName.add(USCORE_TOK);
           pName.add(eos);
           RESULT = pName;
        :}
        ;


infixName ::=
        uscore I:i uscore
        {:
           List iName = list(USCORE_TOK);
           iName.add(i);
           iName.add(USCORE_TOK);
           RESULT = iName;
        :}
        |
        uscore IP:ip uscore
        {:
           List iName = list(USCORE_TOK);
           iName.add(ip);
           iName.add(USCORE_TOK);
           RESULT = iName;
        :}
        |
        uscore EL:el optUscoreEsSsList:ouesl uscore ereOrSre:eos uscore
        {:
           List iName = list(USCORE_TOK);
           iName.add(el);
           iName.addAll(ouesl);
           iName.add(USCORE_TOK);
           iName.add(eos);
           iName.add(USCORE_TOK);
           RESULT = iName;
        :}
        |
        uscore ELP:elp optUscoreEsSsList:ouesl uscore erepOrSrep:eos uscore
        {:
           List iName = list(USCORE_TOK);
           iName.add(elp);
           iName.addAll(ouesl);
           iName.add(USCORE_TOK);
           iName.add(eos);
           iName.add(USCORE_TOK);
           RESULT = iName;
        :}
        ;

nofixName ::=
        L:l optUscoreEsSsList:ouesl uscore erOrSr:eos
        {:
           List nName = list(l);
           nName.addAll(ouesl);
           nName.add(USCORE_TOK);
           nName.add(eos);
           RESULT = nName;
        :}
        |
        LP:lp optUscoreEsSsList:ouesl uscore erpOrSrp:eos
        {:
           List nName = list(lp);
           nName.addAll(ouesl);
           nName.add(USCORE_TOK);
           nName.add(eos);
           RESULT = nName;
        :}
        ;

optUscoreEsSsList ::=
        //empty
        {: RESULT = list(); :}
        |
        optUscoreEsSsList:ouesl uscore esOrSs:eos
        {: 
           ouesl.add(USCORE_TOK);
           ouesl.add(eos);
           RESULT = ouesl;
        :}
        ;

esOrSs ::=
        ES:es
        {: RESULT = es; :}
        |
        SS:ss
        {: RESULT = ss; :}
        ;

ereOrSre ::=
        ERE:ere
        {: RESULT = ere; :}
        |
        SRE:sre
        {: RESULT = sre; :}
        ;

erepOrSrep ::=
        EREP:erep
        {: RESULT = erep; :}
        |
        SREP:srep
        {: RESULT = srep; :}
        ;

erOrSr ::=
        ER:er
        {: RESULT = er; :}
        |
        SR:sr
        {: RESULT = sr; :}
        ;

erpOrSrp ::=
        ERP:erp
        {: RESULT = erp; :}
        |
        SRP:srp
        {: RESULT = srp; :}
        ;

genName ::=
        prefixGenName:pgn
        {: RESULT = pgn; :}
        |
        postfixGenName:pgn
        {: RESULT = pgn; :}
        |
        infixGenName:ign
        {: RESULT = ign; :}
        |
        nofixGenName:ngn
        {: RESULT = ngn; :}
        ;

prefixGenName ::=
        PRE:pre NAME:n
        {: RESULT = list(pre, n); :}
        |
        L:l optNameEsSsList:onesl NAME:n1 ereOrSre:eos NAME:n2
        {:
           List pgName = list(l);
           pgName.addAll(onesl);
           pgName.add(n1);
           pgName.add(eos);
           pgName.add(n2);
           RESULT = pgName; 
        :}
        ;

postfixGenName ::=
        NAME:n POST:p
        {: RESULT = list(n, p); :}
        |
        NAME:n1 EL:el optNameEsSsList:onesl NAME:n2 erOrSr:eos
        {:
           List pgName = list(n1);
           pgName.add(el);
           pgName.addAll(onesl);
           pgName.add(n2);
           pgName.add(eos);
           RESULT = pgName;
         :}
        ;

infixGenName ::=
        NAME:n1 I:i NAME:n2
        {:
           List igName = list(n1);
           igName.add(i);
           igName.add(n2);
           RESULT = igName;
        :}
        |
        NAME:n1 EL:el optNameEsSsList:onesl NAME:n2 ereOrSre:eos NAME:n3
        {: 
           List igName = list(n1);
           igName.add(el);
           igName.addAll(onesl);
           igName.add(n2);
           igName.add(eos);
           igName.add(n3);
           RESULT = igName;
        :}
        ;

nofixGenName ::=
        L:l optNameEsSsList:onesl NAME:n erOrSr:eos
        {:
           List ngName = list(l);
           ngName.addAll(onesl);
           ngName.add(n);
           ngName.add(eos);
           RESULT = ngName;
        :}
        ;

optNameEsSsList ::=
        //empty
        {: 
System.err.println("\n\n\nEMPTY LIST\n\n\n");
RESULT = list(); :}
        |
        optNameEsSsList:ouesl NAME:n esOrSs:eos
        {: 
           ouesl.add(n);
           ouesl.add(eos);
           RESULT = ouesl;
        :}
        ;


/// predicates ///////////////////////////////////////////////////////////////

predicate ::=
        predicate:lhs sep:s predicate1:rhs
        {: RESULT = ozFactory_.createAndPred(lhs, rhs, s); :}
        |
        predicate1:p1
        {: RESULT = p1; :}
        ;

predicate1 ::=
        FORALL schemaText:st predDot predicate1:p
        {: 
           //TODO: fix this? I can't figure out  precedence
           //of quantifiers using cup
           if (p instanceof ExprPred) {
             Expr e = ((ExprPred)p).getExpr();
             ForallExpr ee = ozFactory_.createForallExpr(st, e);
             RESULT = ozFactory_.createExprPred(ee);
           }
           else {
             RESULT = ozFactory_.createForallPred(st, p); 
           }
        :}
        |
        EXISTS schemaText:st predDot predicate1:p
        {:
           if (p instanceof ExprPred) {
             Expr e = ((ExprPred)p).getExpr();
             ExistsExpr ee = ozFactory_.createExistsExpr(st, e);
             RESULT = ozFactory_.createExprPred(ee);
           }
           else {
             RESULT = ozFactory_.createExistsPred(st, p); 
           }
        :}
        |
        EXISTS1 schemaText:st predDot predicate1:p
        {: 
           if (p instanceof ExprPred) {
             Expr e = ((ExprPred)p).getExpr();
             Exists1Expr ee = ozFactory_.createExists1Expr(st, e);
             RESULT = ozFactory_.createExprPred(ee);
           }
           else {
             RESULT = ozFactory_.createExists1Pred(st, p);
           }
        :}
        |
        predicate1:lhs LAND predicate1:rhs
        {: RESULT = ozFactory_.createAndPred(lhs, rhs, Op.And); :}
        |
        predicate1:lhs LOR predicate1:rhs
        {: RESULT = ozFactory_.createOrPred(lhs, rhs); :}
        |
        predicate1:lhs IMP predicate1:rhs
        {: RESULT = ozFactory_.createImpliesPred(lhs, rhs); :}
        |
        predicate1:lhs IFF predicate1:rhs
        {: RESULT = ozFactory_.createIffPred(lhs, rhs); :}
        |
        LNOT predicate1:p
        {: RESULT = ozFactory_.createNegPred(p); :}
        |
        relation:rel
        {: RESULT = rel; :} %prec MEM
        |
        expression:e1
        {: RESULT = ozFactory_.createExprPred(e1); :}
        |
        TRUE
        {: RESULT = ozFactory_.createTruePred(); :}
        |
        FALSE
        {: RESULT = ozFactory_.createFalsePred(); :}    
        |
        LPAREN predicate1:p RPAREN
        {: RESULT = p; :} 
        ;

predDot ::=
        DOT
        ;

/// expressions ///////////////////////////////////////////////////////////////

expression ::=
        FORALL schemaText:st DOT expression:e
        {: RESULT = ozFactory_.createForallExpr(st, e); :}
        |
        EXISTS schemaText:st DOT expression:e 
        {: RESULT = ozFactory_.createExistsExpr(st, e); :} 
        |
        EXISTS1 schemaText:st DOT expression:e 
        {: RESULT = ozFactory_.createExists1Expr(st, e); :}
        |
        /* TODO: why does this have preference!!
        znot expression:e
        {: RESULT = ozFactory_.createNegExpr(e); :} %prec _ZNOT
        |
        */
        expression:lhs IFF expression:rhs
        {: RESULT = ozFactory_.createIffExpr(lhs, rhs); :}
        |
        expression:lhs IMP expression:rhs
        {: RESULT = ozFactory_.createImpliesExpr(lhs, rhs); :}
        |
        expression:lhs LOR expression:rhs
        {: RESULT = ozFactory_.createOrExpr(lhs, rhs); :}
        |
        expression:lhs LAND expression:rhs
        {: RESULT = ozFactory_.createAndExpr(lhs, rhs); :}
        |
        LPAREN expression:e RPAREN 
        {: RESULT = e; :} %prec FORALL
        |
        LAMBDA schemaText:st DOT expression:e
        {: RESULT = ozFactory_.createLambdaExpr(st, e); :} %prec LAMBDA
        |
        MU schemaText:st DOT expression:e
        {: RESULT = ozFactory_.createMuExpr(st, e); :}
        |
        LET letDefinitionList:ldl DOT expression:e 
        {: 
           SchText st = ozFactory_.createSchText(ldl, null);
           RESULT = ozFactory_.createLetExpr(st, e);
        :} %prec LET
        |
        IF predicate1:p1 THEN expression:te ELSE expression:fe
        {: RESULT = ozFactory_.createCondExpr(p1, te, fe); :}
        |
        expression:lhs ZCMP expression:rhs
        {: RESULT = ozFactory_.createCompExpr(lhs, rhs); :}
        |
        expression:lhs ZPIPE expression:rhs
        {: RESULT = ozFactory_.createPipeExpr(lhs, rhs); :}
        |
        expression:e ZHIDE LPAREN declNameList:dnl RPAREN
        {: RESULT = ozFactory_.createHideExpr(e, dnl); :}
        |
        expression:lhs ZPROJECT expression:rhs
        {: RESULT = ozFactory_.createProjExpr(lhs, rhs); :}
        |
        PRECONDITION expression:e
        {: RESULT = ozFactory_.createPreExpr(e); :}
        |
        prodExpressionList:pel
        {: RESULT = ozFactory_.createProdExpr(pel); :}
        |
        application:a
        {: RESULT = a; :}
        |
        //plus the special case of power set (a prefix generic function)
        POWER expression:e
        {: RESULT = ozFactory_.createPowerExpr(e); :}
        |
        expression:e1 expression:e2 
        {: RESULT = ozFactory_.createApplExpr(e1, e2, Boolean.FALSE); :} 
        %prec _APPLICATION
        |
        expression:e stroke:s
        {: RESULT = ozFactory_.createDecorExpr(e, s); :}
        |
        expression:e LSQBRACE renameList:rnl RSQBRACE
        {: RESULT = ozFactory_.createRenameExpr(e, rnl); :}
        |
        expression:e PERIOD refName:rn
        {: RESULT = ozFactory_.createBindSelExpr(e, rn); :}
        |
        expression:e PERIOD NUMBER:n
        {: RESULT = ozFactory_.createTupleSelExpr(e, n); :}
        |
        THETA expression:e optStrokeList:sl
        {: RESULT = ozFactory_.createThetaExpr(e, sl); :}
        |
        refName:rn
        {: RESULT = ozFactory_.createRefExpr(rn, list(), Boolean.TRUE); :}
        |
        refName:rn LSQBRACE expressionList:el RSQBRACE
        {: RESULT = ozFactory_.createRefExpr(rn, el, Boolean.TRUE); :}
        |
        NUMBER:n
        {: RESULT = ozFactory_.createNumExpr(new BigInteger(n.toString())); :}
        |
        LSET optExpressionList:oel RSET
        {: RESULT = ozFactory_.createSetExpr(oel); :}
        |
        LSET basicSchemaText:bst DOT expression:e RSET
        {: RESULT = ozFactory_.createSetCompExpr(bst, e); :}
        |
        LSET expressionDeclPart:edp DOT expression:e RSET
        {: 
           SchText st = ozFactory_.createSchText(edp, null);
           RESULT = ozFactory_.createSetCompExpr(st, e);
        :}
        |
        LSET basicSchemaText:bst RSET
        {: RESULT = ozFactory_.createSetCompExpr(bst, null); :}
        |
        LSQBRACE basicSchemaText:bst RSQBRACE
        {: RESULT = ozFactory_.createSchExpr(bst); :}
        |
        LBLOT optNameExprPairList:onepl RBLOT
        {: RESULT = ozFactory_.createBindExpr(onepl); :}
        |
        LPAREN expressionList:el COMMA expression:e RPAREN
        {: 
           el.add(e);
           RESULT = ozFactory_.createTupleExpr(el);
        :}
        |
        LPAREN MU schemaText:st RPAREN
        {: RESULT = ozFactory_.createMuExpr(st, null); :}
        ;


prodExpressionList ::=
        expression:e1 CROSS expression:e2
        {: RESULT = list(e1,e2); :}
        |
        prodExpressionList:pel CROSS expression:e
        {:
           pel.add(e);
           RESULT = pel;
        :}
        ;

optExpressionList ::=
        //empty
        {: RESULT = list(); :}
        |
        expressionList:el
        {: RESULT = el; :}
        ;

expressionList ::=
        expressionList:el COMMA expression:e
        {:      
           el.add(e);
           RESULT = el;
        :} 
        |
        expression:e
        {: RESULT = list(e); :}
        ;


optNameExprPairList ::=
        //empty
        {: RESULT = list(); :}
        |
        nameExprPairList:nepl
        {: RESULT = nepl; :}
        ;

nameExprPairList ::=
        nameExprPairList:nepl COMMA nameExprPair:nep
        {:      
           nepl.add(nep);
           RESULT = nepl;
        :} 
        |
        nameExprPair:nep
        {: RESULT = list(nep); :}
        ;       

nameExprPair ::=
        declName:dn DEFS expression:e
        {: RESULT = ozFactory_.createNameExprPair(dn, e); :}
        ;

znot ::=
        LNOT %prec NL
        ;

letDefinitionList ::=
        letDefinitionList:ldl SEMI letDefinition:ld
        {:
           ldl.add(ld);
           RESULT = ldl;
        :}
        |
        letDefinition:ld
        {: RESULT = list(ld); :}
        ;       

letDefinition ::=
        declName:n DEFS expression:e
        {: RESULT = ozFactory_.createConstDecl(n,e); :}
        ;

optStrokeList ::=
        optStrokeList:sl stroke:s
        {:
           sl.add(s);
           RESULT = sl;
        :}
        |
        //empty
        {: RESULT = list(); :} %prec INSTROKE
        ;

stroke ::=
        INSTROKE
        {: RESULT = ozFactory_.createInStroke(); :}
        |
        OUTSTROKE
        {: RESULT = ozFactory_.createOutStroke(); :}
        |
        NEXTSTROKE
        {: RESULT = ozFactory_.createNextStroke(); :}
        |
        NUMSTROKE:n
        {: RESULT = ozFactory_.createNumStroke(extractNum(n)); :}
        ;

renameList ::= 
        renameList:rl COMMA rename:rn
        {:
           rl.add(rn);
           RESULT = rl;
        :}
        |
        rename:rn  
        {: RESULT = list(rn); :}
        ;    

rename ::=
        refName:lhs FSLASH declName:rhs
        {: RESULT = ozFactory_.createNameNamePair(lhs, rhs); :}
        ;


relation ::=
        prefixRel:pr
        {: RESULT = pr; :}
        |
        postfixRel:pr
        {: RESULT = pr; :}
        |
        infixRel:ir
        {: RESULT = ir; :}
        |
        nofixRel:nr
        {: RESULT = nr; :}
        ;

//according to the ISO standard, op e1 is equivalent to
//e mem op
prefixRel ::=
        PREP:p expression:e
        {: RESULT = localCreateMemPred(list(p), list(e)); :}
        |
        LP:lp expSep:es expression:e1 EREP:erep expression:e2
        {: 
           List opName = list(lp);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(erep);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(e1);
           expList.add(e2);
           RESULT = localCreateMemPred(opName, expList);
        :}
        |
        LP:lp expSep:es optExpressionList:oel SREP:srep expression:e
        {:
           List opName = list(lp);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(srep);

           List expList = list();
           addExpSepExp(expList, es);
           expList.addAll(oel);
           expList.add(e);
           RESULT = localCreateMemPred(opName, expList);
        :}
        ;

postfixRel ::=
        expression:e POSTP:p
        {: RESULT = localCreateMemPred(list(p), list(e)); :}
        |
        expression:e1 ELP:elp expSep:es expression:e2 ERP:erp
        {:
           List opName = list(USCORE_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(erp);

           List expList = list(e1);
           addExpSepExp(expList, es);
           expList.add(e2);
           RESULT = localCreateMemPred(opName, expList);
        :}
        |
        expression:e ELP:elp expSep:es optExpressionList:oel SRP:srp
        {:
           List opName = list(USCORE_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(srp);

           List expList = list(e);
           addExpSepExp(expList, es);
           expList.addAll(oel);
           RESULT = localCreateMemPred(opName, expList);
        :}
        ;

infixRel ::=
        infixChainRel:icr
        {: RESULT = icr; :}
        |
        expression:e1 ELP:elp expSep:es expression:e2 EREP:erep expression:e3
        {:
           List opName = list(USCORE_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(erep);
           opName.add(USCORE_TOK);

           List expList = list(e1);
           addExpSepExp(expList, es);
           expList.add(e2);
           expList.add(e3);
           RESULT = localCreateMemPred(opName, expList);
        :}
        |
        expression:e1 ELP:elp expSep:es optExpressionList:oel SREP:erep expression:e2
        {:
           List opName = list(USCORE_TOK);
           opName.add(elp);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(erep);
           opName.add(USCORE_TOK);

           List expList = list(e1);
           addExpSepExp(expList, es);
           expList.addAll(oel);
           expList.add(e2);
           RESULT = localCreateMemPred(opName, expList);
        :}
        ;

infixChainRel ::=
        expression:lhs MEM expression:rhs
        {: RESULT = ozFactory_.createMemPred(lhs, rhs, Boolean.TRUE); :}
        |
        expression:lhs EQUALS expression:rhs
        {:
           SetExpr se = ozFactory_.createSetExpr(list(rhs));
           RESULT = ozFactory_.createMemPred(lhs, se, Boolean.TRUE);
        :}
        |
        expression:lhs IP:ip expression:rhs
        {:
           List opName = list(USCORE_TOK);
           opName.add(ip);
           opName.add(USCORE_TOK);
           RESULT = localCreateMemPred(opName, list(lhs, rhs));
        :}
        |
        expression:lhs MEM infixChainRel:icr
        {:
           if (icr instanceof MemPred) {
               Expr expr = ((MemPred)icr).getLeftExpr();
               MemPred mp = 
                   ozFactory_.createMemPred(lhs, expr, Boolean.TRUE);
               RESULT = ozFactory_.createAndPred(mp, icr, Op.Chain);
           }
           else {
               MemPred mpIcr = (MemPred)((AndPred)icr).getLeftPred();
               Expr expr = mpIcr.getLeftExpr();
               MemPred mp =
                   ozFactory_.createMemPred(lhs, expr, Boolean.TRUE);
               RESULT = ozFactory_.createAndPred(mp, icr, Op.Chain);
           }
        :}
        |
        expression:lhs EQUALS infixChainRel:icr
        {:
           if (icr instanceof MemPred) {
               Expr expr = ((MemPred)icr).getLeftExpr();
               SetExpr se = ozFactory_.createSetExpr(list(expr));
               MemPred mp = 
                   ozFactory_.createMemPred(lhs, se, Boolean.TRUE);
               RESULT = ozFactory_.createAndPred(mp, icr, Op.Chain);
           }
           else {
               MemPred mpIcr = (MemPred)((AndPred)icr).getLeftPred();
               Expr expr = mpIcr.getLeftExpr();
               MemPred mp =
                   ozFactory_.createMemPred(lhs, expr, Boolean.TRUE);
               RESULT = ozFactory_.createAndPred(mp, icr, Op.Chain);
           }
        :}
        |
        expression:lhs IP:ip infixChainRel:icr  
        {:
           List opName = list(USCORE_TOK);
           opName.add(ip);
           opName.add(USCORE_TOK);

           if (icr instanceof MemPred) {
               Expr expr = ((MemPred)icr).getLeftExpr();
               MemPred mp = localCreateMemPred(opName, list(lhs, expr));
               RESULT = ozFactory_.createAndPred(mp, icr, Op.Chain);
           }
           else {
               MemPred mpIcr = (MemPred)((AndPred)icr).getLeftPred();
               Expr expr = mpIcr.getLeftExpr();
               MemPred mp = localCreateMemPred(opName, list(lhs, expr));
               RESULT = ozFactory_.createAndPred(mp, icr, Op.Chain);
           }
        :}
        ;

nofixRel ::=
        LP:lp expSep:es expression:e ERP:erp
        {:
           List opName = list(USCORE_TOK);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(erp);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(e);
           RESULT = localCreateMemPred(opName, expList);
        :}
        |
        LP:lp expSep:es optExpressionList:oel SRP:srp
        {:
           List opName = list(USCORE_TOK);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(srp);

           List expList = list();
           addExpSepExp(expList, es);
           expList.addAll(oel);
           RESULT = localCreateMemPred(opName, expList);
        :}
        ;


application ::=
        prefixApp:pa
        {: RESULT = pa; :}
        |
        postfixApp:pa
        {: RESULT = pa; :}
        |
        infixApp:ia
        {: RESULT = ia; :}
        |
        nofixApp:na
        {: RESULT = na; :}
        ;

prefixApp ::=
        PRE:pre expression:e
        {: RESULT = localCreateApplExpr(list(pre), list(e)); :}
        |
        L:l expSep:es expression:e1 ERE:ere expression:e2
        {:
           List opName = list(l);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(ere);
           opName.add(USCORE_TOK);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(e1);
           expList.add(e2);
           RESULT = localCreateApplExpr(opName, expList);
        :}
        |
        L:l expSep:es optExpressionList:oel SRE:sre expression:e
        {:
           List opName = list(l);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(sre);
           opName.add(USCORE_TOK);

           List expList = list();
           addExpSepExp(expList, es);
           expList.addAll(oel);
           expList.add(e);      
           RESULT = localCreateApplExpr(opName, expList);
        :}
        ;

postfixApp ::=
        expression:e POST:post
        {: RESULT = localCreateApplExpr(list(post), list(e)); :}
        |
        expression:e1 EL:el expSep:es expression:e2 ER:er
        {:
           List opName = list(USCORE_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(er);

           List expList = list(e1);
           addExpSepExp(expList, es);
           expList.add(e2);
           RESULT = localCreateApplExpr(opName, expList);
        :}
        |
        expression:e EL:el expSep:es optExpressionList:oel SR:sr
        {:
           List opName = list(USCORE_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(sr);

           List expList = list(e);
           addExpSepExp(expList, es);
           expList.addAll(oel);
           RESULT = localCreateApplExpr(opName, expList);
        :}
        ;

infixApp ::=
        expression:lhs I:i expression:rhs
        {: 
           List opName = list(USCORE_TOK);
           opName.add(i);
           opName.add(USCORE_TOK);
           RESULT = localCreateApplExpr(opName, list(lhs, rhs));
        :}
        |
        expression:e1 EL:el expSep:es expression:e2 ERE:ere expression:e3
        {:
           List opName = list(USCORE_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(ere);
           opName.add(USCORE_TOK);

           List expList = list(e1);
           addExpSepExp(expList, es);
           expList.add(e2);
           expList.add(e3);
           RESULT = localCreateApplExpr(opName, expList);
        :}
        |
        expression:e1 EL:el expSep:es optExpressionList:oel SRE:sre expression:e2
        {:
           List opName = list(USCORE_TOK);
           opName.add(el);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(sre);
           opName.add(USCORE_TOK);

           List expList = list(e1);
           addExpSepExp(expList, es);
           expList.addAll(oel);
           expList.add(e2);
           RESULT = localCreateApplExpr(opName, expList);
        :}
        ;

nofixApp ::=
        L:l expSep:es expression:e ER:er
        {:
           List opName = list(l);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(er);

           List expList = list();
           addExpSepExp(expList, es);
           expList.add(e);
           RESULT = localCreateApplExpr(opName, expList);
        :}
        |
        L:l expSep:es optExpressionList:oel SR:sr
        {:
           List opName = list(l);
           addExpSepName(opName, es);
           opName.add(USCORE_TOK);
           opName.add(sr);

           List expList = list();
           addExpSepExp(expList, es);
           expList.addAll(oel);
           RESULT = localCreateApplExpr(opName, expList);
        :}
        ;

expSep ::=
        //empty
        {: RESULT = list(); :} %prec I
        |
        expression:e ES:es
        {: RESULT = list(list(e), es); :}
        |
        expressionList:el SS:ss
        {: RESULT = list(el, ss); :}
        ;
