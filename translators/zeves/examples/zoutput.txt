<!--
 *** Specification Information ***

 null
2.0
null
null
-->
<cmd name="begin-section"> AxParaTest {toolkit} </cmd>
<zerror><errormessage>Error <name ident="InvalidChar" class="other"/> (line 1) [Scanner]: invalid character: .
                              </errormessage><errormessage>Error <name ident="InvalidChar" class="other"/> (line 1) [Scanner]: invalid character: .
                                                                   </errormessage><errormessage>Error <name ident="InvalidChar" class="other"/> (line 1) [Scanner]: invalid character: .
                        </errormessage><errormessage>Error <name ident="InvalidChar" class="other"/> (line 1) [Scanner]: invalid character: .
                                                             </errormessage><errormessage>Error <name ident="InvalidChar" class="other"/> (line 1) [Scanner]: invalid character: .
                  </errormessage><errormessage>Error <name ident="NextToken" class="other"/> (line 1) [Parser 1]: the next token, "{", is not allowed here.
                                                                           </errormessage><errormessage>Error <name ident="NextToken" class="other"/> (line 1) [Parser 1]: the next token, "}", is not allowed here.
                                                    </errormessage></zerror>



<!--
 *** Specification Information ***

 null
2.0
null
null
-->

<cmd name="begin-section"> AxParaTest toolkit </cmd>
<zerror><errormessage>Error <name ident="UnimplementedApiCommand" class="other"/> [API]: Unimplemented API command: begin-section.
                                                  </errormessage></zerror>

<!--
 *** LaTeX Markup Directives Paragraph ***

 []
-->
<!--
 *** Narrative Paragraph ***

 [

]
-->


<cmd name="add-paragraph">
<schema-box  >S

<decl-part/>x, y: &Nopf;
<ax-part/>x &gt; y
x &isin; &Zopf;
</schema-box>
</cmd>
<zoutput></zoutput>
                   <cmd name="add-paragraph">
<zed-box  >[GP]</zed-box>
</cmd>
<zoutput></zoutput>
                   <cmd name="add-paragraph">
<axiomatic-box  >
<decl-part/>a, b: &Popf; (&Nopf;&cross; GP)
<ax-part/>&not; a  =  {  }
a  =  b
</axiomatic-box>
</cmd>
<zoutput></zoutput>

<cmd name="proof-command">rewrite</cmd>
<zerror><errormessage>No goal formula.
                                      </errormessage></zerror>


<cmd name="add-paragraph"><theorem-def>test
<ax-part/> &forall; s: &Nopf @ s &isin; a</theorem-def></cmd>
<zerror><errormessage>Error <name ident="XmlUnterminatedEntityName" class="other"/> (line 2) [Scanner]: Unterminated entity name: &Nopf.
                                                        </errormessage><errormessage>Error <name ident="XmlNotSymbolStart" class="other"/> (line 2) [Scanner]: The character or entity @ is not the start of a defined symbol.
                                                              </errormessage><errormessage>Error <name ident="NotStartToken" class="other"/> (line 2) [Parser 1]: the next token, an invalid token, does not begin an expression.
                                                                 </errormessage><errormessage>Error <name ident="NextToken" class="other"/> (line 2) [Parser 1]: the next token, "&isin;" (set membership), is not allowed here.
                                                                </errormessage><errormessage>Error <name ident="NextToken" class="other"/> (line 2) [Parser 1]: the next token, an end tag (theorem-def), is not "&bullet;".
                                                            </errormessage><errormessage>Error <name ident="NotStartToken" class="other"/> (line 2) [Parser 1]: the next token, an end tag (theorem-def), does not begin a predicate or expression.
   </errormessage></zerror>


<cmd name="add-paragraph"><theorem-def>test
<ax-part/> &forall; s: &Nopf &bullet; s &isin; a</theorem-def></cmd>
<zerror><errormessage>Error <name ident="XmlUnterminatedEntityName" class="other"/> (line 2) [Scanner]: Unterminated entity name: &Nopf.
                                                        </errormessage><errormessage>Error <name ident="NotStartToken" class="other"/> (line 2) [Parser 1]: the next token, "&bullet;", does not begin an expression.
                                                     </errormessage></zerror>


<cmd name="add-paragraph"><theorem-def>test
<ax-part/> &forall; s: &Nopf; &bullet; s &isin; a</theorem-def></cmd>
<zerror><errormessage>Error <name ident="InvalidMembership" class="other"/> (line 2) [Type checker]: type of <name ident="a" scope="global" kind="expr"></name> is not a power set of type of <name ident="s" scope="local" kind="expr"></name>.
                                                                               </errormessage></zerror>


<cmd name="add-paragraph"><theorem-def>test
<ax-part/> &forall; s: &Nopf; &bullet; s &isin; <word style="roman"/> dom <word/> a</theorem-def></cmd>
<zoutput></zoutput>

<cmd name="set-current-goal-name">test</cmd>
<zoutput></zoutput>

<cmd name="prof-command"> rewrite </cmd>
<zerror><errormessage>Error <name ident="UnknownApiCmd" class="other"/> (line 1) [Parser 1]: Command <name ident="prof-command" class="other"/> is not a recognized Z/EVES API command.
                       </errormessage><errormessage>Error <name ident="NotEndTag" class="other"/> (line 1) [Parser 1]: The next token, "rewrite" (a word), is not an end tag.
             </errormessage></zerror>

<cmd name="proof-command"> rewrite </cmd>
<zoutput></zoutput>

<cmd name="get-goal-proved-state"> test </cmd>
<zoutput><name ident="false"/>
                              </zoutput>

<cmd name="get-current-goal-name"/>
<zoutput><name ident="test"/>
                             </zoutput>

<cmd name="get-history-length"/>
<zoutput><number value="5"/>
                            </zoutput>

<cmd name="get-history-element">0</cmd>
<zoutput></zoutput>

<cmd name="get-history-element">1</cmd>
<zoutput></zoutput>

<cmd name="get-history-element">2</cmd>
<zoutput><schemadef><schname ident="S"/><decpart><decl><namelist><name ident="x" kind="expr"/><name ident="y" kind="expr"/></namelist><name ident="&Nopf;" kind="expr"/></decl></decpart><axpart><relchain><name ident="x" kind="expr"/><name ident="&gt;" class="inrel" kind="expr"/><name ident="y" kind="expr"/></relchain><relchain><name ident="x" kind="expr"/><name ident="&isin;" class="other" kind="expr"/><name ident="&Zopf;" kind="expr"/></relchain></axpart></schemadef>
                                                                       </zoutput>
 <cmd name="get-history-element">3</cmd>
<zoutput><givendef><name ident="GP" kind="expr"/></givendef>
                                                            </zoutput>

<cmd name="get-history-element">4</cmd>
<zoutput><axdef><decpart><decl><namelist><name ident="a" kind="expr"/><name ident="b" kind="expr"/></namelist><op type="preop" kind="expr"><name ident="&Popf;" class="pregen" kind="expr"/><parenform kind="expr"><op type="inop" kind="expr"><name ident="&cross;" class="other" kind="expr"/><name ident="&Nopf;" kind="expr"/><name ident="GP" kind="expr"/></op></parenform></op></decl></decpart><axpart><op type="preop" kind="pred"><name ident="&not;" class="other" kind="expr"/><relchain><name ident="a" kind="expr"/><name ident="=" class="inrel" kind="expr"/><display type="set"></display></relchain></op><relchain><name ident="a" kind="expr"/><name ident="=" class="inrel" kind="expr"/><name ident="b" kind="expr"/></relchain></axpart></axdef>
                      </zoutput>

<cmd name="get-history-element">5</cmd>
<zoutput><theorem><name ident="test" class="other"/><binder type="forall" kind="pred"><decpart><decl><namelist><name ident="s" kind="expr"/></namelist><name ident="&Nopf;" kind="expr"/></decl></decpart><relchain><name ident="s" kind="expr"/><name ident="&isin;" class="other" kind="expr"/><application><name ident="dom" style="roman" kind="expr"/><name ident="a" kind="expr"/></application></relchain></binder></theorem>
                    </zoutput>
                              <cmd name="get-history-element">5</cmd>




<cmd name="add-paragraph">
<schema-box  >S

<decl-part/>x, y: &Nopf;
<ax-part/>x &gt; y
x &isin; &Zopf;
</schema-box>
</cmd>
<zoutput></zoutput>
                   <cmd name="add-paragraph">
<zed-box  >[GP]</zed-box>
</cmd>
<zoutput></zoutput>
                   <cmd name="add-paragraph">
<axiomatic-box  >
<decl-part/>a, b: &Popf; (&Nopf;&cross; GP)
<ax-part/>&not; a  =  {  }
a  =  b
</axiomatic-box>
</cmd>
<zoutput></zoutput>

<cmd name="proof-command">rewrite</cmd>
<zerror><errormessage>No goal formula.
                                      </errormessage></zerror>


<cmd name="add-paragraph"><theorem-def>test
<ax-part/> &forall; s: &Nopf; &bullet; s &isin; <word style="roman"/> dom <word/> a</theorem-def></cmd>

<cmd name="set-current-goal-name"> test </cmd>


<cmd name="proof-command"> rewrite </cmd>


<cmd name="get-goal-proved-state"> test </cmd>

<cmd name="get-current-goal-name"/>

<cmd name="get-history-length"/>
<cmd name="get-history-element">4</cmd>

<cmd name="get-history-element">5</cmd>


<cmd name="get-history-element">2</cmd>
<zoutput>

<schemadef><schname ident="S"/>
<decpart>
<decl>
<namelist>
<name ident="x" kind="expr"/>
<name ident="y" kind="expr"/>
</namelist>
<name ident="&Nopf;" kind="expr"/>
</decl></decpart>
<axpart>
<relchain>
<name ident="x" kind="expr"/>
<name ident="&gt;" class="inrel" kind="expr"/>
<name ident="y" kind="expr"/>
</relchain>
<relchain>
<name ident="x" kind="expr"/>
<name ident="&isin;" class="other" kind="expr"/>
<name ident="&Zopf;" kind="expr"/>
</relchain>
</axpart>
</schemadef>
</zoutput>




=====


<!-- runs the proof commands while reading the given command -->

<cmd name="add-paragraph"><theorem-def>ConjParaImpl1888498147
<ax-part/>0 &isin; &Nopf;
<proof-part/>prove by reduce;
</theorem-def>
</cmd>

<!-- runs the proof commands while reading the given command -->

<cmd name="add-paragraph"><theorem-def>ConjParaImpl2
<ax-part/>0 &isin; &Nopf;
<proof-part/>simplify;
</theorem-def>
</cmd>


<cmd name="set-current-goal-name">ConjParaImpl1888498147</cmd>

<cmd name="get-current-goal-name"></cmd>

<cmd name="get-goal-proved-state">ConjParaImpl1888498147</cmd>

<cmd name="proof-command">prove by reduce</cmd>